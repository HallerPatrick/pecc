,Unnamed: 0,year,day,part,status,output,expected_output,error,code,kpass
0,0,2015,1,1,no_error,"74
",74,,"
with open('input.txt', 'r') as f:
    floor = 0
    for c in f.read():
        if c == '(':
            floor += 1
        elif c == ')':
            floor -= 1
    print(floor)
",0.0
1,1,2015,1,2,no_error,"1795
",1795,,"
with open('input.txt', 'r') as f:
    floor = 0
    for i, c in enumerate(f.read(), 1):
        if c == '(':
            floor += 1
        elif c == ')':
            floor -= 1
        if floor == -1:
            print(i)
            break
",0.0
4,4,2015,2,1,no_error,"1586300
",1586300,,"
def get_surface_area(l, w, h):
    return 2*l*w + 2*w*h + 2*h*l

def get_slack(l, w, h):
    return min(l*w, w*h, h*l)

total_wrapping_paper = 0
with open('input.txt', 'r') as f:
    for line in f:
        l, w, h = map(int, line.split('x'))
        total_wrapping_paper += get_surface_area(l, w, h) + get_slack(l, w, h)

print(total_wrapping_paper)
",0.0
5,5,2015,2,2,no_error,"3737498
",3737498,,"
def get_ribbon_length(l, w, h):
    return 2*min(l+w, w+h, h+l) + l*w*h

total_ribbon_length = 0
with open('input.txt', 'r') as f:
    for line in f:
        l, w, h = map(int, line.split('x'))
        total_ribbon_length += get_ribbon_length(l, w, h)

print(total_ribbon_length)
",0.0
8,8,2015,3,1,no_error,"2565
",2565,,"
with open('input.txt') as f:
    directions = f.read().strip()

houses = set()
x, y = 0, 0
houses.add((x, y))
for direction in directions:
    if direction == '^':
        y += 1
    elif direction == 'v':
        y -= 1
    elif direction == '>':
        x += 1
    elif direction == '<':
        x -= 1
    houses.add((x, y))

print(len(houses))
",0.0
9,9,2015,3,2,wrong_output,"2783
",2639,,"
with open('input.txt') as f:
    directions = f.read().strip()

houses = set()
x, y = 0, 0
houses.add((x, y))
for i, direction in enumerate(directions):
    if i % 2 == 0:
        if direction == '^':
            y += 1
        elif direction == 'v':
            y -= 1
        elif direction == '>':
            x += 1
        elif direction == '<':
            x -= 1
        houses.add((x, y))
    else:
        if direction == '^':
            y -= 1
        elif direction == 'v':
            y += 1
        elif direction == '>':
            x -= 1
        elif direction == '<':
            x += 1
        houses.add((x, y))

print(len(houses))
",2.0
10,10,2015,4,1,wrong_output,"609043
1048970
",117946,,"
import hashlib

def md5(s):
    return hashlib.md5(s.encode('utf-8')).hexdigest()

def mine(key):
    i = 0
    while True:
        h = md5(key + str(i))
        if h.startswith('00000'):
            return i
        i += 1

print(mine('abcdef'))
print(mine('pqrstuv'))
",2.0
11,11,2015,4,2,part1_failed,,3938038,,,
12,12,2015,5,1,no_error,"236
",236,,"
import re

def is_nice(string):
    return (
        sum(1 for c in string if c in 'aeiou') >= 3
        and re.search(r'(.)\1', string)
        and not re.search(r'ab|cd|pq|xy', string)
    )

with open('input.txt') as f:
    print(sum(1 for line in f if is_nice(line)))
",0.0
13,13,2015,5,2,no_error,"51
",51,,"
import re

def is_nice(string):
    return (
        re.search(r'(..).*\1', string)
        and re.search(r'(.).\1', string)
    )

with open('input.txt') as f:
    print(sum(1 for line in f if is_nice(line)))
",0.0
16,16,2015,6,1,runtime_error,,400410,"  File ""/tmp/tmp_4rq87v6/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def turn_on(grid, x1, y1, x2, y2):
    for i in range(x1, x2 + 1):
        for j in range(y1, y2 + 1):
            grid[i][j] = 1

def turn_off(grid, x1, y1, x2, y2):
    for i in range(x1, x2 + 1):
        for j in range(y1, y2 + 1):
            grid[i][j] = 0

def toggle(grid, x1, y1, x2, y2):
    for i in range(x1, x2 + 1):
        for j in range(y1, y2 + 1):
            grid[i][j] = 1 - grid[i][j]

def count_lights(grid):
    count = 0
    for i in range(1000):
        for j in range(1000):
            if grid[i][j] == 1:
                count += 1
    return",2.0
17,17,2015,6,2,part1_failed,,15343601,,,
18,18,2015,7,1,runtime_error,,46065,"  File ""/tmp/tmph52z5rb_/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def get_signal(wire, signals):
    if wire.isdigit():
        return int(wire)
    if wire in signals:
        return signals[wire]
    for instruction in instructions:
        match = re.match(r'(\d+|\w+) (AND|OR|LSHIFT|RSHIFT|NOT) (\d+|\w+) -> (\w+)', instruction)
        if match:
            op1, op, op2, dest = match.groups()
            if dest == wire:
                if op == 'AND':
                    signals[wire] = get_signal(op1, signals) & get_signal(op2, signals)
                elif op == 'OR':
                    signals[wire] = get_signal(op1, signals) | get_signal(op2, signals)
                elif op == 'LSHIFT':
                    signals[wire] = get_signal(op1, signals) << int(op2)
                elif op == 'RSHIFT':
                    signals[wire] = get_signal(op1, signals) >> int(op2)
                elif op == '",2.0
19,19,2015,7,2,part1_failed,,14134,,,
20,20,2015,8,1,wrong_output,"1670
",1371,,"
with open('input.txt') as f:
    total = 0
    for line in f:
        total += len(line) - len(eval(line))
    print(total)
",2.0
21,21,2015,8,2,part1_failed,,2117,,,
22,22,2015,9,1,runtime_error,,251,"Traceback (most recent call last):
  File ""/tmp/tmp3o1cesdr/tmp.py"", line 20, in <module>
    print(get_shortest_route(cities))
  File ""/tmp/tmp3o1cesdr/tmp.py"", line 15, in get_shortest_route
    distance += get_distance(route[i], route[i + 1])
TypeError: unsupported operand type(s) for +=: 'int' and 'NoneType'
","
import itertools

def get_distance(city1, city2):
  with open(""input.txt"") as f:
    for line in f:
      if line.startswith(city1 + "" to "" + city2):
        return int(line.split(""="")[1])

def get_shortest_route(cities):
  distances = []
  for route in itertools.permutations(cities):
    distance = 0
    for i in range(len(route) - 1):
      distance += get_distance(route[i], route[i + 1])
    distances.append(distance)
  return min(distances)

cities = [""London"", ""Dublin"", ""Belfast""]
print(get_shortest_route(cities))
",2.0
23,23,2015,9,2,part1_failed,,898,,,
24,24,2015,10,1,runtime_error,,329356,"Traceback (most recent call last):
  File ""/tmp/tmpxf7quruq/tmp.py"", line 6, in <module>
    s = ''.join(str(len(list(g))) + k for k, g in itertools.groupby(s))
NameError: name 'itertools' is not defined
","
with open('input.txt') as f:
    s = f.read().strip()

for _ in range(40):
    s = ''.join(str(len(list(g))) + k for k, g in itertools.groupby(s))

print(len(s))
",2.0
25,25,2015,10,2,part1_failed,,4666278,,,
26,26,2015,11,1,runtime_error,,vzbxxyzz,"  File ""/tmp/tmp6t5s94x6/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def increment_password(password):
    # Convert the password to a list of characters.
    password = list(password)

    # Increment the rightmost character.
    for i in range(len(password) - 1, -1, -1):
        password[i] = chr(ord(password[i]) + 1)
        if password[i] <= 'z':
            break

    # If the rightmost character wrapped around, increment the next character to the left.
    if password[i] == 'a':
        for j in range(i - 1, -1, -1):
            password[j] = chr(ord(password[j]) + 1)
            if password[j] <= 'z':
                break

    # Convert the list of characters back to a string.
    password = ''.join(password)

    # Return the incremented password.
    return password


def is_valid_password(password):
    # Check if the password contains one increasing straight of at least three letters.
    for i in range(len(password) - 2):
        if password[",2.0
27,27,2015,11,2,part1_failed,,vzcaabcc,,,
28,28,2015,12,1,no_error,"111754
",111754,,"
import json

with open('input.txt') as f:
    data = json.load(f)

def sum_numbers(obj):
    if isinstance(obj, int):
        return obj
    elif isinstance(obj, list):
        return sum(sum_numbers(item) for item in obj)
    elif isinstance(obj, dict):
        return sum(sum_numbers(value) for value in obj.values())
    else:
        return 0

print(sum_numbers(data))
",0.0
29,29,2015,12,2,no_error,"65402
",65402,,"
import json

with open('input.txt') as f:
    data = json.load(f)

def sum_numbers(obj):
    if isinstance(obj, int):
        return obj
    elif isinstance(obj, list):
        return sum(sum_numbers(item) for item in obj)
    elif isinstance(obj, dict):
        if any(value == ""red"" for value in obj.values()):
            return 0
        else:
            return sum(sum_numbers(value) for value in obj.values())
    else:
        return 0

print(sum_numbers(data))
",0.0
32,32,2015,13,1,runtime_error,,733,"  File ""/tmp/tmp5ueryhia/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools

def get_happiness_change(seating_arrangement, happiness_changes):
    total_happiness_change = 0
    for i in range(len(seating_arrangement)):
        left_neighbor = seating_arrangement[i-1]
        right_neighbor = seating_arrangement[(i+1)%len(seating_arrangement)]
        total_happiness_change += happiness_changes[left_neighbor][right_neighbor]
        total_happiness_change += happiness_changes[right_neighbor][left_neighbor]
    return total_happiness_change

def get_optimal_seating_arrangement(guest_list, happiness_changes):
    max_happiness_change = -float('inf')
    optimal_seating_arrangement = None
    for seating_arrangement in itertools.permutations(guest_list):
        happiness_change = get_happiness_change(seating_arrangement, happiness_changes)
        if happiness_change > max_happiness_change:
            max_happiness_change = happiness_change
            optimal_seating_arrangement = seating_arrangement
    return optimal_seating_arrangement, max_",2.0
33,33,2015,13,2,part1_failed,,725,,,
34,34,2015,14,1,runtime_error,,2655,"Traceback (most recent call last):
  File ""/tmp/tmp1fgw7t_8/tmp.py"", line 23, in <module>
    reindeer = [parse_reindeer(line) for line in f]
  File ""/tmp/tmp1fgw7t_8/tmp.py"", line 23, in <listcomp>
    reindeer = [parse_reindeer(line) for line in f]
  File ""/tmp/tmp1fgw7t_8/tmp.py"", line 3, in parse_reindeer
    name, speed, duration, rest = line.split()
ValueError: too many values to unpack (expected 4)
","
def parse_reindeer(line):
    name, speed, duration, rest = line.split()
    return name, int(speed), int(duration), int(rest)

def race(reindeer, seconds):
    distances = {}
    for name, speed, duration, rest in reindeer:
        distance = 0
        time_left = seconds
        while time_left > 0:
            if time_left >= duration:
                distance += speed * duration
                time_left -= duration
            else:
                distance += speed * time_left
                time_left = 0
            time_left -= rest
        distances[name] = distance
    return max(distances.values())

with open('input.txt') as f:
    reindeer = [parse_reindeer(line) for line in f]

print(race(reindeer, 2503))
",2.0
35,35,2015,14,2,part1_failed,,1059,,,
36,36,2015,15,1,runtime_error,,21367368,"  File ""/tmp/tmp8oxiqha6/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def read_input():
    ingredients = []
    with open('input.txt') as f:
        for line in f:
            name, properties = line.strip().split(': ')
            properties = [int(x) for x in properties.split(', ')]
            ingredients.append((name, properties))
    return ingredients


def get_max_score(ingredients):
    max_score = 0
    for i in range(101):
        for j in range(101 - i):
            for k in range(101 - i - j):
                l = 100 - i - j - k
                score = get_score(ingredients, i, j, k, l)
                if score > max_score:
                    max_score = score
    return max_score


def get_score(ingredients, i, j, k, l):
    capacity = 0
    durability = 0
    flavor = 0
    texture = 0
    calories = 0
    for ingredient, properties in ingredients:
        capacity += properties[0] * i
        ",2.0
37,37,2015,15,2,part1_failed,,1766400,,,
38,38,2015,16,1,wrong_output,,40,,"
import re

with open('input.txt') as f:
    aunt_sues = [dict(re.findall(r'(\w+): (\d+)', line)) for line in f]

for sue in aunt_sues:
    if sue.get('children') == 3 and sue.get('cats') == 7 and sue.get('samoyeds') == 2 and sue.get('pomeranians') == 3 and sue.get('akitas') == 0 and sue.get('vizslas') == 0 and sue.get('goldfish') == 5 and sue.get('trees') == 3 and sue.get('cars') == 2 and sue.get('perfumes') == 1:
        print(sue)
",2.0
39,39,2015,16,2,part1_failed,,241,,,
40,40,2015,17,1,no_error,"1638
",1638,,"
from itertools import combinations

with open('input.txt') as f:
    containers = [int(line.strip()) for line in f]

count = 0
for i in range(1, len(containers) + 1):
    for combination in combinations(containers, i):
        if sum(combination) == 150:
            count += 1

print(count)
",0.0
41,41,2015,17,2,wrong_output,"4 17
",17,,"
from itertools import combinations

with open('input.txt') as f:
    containers = [int(line.strip()) for line in f]

min_containers = len(containers)
ways = 0
for i in range(1, len(containers) + 1):
    for combination in combinations(containers, i):
        if sum(combination) == 150:
            if i < min_containers:
                min_containers = i
                ways = 1
            elif i == min_containers:
                ways += 1

print(min_containers, ways)
",2.0
42,42,2015,18,1,runtime_error,,814,"  File ""/tmp/tmp_85iqibs/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def get_neighbors(grid, i, j):
    neighbors = []
    for di in range(-1, 2):
        for dj in range(-1, 2):
            if di == 0 and dj == 0:
                continue
            if i + di < 0 or i + di >= grid.shape[0]:
                continue
            if j + dj < 0 or j + dj >= grid.shape[1]:
                continue
            neighbors.append(grid[i + di, j + dj])
    return neighbors

def step(grid):
    new_grid = np.zeros_like(grid)
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            neighbors = get_neighbors(grid, i, j)
            num_on = sum(neighbors)
            if grid[i, j] == 1:
                if num_on == 2 or num_on == 3:
                    new_grid[i, j] = 1
            else:
                if num_on == 3",2.0
43,43,2015,18,2,part1_failed,,924,,,
44,44,2015,19,1,wrong_output,"192
",518,,"
from collections import defaultdict

def main():
    with open('input.txt') as f:
        replacements, medicine = f.read().split('\n\n')

    replacements = [line.split(' => ') for line in replacements.splitlines()]
    replacements = {a: b for a, b in replacements}

    molecules = set()
    for a, b in replacements.items():
        for i in range(len(medicine)):
            if medicine[i:i+len(a)] == a:
                molecules.add(medicine[:i] + b + medicine[i+len(a):])

    print(len(molecules))

if __name__ == '__main__':
    main()
",2.0
45,45,2015,19,2,part1_failed,,200,,,
46,46,2015,20,1,timeout_error,,776160,TIMEOUT,"
def get_presents(house_number):
    presents = 0
    for elf in range(1, house_number + 1):
        if house_number % elf == 0:
            presents += elf * 10
    return presents

with open('input.txt', 'r') as f:
    presents = int(f.read())

house_number = 1
while get_presents(house_number) < presents:
    house_number += 1

print(house_number)
",2.0
47,47,2015,20,2,part1_failed,,786240,,,
48,48,2015,21,1,runtime_error,,78,"  File ""/tmp/tmp6xmyoc1c/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from itertools import combinations

with open(""input.txt"") as f:
    boss_hp, boss_damage, boss_armor = map(int, f.readlines())

weapons = [
    (""Dagger"", 8, 4, 0),
    (""Shortsword"", 10, 5, 0),
    (""Warhammer"", 25, 6, 0),
    (""Longsword"", 40, 7, 0),
    (""Greataxe"", 74, 8, 0),
]

armor = [
    (""Leather"", 13, 0, 1),
    (""Chainmail"", 31, 0, 2),
    (""Splintmail"", 53, 0, 3),
    (""Bandedmail"", 75, 0, 4),
    (""Platemail"", 102, 0, 5),
]

rings = [
    (""Damage +1"", 25, 1, 0),
    (""Damage +2"", 50, 2, 0),
    (""Damage +",2.0
49,49,2015,21,2,part1_failed,,148,,,
50,50,2015,22,1,runtime_error,,953,"  File ""/tmp/tmpw_53ejep/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict

def parse_input(filename):
    with open(filename) as f:
        lines = f.readlines()
        boss_hp = int(lines[0].split(':')[1])
        boss_dmg = int(lines[1].split(':')[1])
        return boss_hp, boss_dmg

def get_spells():
    spells = defaultdict(lambda: defaultdict(int))
    spells['Magic Missile']['cost'] = 53
    spells['Magic Missile']['dmg'] = 4
    spells['Drain']['cost'] = 73
    spells['Drain']['dmg'] = 2
    spells['Drain']['heal'] = 2
    spells['Shield']['cost'] = 113
    spells['Shield']['armor'] = 7
    spells['Shield']['duration'] = 6
    spells['Poison']['cost'] = 173
    spells['Poison']['dmg'] = 3
    spells['Poison']['duration'] = 6
    spells['Recharge']['cost'] = 229
    spells['Recharge']['mana'] = 101
    spells['Recharge']['",2.0
51,51,2015,22,2,part1_failed,,1289,,,
52,52,2015,23,1,runtime_error,,307,"Traceback (most recent call last):
  File ""/tmp/tmprpz8qkty/tmp.py"", line 8, in <module>
    instruction, arg = instructions[pc].split()
ValueError: too many values to unpack (expected 2)
","
with open('input.txt') as f:
    instructions = [line.strip() for line in f]

registers = {'a': 0, 'b': 0}
pc = 0
while pc < len(instructions):
    instruction, arg = instructions[pc].split()
    if instruction == 'hlf':
        registers[arg] //= 2
        pc += 1
    elif instruction == 'tpl':
        registers[arg] *= 3
        pc += 1
    elif instruction == 'inc':
        registers[arg] += 1
        pc += 1
    elif instruction == 'jmp':
        pc += int(arg)
    elif instruction == 'jie':
        if registers[arg] % 2 == 0:
            pc += int(arg)
        else:
            pc += 1
    elif instruction == 'jio':
        if registers[arg] == 1:
            pc += int(arg)
        else:
            pc += 1

print(registers['b'])
",2.0
53,53,2015,23,2,part1_failed,,160,,,
54,54,2015,24,1,runtime_error,,10439961859,"  File ""/tmp/tmpthko3rs0/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def quantum_entanglement(weights):
    weights.sort()
    total_weight = sum(weights)
    third_group_weight = total_weight // 3
    second_group_weight = third_group_weight * 2
    # Find all possible combinations of packages that weigh exactly the same as the second group
    second_group_combinations = []
    for i in range(len(weights)):
        for j in range(i + 1, len(weights)):
            for k in range(j + 1, len(weights)):
                if weights[i] + weights[j] + weights[k] == second_group_weight:
                    second_group_combinations.append([weights[i], weights[j], weights[k]])
    # Find all possible combinations of packages that weigh exactly the same as the third group
    third_group_combinations = []
    for i in range(len(weights)):
        for j in range(i + 1, len(weights)):
            for k in range(j + 1, len(weights)):
                if weights[i] + weights[j] +",2.0
55,55,2015,24,2,part1_failed,,72050269,,,
56,56,2015,25,1,timeout_error,,9132360,TIMEOUT,"
def get_code(row, col):
    code = 20151125
    for _ in range(1, row * col):
        code = (code * 252533) % 33554393
    return code

row, col = map(int, input().split(','))
print(get_code(row, col))
",2.0
57,57,2015,25,2,part1_failed,,,,,
58,58,2016,1,1,no_error,"287
",287,,"
def get_distance(instructions):
    x, y = 0, 0
    direction = 0  # 0 = north, 1 = east, 2 = south, 3 = west
    for instruction in instructions.split(', '):
        turn = instruction[0]
        distance = int(instruction[1:])
        if turn == 'L':
            direction = (direction - 1) % 4
        elif turn == 'R':
            direction = (direction + 1) % 4
        if direction == 0:
            y += distance
        elif direction == 1:
            x += distance
        elif direction == 2:
            y -= distance
        elif direction == 3:
            x -= distance
    return abs(x) + abs(y)


with open('input.txt') as f:
    instructions = f.read().strip()

print(get_distance(instructions))
",1.0
59,59,2016,1,2,no_error,"133
",133,,"
def get_distance(instructions):
    x, y = 0, 0
    direction = 0  # 0 = north, 1 = east, 2 = south, 3 = west
    visited = set()
    for instruction in instructions.split(', '):
        turn = instruction[0]
        distance = int(instruction[1:])
        if turn == 'L':
            direction = (direction - 1) % 4
        elif turn == 'R':
            direction = (direction + 1) % 4
        for _ in range(distance):
            if direction == 0:
                y += 1
            elif direction == 1:
                x += 1
            elif direction == 2:
                y -= 1
            elif direction == 3:
                x -= 1
            if (x, y) in visited:
                return abs(x) + abs(y)
            visited.add((x, y))


with open('input.txt') as f:
    instructions = f.read().strip()

print(get_distance(instructions))
",0.0
61,61,2016,2,1,runtime_error,,12578,"  File ""/tmp/tmp0b38ttyj/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_bathroom_code(instructions):
    keypad = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    current_button = [1, 1]
    bathroom_code = """"
    for instruction in instructions:
        for move in instruction:
            if move == ""U"" and current_button[0] > 0:
                current_button[0] -= 1
            elif move == ""D"" and current_button[0] < 2:
                current_button[0] += 1
            elif move == ""L"" and current_button[1] > 0:
                current_button[1] -= 1
            elif move == ""R"" and current_button[1] < 2:
                current_button[1] += 1
        bathroom_code += str(keypad[current_button[0]][current_button[1]])
    return bathroom_code

with open(""input.txt"", ""r"") as f:
    instructions = f.read().splitlines()
print(get_bathroom",2.0
62,62,2016,2,2,part1_failed,,516DD,,,
63,63,2016,3,1,no_error,"993
",993,,"
with open('input.txt') as f:
    count = 0
    for line in f:
        a, b, c = map(int, line.split())
        if a + b > c and a + c > b and b + c > a:
            count += 1
    print(count)
",0.0
64,64,2016,3,2,wrong_output,"993
",1849,,"
with open('input.txt') as f:
    count = 0
    for line in f:
        a, b, c = map(int, line.split())
        if a + b > c and a + c > b and b + c > a:
            count += 1
    print(count)
",2.0
65,65,2016,4,1,runtime_error,,245102,"Traceback (most recent call last):
  File ""/tmp/tmpnim8q1w_/tmp.py"", line 30, in <module>
    main()
  File ""/tmp/tmpnim8q1w_/tmp.py"", line 23, in main
    real_rooms = [room for room in rooms if is_real_room(room)]
  File ""/tmp/tmpnim8q1w_/tmp.py"", line 23, in <listcomp>
    real_rooms = [room for room in rooms if is_real_room(room)]
  File ""/tmp/tmpnim8q1w_/tmp.py"", line 3, in is_real_room
    name, sector_id, checksum = room.split('-')
ValueError: too many values to unpack (expected 3)
","
def is_real_room(room):
    name, sector_id, checksum = room.split('-')
    sector_id = int(sector_id)
    checksum = checksum[1:-1]

    counts = {}
    for letter in name:
        if letter not in counts:
            counts[letter] = 0
        counts[letter] += 1

    sorted_counts = sorted(counts.items(), key=lambda x: (-x[1], x[0]))
    most_common_letters = [letter for letter, count in sorted_counts[:5]]

    return ''.join(most_common_letters) == checksum


def main():
    with open('input.txt') as f:
        rooms = f.readlines()

    real_rooms = [room for room in rooms if is_real_room(room)]
    sector_ids = [int(room.split('-')[1]) for room in real_rooms]

    print(sum(sector_ids))


if __name__ == '__main__':
    main()
",2.0
66,66,2016,4,2,part1_failed,,324,,,
67,67,2016,5,1,no_error,"1a3099aa
",1a3099aa,,"
import hashlib

def get_password(door_id):
    password = """"
    i = 0
    while len(password) < 8:
        hash = hashlib.md5((door_id + str(i)).encode()).hexdigest()
        if hash[:5] == ""00000"":
            password += hash[5]
        i += 1
    return password

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as f:
        door_id = f.read().strip()
    print(get_password(door_id))
",2.0
68,68,2016,5,2,runtime_error,,694190cd,"Traceback (most recent call last):
  File ""/tmp/tmpqvx8kjx4/tmp.py"", line 19, in <module>
    print(get_password(door_id))
  File ""/tmp/tmpqvx8kjx4/tmp.py"", line 11, in get_password
    if password[pos] == ""_"":
IndexError: list index out of range
","
import hashlib

def get_password(door_id):
    password = [""_""] * 8
    i = 0
    while ""_"" in password:
        hash = hashlib.md5((door_id + str(i)).encode()).hexdigest()
        if hash[:5] == ""00000"":
            pos = int(hash[5], 16)
            if password[pos] == ""_"":
                password[pos] = hash[6]
        i += 1
    return """".join(password)

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as f:
        door_id = f.read().strip()
    print(get_password(door_id))
",2.0
69,69,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"
with open('input.txt') as f:
    lines = f.readlines()
    columns = [''.join([line[i] for line in lines]) for i in range(len(lines[0])-1)]
    print(''.join([max(set(column), key=column.count) for column in columns]))
",0.0
70,70,2016,6,2,no_error,"pdesmnoz
",pdesmnoz,,"
with open('input.txt') as f:
    lines = f.readlines()
    columns = [''.join([line[i] for line in lines]) for i in range(len(lines[0])-1)]
    print(''.join([min(set(column), key=column.count) for column in columns]))
",0.0
73,73,2016,7,1,wrong_output,"67
",115,,"
import re

def supports_tls(ip):
    abba = re.compile(r'(.)(?!\1)(.)\2\1')
    hypernet = re.compile(r'\[.*?\]')
    return bool(abba.search(ip) and not abba.search(hypernet.sub('', ip)))

with open('input.txt') as f:
    print(sum(supports_tls(line.strip()) for line in f))
",2.0
74,74,2016,7,2,part1_failed,,231,,,
75,75,2016,8,1,runtime_error,,115,"  File ""/tmp/tmpmvc9oj2q/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    instructions = f.readlines()

screen = [['.'] * 50 for _ in range(6)]

for instruction in instructions:
    if instruction.startswith('rect'):
        a, b = map(int, instruction[5:].split('x'))
        for i in range(b):
            for j in range(a):
                screen[i][j] = '#'
    elif instruction.startswith('rotate row'):
        _, y, _, b = instruction.split()
        y = int(y[2:])
        b = int(b)
        screen[y] = screen[y][-b:] + screen[y][:-b]
    elif instruction.startswith('rotate column'):
        _, x, _, b = instruction.split()
        x = int(x[2:])
        b = int(b)
        screen = list(zip(*screen))
        screen[x] = screen[x][-b:] + screen[x][:-b]
        screen = list(zip(*screen))

print('\n'.join(''.join(row) for row in",2.0
76,76,2016,8,2,part1_failed,,"####.####.####.#...##..#.####.###..####..###...##.
#....#....#....#...##.#..#....#..#.#......#.....#.
###..###..###...#.#.##...###..#..#.###....#.....#.
#....#....#......#..#.#..#....###..#......#.....#.
#....#....#......#..#.#..#....#.#..#......#..#..#.
####.#....####...#..#..#.#....#..#.#.....###..##..",,,
77,77,2016,9,1,no_error,"102239
",102239,,"
def decompress(data):
    result = """"
    i = 0
    while i < len(data):
        if data[i] == ""("":
            marker_end = data.find("")"", i)
            marker = data[i+1:marker_end]
            repeat_count = int(marker.split(""x"")[0])
            repeat_data = data[marker_end+1:marker_end+1+repeat_count]
            result += repeat_data * int(marker.split(""x"")[1])
            i = marker_end + 1 + repeat_count
        else:
            result += data[i]
            i += 1
    return result

with open(""input.txt"", ""r"") as f:
    data = f.read()

print(len(decompress(data)))
",1.0
78,78,2016,9,2,no_error,"10780403063
",10780403063,,"
def decompress(data):
    result = """"
    i = 0
    while i < len(data):
        if data[i] == ""("":
            marker_end = data.find("")"", i)
            marker = data[i+1:marker_end]
            repeat_count = int(marker.split(""x"")[0])
            repeat_data = data[marker_end+1:marker_end+1+repeat_count]
            result += decompress(repeat_data) * int(marker.split(""x"")[1])
            i = marker_end + 1 + repeat_count
        else:
            result += data[i]
            i += 1
    return result

with open(""input.txt"", ""r"") as f:
    data = f.read()

print(len(decompress(data)))
",0.0
81,81,2016,10,1,runtime_error,,118,"  File ""/tmp/tmpz56xa3ma/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_instruction(instruction):
    match = re.match(r'value (\d+) goes to bot (\d+)', instruction)
    if match:
        return ('value', int(match.group(1)), int(match.group(2)))
    match = re.match(r'bot (\d+) gives low to (\w+) (\d+) and high to (\w+) (\d+)', instruction)
    if match:
        return ('bot', int(match.group(1)), match.group(2), int(match.group(3)), match.group(4), int(match.group(5)))
    raise ValueError('Invalid instruction: ' + instruction)

def execute_instruction(instruction, bots, outputs):
    if instruction[0] == 'value':
        bots[instruction[2]].append(instruction[1])
    elif instruction[0] == 'bot':
        if len(bots[instruction[1]]) == 2:
            bots[instruction[1]].sort()
            if instruction[2] == 'bot':
                bots[instruction[3]].append(bots[instruction[1",2.0
82,82,2016,10,2,part1_failed,,143153,,,
83,83,2016,11,1,runtime_error,,37,"  File ""/tmp/tmpsiespwv4/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict, deque
from itertools import combinations

def solve(floors):
    # Initialize the state
    state = {
        'elevator': 0,
        'floors': floors,
    }

    # Initialize the queue
    queue = deque([state])

    # Initialize the visited set
    visited = set()

    # Initialize the minimum number of steps
    min_steps = 0

    # While the queue is not empty
    while queue:
        # Pop the current state from the queue
        state = queue.popleft()

        # If the current state is the goal state
        if state['elevator'] == 3 and all(floor == [] for floor in state['floors']):
            # Return the minimum number of steps
            return min_steps

        # If the current state has not been visited
        if state not in visited:
            # Add the current state to the visited set
            visited.add(state)

            # For each possible move
            for move in get_moves(state):
                # Create a new state
                new_state = {
                    'elevator': move[0],
                    ",2.0
84,84,2016,11,2,part1_failed,,61,,,
85,85,2016,12,1,runtime_error,,318083,"Traceback (most recent call last):
  File ""/tmp/tmpr347i3lq/tmp.py"", line 24, in <module>
    print(run_program(code))
  File ""/tmp/tmpr347i3lq/tmp.py"", line 17, in run_program
    if registers[x] != 0:
KeyError: '1'
","
def run_program(code):
    registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
    pc = 0
    while pc < len(code):
        instruction, x, y = code[pc]
        if instruction == 'cpy':
            if x.isdigit():
                registers[y] = int(x)
            else:
                registers[y] = registers[x]
        elif instruction == 'inc':
            registers[x] += 1
        elif instruction == 'dec':
            registers[x] -= 1
        elif instruction == 'jnz':
            if registers[x] != 0:
                pc += int(y) - 1
        pc += 1
    return registers['a']

with open('input.txt') as f:
    code = [line.split() for line in f.readlines()]
print(run_program(code))
",2.0
86,86,2016,12,2,part1_failed,,9227737,,,
87,87,2016,13,1,runtime_error,,92,"  File ""/tmp/tmp1p7gy2y5/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def is_open(x, y, fav_num):
    return bin(x*x + 3*x + 2*x*y + y + y*y + fav_num).count('1') % 2 == 0

def find_shortest_path(fav_num):
    queue = [(1, 1, 0)]
    visited = set()
    while queue:
        x, y, steps = queue.pop(0)
        if (x, y) == (31, 39):
            return steps
        if (x, y) not in visited:
            visited.add((x, y))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if new_x >= 0 and new_y >= 0 and is_open(new_x, new_y, fav_num):
                    queue.append((new_x, new_y, steps + 1))
    return -1

",2.0
88,88,2016,13,2,part1_failed,,124,,,
89,89,2016,14,1,wrong_output,"9097
",23890,,"
import hashlib

def generate_keys(salt):
    index = 0
    keys = []
    while len(keys) < 64:
        md5 = hashlib.md5((salt + str(index)).encode()).hexdigest()
        if any(md5[i] == md5[i+1] == md5[i+2] for i in range(len(md5)-2)):
            for j in range(index+1, index+1001):
                md5 = hashlib.md5((salt + str(j)).encode()).hexdigest()
                if any(md5[i] == md5[i+1] == md5[i+2] == md5[i+3] == md5[i+4] for i in range(len(md5)-4)):
                    keys.append(index)
                    break
        index += 1
    return keys[-1]

with open('input.txt') as f:
    salt = f.read().strip()

print(generate_keys(salt))
",2.0
90,90,2016,14,2,part1_failed,,22696,,,
91,91,2016,15,1,runtime_error,,400589,"Traceback (most recent call last):
  File ""/tmp/tmp7b02kjbr/tmp.py"", line 18, in <module>
    print(get_first_time(positions))
  File ""/tmp/tmp7b02kjbr/tmp.py"", line 6, in get_first_time
    lcm = lcm * period // math.gcd(lcm, period)
NameError: name 'math' is not defined
","
def get_first_time(positions):
    # Find the least common multiple of the disc periods
    lcm = 1
    for period in positions:
        lcm = lcm * period // math.gcd(lcm, period)

    # Find the first time when all discs are aligned
    for time in range(lcm):
        if all((time + i) % period == 0 for i, period in enumerate(positions)):
            return time

    return -1

with open('input.txt') as f:
    positions = [int(line.split()[3]) for line in f.readlines()]

print(get_first_time(positions))
",2.0
92,92,2016,15,2,part1_failed,,3045959,,,
93,93,2016,16,1,no_error,"10100011010101011
",10100011010101011,,"
import itertools

def dragon(s):
    return s + '0' + ''.join('1' if c == '0' else '0' for c in reversed(s))

def checksum(s):
    while len(s) % 2 == 0:
        s = ''.join('1' if a == b else '0' for a, b in zip(s[::2], s[1::2]))
    return s

def main():
    with open('input.txt') as f:
        s = f.read().strip()
    while len(s) < 272:
        s = dragon(s)
    print(checksum(s[:272]))

if __name__ == '__main__':
    main()
",0.0
94,94,2016,16,2,no_error,"01010001101011001
",01010001101011001,,"
import itertools

def dragon(s):
    return s + '0' + ''.join('1' if c == '0' else '0' for c in reversed(s))

def checksum(s):
    while len(s) % 2 == 0:
        s = ''.join('1' if a == b else '0' for a, b in zip(s[::2], s[1::2]))
    return s

def main():
    with open('input.txt') as f:
        s = f.read().strip()
    while len(s) < 35651584:
        s = dragon(s)
    print(checksum(s[:35651584]))

if __name__ == '__main__':
    main()
",0.0
97,97,2016,17,1,runtime_error,,RDDRULDDRR,"  File ""/tmp/tmpest8f6_y/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import hashlib

def get_hash(passcode, path):
    return hashlib.md5((passcode + path).encode()).hexdigest()[:4]

def is_open(hash, direction):
    return hash[direction] in 'bcdef'

def get_next_moves(hash, x, y):
    moves = []
    if x > 0 and is_open(hash, 0):
        moves.append((x - 1, y, 'U'))
    if x < 3 and is_open(hash, 1):
        moves.append((x + 1, y, 'D'))
    if y > 0 and is_open(hash, 2):
        moves.append((x, y - 1, 'L'))
    if y < 3 and is_open(hash, 3):
        moves.append((x, y + 1, 'R'))
    return moves

def find_shortest_path(passcode):
    queue = [(0, 0, '')]
    visited = set()
    while queue:
        x, y, path =",2.0
98,98,2016,17,2,part1_failed,,766,,,
99,99,2016,18,1,runtime_error,,1913,"  File ""/tmp/tmpjbkfrdg1/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def is_trap(left, center, right):
    if left == '^' and center == '^' and right == '.':
        return True
    if center == '^' and right == '^' and left == '.':
        return True
    if left == '^' and center == '.' and right == '.':
        return True
    if left == '.' and center == '.' and right == '^':
        return True
    return False

def next_row(row):
    new_row = []
    for i in range(len(row)):
        left = row[i-1] if i > 0 else '.'
        center = row[i]
        right = row[i+1] if i < len(row)-1 else '.'
        new_row.append('^' if is_trap(left, center, right) else '.')
    return new_row

def count_safe_tiles(rows):
    safe_tiles = 0
    for row in rows:
        for tile in row:
            if tile == '.':
                safe_tiles += 1
    return safe_tiles

with open('input",2.0
100,100,2016,18,2,part1_failed,,19993564,,,
101,101,2016,19,1,timeout_error,,1808357,TIMEOUT,"
with open('input.txt', 'r') as f:
    n = int(f.read())

elves = list(range(1, n+1))
i = 0
while len(elves) > 1:
    elves.pop((i-1) % len(elves))
    i = (i+1) % len(elves)

print(elves[0])
",2.0
102,102,2016,19,2,part1_failed,,1407007,,,
103,103,2016,20,1,wrong_output,,32259706,,"
with open('input.txt') as f:
    blocked = set()
    for line in f:
        start, end = map(int, line.split('-'))
        blocked.update(range(start, end + 1))

    print(min(set(range(4294967296)) - blocked))
",2.0
104,104,2016,20,2,part1_failed,,113,,,
105,105,2016,21,1,runtime_error,,gbhafcde,"  File ""/tmp/tmpwailvj5_/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def swap_position(password, x, y):
    password[x], password[y] = password[y], password[x]
    return password

def swap_letter(password, x, y):
    for i, c in enumerate(password):
        if c == x:
            password[i] = y
        elif c == y:
            password[i] = x
    return password

def rotate_left(password, x):
    return password[x:] + password[:x]

def rotate_right(password, x):
    return password[-x:] + password[:-x]

def rotate_based_on_position(password, x):
    index = password.index(x)
    if index >= 4:
        return rotate_right(password, index + 2)
    else:
        return rotate_right(password, index + 1)

def reverse_positions(password, x, y):
    return password[:x] + password[x:y+1][::-1] + password[y+1:]

def move_position(password, x, y):
    c =",2.0
106,106,2016,21,2,part1_failed,,bcfaegdh,,,
107,107,2016,22,1,no_error,"901
",901,,"
import re

with open('input.txt') as f:
    lines = f.readlines()

# Get the size of each node
nodes = {}
for line in lines:
    match = re.match(r'/dev/grid/node-x(\d+)-y(\d+)\s+(\d+)T\s+(\d+)T\s+(\d+)T\s+(\d+)%', line)
    if match:
        x, y, size, used, avail, percent = match.groups()
        nodes[(int(x), int(y))] = (int(size), int(used), int(avail))

# Count the number of viable pairs
count = 0
for node1, (size1, used1, avail1) in nodes.items():
    if used1 == 0:
        continue
    for node2, (size2, used2, avail2) in nodes.items():
        if node1 == node2:
            continue
        if used1 <= avail2:
            count += 1

print(count)
",0.0
108,108,2016,22,2,runtime_error,,238,"  File ""/tmp/tmpidz8cn9r/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    lines = f.readlines()

# Get the size of each node
nodes = {}
for line in lines:
    match = re.match(r'/dev/grid/node-x(\d+)-y(\d+)\s+(\d+)T\s+(\d+)T\s+(\d+)T\s+(\d+)%', line)
    if match:
        x, y, size, used, avail, percent = match.groups()
        nodes[(int(x), int(y))] = (int(size), int(used), int(avail))

# Find the goal node
goal_x, goal_y = max(nodes.keys(), key=lambda node: node[0])

# Find the path to the goal node
path = []
current_x, current_y = 0, 0
while current_x != goal_x or current_y != goal_y:
    # Find the next node to move to
    next_x, next_y = None, None
    for node, (size, used, avail) in nodes.items",2.0
109,109,2016,23,1,runtime_error,,12516,"  File ""/tmp/tmpx8ji0isi/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

def main():
    with open('input.txt') as f:
        instructions = [line.strip() for line in f.readlines()]

    registers = {'a': 7, 'b': 0, 'c': 0, 'd': 0}
    pc = 0
    while pc < len(instructions):
        instruction, *args = instructions[pc].split()
        if instruction == 'cpy':
            registers[args[1]] = int(args[0]) if args[0].isdigit() else registers[args[0]]
        elif instruction == 'inc':
            registers[args[0]] += 1
        elif instruction == 'dec':
            registers[args[0]] -= 1
        elif instruction == 'jnz':
            if int(args[0]) != 0:
                pc += int(args[1]) - 1
        elif instruction == 'tgl':
            offset = int(args[0])
            if 0 <= pc + offset < len(instructions):
                toggled_instruction = instructions[pc + offset].split()
                if len(togg",2.0
110,110,2016,23,2,part1_failed,,479009076,,,
111,111,2016,24,1,runtime_error,,498,"  File ""/tmp/tmpkg6ypbk2/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import deque

def get_neighbors(x, y, grid):
    neighbors = []
    if x > 0 and grid[y][x - 1] != '#':
        neighbors.append((x - 1, y))
    if x < len(grid[0]) - 1 and grid[y][x + 1] != '#':
        neighbors.append((x + 1, y))
    if y > 0 and grid[y - 1][x] != '#':
        neighbors.append((x, y - 1))
    if y < len(grid) - 1 and grid[y + 1][x] != '#':
        neighbors.append((x, y + 1))
    return neighbors

def bfs(start, grid):
    queue = deque([start])
    visited = set()
    distance = 0

    while queue:
        current = queue.popleft()
        if current not in visited:
            visited.add(current)
            distance += 1
            for neighbor in get_neighbors(*current, grid):
                queue.append(neighbor",2.0
112,112,2016,24,2,part1_failed,,804,,,
113,113,2016,25,1,runtime_error,,196,"  File ""/tmp/tmphjtdtsob/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    code = [line.strip().split() for line in f]

def run(code, a):
    registers = {'a': a, 'b': 0, 'c': 0, 'd': 0}
    ip = 0
    while 0 <= ip < len(code):
        op, *args = code[ip]
        if op == 'cpy':
            x, y = args
            if y in registers:
                registers[y] = registers[x] if x in registers else int(x)
        elif op == 'inc':
            x = args[0]
            registers[x] += 1
        elif op == 'dec':
            x = args[0]
            registers[x] -= 1
        elif op == 'jnz':
            x, y = args
            if registers[x] != 0:
                ip += int(y) - 1
        elif op == 'out':
            x = args[0]
            yield registers[x] if x in registers else int(x)
",2.0
114,114,2016,25,2,part1_failed,,,,,
115,115,2017,1,1,no_error,"1177
",1177,,"
with open('input.txt') as f:
    data = f.read()

total = 0
for i in range(len(data)):
    if data[i] == data[(i + 1) % len(data)]:
        total += int(data[i])

print(total)
",0.0
116,116,2017,1,2,no_error,"1060
",1060,,"
with open('input.txt') as f:
    data = f.read()

total = 0
for i in range(len(data)):
    if data[i] == data[(i + len(data) // 2) % len(data)]:
        total += int(data[i])

print(total)
",0.0
119,119,2017,2,1,no_error,"45158
",45158,,"
with open('input.txt') as f:
    checksum = 0
    for line in f:
        row = list(map(int, line.split()))
        checksum += max(row) - min(row)
    print(checksum)
",0.0
120,120,2017,2,2,wrong_output,"294.0
",294,,"
with open('input.txt') as f:
    checksum = 0
    for line in f:
        row = list(map(int, line.split()))
        for i in range(len(row)):
            for j in range(len(row)):
                if i != j and row[i] % row[j] == 0:
                    checksum += row[i] / row[j]
                    break
    print(checksum)
",2.0
121,121,2017,3,1,wrong_output,"514
",438,,"
with open('input.txt', 'r') as f:
    input_data = f.read()

input_data = int(input_data)

# Find the side length of the square that contains the input data
side_length = 1
while side_length**2 < input_data:
    side_length += 2

# Find the coordinates of the input data
x = (side_length - 1) // 2
y = (side_length - 1) // 2
if input_data > side_length**2 // 2:
    x = side_length - 1 - x
    y = side_length - 1 - y

# Calculate the Manhattan distance from the input data to the center
manhattan_distance = abs(x) + abs(y)

print(manhattan_distance)
",2.0
122,122,2017,3,2,part1_failed,,266330,,,
123,123,2017,4,1,no_error,"383
",383,,"
with open('input.txt') as f:
    valid = 0
    for line in f:
        words = line.split()
        if len(set(words)) == len(words):
            valid += 1
    print(valid)
",0.0
124,124,2017,4,2,no_error,"265
",265,,"
with open('input.txt') as f:
    valid = 0
    for line in f:
        words = line.split()
        anagrams = set()
        for word in words:
            anagrams.add(''.join(sorted(word)))
        if len(anagrams) == len(words):
            valid += 1
    print(valid)
",0.0
127,127,2017,5,1,no_error,"391540
",391540,,"
with open('input.txt') as f:
    offsets = [int(line) for line in f]

pc = 0
steps = 0
while 0 <= pc < len(offsets):
    offset = offsets[pc]
    offsets[pc] += 1
    pc += offset
    steps += 1

print(steps)
",2.0
128,128,2017,5,2,no_error,"30513679
",30513679,,"
with open('input.txt') as f:
    offsets = [int(line) for line in f]

pc = 0
steps = 0
while 0 <= pc < len(offsets):
    offset = offsets[pc]
    if offset >= 3:
        offsets[pc] -= 1
    else:
        offsets[pc] += 1
    pc += offset
    steps += 1

print(steps)
",0.0
131,131,2017,6,1,no_error,"6681
",6681,,"
def reallocate(banks):
    seen = set()
    while tuple(banks) not in seen:
        seen.add(tuple(banks))
        i, blocks = max(enumerate(banks), key=lambda x: (x[1], -x[0]))
        banks[i] = 0
        while blocks:
            i = (i + 1) % len(banks)
            banks[i] += 1
            blocks -= 1
    return len(seen)

with open('input.txt') as f:
    banks = [int(x) for x in f.read().split()]
    print(reallocate(banks))
",0.0
132,132,2017,6,2,runtime_error,,2392,"Traceback (most recent call last):
  File ""/tmp/tmpnd0_rs9m/tmp.py"", line 16, in <module>
    print(reallocate(banks))
  File ""/tmp/tmpnd0_rs9m/tmp.py"", line 12, in reallocate
    return len(seen), len(seen) - seen.index(tuple(banks))
AttributeError: 'set' object has no attribute 'index'
","
def reallocate(banks):
    seen = set()
    while tuple(banks) not in seen:
        seen.add(tuple(banks))
        i, blocks = max(enumerate(banks), key=lambda x: (x[1], -x[0]))
        banks[i] = 0
        while blocks:
            i = (i + 1) % len(banks)
            banks[i] += 1
            blocks -= 1
    return len(seen), len(seen) - seen.index(tuple(banks))

with open('input.txt') as f:
    banks = [int(x) for x in f.read().split()]
    print(reallocate(banks))
",2.0
133,133,2017,7,1,runtime_error,,cyrupz,"Traceback (most recent call last):
  File ""/tmp/tmpm53kvev_/tmp.py"", line 30, in <module>
    bottom_program = get_bottom_program('input.txt')
  File ""/tmp/tmpm53kvev_/tmp.py"", line 13, in get_bottom_program
    name, weight, children = match.groups()
ValueError: too many values to unpack (expected 3)
","
import re

def get_bottom_program(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    # Create a dictionary of programs and their weights
    programs = {}
    for line in lines:
        match = re.match(r'(\w+) \((\d+)\)( -> (.*))?', line)
        if match:
            name, weight, children = match.groups()
            programs[name] = {
                'weight': int(weight),
                'children': children.split(', ') if children else []
            }

    # Find the bottom program
    bottom_program = None
    for program in programs:
        if not any(program in children for children in programs.values()):
            bottom_program = program
            break

    return bottom_program


if __name__ == '__main__':
    bottom_program = get_bottom_program('input.txt')
    print(bottom_program)
",2.0
134,134,2017,7,2,part1_failed,,193,,,
135,135,2017,8,1,runtime_error,,4448,"Traceback (most recent call last):
  File ""/tmp/tmps84giyeo/tmp.py"", line 6, in <module>
    reg, op, val, cond_reg, cond_op, cond_val = line.split()
ValueError: too many values to unpack (expected 6)
","
registers = {}

with open('input.txt') as f:
    for line in f:
        reg, op, val, cond_reg, cond_op, cond_val = line.split()
        if eval(f'{registers.get(cond_reg, 0)} {cond_op} {cond_val}'):
            registers[reg] = registers.get(reg, 0) + (1 if op == 'inc' else -1) * int(val)

print(max(registers.values()))
",2.0
136,136,2017,8,2,part1_failed,,6582,,,
137,137,2017,9,1,wrong_output,"-188694
",7640,,"
score = 0
depth = 0
with open('input.txt') as f:
    for c in f.read():
        if c == '{':
            depth += 1
        elif c == '}':
            score += depth
            depth -= 1
print(score)
",2.0
138,138,2017,9,2,part1_failed,,4368,,,
139,139,2017,10,1,wrong_output,"272
",46600,,"
def knot_hash(lengths, size=256):
    lst = list(range(size))
    pos = 0
    skip = 0
    for length in lengths:
        lst[pos:pos+length] = lst[pos:pos+length][::-1]
        pos = (pos + length + skip) % size
        skip += 1
    return lst[0] * lst[1]

with open('input.txt') as f:
    lengths = [int(x) for x in f.read().split(',')]

print(knot_hash(lengths))
",2.0
140,140,2017,10,2,part1_failed,,23234babdc6afa036749cfa9b597de1b,,,
141,141,2017,11,1,wrong_output,"1461
",696,,"
def hex_distance(path):
    dirs = {'n': (0, -1), 'ne': (1, -1), 'se': (1, 0), 's': (0, 1), 'sw': (-1, 1), 'nw': (-1, 0)}
    x, y = 0, 0
    max_dist = 0
    for d in path.split(','):
        dx, dy = dirs[d]
        x += dx
        y += dy
        dist = max(abs(x), abs(y))
        max_dist = max(max_dist, dist)
    return max_dist

if __name__ == '__main__':
    with open('input.txt') as f:
        path = f.read().strip()
    print(hex_distance(path))
",2.0
142,142,2017,11,2,part1_failed,,1461,,,
143,143,2017,12,1,no_error,"288
",288,,"
programs = {}
with open('input.txt') as f:
    for line in f:
        program, connected = line.strip().split(' <-> ')
        programs[program] = set(connected.split(', '))

def find_group(program):
    group = set()
    stack = [program]
    while stack:
        current = stack.pop()
        if current not in group:
            group.add(current)
            stack.extend(programs[current])
    return group

print(len(find_group('0')))
",1.0
144,144,2017,12,2,runtime_error,,211,"Traceback (most recent call last):
  File ""/tmp/tmphviu39ys/tmp.py"", line 22, in <module>
    groups.add(group)
TypeError: unhashable type: 'set'
","
programs = {}
with open('input.txt') as f:
    for line in f:
        program, connected = line.strip().split(' <-> ')
        programs[program] = set(connected.split(', '))

def find_group(program):
    group = set()
    stack = [program]
    while stack:
        current = stack.pop()
        if current not in group:
            group.add(current)
            stack.extend(programs[current])
    return group

groups = set()
for program in programs:
    group = find_group(program)
    if group not in groups:
        groups.add(group)

print(len(groups))
",2.0
145,145,2017,13,1,wrong_output,"3923436
",1624,,"
def parse_firewall(firewall_str):
    firewall = []
    for line in firewall_str.splitlines():
        depth, rng = line.split(': ')
        firewall.append((int(depth), int(rng)))
    return firewall

def is_caught(firewall, delay):
    for depth, rng in firewall:
        if (depth + delay) % (2 * (rng - 1)) == 0:
            return True
    return False

def main():
    with open('input.txt') as f:
        firewall = parse_firewall(f.read())

    delay = 0
    while is_caught(firewall, delay):
        delay += 1

    print(delay)

if __name__ == '__main__':
    main()
",2.0
146,146,2017,13,2,part1_failed,,3923436,,,
147,147,2017,14,1,runtime_error,,8148,"  File ""/tmp/tmpc4_mqin1/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import hashlib

def knot_hash(key):
    lengths = [ord(c) for c in key] + [17, 31, 73, 47, 23]
    state = list(range(256))
    skip_size = 0
    current_position = 0
    for _ in range(64):
        for length in lengths:
            for i in range(length // 2):
                state[current_position + i], state[current_position + length - i - 1] = state[current_position + length - i - 1], state[current_position + i]
            current_position = (current_position + length + skip_size) % 256
            skip_size += 1
    dense_hash = []
    for i in range(16):
        xor_result = state[i * 16]
        for j in range(1, 16):
            xor_result ^= state[i * 16 + j]
        dense_hash.append(xor_result)
    return ''.",2.0
148,148,2017,14,2,part1_failed,,1180,,,
149,149,2017,15,1,runtime_error,,650,"Traceback (most recent call last):
  File ""/tmp/tmp7qxpnvzb/tmp.py"", line 19, in <module>
    print(judge(gen_a(65), gen_b(8921)))
  File ""/tmp/tmp7qxpnvzb/tmp.py"", line 15, in judge
    if a() & 0xffff == b() & 0xffff:
TypeError: 'generator' object is not callable
","
def gen_a(start):
    while True:
        start = (start * 16807) % 2147483647
        yield start

def gen_b(start):
    while True:
        start = (start * 48271) % 2147483647
        yield start

def judge(a, b):
    count = 0
    for _ in range(40000000):
        if a() & 0xffff == b() & 0xffff:
            count += 1
    return count

print(judge(gen_a(65), gen_b(8921)))
",2.0
150,150,2017,15,2,part1_failed,,336,,,
151,151,2017,16,1,no_error,"nlciboghjmfdapek
",nlciboghjmfdapek,,"
with open('input.txt', 'r') as f:
    moves = f.read().strip().split(',')

programs = list('abcdefghijklmnop')

for move in moves:
    if move[0] == 's':
        programs = programs[-int(move[1:]):] + programs[:len(programs)-int(move[1:])]
    elif move[0] == 'x':
        a, b = map(int, move[1:].split('/'))
        programs[a], programs[b] = programs[b], programs[a]
    elif move[0] == 'p':
        a, b = move[1:].split('/')
        a, b = programs.index(a), programs.index(b)
        programs[a], programs[b] = programs[b], programs[a]

print(''.join(programs))
",0.0
152,152,2017,16,2,timeout_error,,nlciboghmkedpfja,TIMEOUT,"
with open('input.txt', 'r') as f:
    moves = f.read().strip().split(',')

programs = list('abcdefghijklmnop')

for _ in range(1000000000):
    for move in moves:
        if move[0] == 's':
            programs = programs[-int(move[1:]):] + programs[:len(programs)-int(move[1:])]
        elif move[0] == 'x':
            a, b = map(int, move[1:].split('/'))
            programs[a], programs[b] = programs[b], programs[a]
        elif move[0] == 'p':
            a, b = move[1:].split('/')
            a, b = programs.index(a), programs.index(b)
            programs[a], programs[b] = programs[b], programs[a]

print(''.join(programs))
",2.0
153,153,2017,17,1,wrong_output,"638
",640,,"
def spinlock(steps):
    buffer = [0]
    current = 0
    for i in range(1, 2018):
        current = (current + steps) % len(buffer) + 1
        buffer.insert(current, i)
    return buffer[buffer.index(2017) + 1]

print(spinlock(3))
",2.0
154,154,2017,17,2,part1_failed,,47949463,,,
155,155,2017,18,1,runtime_error,,4601,"  File ""/tmp/tmp7f6yag20/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
registers = {}
for c in 'abcdefghijklmnopqrstuvwxyz':
    registers[c] = 0
pc = 0
snd = None
while True:
    instr = input().split()
    if instr[0] == 'snd':
        snd = registers[instr[1]]
    elif instr[0] == 'set':
        registers[instr[1]] = int(instr[2]) if instr[2].isdigit() else registers[instr[2]]
    elif instr[0] == 'add':
        registers[instr[1]] += int(instr[2]) if instr[2].isdigit() else registers[instr[2]]
    elif instr[0] == 'mul':
        registers[instr[1]] *= int(instr[2]) if instr[2].isdigit() else registers[instr[2]]
    elif instr[0] == 'mod':
        registers[instr[1]] %= int(instr[2]) if instr[2].isdigit() else registers[instr[2]]
    elif instr[0] == 'rcv':
        if registers[instr[1]] != 0:
            print(snd)
",2.0
156,156,2017,18,2,part1_failed,,6858,,,
157,157,2017,19,1,runtime_error,,GSXDIPWTU,"  File ""/tmp/tmpcwqf1n6k/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def follow_path(diagram):
    # Find the starting point
    for i, row in enumerate(diagram):
        if row[0] == '|':
            start_x, start_y = 0, i
            break

    # Initialize the direction
    direction = 'down'

    # Initialize the path
    path = []

    # Follow the path
    while True:
        # Get the next position
        if direction == 'down':
            next_x, next_y = start_x, start_y + 1
        elif direction == 'up':
            next_x, next_y = start_x, start_y - 1
        elif direction == 'left':
            next_x, next_y = start_x - 1, start_y
        elif direction == 'right':
            next_x, next_y = start_x + 1, start_y

        # Check if the next position is valid
        if next_x < 0 or next_x >= len(diagram[0]) or next_y < 0 or next_y >= len(diagram):
",2.0
158,158,2017,19,2,part1_failed,,16100,,,
159,159,2017,20,1,runtime_error,,344,"  File ""/tmp/tmphv83y_x7/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import math

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) + abs(p1[2] - p2[2])

def update_particle(particle):
    particle[1][0] += particle[2][0]
    particle[1][1] += particle[2][1]
    particle[1][2] += particle[2][2]
    particle[0][0] += particle[1][0]
    particle[0][1] += particle[1][1]
    particle[0][2] += particle[1][2]

def find_closest_particle(particles):
    closest_particle = 0
    closest_distance = math.inf
    for i, particle in enumerate(particles):
        distance = manhattan_distance(particle[0], [0, 0, 0])
        if distance < closest_distance:
            closest_particle = i
            closest_distance = distance
    return closest_particle

with open('input.txt') as",2.0
160,160,2017,20,2,part1_failed,,404,,,
161,161,2017,21,1,runtime_error,,179,"  File ""/tmp/tmpyiprn8qu/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def enhance(image, rules):
    new_image = []
    for i in range(0, len(image), 3):
        for j in range(0, len(image[0]), 3):
            sub_image = [image[i + k][j + l] for k in range(3) for l in range(3)]
            rule_index = int(''.join(['1' if c == '#' else '0' for c in sub_image]), 2)
            new_image.append(rules[rule_index])
    return new_image

def rotate(image):
    return [''.join(row[::-1]) for row in image[::-1]]

def flip(image):
    return [row[::-1] for row in image]

def get_all_rotations(image):
    return [image, rotate(image), rotate(rotate(image)), rotate(rotate(rotate(image))),
            flip(image), rotate(flip(image)), rotate(rotate(flip(image))), rotate(rotate(rotate(flip(image))))]

def get_all_matches(image, rules):
    ",2.0
162,162,2017,21,2,part1_failed,,2766750,,,
163,163,2017,22,1,runtime_error,,5280,"  File ""/tmp/tmpy1kqmp0d/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict

def main():
    with open('input.txt') as f:
        grid = defaultdict(lambda: '.')
        for y, line in enumerate(f):
            for x, char in enumerate(line.strip()):
                grid[(x, y)] = char

    x, y = len(grid) // 2, len(grid) // 2
    direction = 0  # 0 = up, 1 = right, 2 = down, 3 = left
    infections = 0

    for _ in range(10000):
        if grid[(x, y)] == '.':
            direction = (direction - 1) % 4
            grid[(x, y)] = '#'
            infections += 1
        else:
            direction = (direction + 1) % 4
            grid[(x, y)] = '.'

        if direction == 0:
            y -= 1
        elif direction == 1:
            x += 1
        elif direction == 2:
            y += 1
        elif direction == 3:
            x",2.0
164,164,2017,22,2,part1_failed,,2512261,,,
165,165,2017,23,1,runtime_error,,6724,"Traceback (most recent call last):
  File ""/tmp/tmpbf2j1s03/tmp.py"", line 24, in <module>
    print(run_program(instructions))
  File ""/tmp/tmpbf2j1s03/tmp.py"", line 9, in run_program
    registers[x] = int(y)
ValueError: invalid literal for int() with base 10: 'b'
","
def run_program(instructions):
    registers = {chr(ord('a') + i): 0 for i in range(8)}
    ip = 0
    mul_count = 0
    while 0 <= ip < len(instructions):
        instruction, x, y = instructions[ip]
        if instruction == 'set':
            registers[x] = int(y)
        elif instruction == 'sub':
            registers[x] -= int(y)
        elif instruction == 'mul':
            registers[x] *= int(y)
            mul_count += 1
        elif instruction == 'jnz':
            if registers[x] != 0:
                ip += int(y) - 1
        ip += 1
    return mul_count


with open('input.txt') as f:
    instructions = [line.strip().split(' ') for line in f]
print(run_program(instructions))
",2.0
166,166,2017,23,2,part1_failed,,903,,,
167,167,2017,24,1,runtime_error,,2006,"  File ""/tmp/tmpb_eikl6_/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_bridges(components):
    bridges = []
    for component in components:
        for other_component in components:
            if component[0] == other_component[1]:
                bridges.append([component, other_component])
            elif component[1] == other_component[0]:
                bridges.append([other_component, component])
    return bridges

def get_strongest_bridge(bridges):
    strongest_bridge = []
    strongest_bridge_strength = 0
    for bridge in bridges:
        bridge_strength = sum(sum(component) for component in bridge)
        if bridge_strength > strongest_bridge_strength:
            strongest_bridge = bridge
            strongest_bridge_strength = bridge_strength
    return strongest_bridge, strongest_bridge_strength

with open('input.txt') as f:
    components = [tuple(map(int, line.strip().split('/'))) for line in f]

bridges = get_bridges(components)
strongest_bridge, strongest_bridge_strength = get_strongest_bridge(bridges)

print(f'The",2.0
168,168,2017,24,2,part1_failed,,1994,,,
169,169,2017,25,1,runtime_error,,2846,"  File ""/tmp/tmpluxefoub/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

def main():
    with open('input.txt') as f:
        lines = f.readlines()

    # Parse the input
    state = lines[0].split()[3]
    checksum_steps = int(lines[1].split()[4])
    states = {}
    for line in lines[3:]:
        line = line.strip()
        if line.startswith('In state'):
            state_name = line.split()[2]
            states[state_name] = {}
        elif line.startswith('  If the current value is'):
            value = int(line.split()[5])
            states[state_name][value] = line[27:].split()

    # Initialize the tape
    tape = [0]

    # Run the Turing machine
    cursor = 0
    steps = 0
    while steps < checksum_steps:
        # Read the current value
        value = tape[cursor]

        # Get the next state and action
        next_state, write_value, move_direction = states[state][value]

        # Write the new value
        tape",2.0
170,170,2017,25,2,part1_failed,,,,,
171,0,2018,1,1,no_error,"490
",490,,"
with open('input.txt') as f:
    changes = [int(line) for line in f]

print(sum(changes))
",0.0
172,1,2018,1,2,timeout_error,,70357,TIMEOUT,"
with open('input.txt') as f:
    changes = [int(line) for line in f]

seen = set()
freq = 0
while freq not in seen:
    seen.add(freq)
    for change in changes:
        freq += change

print(freq)
",2.0
173,2,2018,2,1,no_error,"7163
",7163,,"
with open('input.txt') as f:
    box_ids = f.readlines()

# Count the number of box IDs with exactly two of any letter
two_count = 0
for box_id in box_ids:
    letter_counts = {}
    for letter in box_id:
        letter_counts[letter] = letter_counts.get(letter, 0) + 1
    if 2 in letter_counts.values():
        two_count += 1

# Count the number of box IDs with exactly three of any letter
three_count = 0
for box_id in box_ids:
    letter_counts = {}
    for letter in box_id:
        letter_counts[letter] = letter_counts.get(letter, 0) + 1
    if 3 in letter_counts.values():
        three_count += 1

# Multiply the two counts together to get the checksum
checksum = two_count * three_count

print(checksum)
",0.0
174,3,2018,2,2,runtime_error,,ighfbyijnoumxjlxevacpwqtr,"Traceback (most recent call last):
  File ""/tmp/tmpthhhd9u0/tmp.py"", line 8, in <module>
    if box_id1 != box_id2 and sum(1 for i in range(len(box_id1)) if box_id1[i] != box_id2[i]) == 1:
  File ""/tmp/tmpthhhd9u0/tmp.py"", line 8, in <genexpr>
    if box_id1 != box_id2 and sum(1 for i in range(len(box_id1)) if box_id1[i] != box_id2[i]) == 1:
IndexError: string index out of range
","
with open('input.txt') as f:
    box_ids = f.readlines()

# Find the two box IDs that differ by exactly one character
for box_id1 in box_ids:
    for box_id2 in box_ids:
        if box_id1 != box_id2 and sum(1 for i in range(len(box_id1)) if box_id1[i] != box_id2[i]) == 1:
            # Found the two box IDs
            break

# Find the common letters between the two box IDs
common_letters = ''
for i in range(len(box_id1)):
    if box_id1[i] == box_id2[i]:
        common_letters += box_id1[i]

print(common_letters)
",2.0
175,4,2018,3,1,runtime_error,,109716,"Traceback (most recent call last):
  File ""/tmp/tmp7jr3tpc7/tmp.py"", line 13, in <module>
    for j in range(claim[3], claim[3] + claim[5]):
IndexError: tuple index out of range
","
import re

claims = []
with open('input.txt') as f:
    for line in f:
        m = re.match(r'#(\d+) @ (\d+),(\d+): (\d+)x(\d+)', line)
        claims.append((int(m.group(1)), int(m.group(2)), int(m.group(3)), int(m.group(4)), int(m.group(5))))

fabric = [[0 for _ in range(1000)] for _ in range(1000)]
for claim in claims:
    for i in range(claim[2], claim[2] + claim[4]):
        for j in range(claim[3], claim[3] + claim[5]):
            fabric[i][j] += 1

count = 0
for i in range(1000):
    for j in range(1000):
        if fabric[i][j] >= 2:
            count += 1

print(count)
",2.0
176,5,2018,3,2,part1_failed,,124,,,
177,6,2018,4,1,runtime_error,,73646,"  File ""/tmp/tmpqo5qz2wa/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def get_guard_sleep_minutes(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    # Sort the lines by timestamp
    lines.sort(key=lambda x: x.split(']')[0][1:])

    # Create a dictionary to store the guard sleep minutes
    guard_sleep_minutes = {}

    # Iterate over the lines
    for line in lines:
        # Get the guard ID
        guard_id = re.findall('#(\d+)', line)[0]

        # Get the start and end times of the guard's shift
        start_time = re.findall('\[(.*)\]', line)[0]
        end_time = re.findall('\[(.*)\]', lines[lines.index(line) + 1])[0]

        # Calculate the number of minutes the guard slept
        minutes_slept = (int(end_time.split(':')[1]) - int(start_time.split(':')[1]))

        # Add the minutes slept to the dictionary
        if guard_id not in guard_",2.0
178,7,2018,4,2,part1_failed,,4727,,,
179,8,2018,5,1,no_error,"9686
",9686,,"
with open('input.txt', 'r') as f:
    polymer = f.read().strip()

def react(polymer):
    for i in range(len(polymer) - 1):
        if polymer[i] != polymer[i + 1] and polymer[i].lower() == polymer[i + 1].lower():
            return polymer[:i] + polymer[i + 2:]
    return polymer

while True:
    new_polymer = react(polymer)
    if new_polymer == polymer:
        break
    polymer = new_polymer

print(len(polymer))
",0.0
180,9,2018,5,2,wrong_output,"0
",5524,,"
with open('input.txt', 'r') as f:
    polymer = f.read().strip()

def react(polymer):
    for i in range(len(polymer) - 1):
        if polymer[i] != polymer[i + 1] and polymer[i].lower() == polymer[i + 1].lower():
            return polymer[:i] + polymer[i + 2:]
    return polymer

shortest = len(polymer)
for unit in 'abcdefghijklmnopqrstuvwxyz':
    new_polymer = polymer.replace(unit, '').replace(unit.upper(), '')
    while True:
        new_polymer = react(new_polymer)
        if new_polymer == polymer:
            break
        polymer = new_polymer
    shortest = min(shortest, len(new_polymer))

print(shortest)
",2.0
181,10,2018,6,1,runtime_error,,3909,"  File ""/tmp/tmpmis0abn3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def find_closest_coordinate(point, coordinates):
    closest_coordinate = coordinates[0]
    min_distance = manhattan_distance(point, closest_coordinate)
    for coordinate in coordinates[1:]:
        distance = manhattan_distance(point, coordinate)
        if distance < min_distance:
            closest_coordinate = coordinate
            min_distance = distance
        elif distance == min_distance:
            closest_coordinate = None
    return closest_coordinate

def find_largest_finite_area(coordinates):
    max_area = 0
    for coordinate in coordinates:
        area = 0
        for x in range(min(coordinates, key=lambda c: c[0])[0], max(coordinates, key=lambda c: c[0])[0] + 1):
            for y in range(min(coordinates, key=lambda c: c[1])[1], max(coordinates, key=lambda c: c[1",2.0
182,11,2018,6,2,part1_failed,,36238,,,
183,12,2018,7,1,runtime_error,,GKRVWBESYAMZDPTIUCFXQJLHNO,"  File ""/tmp/tmpc1ygvfve/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open(""input.txt"") as f:
    lines = f.readlines()

# Create a dictionary of prerequisites
prerequisites = {}
for line in lines:
    match = re.match(r""Step ([A-Z]) must be finished before step ([A-Z]) can begin."", line)
    if match:
        prerequisites[match.group(2)] = prerequisites.get(match.group(2), []) + [match.group(1)]

# Create a list of steps that have no prerequisites
steps = [step for step in prerequisites if step not in prerequisites.values()]

# Sort the steps alphabetically
steps.sort()

# Create a list of completed steps
completed = []

# While there are still steps to be completed
while steps:
    # Get the first step in the list
    step = steps[0]

    # If all of the step's prerequisites have been completed
    if all(prerequisite in completed for prerequisite in prerequisites.get(step, [])):
        # Add the step to the list of completed steps
        completed.append(step)

        # Remove the step from the list of",2.0
184,13,2018,7,2,part1_failed,,903,,,
185,14,2018,8,1,runtime_error,,47244,"Traceback (most recent call last):
  File ""/tmp/tmppu32vm1f/tmp.py"", line 7, in <module>
    print(sum_metadata(tree))
  File ""/tmp/tmppu32vm1f/tmp.py"", line 3, in sum_metadata
    return sum(tree[1]) + sum(sum_metadata(child) for child in tree[0])
IndexError: list index out of range
","
def sum_metadata(tree):
    return sum(tree[1]) + sum(sum_metadata(child) for child in tree[0])

with open('input.txt') as f:
    tree = [list(map(int, line.split())) for line in f]
    print(sum_metadata(tree))
",2.0
186,15,2018,8,2,part1_failed,,17267,,,
187,16,2018,9,1,runtime_error,,384288,"  File ""/tmp/tmpdpthsj75/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def play_game(num_players, last_marble):
    circle = [0]
    current_marble_index = 0
    scores = [0] * num_players
    current_player = 0

    for marble in range(1, last_marble + 1):
        if marble % 23 == 0:
            scores[current_player] += marble
            remove_index = (current_marble_index - 7) % len(circle)
            scores[current_player] += circle.pop(remove_index)
            current_marble_index = remove_index
        else:
            insert_index = (current_marble_index + 2) % len(circle)
            circle.insert(insert_index, marble)
            current_marble_index = insert_index

        current_player = (current_player + 1) % num_players

    return max(scores)


if __name__ == ""__main__"":
    with open(""input.txt"") as f:
        num_players, last_marble = map(int, f.read().split())

    print",2.0
188,17,2018,9,2,part1_failed,,3189426841,,,
189,18,2018,10,1,runtime_error,,GFNKCGGH,"  File ""/tmp/tmpk35gdfp5/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    points = [re.findall(r'-?\d+', line) for line in f]

points = [(int(x), int(y)) for x, y in points]
velocities = [(int(x), int(y)) for x, y in points]

# Find the bounding box of the points
min_x = min(x for x, y in points)
max_x = max(x for x, y in points)
min_y = min(y for x, y in points)
max_y = max(y for x, y in points)

# Find the time at which the points are closest together
time = 0
while True:
    # Update the positions of the points
    points = [(x + vx * time, y + vy * time) for (x, y), (vx, vy) in zip(points, velocities)]

    # Find the bounding box of the points
    min_x = min(x for x, y in points)
    max_x = max(x for x, y in points)
    min_",2.0
190,19,2018,10,2,part1_failed,,10274,,,
191,20,2018,11,1,runtime_error,,"235,63","  File ""/tmp/tmphf0nqi_9/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_power_level(x, y, serial_number):
    rack_id = x + 10
    power_level = rack_id * y
    power_level += serial_number
    power_level *= rack_id
    power_level = int(str(power_level)[-3])
    power_level -= 5
    return power_level

def get_max_power_square(serial_number):
    max_power = -float('inf')
    max_x = 0
    max_y = 0
    for x in range(1, 300 - 2):
        for y in range(1, 300 - 2):
            power = 0
            for i in range(3):
                for j in range(3):
                    power += get_power_level(x + i, y + j, serial_number)
            if power > max_power:
                max_power = power
                max_x = x
                max_y = y
    return max_x, max_y

if __name__ ==",2.0
192,21,2018,11,2,part1_failed,,"229,251,16",,,
193,22,2018,12,1,runtime_error,,4110,"  File ""/tmp/tmpdx_ga_8h/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict

def parse_input(filename):
    with open(filename) as f:
        lines = f.readlines()
    initial_state = lines[0].strip().split(': ')[1]
    rules = {}
    for line in lines[2:]:
        rule, result = line.strip().split(' => ')
        rules[rule] = result
    return initial_state, rules

def evolve(state, rules):
    new_state = ''
    for i in range(-2, len(state) + 2):
        rule = state[i-2:i+3]
        new_state += rules.get(rule, '.')
    return new_state

def sum_pots(state):
    return sum(i for i, c in enumerate(state) if c == '#')

def main():
    initial_state, rules = parse_input('input.txt')
    state = initial_state
    for i in range(20):
        state = evolve(state, rules)
    print(sum_pots(state))

if __name__ == '__main__':
    main",2.0
194,23,2018,12,2,part1_failed,,2650000000466,,,
195,24,2018,13,1,runtime_error,,"79,128","  File ""/tmp/tmpkn5ljap0/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

class Cart:
    def __init__(self, x, y, direction):
        self.x = x
        self.y = y
        self.direction = direction
        self.turn = 0

    def __repr__(self):
        return f""Cart({self.x}, {self.y}, {self.direction})""

    def move(self, tracks):
        if self.direction == ""^"":
            self.y -= 1
        elif self.direction == ""v"":
            self.y += 1
        elif self.direction == ""<"":
            self.x -= 1
        elif self.direction == "">"":
            self.x += 1

        if tracks[self.y][self.x] == ""+"":
            self.turn = (self.turn + 1) % 3
            if self.turn == 0:
                self.direction = {""^"": ""<"", ""v"": "">"", ""<"": ""v"", "">"": ""^""}[self.direction]
            elif self.turn == 1:
                pass
            elif self.turn == 2:",2.0
196,25,2018,13,2,part1_failed,,"3,42",,,
197,26,2018,14,1,no_error,"9411137133
",9411137133,,"
def get_recipes(n):
    recipes = [3, 7]
    elf1 = 0
    elf2 = 1
    while len(recipes) < n + 10:
        new_recipe = recipes[elf1] + recipes[elf2]
        if new_recipe >= 10:
            recipes.append(new_recipe // 10)
        recipes.append(new_recipe % 10)
        elf1 = (elf1 + recipes[elf1] + 1) % len(recipes)
        elf2 = (elf2 + recipes[elf2] + 1) % len(recipes)
    return recipes[n:]

recipes = get_recipes(int(open('input.txt').read()))
print(''.join(str(r) for r in recipes))
",1.0
198,27,2018,14,2,timeout_error,,20317612,TIMEOUT,"
def get_recipes(n):
    recipes = [3, 7]
    elf1 = 0
    elf2 = 1
    while True:
        new_recipe = recipes[elf1] + recipes[elf2]
        if new_recipe >= 10:
            recipes.append(new_recipe // 10)
        recipes.append(new_recipe % 10)
        elf1 = (elf1 + recipes[elf1] + 1) % len(recipes)
        elf2 = (elf2 + recipes[elf2] + 1) % len(recipes)
        if ''.join(str(r) for r in recipes[-len(n):]) == n:
            return len(recipes) - len(n)

print(get_recipes(open('input.txt').read()))
",2.0
199,28,2018,15,1,runtime_error,,201638,"  File ""/tmp/tmp60erawg9/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

def read_input():
    with open('input.txt') as f:
        return [list(line.strip()) for line in f.readlines()]

def print_map(map):
    for row in map:
        print(''.join(row))

def get_adjacent_squares(map, x, y):
    adjacent_squares = []
    if x > 0:
        adjacent_squares.append((x - 1, y))
    if x < len(map[0]) - 1:
        adjacent_squares.append((x + 1, y))
    if y > 0:
        adjacent_squares.append((x, y - 1))
    if y < len(map) - 1:
        adjacent_squares.append((x, y + 1))
    return adjacent_squares

def get_targets(map, x, y):
    targets = []
    for adjacent_square in get_adjacent_squares(map, x, y):
        if map[adjacent_square[1]][adjacent_square[0]] == 'G':
            targets.",2.0
200,29,2018,15,2,part1_failed,,95764,,,
201,30,2018,16,1,runtime_error,,642,"  File ""/tmp/tmp06kh_5l9/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_instruction(instruction):
    opcode, a, b, c = map(int, re.findall(r'-?\d+', instruction))
    return opcode, a, b, c

def execute_instruction(opcode, a, b, c, registers):
    if opcode == 0:
        registers[c] = registers[a] + registers[b]
    elif opcode == 1:
        registers[c] = registers[a] + b
    elif opcode == 2:
        registers[c] = registers[a] * registers[b]
    elif opcode == 3:
        registers[c] = registers[a] * b
    elif opcode == 4:
        registers[c] = registers[a] & registers[b]
    elif opcode == 5:
        registers[c] = registers[a] & b
    elif opcode == 6:
        registers[c] = registers[a] | registers[b]
    elif opcode == 7:
        registers[c] = registers[a] | b
    elif opcode == 8:
        registers[",2.0
202,31,2018,16,2,part1_failed,,481,,,
203,32,2018,17,1,runtime_error,,31788,"  File ""/tmp/tmpqtc_lcw0/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_input(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    clay = set()
    for line in lines:
        match = re.match(r'x=(\d+), y=(\d+)\.\.(\d+)', line)
        if match:
            x, y1, y2 = int(match.group(1)), int(match.group(2)), int(match.group(3))
            for y in range(y1, y2 + 1):
                clay.add((x, y))
        else:
            match = re.match(r'y=(\d+), x=(\d+)\.\.(\d+)', line)
            if match:
                y, x1, x2 = int(match.group(1)), int(match.group(2)), int(match.group(3))
                for x in range(x1, x2 + 1):
                    clay.add((x, y))

    return clay

def print_map(clay, water, min_y",2.0
204,33,2018,17,2,part1_failed,,25800,,,
205,34,2018,18,1,runtime_error,,653184,"  File ""/tmp/tmpre_xsy8p/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def get_adjacent(grid, i, j):
    adjacent = []
    for di in range(-1, 2):
        for dj in range(-1, 2):
            if di == 0 and dj == 0:
                continue
            if i + di < 0 or i + di >= grid.shape[0]:
                continue
            if j + dj < 0 or j + dj >= grid.shape[1]:
                continue
            adjacent.append(grid[i + di, j + dj])
    return adjacent

def get_next_grid(grid):
    next_grid = np.copy(grid)
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            adjacent = get_adjacent(grid, i, j)
            if grid[i, j] == '.':
                if adjacent.count('|') >= 3:
                    next_grid[i, j] = '|'
            elif grid[i, j] == '|':
                if adjacent.count('#') >= 3:
                    next",2.0
206,35,2018,18,2,part1_failed,,169106,,,
207,36,2018,19,1,runtime_error,,2520,"  File ""/tmp/tmpspndwhml/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def execute(instructions, ip_reg):
    ip = 0
    registers = [0] * 6
    while ip < len(instructions):
        registers[ip_reg] = ip
        opcode, a, b, c = instructions[ip]
        if opcode == ""addr"":
            registers[c] = registers[a] + registers[b]
        elif opcode == ""addi"":
            registers[c] = registers[a] + b
        elif opcode == ""mulr"":
            registers[c] = registers[a] * registers[b]
        elif opcode == ""muli"":
            registers[c] = registers[a] * b
        elif opcode == ""banr"":
            registers[c] = registers[a] & registers[b]
        elif opcode == ""bani"":
            registers[c] = registers[a] & b
        elif opcode == ""borr"":
            registers[c] = registers[a] | registers[b]
        elif opcode == ""bori"":
            registers[c] = registers[a] | b
        elif opcode == ""setr"":
            registers",2.0
208,37,2018,19,2,part1_failed,,27941760,,,
209,38,2018,20,1,runtime_error,,4432,"  File ""/tmp/tmp9o7lvkbi/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_regex(regex):
    # Parse the regex into a list of instructions
    instructions = []
    for char in regex:
        if char == '^' or char == '$':
            continue
        elif char == 'N':
            instructions.append('N')
        elif char == 'S':
            instructions.append('S')
        elif char == 'E':
            instructions.append('E')
        elif char == 'W':
            instructions.append('W')
        elif char == '(':
            instructions.append('(')
        elif char == ')':
            instructions.append(')')
        elif char == '|':
            instructions.append('|')
        else:
            raise ValueError('Invalid character in regex: {}'.format(char))
    return instructions

def follow_instructions(instructions, x, y, doors):
    # Follow the instructions and update the map
    for instruction in instructions:
        if instruction == 'N':
            y -= 1
        elif instruction == 'S':
            y += 1
        elif instruction == 'E':
            x += 1
        elif",2.0
210,39,2018,20,2,part1_failed,,8681,,,
211,40,2018,21,1,runtime_error,,2159153,"  File ""/tmp/tmp5esph7wp/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def parse_instruction(instruction):
    opcode, a, b, c = instruction.split()
    return opcode, int(a), int(b), int(c)

def execute_instruction(opcode, a, b, c, registers):
    if opcode == 'addr':
        registers[c] = registers[a] + registers[b]
    elif opcode == 'addi':
        registers[c] = registers[a] + b
    elif opcode == 'mulr':
        registers[c] = registers[a] * registers[b]
    elif opcode == 'muli':
        registers[c] = registers[a] * b
    elif opcode == 'banr':
        registers[c] = registers[a] & registers[b]
    elif opcode == 'bani':
        registers[c] = registers[a] & b
    elif opcode == 'borr':
        registers[c] = registers[a] | registers[b]
    elif opcode == 'bori':
        registers[c] = registers[a] | b
    elif opcode == 'setr':
        registers[c] =",2.0
212,41,2018,21,2,part1_failed,,7494885,,,
213,42,2018,22,1,runtime_error,,11972,"  File ""/tmp/tmpido9pvcq/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def get_erosion_level(x, y, depth):
    if x == 0 and y == 0:
        return 0
    elif x == target[0] and y == target[1]:
        return 0
    elif y == 0:
        return x * 16807
    elif x == 0:
        return y * 48271
    else:
        return (get_erosion_level(x - 1, y, depth) * get_erosion_level(x, y - 1, depth)) % 20183

def get_region_type(x, y, depth):
    erosion_level = get_erosion_level(x, y, depth)
    return erosion_level % 3

def get_risk_level(x, y, depth):
    region_type = get_region_type(x, y, depth)
    if region_type == 0:
        return 0
    elif region_type == 1:
        return 1
    else:",2.0
214,43,2018,22,2,part1_failed,,1092,,,
215,44,2018,23,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmp66th0m_2/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np

# Read input
with open('input.txt') as f:
    lines = f.readlines()

# Parse input
nanobots = []
for line in lines:
    pos, r = line.strip().split(', ')
    pos = np.array([int(x) for x in pos[4:-1].split(',')])
    r = int(r[2:])
    nanobots.append((pos, r))

# Find strongest nanobot
strongest_nanobot = max(nanobots, key=lambda x: x[1])

# Count nanobots in range
in_range = 0
for nanobot in nanobots:
    if np.linalg.norm(nanobot[0] - strongest_nanobot[0]) <= strongest_nanobot[1]:
        in_range += 1

# Print result
print(in_range)
",2.0
216,45,2018,23,2,part1_failed,,106323091,,,
217,46,2018,24,1,runtime_error,,14377,"  File ""/tmp/tmpqnytuarz/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

class Group:
    def __init__(self, units, hp, attack_damage, attack_type, initiative, weaknesses=None, immunities=None):
        self.units = units
        self.hp = hp
        self.attack_damage = attack_damage
        self.attack_type = attack_type
        self.initiative = initiative
        self.weaknesses = weaknesses or []
        self.immunities = immunities or []

    def __repr__(self):
        return f'{self.units} units each with {self.hp} hit points ({"", "".join(self.weaknesses)} weak to; {"", "".join(self.immunities)} immune to) with an attack that does {self.attack_damage} {self.attack_type} damage at initiative {self.initiative}'

    def effective_power(self):
        return self.units * self.attack_damage

    def damage_to(self, other):
        if self.attack_type in other.immunities:
            return 0
        elif self.attack_type in other.weaknesses:
            return 2 * self",2.0
218,47,2018,24,2,part1_failed,,6947,,,
219,48,2018,25,1,runtime_error,,363,"Traceback (most recent call last):
  File ""/tmp/tmp2nupzv1j/tmp.py"", line 29, in <module>
    main()
  File ""/tmp/tmp2nupzv1j/tmp.py"", line 24, in main
    constellations.add({p})
TypeError: unhashable type: 'set'
","
from itertools import combinations

def manhattan_distance(p1, p2):
    return sum(abs(a - b) for a, b in zip(p1, p2))

def is_in_constellation(p, constellation):
    for q in constellation:
        if manhattan_distance(p, q) <= 3:
            return True
    return False

def main():
    with open('input.txt') as f:
        points = [tuple(map(int, line.split(','))) for line in f]

    constellations = set()
    for p in points:
        for constellation in constellations:
            if is_in_constellation(p, constellation):
                constellation.add(p)
                break
        else:
            constellations.add({p})

    print(len(constellations))

if __name__ == '__main__':
    main()
",2.0
220,49,2018,25,2,part1_failed,,,,,
221,50,2019,1,1,no_error,"3336439
",3336439,,"
with open('input.txt') as f:
    print(sum(int(mass) // 3 - 2 for mass in f))
",0.0
222,51,2019,1,2,wrong_output,"-449
",5001791,,"
with open('input.txt') as f:
    print(sum(sum(int(mass) // 3 - 2 for mass in str(int(mass) // 3 - 2)) for mass in f))
",2.0
223,52,2019,2,1,no_error,"4138658
",4138658,,"
with open('input.txt') as f:
    program = [int(x) for x in f.read().split(',')]

program[1] = 12
program[2] = 2

i = 0
while True:
    opcode = program[i]
    if opcode == 99:
        break
    elif opcode == 1:
        program[program[i+3]] = program[program[i+1]] + program[program[i+2]]
    elif opcode == 2:
        program[program[i+3]] = program[program[i+1]] * program[program[i+2]]
    i += 4

print(program[0])
",0.0
224,53,2019,2,2,no_error,"7264
",7264,,"
with open('input.txt') as f:
    program = [int(x) for x in f.read().split(',')]

for noun in range(100):
    for verb in range(100):
        program_copy = program.copy()
        program_copy[1] = noun
        program_copy[2] = verb

        i = 0
        while True:
            opcode = program_copy[i]
            if opcode == 99:
                break
            elif opcode == 1:
                program_copy[program_copy[i+3]] = program_copy[program_copy[i+1]] + program_copy[program_copy[i+2]]
            elif opcode == 2:
                program_copy[program_copy[i+3]] = program_copy[program_copy[i+1]] * program_copy[program_copy[i+2]]
            i += 4

        if program_copy[0] == 19690720:
            print(100 * noun + verb)
            break
",0.0
227,56,2019,3,1,runtime_error,,248,"  File ""/tmp/tmp66etec0p/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def manhattan_distance(point1, point2):
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

def find_closest_intersection(wire1, wire2):
    # Convert the wires to sets of points
    wire1_points = set()
    for segment in wire1.split("",""):
        direction = segment[0]
        distance = int(segment[1:])
        if direction == ""R"":
            for i in range(distance):
                wire1_points.add((i, 0))
        elif direction == ""L"":
            for i in range(distance):
                wire1_points.add((-i, 0))
        elif direction == ""U"":
            for i in range(distance):
                wire1_points.add((0, i))
        elif direction == ""D"":
            for i in range(distance):
                wire1_points.add((0, -i))

    wire2_points = set()
    for segment in wire2.split("",""):
        direction = segment",2.0
228,57,2019,3,2,part1_failed,,28580,,,
229,58,2019,4,1,no_error,"454
",454,,"
with open('input.txt') as f:
    start, end = map(int, f.read().split('-'))

count = 0
for i in range(start, end + 1):
    s = str(i)
    if s[0] > s[1] or s[1] > s[2] or s[2] > s[3] or s[3] > s[4] or s[4] > s[5]:
        continue
    if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4] or s[4] == s[5]:
        count += 1

print(count)
",0.0
230,59,2019,4,2,runtime_error,,288,"  File ""/tmp/tmp6pkt6ytb/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    start, end = map(int, f.read().split('-'))

count = 0
for i in range(start, end + 1):
    s = str(i)
    if s[0] > s[1] or s[1] > s[2] or s[2] > s[3] or s[3] > s[4] or s[4] > s[5]:
        continue
    if s[0] == s[1] and s[1] == s[2]:
        continue
    if s[1] == s[2] and s[2] == s[3]:
        continue
    if s[2] == s[3] and s[3] == s[4]:
        continue
    if s[3] == s[4] and s[4] == s[5]:
        continue
    if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4] or s[",2.0
231,60,2019,5,1,runtime_error,,6069343,"  File ""/tmp/tmp5xa8ehm6/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

def get_input():
    with open('input.txt', 'r') as f:
        return [int(x) for x in f.read().split(',')]

def run_program(program, input_value):
    pc = 0
    while pc < len(program):
        opcode = program[pc] % 100
        mode_1 = (program[pc] // 100) % 10
        mode_2 = (program[pc] // 1000) % 10
        mode_3 = (program[pc] // 10000) % 10

        if opcode == 1:
            # add
            a = program[pc + 1] if mode_1 == 0 else pc + 1
            b = program[pc + 2] if mode_2 == 0 else pc + 2
            c = program[pc + 3]
            program[c] = program[a] + program[b]
            pc += 4
        elif opcode == 2:
            # multiply
            a",2.0
232,61,2019,5,2,part1_failed,,3188550,,,
233,62,2019,6,1,no_error,"142497
",142497,,"
orbits = {}
with open('input.txt') as f:
    for line in f:
        a, b = line.strip().split(')')
        orbits[b] = a

def count_orbits(obj):
    if obj not in orbits:
        return 0
    return 1 + count_orbits(orbits[obj])

print(sum(count_orbits(obj) for obj in orbits))
",0.0
234,63,2019,6,2,wrong_output,"441
",301,,"
orbits = {}
with open('input.txt') as f:
    for line in f:
        a, b = line.strip().split(')')
        orbits[b] = a

def path_to_com(obj):
    path = [obj]
    while obj in orbits:
        obj = orbits[obj]
        path.append(obj)
    return path

you_path = path_to_com('YOU')
san_path = path_to_com('SAN')

for i in range(min(len(you_path), len(san_path))):
    if you_path[i] != san_path[i]:
        break

print(len(you_path) + len(san_path) - 2 * i - 2)
",2.0
235,64,2019,7,1,runtime_error,,77500,"  File ""/tmp/tmp0k71wxos/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools

def run_amplifier(program, phase_setting, input_signal):
    inputs = [phase_setting, input_signal]
    output = 0
    for i in range(0, len(program), 4):
        opcode = program[i]
        if opcode == 99:
            break
        elif opcode == 1:
            program[program[i+3]] = program[program[i+1]] + program[program[i+2]]
        elif opcode == 2:
            program[program[i+3]] = program[program[i+1]] * program[program[i+2]]
        elif opcode == 3:
            program[program[i+1]] = inputs.pop(0)
        elif opcode == 4:
            output = program[program[i+1]]
            inputs.append(output)
        elif opcode == 5:
            if program[program[i+1]] != 0:
                i = program[program[i+2]] - 4
                continue
        elif opcode == 6:
            if program[",2.0
236,65,2019,7,2,part1_failed,,22476942,,,
237,66,2019,8,1,no_error,"1742
",1742,,"
with open('input.txt') as f:
    data = f.read()

layers = [data[i:i+25*6] for i in range(0, len(data), 25*6)]

fewest_zeros = min(layers, key=lambda x: x.count('0'))

print(fewest_zeros.count('1') * fewest_zeros.count('2'))
",0.0
238,67,2019,8,2,wrong_output," ##    ## #   #####  ##  #  #    # #   ##    #  # #       #  # # ###  #  # # ##    #   #  #    #### #  # #  #   #  #    #  #  ###  ##    #  #### #  # 
",GJYEA,,"
with open('input.txt') as f:
    data = f.read()

layers = [data[i:i+25*6] for i in range(0, len(data), 25*6)]

image = ''
for i in range(25*6):
    for layer in layers:
        if layer[i] != '2':
            image += layer[i]
            break

print(image.replace('0', ' ').replace('1', '#'))
",2.0
239,68,2019,9,1,runtime_error,,3780860499,"  File ""/tmp/tmpbinoxhqs/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

class Intcode:
    def __init__(self, program):
        self.program = program + [0] * 100000
        self.pc = 0
        self.rb = 0

    def run(self, inputs):
        outputs = []
        while True:
            opcode = self.program[self.pc] % 100
            mode1 = self.program[self.pc] // 100 % 10
            mode2 = self.program[self.pc] // 1000 % 10
            mode3 = self.program[self.pc] // 10000 % 10
            if opcode == 99:
                return outputs
            elif opcode == 1:
                self.program[self.program[self.pc + 3]] = self.get_value(self.program[self.pc + 1], mode1) + self.get_value(self.program[self.pc + 2], mode2)
                self.pc += 4
            elif opcode == 2:",2.0
240,69,2019,9,2,part1_failed,,33343,,,
241,70,2019,10,1,runtime_error,,309,"  File ""/tmp/tmpjkury9p_/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def get_asteroid_map(filename):
    with open(filename, 'r') as f:
        asteroid_map = np.array([list(line.strip()) for line in f.readlines()])
    return asteroid_map

def get_visible_asteroids(asteroid_map, x, y):
    visible_asteroids = set()
    for i in range(asteroid_map.shape[0]):
        for j in range(asteroid_map.shape[1]):
            if asteroid_map[i, j] == '#' and (i != x or j != y):
                if is_visible(asteroid_map, x, y, i, j):
                    visible_asteroids.add((i, j))
    return visible_asteroids

def is_visible(asteroid_map, x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    gcd = np.gcd(dx, dy)
    dx //= gcd
    dy //= gcd
    for i in range(1, max(abs(dx),",2.0
242,71,2019,10,2,part1_failed,,416,,,
243,72,2019,11,1,runtime_error,,2336,"  File ""/tmp/tmps7k_xybw/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

class Robot:
    def __init__(self, program):
        self.program = program
        self.ip = 0
        self.rb = 0
        self.memory = np.zeros(10000, dtype=np.int64)
        self.memory[:len(program)] = program
        self.direction = np.array([0, 1])
        self.position = np.array([0, 0])
        self.painted = set()

    def run(self):
        while True:
            opcode = self.memory[self.ip] % 100
            if opcode == 99:
                break
            elif opcode == 1:
                self.memory[self.get_address(3)] = self.get_value(1) + self.get_value(2)
                self.ip += 4
            elif opcode == 2:
                self.memory[self.get_address(3)] = self.get_value(1) * self.get_value(2)
                self.ip += 4
",2.0
244,73,2019,11,2,part1_failed,,UZAEKBLP,,,
245,74,2019,12,1,runtime_error,,6220,"  File ""/tmp/tmp8utpco_7/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def apply_gravity(moons):
    """"""Apply gravity to the moons.""""""
    for i in range(len(moons)):
        for j in range(i + 1, len(moons)):
            moon1, moon2 = moons[i], moons[j]
            for k in range(3):
                if moon1[k] < moon2[k]:
                    moon1[k] += 1
                    moon2[k] -= 1
                elif moon1[k] > moon2[k]:
                    moon1[k] -= 1
                    moon2[k] += 1

def apply_velocity(moons):
    """"""Apply velocity to the moons.""""""
    for moon in moons:
        for i in range(3):
            moon[i] += moon[i + 3]

def simulate_moons(moons, steps):
    """"""Simulate the moons for the given number of steps.""""""
    for _ in range(steps):
        apply_gravity(moons)
        apply_velocity(moons)

def calculate_energy(moons):
    """"""Calculate the total energy of",2.0
246,75,2019,12,2,part1_failed,,548525804273976,,,
247,76,2019,13,1,runtime_error,,270,"  File ""/tmp/tmp57qbcxp3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools
from collections import defaultdict

def get_input():
    with open('input.txt') as f:
        return [int(x) for x in f.read().split(',')]

def run_intcode(program, inputs):
    i = 0
    relative_base = 0
    outputs = []

    def get_value(parameter, mode):
        if mode == 0:
            return program[parameter]
        elif mode == 1:
            return parameter
        elif mode == 2:
            return program[relative_base + parameter]
        else:
            raise Exception(""Invalid mode: {}"".format(mode))

    def set_value(parameter, mode, value):
        if mode == 0:
            program[parameter] = value
        elif mode == 2:
            program[relative_base + parameter] = value
        else:
            raise Exception(""Invalid mode: {}"".format(mode))

    while True:
        opcode = program[i] % 100
        modes = [int(x) for x in str(program[i] // 10",2.0
248,77,2019,13,2,part1_failed,,12535,,,
249,78,2019,14,1,runtime_error,,532506,"  File ""/tmp/tmps30m70au/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict
from heapq import heappop, heappush

def parse_reaction(reaction):
    inputs, output = reaction.split(' => ')
    output_count, output_chem = output.split(' ')
    input_counts = []
    for input_chem in inputs.split(', '):
        input_count, input_chem = input_chem.split(' ')
        input_counts.append((int(input_count), input_chem))
    return (int(output_count), output_chem), input_counts

def ore_required(reactions, fuel_needed=1):
    needed = defaultdict(int, {'FUEL': fuel_needed})
    leftover = defaultdict(int)
    ore_needed = 0
    while needed:
        chem, count = heappop(needed)
        if chem == 'ORE':
            ore_needed += count
        else:
            produced, inputs = reactions[chem]
            reaction_count = (count + produced - 1) // produced
            for input_count, input_chem in inputs:
                leftover[input_chem] += reaction_",2.0
250,79,2019,14,2,part1_failed,,2595245,,,
251,80,2019,15,1,runtime_error,,300,"  File ""/tmp/tmp5bz1no6c/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys
from collections import defaultdict
from enum import Enum


class Direction(Enum):
    NORTH = 1
    SOUTH = 2
    WEST = 3
    EAST = 4


class Status(Enum):
    WALL = 0
    MOVED = 1
    OXYGEN = 2


class RepairDroid:
    def __init__(self, program):
        self.program = program
        self.pc = 0
        self.relative_base = 0
        self.grid = defaultdict(lambda: defaultdict(int))
        self.position = (0, 0)
        self.direction = Direction.NORTH

    def run(self):
        while True:
            opcode = self.program[self.pc] % 100
            if opcode == 99:
                break
            elif opcode == 1:
                self.add(self.pc + 1, self.pc + 2, self.pc + 3)
            elif opcode == 2:
                self.multiply(self.pc + 1, self.pc + 2, self.pc + 3",2.0
252,81,2019,15,2,part1_failed,,312,,,
253,82,2019,16,1,wrong_output,"15011190
",68317988,,"
def fft(signal):
    signal = list(map(int, signal))
    for _ in range(100):
        new_signal = []
        for i in range(len(signal)):
            pattern = [0] * (i + 1) + [1] * (i + 1) + [0] * (i + 1) + [-1] * (i + 1)
            pattern = pattern[1:] + pattern[:1]
            new_signal.append(abs(sum(a * b for a, b in zip(signal, pattern))) % 10)
        signal = new_signal
    return ''.join(map(str, signal[:8]))

with open('input.txt') as f:
    signal = f.read().strip()
    print(fft(signal))
",2.0
254,83,2019,16,2,part1_failed,,53850800,,,
255,84,2019,17,1,runtime_error,,9876,"  File ""/tmp/tmp_uxj3m2k/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools
import sys

def get_input():
    with open('input.txt') as f:
        return [int(x) for x in f.read().split(',')]

def run_program(program, inputs):
    ip = 0
    rb = 0
    outputs = []
    while True:
        opcode = program[ip] % 100
        mode1 = program[ip] // 100 % 10
        mode2 = program[ip] // 1000 % 10
        mode3 = program[ip] // 10000 % 10
        if opcode == 99:
            break
        elif opcode == 1:
            p1 = program[ip+1] if mode1 == 1 else program[rb+program[ip+1]] if mode1 == 2 else program[program[ip+1]]
            p2 = program[ip+2] if mode2 == 1 else program[rb+program[ip+2]] if mode2 == 2 else program[program[ip+2]]
            program[",2.0
256,85,2019,17,2,part1_failed,,1234055,,,
257,86,2019,18,1,runtime_error,,6316,"  File ""/tmp/tmpbyuuhqsq/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import deque

def get_neighbors(x, y, grid):
    neighbors = []
    if x > 0 and grid[y][x-1] != '#':
        neighbors.append((x-1, y))
    if x < len(grid[0])-1 and grid[y][x+1] != '#':
        neighbors.append((x+1, y))
    if y > 0 and grid[y-1][x] != '#':
        neighbors.append((x, y-1))
    if y < len(grid)-1 and grid[y+1][x] != '#':
        neighbors.append((x, y+1))
    return neighbors

def get_keys(grid):
    keys = []
    for y in range(len(grid)):
        for x in range(len(grid[0])):
            if grid[y][x].islower():
                keys.append((x, y))
    return keys

def get_doors(grid):
    doors = []
    for y in range(len(grid)):
        for x in range(len",2.0
258,87,2019,18,2,part1_failed,,1648,,,
259,88,2019,19,1,runtime_error,,150,"  File ""/tmp/tmp101jflb3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools

def get_input():
    with open('input.txt') as f:
        return list(map(int, f.read().split(',')))

def run_program(program, inputs):
    i = 0
    relative_base = 0
    outputs = []

    def get_value(parameter_mode, value):
        if parameter_mode == 0:
            return program[value]
        elif parameter_mode == 1:
            return value
        elif parameter_mode == 2:
            return program[relative_base + value]
        else:
            raise ValueError('Invalid parameter mode: {}'.format(parameter_mode))

    def set_value(parameter_mode, value, new_value):
        if parameter_mode == 0:
            program[value] = new_value
        elif parameter_mode == 2:
            program[relative_base + value] = new_value
        else:
            raise ValueError('Invalid parameter mode: {}'.format(parameter_mode))

    while True:
        opcode = program[i] % 100
        parameter",2.0
260,89,2019,19,2,part1_failed,,12201460,,,
261,90,2019,20,1,runtime_error,,608,"  File ""/tmp/tmpgbl9rmx4/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import deque

def get_neighbors(maze, x, y):
    neighbors = []
    if x > 0 and maze[y][x - 1] != '#':
        neighbors.append((x - 1, y))
    if x < len(maze[0]) - 1 and maze[y][x + 1] != '#':
        neighbors.append((x + 1, y))
    if y > 0 and maze[y - 1][x] != '#':
        neighbors.append((x, y - 1))
    if y < len(maze) - 1 and maze[y + 1][x] != '#':
        neighbors.append((x, y + 1))
    return neighbors

def get_portals(maze):
    portals = {}
    for y in range(len(maze)):
        for x in range(len(maze[0])):
            if maze[y][x] in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':
                if maze[y][x] not in portals:
                    portals[maze[y][x]] = []
                port",2.0
262,91,2019,20,2,part1_failed,,6706,,,
263,92,2019,21,1,runtime_error,,19358688,"  File ""/tmp/tmpuiqmnbtu/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys

def run_program(program, inputs):
    pc = 0
    relative_base = 0
    outputs = []
    while True:
        opcode = program[pc] % 100
        mode1 = program[pc] // 100 % 10
        mode2 = program[pc] // 1000 % 10
        mode3 = program[pc] // 10000 % 10
        if opcode == 99:
            break
        elif opcode == 1:
            p1 = program[pc + 1] if mode1 == 1 else program[relative_base + program[pc + 1]] if mode1 == 2 else program[program[pc + 1]]
            p2 = program[pc + 2] if mode2 == 1 else program[relative_base + program[pc + 2]] if mode2 == 2 else program[program[pc + 2]]
            program[program[pc + 3] + (relative_base if mode3 == 2 else 0)] = p1 + p",2.0
264,93,2019,21,2,part1_failed,,1141236756,,,
265,94,2019,22,1,runtime_error,,1252,"  File ""/tmp/tmp_nl0s6rk/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def deal_into_new_stack(deck):
    return deck[::-1]

def cut(deck, n):
    if n >= 0:
        return deck[n:] + deck[:n]
    else:
        return deck[-n:] + deck[:-n]

def deal_with_increment(deck, n):
    new_deck = [0] * len(deck)
    for i, card in enumerate(deck):
        new_deck[(i * n) % len(deck)] = card
    return new_deck

def shuffle(deck, instructions):
    for instruction in instructions:
        if instruction.startswith(""deal into new stack""):
            deck = deal_into_new_stack(deck)
        elif instruction.startswith(""cut""):
            n = int(instruction.split("" "")[1])
            deck = cut(deck, n)
        elif instruction.startswith(""deal with increment""):
            n = int(instruction.split("" "")[3])
            deck = deal_with_increment(deck, n)
    return deck

with open(""input.txt"") as f:
    instructions = [",2.0
266,95,2019,22,2,part1_failed,,46116012647793,,,
267,96,2019,23,1,runtime_error,,24922,"  File ""/tmp/tmpfwj3_aek/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import itertools
import sys

class Intcode:
    def __init__(self, program):
        self.program = program.copy()
        self.ip = 0
        self.rb = 0

    def get_param(self, mode, offset):
        if mode == 0:
            return self.program[self.program[self.ip + offset]]
        elif mode == 1:
            return self.program[self.ip + offset]
        elif mode == 2:
            return self.program[self.rb + self.program[self.ip + offset]]
        else:
            raise ValueError(""Invalid mode: {}"".format(mode))

    def set_param(self, mode, offset, value):
        if mode == 0:
            self.program[self.program[self.ip + offset]] = value
        elif mode == 2:
            self.program[self.rb + self.program[self.ip + offset]] = value
        else:
            raise ValueError(""Invalid mode: {}"".format(mode))

    def run(self, inputs):
        outputs = []",2.0
268,97,2019,23,2,part1_failed,,19478,,,
269,98,2019,24,1,runtime_error,,1151290,"  File ""/tmp/tmpz_f_r14f/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_adjacent(grid, x, y):
    adjacent = []
    if x > 0:
        adjacent.append(grid[y][x - 1])
    if x < len(grid[0]) - 1:
        adjacent.append(grid[y][x + 1])
    if y > 0:
        adjacent.append(grid[y - 1][x])
    if y < len(grid) - 1:
        adjacent.append(grid[y + 1][x])
    return adjacent


def get_biodiversity_rating(grid):
    rating = 0
    for y in range(len(grid)):
        for x in range(len(grid[0])):
            if grid[y][x] == ""#"":
                rating += 2 ** (y * 5 + x)
    return rating


def print_grid(grid):
    for row in grid:
        print("""".join(row))


def main():
    with open(""input.txt"") as f:
        grid = [list(line.strip()) for line in f.readlines",2.0
270,99,2019,24,2,part1_failed,,1953,,,
271,100,2019,25,1,runtime_error,,25166400,"  File ""/tmp/tmp_oa2de50/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import sys
import time

class Intcode:
    def __init__(self, program):
        self.program = program.copy()
        self.ip = 0
        self.rb = 0

    def run(self, inputs):
        outputs = []
        while True:
            opcode = self.program[self.ip] % 100
            mode1 = self.program[self.ip] // 100 % 10
            mode2 = self.program[self.ip] // 1000 % 10
            mode3 = self.program[self.ip] // 10000 % 10
            if opcode == 99:
                break
            elif opcode == 1:
                self.program[self.get_address(3, mode3)] = self.get_value(1, mode1) + self.get_value(2, mode2)
                self.ip += 4
            elif opcode == 2:
                self.program[self.get_address(3, mode3)] = self.get_value(1",2.0
272,101,2019,25,2,part1_failed,,,,,
273,102,2020,1,1,no_error,"928896
",928896,,"
with open('input.txt', 'r') as f:
    numbers = [int(line.strip()) for line in f]

for i in range(len(numbers)):
    for j in range(i + 1, len(numbers)):
        if numbers[i] + numbers[j] == 2020:
            print(numbers[i] * numbers[j])
            break
",0.0
274,103,2020,1,2,no_error,"295668576
",295668576,,"
with open('input.txt', 'r') as f:
    numbers = [int(line.strip()) for line in f]

for i in range(len(numbers)):
    for j in range(i + 1, len(numbers)):
        for k in range(j + 1, len(numbers)):
            if numbers[i] + numbers[j] + numbers[k] == 2020:
                print(numbers[i] * numbers[j] * numbers[k])
                break
",0.0
277,106,2020,2,1,runtime_error,,434,"Traceback (most recent call last):
  File ""/tmp/tmp3itsh4ua/tmp.py"", line 12, in <module>
    if is_valid(policy, password):
  File ""/tmp/tmp3itsh4ua/tmp.py"", line 3, in is_valid
    min_count, max_count, letter = policy.split()
ValueError: not enough values to unpack (expected 3, got 2)
","
def is_valid(policy, password):
    min_count, max_count, letter = policy.split()
    min_count = int(min_count)
    max_count = int(max_count)
    return min_count <= password.count(letter) <= max_count

with open('input.txt') as f:
    valid_passwords = 0
    for line in f:
        policy, password = line.split(':')
        if is_valid(policy, password):
            valid_passwords += 1
    print(valid_passwords)
",2.0
278,107,2020,2,2,part1_failed,,509,,,
279,108,2020,3,1,no_error,"292
",292,,"
def count_trees(map, slope):
    x, y = 0, 0
    tree_count = 0
    while y < len(map):
        if map[y][x] == '#':
            tree_count += 1
        x = (x + slope[0]) % len(map[0])
        y += slope[1]
    return tree_count

with open('input.txt') as f:
    map = [line.strip() for line in f.readlines()]
    print(count_trees(map, (3, 1)))
",0.0
280,109,2020,3,2,no_error,"9354744432
",9354744432,,"
def count_trees(map, slope):
    x, y = 0, 0
    tree_count = 0
    while y < len(map):
        if map[y][x] == '#':
            tree_count += 1
        x = (x + slope[0]) % len(map[0])
        y += slope[1]
    return tree_count

with open('input.txt') as f:
    map = [line.strip() for line in f.readlines()]
    slopes = [(1, 1), (3, 1), (5, 1), (7, 1), (1, 2)]
    product = 1
    for slope in slopes:
        product *= count_trees(map, slope)
    print(product)
",0.0
283,112,2020,4,1,no_error,"233
",233,,"
import re

def is_valid(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

with open('input.txt') as f:
    passports = f.read().split('\n\n')

valid_passports = 0
for passport in passports:
    if is_valid(passport):
        valid_passports += 1

print(valid_passports)
",0.0
284,113,2020,4,2,runtime_error,,111,"  File ""/tmp/tmphcia0aux/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def is_valid(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

def is_valid_data(passport):
    byr = int(passport['byr'])
    if byr < 1920 or byr > 2002:
        return False
    iyr = int(passport['iyr'])
    if iyr < 2010 or iyr > 2020:
        return False
    eyr = int(passport['eyr'])
    if eyr < 2020 or eyr > 2030:
        return False
    hgt = passport['hgt']
    if hgt[-2:] == 'cm':
        hgt = int(hgt[:-2])
        if hgt < 150 or hgt > 193:
            return False
    elif hgt[-2:] == 'in",2.0
285,114,2020,5,1,no_error,"987
",987,,"
def get_seat_id(boarding_pass):
    row = int(boarding_pass[:7].replace(""F"", ""0"").replace(""B"", ""1""), 2)
    column = int(boarding_pass[7:].replace(""L"", ""0"").replace(""R"", ""1""), 2)
    return row * 8 + column

with open(""input.txt"") as f:
    boarding_passes = [line.strip() for line in f]

print(max(get_seat_id(boarding_pass) for boarding_pass in boarding_passes))
",0.0
286,115,2020,5,2,no_error,"603
",603,,"
def get_seat_id(boarding_pass):
    row = int(boarding_pass[:7].replace(""F"", ""0"").replace(""B"", ""1""), 2)
    column = int(boarding_pass[7:].replace(""L"", ""0"").replace(""R"", ""1""), 2)
    return row * 8 + column

with open(""input.txt"") as f:
    boarding_passes = [line.strip() for line in f]

seat_ids = set(get_seat_id(boarding_pass) for boarding_pass in boarding_passes)
for seat_id in range(min(seat_ids), max(seat_ids) + 1):
    if seat_id not in seat_ids and seat_id - 1 in seat_ids and seat_id + 1 in seat_ids:
        print(seat_id)
",0.0
289,118,2020,6,1,no_error,"6775
",6775,,"
with open('input.txt') as f:
    groups = f.read().split('\n\n')

def count_yes(group):
    return len(set(group.replace('\n', '')))

print(sum(count_yes(group) for group in groups))
",0.0
290,119,2020,6,2,no_error,"3356
",3356,,"
with open('input.txt') as f:
    groups = f.read().split('\n\n')

def count_yes(group):
    return len(set.intersection(*[set(person) for person in group.split('\n')]))

print(sum(count_yes(group) for group in groups))
",0.0
292,121,2020,7,1,wrong_output,"30
",226,,"
import re

def parse_rules(rules):
    bags = {}
    for rule in rules:
        bag, contents = rule.split("" contain "")
        bag = bag.replace("" bags"", """")
        contents = contents.replace(""."", """").replace("" bags"", """").replace("" bag"", """")
        if contents == ""no other"":
            bags[bag] = []
        else:
            bags[bag] = [content.split("" "", 1) for content in contents.split("", "")]
    return bags

def find_bags(bags, bag):
    found = set()
    for b in bags:
        if bag in [c[1] for c in bags[b]]:
            found.add(b)
            found.update(find_bags(bags, b))
    return found

with open(""input.txt"") as f:
    rules = f.readlines()

bags = parse_rules(rules)
print(len(find_bags(bags, ""shiny gold"")))
",2.0
293,122,2020,7,2,part1_failed,,9569,,,
294,123,2020,8,1,no_error,"1384
",1384,,"
def run_program(instructions):
    accumulator = 0
    pc = 0
    visited = set()
    while pc not in visited and pc < len(instructions):
        visited.add(pc)
        op, arg = instructions[pc].split()
        if op == 'acc':
            accumulator += int(arg)
            pc += 1
        elif op == 'jmp':
            pc += int(arg)
        elif op == 'nop':
            pc += 1
    return accumulator, pc == len(instructions)

with open('input.txt') as f:
    instructions = [line.strip() for line in f]

accumulator, terminated = run_program(instructions)
print(accumulator)
",1.0
295,124,2020,8,2,runtime_error,,761,"  File ""/tmp/tmpnb9r2tfi/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def run_program(instructions):
    accumulator = 0
    pc = 0
    visited = set()
    while pc not in visited and pc < len(instructions):
        visited.add(pc)
        op, arg = instructions[pc].split()
        if op == 'acc':
            accumulator += int(arg)
            pc += 1
        elif op == 'jmp':
            pc += int(arg)
        elif op == 'nop':
            pc += 1
    return accumulator, pc == len(instructions)

with open('input.txt') as f:
    instructions = [line.strip() for line in f]

for i in range(len(instructions)):
    if instructions[i].startswith('nop'):
        instructions[i] = instructions[i].replace('nop', 'jmp')
        accumulator, terminated = run_program(instructions)
        if terminated:
            print(accumulator)
            break
        instructions[i] = instructions[i].replace('jmp', 'nop')
    elif instructions[i].startswith('jmp'):
        instructions[i] = instructions[i].replace",2.0
296,125,2020,9,1,no_error,"258585477
",258585477,,"
with open('input.txt') as f:
    nums = [int(line) for line in f]

preamble = 25
for i in range(preamble, len(nums)):
    found = False
    for j in range(i-preamble, i):
        for k in range(j+1, i):
            if nums[j] + nums[k] == nums[i]:
                found = True
                break
        if found:
            break
    if not found:
        print(nums[i])
        break
",0.0
297,126,2020,9,2,wrong_output,"36981213
517170954
",36981213,,"
with open('input.txt') as f:
    nums = [int(line) for line in f]

preamble = 25
invalid = 0
for i in range(preamble, len(nums)):
    found = False
    for j in range(i-preamble, i):
        for k in range(j+1, i):
            if nums[j] + nums[k] == nums[i]:
                found = True
                break
        if found:
            break
    if not found:
        invalid = nums[i]
        break

for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if sum(nums[i:j]) == invalid:
            print(min(nums[i:j]) + max(nums[i:j]))
            break
",2.0
298,127,2020,10,1,no_error,"2263
",2263,,"
with open('input.txt', 'r') as f:
    adapters = [int(line.strip()) for line in f]

adapters.sort()
adapters.insert(0, 0)
adapters.append(adapters[-1] + 3)

differences = [0] * 4
for i in range(1, len(adapters)):
    diff = adapters[i] - adapters[i - 1]
    differences[diff] += 1

print(differences[1] * differences[3])
",0.0
299,128,2020,10,2,no_error,"396857386627072
",396857386627072,,"
with open('input.txt', 'r') as f:
    adapters = [int(line.strip()) for line in f]

adapters.sort()
adapters.insert(0, 0)
adapters.append(adapters[-1] + 3)

ways = [0] * len(adapters)
ways[0] = 1

for i in range(1, len(adapters)):
    for j in range(i - 3, i):
        if j >= 0 and adapters[i] - adapters[j] <= 3:
            ways[i] += ways[j]

print(ways[-1])
",0.0
302,131,2020,11,1,runtime_error,,2368,"  File ""/tmp/tmpelbmmlzm/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_adjacent_seats(seat_map, row, col):
    adjacent_seats = []
    for i in range(row-1, row+2):
        for j in range(col-1, col+2):
            if i >= 0 and i < len(seat_map) and j >= 0 and j < len(seat_map[0]) and (i != row or j != col):
                adjacent_seats.append(seat_map[i][j])
    return adjacent_seats

def apply_seating_rules(seat_map):
    new_seat_map = []
    for row in range(len(seat_map)):
        new_row = []
        for col in range(len(seat_map[0])):
            adjacent_seats = get_adjacent_seats(seat_map, row, col)
            if seat_map[row][col] == 'L' and '#' not in adjacent_seats:
                new_row.append('#')
            elif seat_map[row][col] == '#' and adjacent_seats.count('#') >= 4:
                new",2.0
303,132,2020,11,2,part1_failed,,2124,,,
304,133,2020,12,1,runtime_error,,962,"  File ""/tmp/tmpxc6vuho3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import math

def main():
    with open('input.txt') as f:
        instructions = f.read().splitlines()

    # Initialize the ship's position and heading.
    x = 0
    y = 0
    heading = 0

    # Process the instructions.
    for instruction in instructions:
        action = instruction[0]
        value = int(instruction[1:])

        if action == 'N':
            y += value
        elif action == 'S':
            y -= value
        elif action == 'E':
            x += value
        elif action == 'W':
            x -= value
        elif action == 'L':
            heading = (heading - value) % 360
        elif action == 'R':
            heading = (heading + value) % 360
        elif action == 'F':
            x += math.cos(math.radians(heading)) * value
            y += math.sin(math.radians(heading)) * value

    # Calculate the Manhattan distance.
    manhattan_distance = abs(x) + abs(y)

    #",2.0
305,134,2020,12,2,part1_failed,,56135,,,
306,135,2020,13,1,no_error,"2095
",2095,,"
with open('input.txt') as f:
    timestamp, buses = f.read().splitlines()

timestamp = int(timestamp)
buses = [int(bus) for bus in buses.split(',') if bus != 'x']

next_bus = min((bus - timestamp % bus, bus) for bus in buses)
print(next_bus[0] * next_bus[1])
",0.0
307,136,2020,13,2,runtime_error,,598411311431841,"Traceback (most recent call last):
  File ""/tmp/tmp9pa8ardp/tmp.py"", line 8, in <module>
    while (timestamp + i) % bus != 0:
TypeError: unsupported operand type(s) for %: 'int' and 'NoneType'
","
with open('input.txt') as f:
    buses = [int(bus) if bus != 'x' else None for bus in f.read().splitlines()[1].split(',')]

timestamp = 0
step = buses[0]
for i, bus in enumerate(buses[1:], 1):
    while (timestamp + i) % bus != 0:
        timestamp += step
    step *= bus

print(timestamp)
",2.0
308,137,2020,14,1,no_error,"14553106347726
",14553106347726,,"
def apply_mask(mask, value):
    value = bin(value)[2:].zfill(36)
    result = """"
    for i in range(36):
        if mask[i] == ""X"":
            result += value[i]
        else:
            result += mask[i]
    return int(result, 2)

def main():
    mask = """"
    memory = {}
    with open(""input.txt"") as f:
        for line in f:
            line = line.strip()
            if line.startswith(""mask""):
                mask = line.split("" = "")[1]
            else:
                address = int(line.split(""["")[1].split(""]"")[0])
                value = int(line.split("" = "")[1])
                memory[address] = apply_mask(mask, value)

    print(sum(memory.values()))

if __name__ == ""__main__"":
    main()
",0.0
309,138,2020,14,2,runtime_error,,2737766154126,"  File ""/tmp/tmpgj24_khm/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def apply_mask(mask, address):
    address = bin(address)[2:].zfill(36)
    result = """"
    for i in range(36):
        if mask[i] == ""0"":
            result += address[i]
        elif mask[i] == ""1"":
            result += ""1""
        else:
            result += ""X""
    return result

def main():
    mask = """"
    memory = {}
    with open(""input.txt"") as f:
        for line in f:
            line = line.strip()
            if line.startswith(""mask""):
                mask = line.split("" = "")[1]
            else:
                address = int(line.split(""["")[1].split(""]"")[0])
                value = int(line.split("" = "")[1])
                address = apply_mask(mask, address)
                for i in range(2**address.count(""X"")):
                    binary = bin(i)[2:].zfill(address.count(""X""))
                    new_address = address.replace(""X"", binary, ",2.0
310,139,2020,15,1,no_error,"468
",468,,"
from collections import defaultdict

def memory_game(starting_numbers, turns):
    spoken_numbers = defaultdict(list)
    for i, number in enumerate(starting_numbers):
        spoken_numbers[number].append(i + 1)
    last_number = starting_numbers[-1]
    for turn in range(len(starting_numbers) + 1, turns + 1):
        if len(spoken_numbers[last_number]) == 1:
            last_number = 0
        else:
            last_number = spoken_numbers[last_number][-1] - spoken_numbers[last_number][-2]
        spoken_numbers[last_number].append(turn)
    return last_number

with open('input.txt', 'r') as f:
    starting_numbers = [int(number) for number in f.read().split(',')]

print(memory_game(starting_numbers, 2020))
",1.0
311,140,2020,15,2,no_error,"1801753
",1801753,,"
from collections import defaultdict

def memory_game(starting_numbers, turns):
    spoken_numbers = defaultdict(list)
    for i, number in enumerate(starting_numbers):
        spoken_numbers[number].append(i + 1)
    last_number = starting_numbers[-1]
    for turn in range(len(starting_numbers) + 1, turns + 1):
        if len(spoken_numbers[last_number]) == 1:
            last_number = 0
        else:
            last_number = spoken_numbers[last_number][-1] - spoken_numbers[last_number][-2]
        spoken_numbers[last_number].append(turn)
    return last_number

with open('input.txt', 'r') as f:
    starting_numbers = [int(number) for number in f.read().split(',')]

print(memory_game(starting_numbers, 30000000))
",0.0
314,143,2020,16,1,no_error,"26026
",26026,,"
import re

with open('input.txt') as f:
    rules, my_ticket, nearby_tickets = f.read().split('\n\n')

rules = [re.match(r'(.+): (\d+)-(\d+) or (\d+)-(\d+)', rule).groups() for rule in rules.splitlines()]
my_ticket = [int(num) for num in my_ticket.splitlines()[1].split(',')]
nearby_tickets = [[int(num) for num in ticket.split(',')] for ticket in nearby_tickets.splitlines()[1:]]

error_rate = 0
for ticket in nearby_tickets:
    for num in ticket:
        if not any(int(rule[1]) <= num <= int(rule[2]) or int(rule[3]) <= num <= int(rule[4]) for rule in rules):
            error_rate += num

print(error_rate)
",0.0
315,144,2020,16,2,runtime_error,,1305243193339,"  File ""/tmp/tmporcmvanb/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    rules, my_ticket, nearby_tickets = f.read().split('\n\n')

rules = [re.match(r'(.+): (\d+)-(\d+) or (\d+)-(\d+)', rule).groups() for rule in rules.splitlines()]
my_ticket = [int(num) for num in my_ticket.splitlines()[1].split(',')]
nearby_tickets = [[int(num) for num in ticket.split(',')] for ticket in nearby_tickets.splitlines()[1:]]

valid_tickets = []
for ticket in nearby_tickets:
    if all(any(int(rule[1]) <= num <= int(rule[2]) or int(rule[3]) <= num <= int(rule[4]) for rule in rules) for num in ticket):
        valid_tickets.append(ticket)

fields = [[] for _ in range(len(valid_tickets[0]))]
for ticket in valid_tickets:
    for i, num in enumerate(ticket):
        fields[i].append(num)

possible_fields",2.0
316,145,2020,17,1,runtime_error,,263,"  File ""/tmp/tmp8dsft57x/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def read_input():
    with open('input.txt') as f:
        return [list(line.strip()) for line in f.readlines()]

def get_neighbors(x, y, z, grid):
    neighbors = []
    for i in range(-1, 2):
        for j in range(-1, 2):
            for k in range(-1, 2):
                if i == 0 and j == 0 and k == 0:
                    continue
                if 0 <= x + i < len(grid) and 0 <= y + j < len(grid[0]) and 0 <= z + k < len(grid[0][0]):
                    neighbors.append((x + i, y + j, z + k))
    return neighbors

def count_active_neighbors(x, y, z, grid):
    active_neighbors = 0
    for neighbor in get_neighbors(x, y, z, grid):
        if grid[neighbor[0]][neighbor[1]][neighbor[2]] == '#':
            active_neighbors += 1
    return active_neighbors

def",2.0
317,146,2020,17,2,part1_failed,,1680,,,
318,147,2020,18,1,no_error,"31142189909908
",31142189909908,,"
def evaluate(expression):
    while ""("" in expression:
        start = expression.rfind(""("")
        end = expression.find("")"", start)
        expression = expression[:start] + str(evaluate(expression[start+1:end])) + expression[end+1:]

    tokens = expression.split()
    result = int(tokens[0])
    for i in range(1, len(tokens), 2):
        if tokens[i] == ""+"":
            result += int(tokens[i+1])
        elif tokens[i] == ""*"":
            result *= int(tokens[i+1])
    return result

with open(""input.txt"") as f:
    expressions = [line.strip() for line in f]

print(sum(evaluate(expression) for expression in expressions))
",0.0
319,148,2020,18,2,wrong_output,"31142189909908
",323912478287549,,"
def evaluate(expression):
    while ""("" in expression:
        start = expression.rfind(""("")
        end = expression.find("")"", start)
        expression = expression[:start] + str(evaluate(expression[start+1:end])) + expression[end+1:]

    tokens = expression.split()
    result = int(tokens[0])
    for i in range(1, len(tokens), 2):
        if tokens[i] == ""+"":
            result += int(tokens[i+1])
        elif tokens[i] == ""*"":
            result *= int(tokens[i+1])
    return result

with open(""input.txt"") as f:
    expressions = [line.strip() for line in f]

print(sum(evaluate(expression) for expression in expressions))
",2.0
320,149,2020,19,1,runtime_error,,173,"  File ""/tmp/tmpg79q9w7c/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_rules(rules):
    rules_dict = {}
    for rule in rules:
        rule_num, rule_def = rule.split(': ')
        rule_def = rule_def.replace('""', '')
        if '|' in rule_def:
            rule_def = rule_def.split(' | ')
        rules_dict[rule_num] = rule_def
    return rules_dict

def generate_regex(rules_dict, rule_num):
    rule_def = rules_dict[rule_num]
    if isinstance(rule_def, str):
        return rule_def
    else:
        regex = '('
        for sub_rule in rule_def:
            regex += generate_regex(rules_dict, sub_rule)
        regex += ')'
        return regex

def check_message(message, regex):
    return bool(re.fullmatch(regex, message))

def main():
    with open('input.txt') as f:
        rules, messages = f.read().split('\n\n')
    rules_dict = parse_rules(",2.0
321,150,2020,19,2,part1_failed,,367,,,
322,151,2020,20,1,runtime_error,,15003787688423,"  File ""/tmp/tmp6z3qfqbv/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict
from itertools import product

def read_input():
    tiles = {}
    with open('input.txt') as f:
        for tile in f.read().split('\n\n'):
            tile_id, image = tile.split(':\n')
            tile_id = int(tile_id.split()[1])
            image = image.splitlines()
            tiles[tile_id] = image
    return tiles

def get_borders(image):
    top = image[0]
    bottom = image[-1]
    left = ''.join(row[0] for row in image)
    right = ''.join(row[-1] for row in image)
    return top, bottom, left, right

def flip_image(image):
    return [row[::-1] for row in image]

def rotate_image(image):
    return [''.join(row[i] for row in image[::-1]) for i in range(len(image))]

def get_all_orientations(image):
    orientations = [image]
    for _ in range(3):
        image",2.0
323,152,2020,20,2,part1_failed,,1705,,,
324,153,2020,21,1,runtime_error,,2542,"  File ""/tmp/tmpdkn_50qc/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_food(food):
    ingredients, allergens = food.split(' (contains ')
    allergens = allergens[:-1].split(', ')
    return ingredients.split(' '), allergens

def find_safe_ingredients(foods):
    ingredients = set()
    allergens = set()
    for food in foods:
        ingredients.update(food[0])
        allergens.update(food[1])

    allergen_ingredients = {}
    for allergen in allergens:
        allergen_ingredients[allergen] = set()

    for food in foods:
        for allergen in food[1]:
            allergen_ingredients[allergen].update(food[0])

    safe_ingredients = ingredients - set.union(*allergen_ingredients.values())
    return safe_ingredients

def count_safe_ingredients(foods):
    safe_ingredients = find_safe_ingredients(foods)
    count = 0
    for food in foods:
        for ingredient in food[0]:
            if ingredient in safe_ingredients:
                count += 1
    return count

with open('input.txt",2.0
325,154,2020,21,2,part1_failed,,"hkflr,ctmcqjf,bfrq,srxphcm,snmxl,zvx,bd,mqvk",,,
326,155,2020,22,1,no_error,"34255
",34255,,"
with open('input.txt') as f:
    p1, p2 = [list(map(int, deck.splitlines()[1:])) for deck in f.read().split('\n\n')]

while p1 and p2:
    a, b = p1.pop(0), p2.pop(0)
    if a > b:
        p1.append(a)
        p1.append(b)
    else:
        p2.append(b)
        p2.append(a)

print(sum(i * j for i, j in enumerate(reversed(p1 or p2), 1)))
",0.0
327,156,2020,22,2,runtime_error,,33369,"  File ""/tmp/tmpc8fnu2wz/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    p1, p2 = [list(map(int, deck.splitlines()[1:])) for deck in f.read().split('\n\n')]

def game(p1, p2, depth=0):
    seen = set()
    while p1 and p2:
        if (tuple(p1), tuple(p2)) in seen:
            return 1, p1
        seen.add((tuple(p1), tuple(p2)))
        a, b = p1.pop(0), p2.pop(0)
        if a <= len(p1) and b <= len(p2):
            winner, _ = game(p1[:a], p2[:b], depth+1)
        else:
            winner = 1 if a > b else 2
        if winner == 1:
            p1.append(a)
            p1.append(b)
        else:
            p2.append(b)
            p2.append(a)
    return 1 if p1 else 2, p",2.0
328,157,2020,23,1,runtime_error,,49576328,"Traceback (most recent call last):
  File ""/tmp/tmpah75v5g8/tmp.py"", line 19, in <module>
    print(play_crab_cups(cups, 100))
  File ""/tmp/tmpah75v5g8/tmp.py"", line 12, in play_crab_cups
    cups.insert(cups.index(destination) + 1, *picked_up)
TypeError: insert() takes exactly 2 arguments (4 given)
","
from collections import deque

def play_crab_cups(cups, moves):
    current_cup = cups[0]
    cups = deque(cups)
    for _ in range(moves):
        picked_up = [cups.popleft() for _ in range(3)]
        destination = current_cup - 1
        while destination in picked_up or destination < min(cups):
            destination = (destination - 1) % max(cups) + 1
        cups.insert(cups.index(destination) + 1, *picked_up)
        current_cup = cups[cups.index(current_cup) + 1]
    return ''.join(str(cup) for cup in cups[cups.index(1) + 1:] + cups[:cups.index(1)])

with open('input.txt') as f:
    cups = [int(cup) for cup in f.read().strip()]

print(play_crab_cups(cups, 100))
",2.0
329,158,2020,23,2,part1_failed,,511780369955,,,
330,159,2020,24,1,wrong_output,"2616
",356,,"
def get_neighbors(tile):
    neighbors = []
    for direction in ['e', 'se', 'sw', 'w', 'nw', 'ne']:
        neighbors.append(tile + direction)
    return neighbors

def flip_tile(tile, tiles):
    if tile in tiles:
        tiles.remove(tile)
    else:
        tiles.add(tile)

def main():
    tiles = set()
    with open('input.txt') as f:
        for line in f:
            tile = ''
            for char in line.strip():
                tile += char
            neighbors = get_neighbors(tile)
            for neighbor in neighbors:
                flip_tile(neighbor, tiles)
    print(len(tiles))

if __name__ == '__main__':
    main()
",2.0
331,160,2020,24,2,part1_failed,,3887,,,
332,161,2020,25,1,timeout_error,,711945,TIMEOUT,"
def transform(subject_number, loop_size):
    value = 1
    for _ in range(loop_size):
        value = (value * subject_number) % 20201227
    return value

def find_loop_size(public_key):
    subject_number = 7
    loop_size = 1
    while True:
        value = transform(subject_number, loop_size)
        if value == public_key:
            return loop_size
        loop_size += 1

with open('input.txt') as f:
    card_public_key, door_public_key = map(int, f.readlines())

card_loop_size = find_loop_size(card_public_key)
door_loop_size = find_loop_size(door_public_key)

print(transform(door_public_key, card_loop_size))
",2.0
333,162,2020,25,2,part1_failed,,,,,
334,0,2021,1,1,no_error,"1532
",1532,,"
with open('input.txt') as f:
    lines = f.readlines()

count = 0
for i in range(1, len(lines)):
    if int(lines[i]) > int(lines[i-1]):
        count += 1

print(count)
",0.0
335,1,2021,1,2,no_error,"1571
",1571,,"
with open('input.txt') as f:
    lines = f.readlines()

count = 0
for i in range(3, len(lines)):
    if int(lines[i]) + int(lines[i-1]) + int(lines[i-2]) > int(lines[i-1]) + int(lines[i-2]) + int(lines[i-3]):
        count += 1

print(count)
",0.0
338,4,2021,2,1,no_error,"1990000
",1990000,,"
with open('input.txt') as f:
    commands = [line.strip() for line in f]

horizontal = 0
depth = 0

for command in commands:
    direction, amount = command.split()
    amount = int(amount)

    if direction == 'forward':
        horizontal += amount
    elif direction == 'down':
        depth += amount
    elif direction == 'up':
        depth -= amount

print(horizontal * depth)
",0.0
339,5,2021,2,2,no_error,"1975421260
",1975421260,,"
with open('input.txt') as f:
    commands = [line.strip() for line in f]

horizontal = 0
depth = 0
aim = 0

for command in commands:
    direction, amount = command.split()
    amount = int(amount)

    if direction == 'forward':
        horizontal += amount
        depth += aim * amount
    elif direction == 'down':
        aim += amount
    elif direction == 'up':
        aim -= amount

print(horizontal * depth)
",0.0
342,8,2021,3,1,no_error,"3549854
",3549854,,"
with open('input.txt') as f:
    lines = f.readlines()

gamma = ''
epsilon = ''
for i in range(len(lines[0]) - 1):
    zeros = 0
    ones = 0
    for line in lines:
        if line[i] == '0':
            zeros += 1
        else:
            ones += 1
    if zeros > ones:
        gamma += '0'
        epsilon += '1'
    else:
        gamma += '1'
        epsilon += '0'

print(int(gamma, 2) * int(epsilon, 2))
",0.0
343,9,2021,3,2,runtime_error,,3765399,"  File ""/tmp/tmpxzh6z_br/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    lines = f.readlines()

def get_rating(lines, bit_criteria):
    for i in range(len(lines[0]) - 1):
        zeros = 0
        ones = 0
        for line in lines:
            if line[i] == '0':
                zeros += 1
            else:
                ones += 1
        if bit_criteria == 'oxygen':
            if zeros > ones:
                lines = [line for line in lines if line[i] == '1']
            else:
                lines = [line for line in lines if line[i] == '0']
        else:
            if zeros > ones:
                lines = [line for line in lines if line[i] == '0']
            else:
                lines = [line for line in lines if line[i] == '1']
        if len(lines) == 1:
            break
    return int(lines[0], 2)

oxygen_rating = get_rating(lines, 'oxygen')
co2_rating = get_",2.0
344,10,2021,4,1,runtime_error,,49860,"  File ""/tmp/tmpq6mhk_3h/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def read_input():
    with open('input.txt') as f:
        numbers = [int(x) for x in f.readline().split(',')]
        boards = []
        for line in f.readlines():
            boards.append(np.array([[int(x) for x in line.split()] for line in f.readlines()]))
    return numbers, boards

def mark_boards(numbers, boards):
    for number in numbers:
        for board in boards:
            board[board == number] = -1

def check_boards(boards):
    for board in boards:
        if np.any(np.all(board == -1, axis=0)) or np.any(np.all(board == -1, axis=1)):
            return board
    return None

def calculate_score(board, number):
    return np.sum(board[board != -1]) * number

def main():
    numbers, boards = read_input()
    mark_boards(numbers, boards)
    winning_board = check_boards(boards)
    score = calculate",2.0
345,11,2021,4,2,part1_failed,,24628,,,
346,12,2021,5,1,no_error,"6710
",6710,,"
with open('input.txt') as f:
    lines = [line.strip() for line in f.readlines()]

grid = [[0] * 1000 for _ in range(1000)]

for line in lines:
    x1, y1, x2, y2 = map(int, line.replace(' -> ', ',').split(','))
    if x1 == x2:
        for y in range(min(y1, y2), max(y1, y2) + 1):
            grid[y][x1] += 1
    elif y1 == y2:
        for x in range(min(x1, x2), max(x1, x2) + 1):
            grid[y1][x] += 1

count = 0
for row in grid:
    for cell in row:
        if cell >= 2:
            count += 1

print(count)
",0.0
347,13,2021,5,2,runtime_error,,20121,"  File ""/tmp/tmpnv61mg_w/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    lines = [line.strip() for line in f.readlines()]

grid = [[0] * 1000 for _ in range(1000)]

for line in lines:
    x1, y1, x2, y2 = map(int, line.replace(' -> ', ',').split(','))
    if x1 == x2:
        for y in range(min(y1, y2), max(y1, y2) + 1):
            grid[y][x1] += 1
    elif y1 == y2:
        for x in range(min(x1, x2), max(x1, x2) + 1):
            grid[y1][x] += 1
    else:
        # diagonal line
        if x1 < x2:
            x_range = range(x1, x2 + 1)
        else:
            x_range = range(x1, x2 - 1, -1)
        if y1 < y2:
            y_range",2.0
348,14,2021,6,1,no_error,"380243
",380243,,"
with open('input.txt') as f:
    fish = [int(x) for x in f.read().split(',')]

for _ in range(80):
    new_fish = []
    for i, f in enumerate(fish):
        if f == 0:
            new_fish.append(8)
            fish[i] = 6
        else:
            fish[i] -= 1
    fish.extend(new_fish)

print(len(fish))
",0.0
349,15,2021,6,2,timeout_error,,1708791884591,TIMEOUT,"
with open('input.txt') as f:
    fish = [int(x) for x in f.read().split(',')]

for _ in range(256):
    new_fish = []
    for i, f in enumerate(fish):
        if f == 0:
            new_fish.append(8)
            fish[i] = 6
        else:
            fish[i] -= 1
    fish.extend(new_fish)

print(len(fish))
",2.0
350,16,2021,7,1,no_error,"344297
",344297,,"
with open('input.txt') as f:
    crabs = [int(x) for x in f.read().split(',')]

min_fuel = float('inf')
for i in range(min(crabs), max(crabs) + 1):
    fuel = sum(abs(crab - i) for crab in crabs)
    min_fuel = min(min_fuel, fuel)

print(min_fuel)
",0.0
351,17,2021,7,2,no_error,"97164301
",97164301,,"
with open('input.txt') as f:
    crabs = [int(x) for x in f.read().split(',')]

min_fuel = float('inf')
for i in range(min(crabs), max(crabs) + 1):
    fuel = sum(sum(range(1, abs(crab - i) + 1)) for crab in crabs)
    min_fuel = min(min_fuel, fuel)

print(min_fuel)
",0.0
354,20,2021,8,1,no_error,"440
",440,,"
import re

with open('input.txt') as f:
    lines = f.readlines()

count = 0
for line in lines:
    output = line.split(' | ')[1]
    for digit in output.split():
        if len(digit) in [2, 4, 3, 7]:
            count += 1

print(count)
",0.0
355,21,2021,8,2,runtime_error,,1046281,"  File ""/tmp/tmpeuc4wzlb/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    lines = f.readlines()

count = 0
for line in lines:
    signals, output = line.split(' | ')
    signals = signals.split()
    output = output.split()

    # Find the unique signal patterns
    unique_signals = [signal for signal in signals if len(signal) in [2, 3, 4, 7]]

    # Find the digit that uses 2 segments (1)
    one = [signal for signal in unique_signals if len(signal) == 2][0]

    # Find the digit that uses 3 segments (7)
    seven = [signal for signal in unique_signals if len(signal) == 3][0]

    # Find the digit that uses 4 segments (4)
    four = [signal for signal in unique_signals if len(signal) == 4][0]

    # Find the digit that uses 7 segments (8)
    eight = [signal for signal in unique_signals if len(signal) == 7][0]

    # Find the digit that",2.0
356,22,2021,9,1,no_error,"462
",462,,"
with open('input.txt') as f:
    heightmap = [list(map(int, line.strip())) for line in f]

low_points = []
for i in range(len(heightmap)):
    for j in range(len(heightmap[0])):
        if all(heightmap[i][j] < heightmap[x][y] for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] if 0 <= x < len(heightmap) and 0 <= y < len(heightmap[0])):
            low_points.append((i, j))

print(sum(heightmap[i][j] + 1 for i, j in low_points))
",0.0
357,23,2021,9,2,runtime_error,,1397760,"  File ""/tmp/tmpn2kpwyc3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    heightmap = [list(map(int, line.strip())) for line in f]

low_points = []
for i in range(len(heightmap)):
    for j in range(len(heightmap[0])):
        if all(heightmap[i][j] < heightmap[x][y] for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)] if 0 <= x < len(heightmap) and 0 <= y < len(heightmap[0])):
            low_points.append((i, j))

basins = []
for i, j in low_points:
    basin = set()
    stack = [(i, j)]
    while stack:
        x, y = stack.pop()
        if (x, y) not in basin and heightmap[x][y] != 9:
            basin.add((x, y))
            stack.extend([(x-1, y), (x+1, y), (x, y-",2.0
358,24,2021,10,1,runtime_error,,299793,"  File ""/tmp/tmp_z4o39wh/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def is_corrupted(line):
    stack = []
    for char in line:
        if char in '([{<':
            stack.append(char)
        else:
            if not stack:
                return char
            if char == ')' and stack[-1] == '(':
                stack.pop()
            elif char == ']' and stack[-1] == '[':
                stack.pop()
            elif char == '}' and stack[-1] == '{':
                stack.pop()
            elif char == '>' and stack[-1] == '<':
                stack.pop()
            else:
                return char
    return None

def get_score(char):
    if char == ')':
        return 3
    elif char == ']':
        return 57
    elif char == '}':
        return 1197
    elif char == '>':
        return 25137

with open('input.txt') as f:
    lines = f.readlines()

corrupted_lines = []
for line in lines:
    char = is_corrupted(line)",2.0
359,25,2021,10,2,part1_failed,,3654963618,,,
360,26,2021,11,1,runtime_error,,1793,"  File ""/tmp/tmp2q52flm3/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open(""input.txt"") as f:
    grid = [list(map(int, line.strip())) for line in f.readlines()]

def print_grid(grid):
    for row in grid:
        print("""".join(map(str, row)))

def step(grid):
    flashes = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            grid[i][j] += 1
    while True:
        flashed = False
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] > 9 and not flashed:
                    flashed = True
                    flashes += 1
                    grid[i][j] = 0
                    for di in range(-1, 2):
                        for dj in range(-1, 2):
                            if 0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]):
                                grid[i + di][j + dj] += 1
        if",2.0
361,27,2021,11,2,part1_failed,,247,,,
362,28,2021,12,1,no_error,"3887
",3887,,"
from collections import defaultdict

def find_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    paths = []
    for node in graph[start]:
        if node not in path or node.isupper():
            newpaths = find_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def main():
    with open('input.txt') as f:
        graph = defaultdict(list)
        for line in f:
            a, b = line.strip().split('-')
            graph[a].append(b)
            graph[b].append(a)

    paths = find_paths(graph, 'start', 'end')
    print(len(paths))

if __name__ == '__main__':
    main()
",0.0
363,29,2021,12,2,timeout_error,,104834,TIMEOUT,"
from collections import defaultdict

def find_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    paths = []
    for node in graph[start]:
        if node not in path or node.isupper() or (node.islower() and path.count(node) < 2):
            newpaths = find_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def main():
    with open('input.txt') as f:
        graph = defaultdict(list)
        for line in f:
            a, b = line.strip().split('-')
            graph[a].append(b)
            graph[b].append(a)

    paths = find_paths(graph, 'start', 'end')
    print(len(paths))

if __name__ == '__main__':
    main()
",2.0
364,30,2021,13,1,runtime_error,,712,"Traceback (most recent call last):
  File ""/tmp/tmpqbdtwvqm/tmp.py"", line 7, in <module>
    dots = {(x if axis == 'x' else n - x, y if axis == 'y' else n - y) for x, y in dots}
  File ""/tmp/tmpqbdtwvqm/tmp.py"", line 7, in <setcomp>
    dots = {(x if axis == 'x' else n - x, y if axis == 'y' else n - y) for x, y in dots}
TypeError: unsupported operand type(s) for -: 'str' and 'int'
","
with open('input.txt') as f:
    dots, folds = f.read().split('\n\n')
    dots = set(tuple(map(int, dot.split(','))) for dot in dots.splitlines())
    for fold in folds.splitlines():
        axis, n = fold[11:].split('=')
        dots = {(x if axis == 'x' else n - x, y if axis == 'y' else n - y) for x, y in dots}
        break
    print(len(dots))
",2.0
365,31,2021,13,2,part1_failed,,BLHFJPJF,,,
366,32,2021,14,1,no_error,"2233
",2233,,"
from collections import Counter

with open('input.txt') as f:
    template, rules = f.read().split('\n\n')

rules = dict(rule.split(' -> ') for rule in rules.splitlines())

for _ in range(10):
    new_template = ''
    for i in range(len(template) - 1):
        new_template += template[i] + rules[template[i:i+2]]
    new_template += template[-1]
    template = new_template

counts = Counter(template)
print(counts.most_common()[0][1] - counts.most_common()[-1][1])
",0.0
367,33,2021,14,2,timeout_error,,2884513602164,TIMEOUT,"
from collections import Counter

with open('input.txt') as f:
    template, rules = f.read().split('\n\n')

rules = dict(rule.split(' -> ') for rule in rules.splitlines())

for _ in range(40):
    new_template = ''
    for i in range(len(template) - 1):
        new_template += template[i] + rules[template[i:i+2]]
    new_template += template[-1]
    template = new_template

counts = Counter(template)
print(counts.most_common()[0][1] - counts.most_common()[-1][1])
",2.0
368,34,2021,15,1,runtime_error,,423,"  File ""/tmp/tmpkv_cdihv/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open(""input.txt"") as f:
    grid = [list(map(int, line.strip())) for line in f]

    width = len(grid[0])
    height = len(grid)

    # Initialize the risk grid
    risk_grid = [[0 for _ in range(width)] for _ in range(height)]

    # Set the risk of the starting position
    risk_grid[0][0] = grid[0][0]

    # Iterate over the grid, calculating the risk of each position
    for i in range(1, width):
        risk_grid[0][i] = risk_grid[0][i - 1] + grid[0][i]

    for j in range(1, height):
        risk_grid[j][0] = risk_grid[j - 1][0] + grid[j][0]

    # Iterate over the grid, calculating the risk of each position
    for i in range(1, width):
        for j in range(1, height):
            risk_grid[j][i] = min(risk_grid[j -",2.0
369,35,2021,15,2,part1_failed,,2778,,,
370,36,2021,16,1,runtime_error,,947,"  File ""/tmp/tmpdf6tl2dh/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def parse_packet(bits):
    version = int(bits[:3], 2)
    type_id = int(bits[3:6], 2)
    if type_id == 4:
        value = """"
        while True:
            group = bits[6:11]
            value += group[1:]
            bits = bits[11:]
            if group[0] == ""0"":
                break
        return version, int(value, 2)
    else:
        length_type_id = bits[6]
        bits = bits[7:]
        if length_type_id == ""0"":
            length = int(bits[:15], 2)
            bits = bits[15:]
            sub_packets = []
            while length > 0:
                version, value = parse_packet(bits)
                sub_packets.append(value)
                length -= len(bits)
                bits = bits[len(bits):]
        else:
            num_sub_packets = int(bits[:11], 2)
            bits = bits",2.0
371,37,2021,16,2,part1_failed,,660797830937,,,
372,38,2021,17,1,runtime_error,,8646,"  File ""/tmp/tmpvq0qyq2a/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def parse_input(input_file):
    with open(input_file, 'r') as f:
        match = re.match(r'target area: x=([-\d]+)..([-\d]+), y=([-\d]+)..([-\d]+)', f.read())
        return (int(match.group(1)), int(match.group(2))), (int(match.group(3)), int(match.group(4)))

def simulate_probe(velocity, target_area):
    x_range, y_range = target_area
    x, y = 0, 0
    max_y = 0
    while x <= x_range[1] and y >= y_range[0]:
        x += velocity[0]
        y += velocity[1]
        max_y = max(max_y, y)
        velocity = (velocity[0] - 1 if velocity[0] > 0 else (velocity[0] + 1 if velocity[0] < 0 else 0), velocity[1] - 1)
        if x_",2.0
373,39,2021,17,2,part1_failed,,5945,,,
374,40,2021,18,1,runtime_error,,4184,"  File ""/tmp/tmp_g84nlhb/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import copy

def add(a, b):
    return [a, b]

def explode(snailfish_number):
    for i, pair in enumerate(snailfish_number):
        if isinstance(pair, list) and len(pair) == 5:
            if isinstance(snailfish_number[i - 1], int):
                snailfish_number[i - 1] += pair[0]
            if isinstance(snailfish_number[i + 2], int):
                snailfish_number[i + 2] += pair[1]
            snailfish_number[i] = 0
            return True
    return False

def split(snailfish_number):
    for i, num in enumerate(snailfish_number):
        if isinstance(num, int) and num >= 10:
            snailfish_number[i] = [num // 2, num - num // 2]
            return True
    return False

def reduce(snailfish_number):
    while True:
        if explode(snailfish_number):
            continue
        if split(snailfish_number",2.0
375,41,2021,18,2,part1_failed,,4731,,,
376,42,2021,19,1,runtime_error,,405,"  File ""/tmp/tmp3b08ht6h/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

def parse_input(filename):
    with open(filename) as f:
        scanners = []
        for line in f:
            if line.startswith(""--- scanner""):
                scanners.append([])
            elif line.strip() != """":
                scanners[-1].append(np.array([int(x) for x in line.split("","")]))
    return scanners

def find_rotations(scanner):
    rotations = []
    for i in range(4):
        scanner = np.rot90(scanner, axes=(1, 2))
        for j in range(3):
            scanner = np.rot90(scanner, axes=(0, 2))
            rotations.append(scanner.copy())
    return rotations

def find_overlaps(scanner1, scanner2):
    for rotation in find_rotations(scanner2):
        for i in range(len(scanner1) - 11):
            for j in range(len(rotation) - 11):
                if np.array_equal(scanner1[i:i+12",2.0
377,43,2021,19,2,part1_failed,,12306,,,
378,44,2021,20,1,wrong_output,"0
",5682,,"
with open('input.txt') as f:
    algorithm, image = f.read().split('\n\n')

algorithm = algorithm.replace('.', '0').replace('#', '1')

def enhance(image, algorithm):
    image = image.replace('.', '0').replace('#', '1')
    new_image = ''
    for i in range(len(image) - 2):
        for j in range(len(image[0]) - 2):
            binary = ''
            for k in range(i, i + 3):
                for l in range(j, j + 3):
                    binary += image[k][l]
            new_image += algorithm[int(binary, 2)]
    return new_image

for _ in range(2):
    image = enhance(image, algorithm)

print(image.count('1'))
",2.0
379,45,2021,20,2,part1_failed,,17628,,,
380,46,2021,21,1,runtime_error,,504972,"  File ""/tmp/tmp0d8omdt6/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def roll_deterministic_die():
    for i in range(1, 101):
        yield i

def play_game(p1_pos, p2_pos):
    p1_score = 0
    p2_score = 0
    die = roll_deterministic_die()
    rolls = 0
    while True:
        rolls += 3
        p1_pos += sum(next(die) for _ in range(3))
        p1_pos = (p1_pos - 1) % 10 + 1
        p1_score += p1_pos
        if p1_score >= 1000:
            return p2_score * rolls
        p2_pos += sum(next(die) for _ in range(3))
        p2_pos = (p2_pos - 1) % 10 + 1
        p2_score += p2_pos
        if p2_score >= 1000:
            return p1_score * rolls

with open('input.txt') as f:
    ",2.0
381,47,2021,21,2,part1_failed,,446968027750017,,,
382,48,2021,22,1,runtime_error,,600458,"  File ""/tmp/tmp2e3hkd9u/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def parse_step(step):
    on_off, coords = step.split(' ')
    x, y, z = coords.split(',')
    x1, x2 = map(int, x[2:].split('..'))
    y1, y2 = map(int, y[2:].split('..'))
    z1, z2 = map(int, z[2:].split('..'))
    return on_off, (x1, x2), (y1, y2), (z1, z2)

def apply_step(step, grid):
    on_off, (x1, x2), (y1, y2), (z1, z2) = parse_step(step)
    for x in range(x1, x2 + 1):
        for y in range(y1, y2 + 1):
            for z in range(z1, z2 + 1):
                if on_off == 'on':
                    grid[x][y][z] = 1
                else:
                    grid[x][y][z] = 0

",2.0
383,49,2021,22,2,part1_failed,,1334275219162622,,,
384,50,2021,23,1,runtime_error,,19019,"  File ""/tmp/tmpr7j_4wtf/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict, namedtuple
from heapq import heappop, heappush

Room = namedtuple(""Room"", [""idx"", ""type""])

def parse_input(filename):
    with open(filename) as f:
        lines = f.readlines()
    rooms = []
    hallway = []
    for i, line in enumerate(lines):
        if i == 1:
            continue
        elif i == 2:
            for j, c in enumerate(line[3:11:2]):
                if c != ""."":
                    hallway.append((j, c))
        else:
            for j, c in enumerate(line[3:11:2]):
                if c != ""."":
                    rooms.append((j, c))
    return hallway, rooms

def is_valid_move(hallway, rooms, src, dst):
    if src == dst:
        return False
    if src[0] == dst[0]:
        return True
    if src[0] < dst[0]:
        for i in range(src[0] + 1, dst[0",2.0
385,51,2021,23,2,part1_failed,,47533,,,
386,52,2021,24,1,runtime_error,,49917929934999,"  File ""/tmp/tmpw9_obvjz/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def run_program(program, inputs):
    registers = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
    ip = 0
    while ip < len(program):
        instruction, a, b = program[ip]
        if instruction == 'inp':
            registers[a] = inputs[ip]
            ip += 1
        elif instruction == 'add':
            registers[a] += registers[b] if b in registers else int(b)
            ip += 1
        elif instruction == 'mul':
            registers[a] *= registers[b] if b in registers else int(b)
            ip += 1
        elif instruction == 'div':
            registers[a] //= registers[b] if b in registers else int(b)
            ip += 1
        elif instruction == 'mod':
            registers[a] %= registers[b] if b in registers else int(b)
            ip += 1
        elif instruction == 'eql':
            registers[a] = 1 if registers[a] == registers[b]",2.0
387,53,2021,24,2,part1_failed,,11911316711816,,,
388,54,2021,25,1,runtime_error,,489,"  File ""/tmp/tmpi3086kgb/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def read_input(filename):
    with open(filename, 'r') as f:
        return [list(line.strip()) for line in f.readlines()]

def print_map(map):
    for row in map:
        print(''.join(row))

def move_east(map):
    for row in range(len(map)):
        for col in range(len(map[row])):
            if map[row][col] == '>':
                if map[row][(col + 1) % len(map[row])] == '.':
                    map[row][col] = '.'
                    map[row][(col + 1) % len(map[row])] = '>'

def move_south(map):
    for row in range(len(map)):
        for col in range(len(map[row])):
            if map[row][col] == 'v':
                if map[(row + 1) % len(map)][col] == '.':
                    map[row][col] = '.'
                    map[(row + 1) % len(map)][col] = '",2.0
389,55,2021,25,2,part1_failed,,,,,
390,56,2022,1,1,no_error,"70116
",70116,,"
with open('input.txt') as f:
    elves = [sum(map(int, elf.splitlines())) for elf in f.read().split('\n\n')]
print(max(elves))
",0.0
391,57,2022,1,2,no_error,"206582
",206582,,"
with open('input.txt') as f:
    elves = [sum(map(int, elf.splitlines())) for elf in f.read().split('\n\n')]
print(sum(sorted(elves, reverse=True)[:3]))
",0.0
394,60,2022,2,1,wrong_output,"8394
",12276,,"
with open('input.txt') as f:
    lines = f.readlines()

# Create a dictionary to store the scores for each shape and outcome
scores = {
    'X': 1,
    'Y': 2,
    'Z': 3,
    'A X': 3,
    'A Y': 6,
    'A Z': 0,
    'B X': 0,
    'B Y': 3,
    'B Z': 6,
    'C X': 6,
    'C Y': 0,
    'C Z': 3
}

# Calculate the total score
total_score = 0
for line in lines:
    total_score += scores[line.strip()]

print(total_score)
",2.0
395,61,2022,2,2,part1_failed,,9975,,,
396,62,2022,3,1,no_error,"8053
",8053,,"
with open('input.txt') as f:
    rucksacks = f.readlines()

def get_priority(item):
    if item.islower():
        return ord(item) - ord('a') + 1
    else:
        return ord(item) - ord('A') + 27

def find_common_item(rucksack):
    first_compartment = set(rucksack[:len(rucksack)//2])
    second_compartment = set(rucksack[len(rucksack)//2:])
    return first_compartment.intersection(second_compartment).pop()

total_priority = 0
for rucksack in rucksacks:
    common_item = find_common_item(rucksack)
    total_priority += get_priority(common_item)

print(total_priority)
",0.0
397,63,2022,3,2,no_error,"2425
",2425,,"
with open('input.txt') as f:
    rucksacks = f.readlines()

def get_priority(item):
    if item.islower():
        return ord(item) - ord('a') + 1
    else:
        return ord(item) - ord('A') + 27

def find_common_item(rucksack1, rucksack2, rucksack3):
    set1 = set(rucksack1)
    set2 = set(rucksack2)
    set3 = set(rucksack3)
    return set1.intersection(set2).intersection(set3).pop()

total_priority = 0
for i in range(0, len(rucksacks), 3):
    common_item = find_common_item(rucksacks[i], rucksacks[i+1], rucksacks[i+2])
    total_priority += get_priority(common_item)

print(total_priority)
",2.0
398,64,2022,4,1,no_error,"441
",441,,"
with open('input.txt') as f:
    count = 0
    for line in f:
        a, b = line.strip().split(',')
        a1, a2 = map(int, a.split('-'))
        b1, b2 = map(int, b.split('-'))
        if (a1 <= b1 and a2 >= b2) or (b1 <= a1 and b2 >= a2):
            count += 1
    print(count)
",0.0
399,65,2022,4,2,no_error,"861
",861,,"
with open('input.txt') as f:
    count = 0
    for line in f:
        a, b = line.strip().split(',')
        a1, a2 = map(int, a.split('-'))
        b1, b2 = map(int, b.split('-'))
        if (a1 <= b1 and a2 >= b1) or (b1 <= a1 and b2 >= a1):
            count += 1
    print(count)
",0.0
402,68,2022,5,1,runtime_error,,FCVRLMVQP,"Traceback (most recent call last):
  File ""/tmp/tmprj_yf_10/tmp.py"", line 10, in <module>
    stacks[dst-1].extend(stacks[src-1][-n:])
IndexError: list index out of range
","
with open('input.txt') as f:
    stacks, moves = f.read().split('\n\n')

stacks = [list(row)[1::4] for row in stacks.splitlines()[:-1]]
stacks = [list(reversed(stack)) for stack in stacks]

for move in moves.splitlines():
    n, src, dst = map(int, move.split()[1::2])
    stacks[dst-1].extend(stacks[src-1][-n:])
    stacks[src-1] = stacks[src-1][:-n]

print(''.join(stack[-1] for stack in stacks))
",2.0
403,69,2022,5,2,part1_failed,,RWLWGJGFD,,,
404,70,2022,6,1,no_error,"1109
",1109,,"
with open('input.txt', 'r') as f:
    data = f.read()

for i in range(3, len(data)):
    if len(set(data[i-3:i+1])) == 4:
        print(i+1)
        break
",0.0
405,71,2022,6,2,no_error,"3965
",3965,,"
with open('input.txt', 'r') as f:
    data = f.read()

for i in range(13, len(data)):
    if len(set(data[i-13:i+1])) == 14:
        print(i+1)
        break
",0.0
408,74,2022,7,1,runtime_error,,1443806,"  File ""/tmp/tmploa59qzo/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

def get_dir_sizes(lines):
    dir_sizes = {}
    current_dir = ""/""
    for line in lines:
        if line.startswith(""$ cd""):
            match = re.match(r""\$ cd (.*)"", line)
            if match:
                new_dir = match.group(1)
                if new_dir == "".."":
                    current_dir = ""/"".join(current_dir.split(""/"")[:-1])
                else:
                    current_dir = current_dir + ""/"" + new_dir
        elif line.startswith(""dir""):
            match = re.match(r""dir (.*)"", line)
            if match:
                dir_name = match.group(1)
                dir_sizes[current_dir + ""/"" + dir_name] = 0
        else:
            match = re.match(r""(\d+) (.*)"", line)
            if match:
                file_size = int(match.group(1))
                file_name = match.group(2)
                dir_sizes[current_dir] = dir_sizes.get",2.0
409,75,2022,7,2,part1_failed,,942298,,,
410,76,2022,8,1,wrong_output,"1415
",1807,,"
with open('input.txt') as f:
    grid = [list(map(int, line.strip())) for line in f]

visible = 0
for i in range(1, len(grid) - 1):
    for j in range(1, len(grid[0]) - 1):
        if all(grid[i][k] < grid[i][j] for k in range(j)) or \
           all(grid[i][k] < grid[i][j] for k in range(j + 1, len(grid[0]))) or \
           all(grid[k][j] < grid[i][j] for k in range(i)) or \
           all(grid[k][j] < grid[i][j] for k in range(i + 1, len(grid))):
            visible += 1

print(visible)
",2.0
411,77,2022,8,2,part1_failed,,480000,,,
412,78,2022,9,1,runtime_error,,6087,"  File ""/tmp/tmprpgemu2w/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def move_tail(head, tail):
    if abs(head[0] - tail[0]) > 1 or abs(head[1] - tail[1]) > 1:
        if head[0] == tail[0]:
            tail[1] += 1 if head[1] > tail[1] else -1
        elif head[1] == tail[1]:
            tail[0] += 1 if head[0] > tail[0] else -1
        else:
            tail[0] += 1 if head[0] > tail[0] else -1
            tail[1] += 1 if head[1] > tail[1] else -1

def simulate_rope(motions):
    head = [0, 0]
    tail = [0, 0]
    visited = set()
    visited.add(tuple(tail))
    for motion in motions:
        direction, steps = motion[0], int(motion[1:])
        for _ in range(steps):
            if direction == 'U':
                head[1] += 1
            ",2.0
413,79,2022,9,2,part1_failed,,2493,,,
414,80,2022,10,1,wrong_output,"7560
",15360,,"
def run_program(program):
    x = 1
    cycle = 0
    signal_strengths = []
    for instruction in program:
        if instruction.startswith(""noop""):
            cycle += 1
            if cycle in [20, 60, 100, 140, 180, 220]:
                signal_strengths.append(cycle * x)
        else:
            v = int(instruction.split("" "")[1])
            cycle += 2
            if cycle in [20, 60, 100, 140, 180, 220]:
                signal_strengths.append(cycle * x)
            x += v
    return sum(signal_strengths)


if __name__ == ""__main__"":
    with open(""input.txt"") as f:
        program = [line.strip() for line in f.readlines()]
    print(run_program(program))
",2.0
415,81,2022,10,2,part1_failed,,PHLHJGZA,,,
416,82,2022,11,1,runtime_error,,69918,"  File ""/tmp/tmpie5st7ih/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import fileinput

monkeys = {}
for line in fileinput.input():
    line = line.strip()
    if line.startswith('Monkey'):
        monkey = int(line.split()[1][:-1])
        monkeys[monkey] = {'items': [], 'operation': '', 'test': 0, 'true': 0, 'false': 0, 'inspected': 0}
    elif line.startswith('Starting'):
        monkeys[monkey]['items'] = [int(x) for x in line.split(':')[1].split(',')]
    elif line.startswith('Operation'):
        monkeys[monkey]['operation'] = line.split('=')[1].strip()
    elif line.startswith('Test'):
        monkeys[monkey]['test'] = int(line.split('by')[1])
    elif line.startswith('If true'):
        monkeys[monkey]['true'] = int(line.split('monkey')[1])
    elif line.startswith('If false'):
        monkeys[monkey]['false'] = int(line.split('monkey')[1])

for _ in range(20):",2.0
417,83,2022,11,2,part1_failed,,19573408701,,,
418,84,2022,12,1,runtime_error,,504,"  File ""/tmp/tmpv9hgrl5p/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def get_heightmap(filename):
    with open(filename) as f:
        heightmap = [list(line.strip()) for line in f.readlines()]
    return heightmap

def find_start_and_end(heightmap):
    for i, row in enumerate(heightmap):
        for j, col in enumerate(row):
            if col == 'S':
                start = (i, j)
            elif col == 'E':
                end = (i, j)
    return start, end

def is_valid_move(heightmap, start, end):
    if start[0] < 0 or start[0] >= len(heightmap):
        return False
    if start[1] < 0 or start[1] >= len(heightmap[0]):
        return False
    if heightmap[start[0]][start[1]] == 'z' and heightmap[end[0]][end[1]] == 'a':
        return False
    if heightmap[start[0]][start[1]] == 'a' and heightmap[end[0]][end[1]]",2.0
419,85,2022,12,2,part1_failed,,500,,,
420,86,2022,13,1,syntax_error,,5503,"Traceback (most recent call last):
  File ""/tmp/tmpqcjav1p0/tmp.py"", line 27, in <module>
    main()
  File ""/tmp/tmpqcjav1p0/tmp.py"", line 17, in main
    packets = [eval(line) for line in f.read().split('\n\n')]
  File ""/tmp/tmpqcjav1p0/tmp.py"", line 17, in <listcomp>
    packets = [eval(line) for line in f.read().split('\n\n')]
  File ""<string>"", line 2
    [[],[],[9,[8,[],1]],[1,5],[[],[]]]
    ^
SyntaxError: invalid syntax
","
def compare(left, right):
    if isinstance(left, int) and isinstance(right, int):
        return left < right
    elif isinstance(left, list) and isinstance(right, list):
        for i in range(min(len(left), len(right))):
            if compare(left[i], right[i]):
                return True
            elif compare(right[i], left[i]):
                return False
        return len(left) <= len(right)
    else:
        return compare([left], right) or compare(left, [right])

def main():
    with open('input.txt') as f:
        packets = [eval(line) for line in f.read().split('\n\n')]

    count = 0
    for i, packet in enumerate(packets):
        if compare(packet[0], packet[1]):
            count += i + 1

    print(count)

if __name__ == '__main__':
    main()
",2.0
421,87,2022,13,2,part1_failed,,20952,,,
422,88,2022,14,1,runtime_error,,825,"  File ""/tmp/tmpol_g15l5/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    lines = f.readlines()

# Get the max x and y values
max_x = 0
max_y = 0
for line in lines:
    x, y = map(int, re.findall(r'\d+', line))
    max_x = max(max_x, x)
    max_y = max(max_y, y)

# Create a grid of zeros
grid = [[0 for _ in range(max_x + 1)] for _ in range(max_y + 1)]

# Draw the rocks
for line in lines:
    x1, y1, x2, y2 = map(int, re.findall(r'\d+', line))
    if x1 == x2:
        for y in range(min(y1, y2), max(y1, y2) + 1):
            grid[y][x1] = 1
    else:
        for x in range(min(x1, x2), max(x1, x2) + 1):
",2.0
423,89,2022,14,2,part1_failed,,26729,,,
424,90,2022,15,1,runtime_error,,4861076,"  File ""/tmp/tmpi7ayenqp/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import re

with open('input.txt') as f:
    data = f.read().splitlines()

sensors = []
beacons = []
for line in data:
    match = re.match(r'Sensor at x=(-?\d+), y=(-?\d+): closest beacon is at x=(-?\d+), y=(-?\d+)', line)
    sensors.append((int(match.group(1)), int(match.group(2))))
    beacons.append((int(match.group(3)), int(match.group(4))))

# Find the max and min x and y coordinates of the sensors and beacons
max_x = max(max(s[0] for s in sensors), max(b[0] for b in beacons))
min_x = min(min(s[0] for s in sensors), min(b[0] for b in beacons))
max_y = max(max(s[1] for s in sensors), max(b[1] for b in beacons))
min_y = min(min(s[1] for s in sensors), min(b[1] for b in",2.0
425,91,2022,15,2,part1_failed,,10649103160102,,,
426,92,2022,16,1,runtime_error,,2080,"  File ""/tmp/tmpcyqhm_mn/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict
from heapq import heappush, heappop

def dijkstra(edges, from_node, to_node):
    g = defaultdict(list)
    for l,r,c in edges:
        g[l].append((c,r))
        g[r].append((c,l))
    q, seen = [(0,from_node,())], set()
    while q:
        (cost,v1,path) = heappop(q)
        if v1 not in seen:
            seen.add(v1)
            path = (v1, path)
            if v1 == to_node:
                return cost, path
            for c, v2 in g.get(v1, ()):
                if v2 not in seen:
                    heappush(q, (cost+c, v2, path))
    return float(""inf""), []

def max_pressure(valves):
    # Dijkstra's algorithm to find the shortest path from AA to each other valve
    # Then, for each valve, calculate the maximum pressure that can be released
    #",2.0
427,93,2022,16,2,part1_failed,,2752,,,
428,94,2022,17,1,runtime_error,,3235,"  File ""/tmp/tmp2n45ox58/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
with open('input.txt') as f:
    jets = f.read().strip()

rocks = [
    [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [1, 1, 1, 1],
    ],
    [
        [0, 1, 0],
        [1, 1, 1],
        [0, 1, 0],
        [0, 0, 0],
    ],
    [
        [0, 0, 1],
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0],
    ],
    [
        [1, 0, 0, 0],
        [1, 0, 0, 0],
        [1, 0, 0, 0],
        [1, 0, 0, 0],
    ],
    [
        ",2.0
429,95,2022,17,2,part1_failed,,1591860465110,,,
430,96,2022,18,1,no_error,"4310
",4310,,"
with open('input.txt') as f:
    lava = [list(map(int, line.split(','))) for line in f.readlines()]

surface_area = 0
for x, y, z in lava:
    for i, j, k in [(x-1, y, z), (x+1, y, z), (x, y-1, z), (x, y+1, z), (x, y, z-1), (x, y, z+1)]:
        if [i, j, k] not in lava:
            surface_area += 1

print(surface_area)
",1.0
431,97,2022,18,2,wrong_output,"270
",2466,,"
with open('input.txt') as f:
    lava = [list(map(int, line.split(','))) for line in f.readlines()]

surface_area = 0
for x, y, z in lava:
    for i, j, k in [(x-1, y, z), (x+1, y, z), (x, y-1, z), (x, y+1, z), (x, y, z-1), (x, y, z+1)]:
        if [i, j, k] not in lava and all([a, b, c] in lava for a, b, c in [(i-1, j, k), (i+1, j, k), (i, j-1, k), (i, j+1, k), (i, j, k-1), (i, j, k+1)]):
            surface_area += 1

print(surface_area)
",2.0
432,98,2022,19,1,runtime_error,,1613,"  File ""/tmp/tmpokbg5for/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import fileinput

def parse_blueprint(blueprint):
    ore_cost = int(blueprint[0].split()[2])
    clay_cost = int(blueprint[1].split()[2])
    obs_cost = int(blueprint[2].split()[2])
    geo_cost = int(blueprint[3].split()[2])
    return ore_cost, clay_cost, obs_cost, geo_cost

def get_max_geodes(blueprint, minutes):
    ore_cost, clay_cost, obs_cost, geo_cost = blueprint
    ore_robots = 1
    clay_robots = 0
    obs_robots = 0
    geo_robots = 0
    ore = 0
    clay = 0
    obs = 0
    geodes = 0
    for minute in range(1, minutes + 1):
        ore += ore_robots
        clay += clay_robots
        obs += obs_robots
        geodes += geo_robots
        if minute >= ore_cost and ore >= ore_robots:
            ore -= ore_robots
            ore_robots +=",2.0
433,99,2022,19,2,part1_failed,,46816,,,
434,100,2022,20,1,wrong_output,"10000
",18257,,"
with open('input.txt') as f:
    nums = [int(line) for line in f]

for _ in range(len(nums)):
    for i, num in enumerate(nums):
        nums[i] = nums[(i + num) % len(nums)]

print(sum(nums[i - 1] for i in (1000, 2000, 3000)))
",2.0
435,101,2022,20,2,part1_failed,,4148032160983,,,
436,102,2022,21,1,runtime_error,,118565889858886,"Traceback (most recent call last):
  File ""/tmp/tmp5_ik_tyz/tmp.py"", line 24, in <module>
    print(evaluate(""root"", monkeys))
  File ""/tmp/tmp5_ik_tyz/tmp.py"", line 8, in evaluate
    op, a, b = monkey.split()
ValueError: not enough values to unpack (expected 3, got 1)
","
import math

def evaluate(monkey, monkeys):
    if monkey.isdigit():
        return int(monkey)
    else:
        op, a, b = monkey.split()
        if op == ""+"":
            return evaluate(a, monkeys) + evaluate(b, monkeys)
        elif op == ""-"":
            return evaluate(a, monkeys) - evaluate(b, monkeys)
        elif op == ""*"":
            return evaluate(a, monkeys) * evaluate(b, monkeys)
        elif op == ""/"":
            return math.floor(evaluate(a, monkeys) / evaluate(b, monkeys))

with open(""input.txt"") as f:
    monkeys = {}
    for line in f:
        monkey, job = line.strip().split("": "")
        monkeys[monkey] = job

    print(evaluate(""root"", monkeys))
",2.0
437,103,2022,21,2,part1_failed,,3032671800353,,,
438,104,2022,22,1,runtime_error,,93226,"  File ""/tmp/tmp5kx72ggu/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
import numpy as np

# Read input
with open('input.txt') as f:
    lines = f.readlines()

# Parse map
map = np.array([list(line.strip()) for line in lines[:lines.index('\n')]])

# Parse path
path = lines[lines.index('\n')+1].strip()

# Initialize position and facing
row, col, facing = 0, 0, 0

# Follow path
for instruction in path:
    if instruction.isdigit():
        # Move forward
        for _ in range(int(instruction)):
            if facing == 0:
                col = (col + 1) % map.shape[1]
            elif facing == 1:
                row = (row + 1) % map.shape[0]
            elif facing == 2:
                col = (col - 1) % map.shape[1]
            elif facing == 3:
                row = (row - 1) % map.shape[0]
    else:
        # Turn
        if instruction == 'R':
            facing = (facing +",2.0
439,105,2022,22,2,part1_failed,,37415,,,
440,106,2022,23,1,runtime_error,,4109,"  File ""/tmp/tmpqvfzfrl8/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import defaultdict

def get_adjacent(x, y, grid):
    adjacent = []
    for dx, dy in [(0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1)]:
        if grid[y + dy][x + dx] == '.':
            adjacent.append((x + dx, y + dy))
    return adjacent

def get_proposed_move(x, y, grid, adjacent):
    for dx, dy in [(0, -1), (-1, 0), (0, 1), (1, 0)]:
        if (x + dx, y + dy) in adjacent:
            return (x + dx, y + dy)
    return None

def move_elves(grid):
    elves = set()
    for y, row in enumerate(grid):
        for x, cell in enumerate(row):
            if cell == '#':
                elves.add((x, y))
    adjacent = defaultdict(list)
",2.0
441,107,2022,23,2,part1_failed,,1055,,,
442,108,2022,24,1,runtime_error,,279,"  File ""/tmp/tmph73gsccd/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
from collections import deque

def get_next_state(state):
    new_state = [['.' for _ in range(len(state[0]))] for _ in range(len(state))]
    for i in range(len(state)):
        for j in range(len(state[0])):
            if state[i][j] == '>':
                new_state[i][(j + 1) % len(state[0])] = '>'
            elif state[i][j] == '<':
                new_state[i][(j - 1) % len(state[0])] = '<'
            elif state[i][j] == '^':
                new_state[(i - 1) % len(state)][j] = '^'
            elif state[i][j] == 'v':
                new_state[(i + 1) % len(state)][j] = 'v'
    return new_state

def is_valid_move(state, i, j):
    return state[i][j] == '.' and all(state[k][l] != 'E' for k",2.0
443,109,2022,24,2,part1_failed,,762,,,
444,110,2022,25,1,runtime_error,,2=0=02-0----2-=02-10,"  File ""/tmp/tmpu47lkn31/tmp.py"", line 1
    ```python
IndentationError: unexpected indent
"," ```python
def snafu_to_decimal(snafu):
    result = 0
    for i, digit in enumerate(snafu):
        if digit == '=':
            result -= 2 * 5 ** i
        elif digit == '-':
            result -= 1 * 5 ** i
        else:
            result += int(digit) * 5 ** i
    return result

def decimal_to_snafu(decimal):
    if decimal == 0:
        return '0'
    result = ''
    while decimal > 0:
        digit = decimal % 5
        if digit == 4:
            result = '2=' + result
            decimal -= 4
        elif digit == 3:
            result = '2-' + result
            decimal -= 3
        elif digit == 2:
            result = '1=' + result
            decimal -= 2
        elif digit == 1:
            result = '1-' + result
            decimal -= 1
        else:
            result = str(digit) + result
        decimal //= 5
    return result

with open('input",2.0
445,111,2022,25,2,part1_failed,,,,,
