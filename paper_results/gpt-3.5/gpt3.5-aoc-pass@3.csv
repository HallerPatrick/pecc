,year,day,part,status,output,expected_output,error,code,kpass
0,2015,1,1,no_error,74,74,,"
def find_floor(instructions):
    floor = 0
    for instruction in instructions:
        if instruction == '(':
            floor += 1
        elif instruction == ')':
            floor -= 1
    return floor

# Read the instructions from input.txt
with open('input.txt', 'r') as file:
    instructions = file.read().strip()

# Calculate the floor using the instructions
result = find_floor(instructions)

print(f""Santa will end up on floor {result}."")
",0.0
1,2015,1,2,no_error,1795,1795,,"
def find_basement_position(instructions):
    floor = 0
    position = 0
    for instruction in instructions:
        position += 1
        if instruction == '(':
            floor += 1
        elif instruction == ')':
            floor -= 1
        if floor == -1:
            return position

# Read the instructions from input.txt
with open('input.txt', 'r') as file:
    instructions = file.read().strip()

# Find the position of the first character that causes Santa to enter the basement
result = find_basement_position(instructions)

print(f""Santa enters the basement at position {result}."")
",0.0
4,2015,2,1,no_error,1586300,1586300,,"
present_dimensions = []
with open('input.txt', 'r') as file:
    for line in file:
        dimensions = line.strip().split('x')
        present_dimensions.append(dimensions)


total_wrapping_paper = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    surface_area = 2*l*w + 2*w*h + 2*h*l
    slack_area = min(l*w, w*h, h*l)
    total_wrapping_paper += surface_area + slack_area


print(total_wrapping_paper)


present_dimensions = []
with open('input.txt', 'r') as file:
    for line in file:
        dimensions = line.strip().split('x')
        present_dimensions.append(dimensions)

total_wrapping_paper = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    surface_area = 2*l*w + 2*w*h + 2*h*l
    slack_area = min(l*w, w*h, h*l)
    total_wrapping_paper += surface_area + slack_area

print(total_wrapping_paper)
",0.0
5,2015,2,2,no_error,3737498,3737498,,"
present_dimensions = []
with open('input.txt', 'r') as file:
    for line in file:
        dimensions = line.strip().split('x')
        present_dimensions.append(dimensions)


total_ribbon = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    sorted_dimensions = sorted([l, w, h])
    smallest_perimeter = 2 * (sorted_dimensions[0] + sorted_dimensions[1])
    total_ribbon += smallest_perimeter


total_bow_ribbon = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    volume = l * w * h
    total_bow_ribbon += volume


total_feet_of_ribbon = total_ribbon + total_bow_ribbon
print(total_feet_of_ribbon)


present_dimensions = []
with open('input.txt', 'r') as file:
    for line in file:
        dimensions = line.strip().split('x')
        present_dimensions.append(dimensions)

total_ribbon = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    sorted_dimensions = sorted([l, w, h])
    smallest_perimeter = 2 * (sorted_dimensions[0] + sorted_dimensions[1])
    total_ribbon += smallest_perimeter

total_bow_ribbon = 0
for dimensions in present_dimensions:
    l, w, h = map(int, dimensions)
    volume = l * w * h
    total_bow_ribbon += volume

total_feet_of_ribbon = total_ribbon + total_bow_ribbon
print(total_feet_of_ribbon)
",0.0
7,2015,3,1,no_error,"2565
",2565,,"
# Read the input from the file
with open('input.txt', 'r') as file:
    moves = file.read().strip()

# Set to store the visited houses
visited_houses = set()

# Santa's starting location
x, y = 0, 0

# Deliver a present to the starting house
visited_houses.add((x, y))

# Simulate Santa's movements
for move in moves:
    if move == '^':
        y += 1
    elif move == 'v':
        y -= 1
    elif move == '>':
        x += 1
    elif move == '<':
        x -= 1

    # Deliver a present to the current house
    visited_houses.add((x, y))

# Print the number of unique houses visited
print(len(visited_houses))
",0.0
8,2015,3,2,no_error,"2639
",2639,,"
# Read the input from the file
with open('input.txt', 'r') as file:
    moves = file.read().strip()

# Set to store the visited houses
visited_houses = set()

# Santa's and Robo-Santa's starting location
santa_x, santa_y = 0, 0
robo_x, robo_y = 0, 0

# Deliver a present to the starting house
visited_houses.add((santa_x, santa_y))

# Simulate Santa's and Robo-Santa's movements
for i, move in enumerate(moves):
    if i % 2 == 0:
        # Santa's turn
        if move == '^':
            santa_y += 1
        elif move == 'v':
            santa_y -= 1
        elif move == '>':
            santa_x += 1
        elif move == '<':
            santa_x -= 1

        # Deliver a present to Santa's current house
        visited_houses.add((santa_x, santa_y))
    else:
        # Robo-Santa's turn
        if move == '^':
            robo_y += 1
        elif move == 'v':
            robo_y -= 1
        elif move == '>':
            robo_x += 1
        elif move == '<':
            robo_x -= 1

        # Deliver a present to Robo-Santa's current house
        visited_houses.add((robo_x, robo_y))

# Print the number of unique houses visited
print(len(visited_houses))
",0.0
11,2015,4,1,no_error,117946,117946,,"
import hashlib


with open('input.txt', 'r') as f:
    secret_key = f.readline().strip()


def calculate_md5(string):
    md5 = hashlib.md5()
    md5.update(string.encode('utf-8'))
    return md5.hexdigest()


number = 1
while True:
    hash_string = secret_key + str(number)
    hash_value = calculate_md5(hash_string)
    if hash_value.startswith('00000'):
        break
    number += 1


print(number)


import hashlib

with open('input.txt', 'r') as f:
    secret_key = f.readline().strip()

def calculate_md5(string):
    md5 = hashlib.md5()
    md5.update(string.encode('utf-8'))
    return md5.hexdigest()

number = 1
while True:
    hash_string = secret_key + str(number)
    hash_value = calculate_md5(hash_string)
    if hash_value.startswith('00000'):
        break
    number += 1

print(number)
",0.0
12,2015,4,2,no_error,"3938038
",3938038,,"
import hashlib

with open('input.txt', 'r') as f:
    secret_key = f.readline().strip()

def calculate_md5(string):
    md5 = hashlib.md5()
    md5.update(string.encode('utf-8'))
    return md5.hexdigest()

number = 1
while True:
    hash_string = secret_key + str(number)
    hash_value = calculate_md5(hash_string)
    if hash_value.startswith('000000'):
        break
    number += 1

print(number)
",0.0
15,2015,5,1,no_error,"236
",236,,"
def is_nice_string(string):
    vowels = 'aeiou'
    disallowed_substrings = ['ab', 'cd', 'pq', 'xy']
    
    vowel_count = sum(1 for char in string if char in vowels)
    
    has_double_letter = any(string[i] == string[i+1] for i in range(len(string)-1))
    
    has_disallowed_substring = any(substring in string for substring in disallowed_substrings)
    
    return vowel_count >= 3 and has_double_letter and not has_disallowed_substring

def count_nice_strings(filename):
    count = 0
    with open(filename, 'r') as file:
        for line in file:
            if is_nice_string(line.strip()):
                count += 1
    return count

nice_strings_count = count_nice_strings('input.txt')
print(nice_strings_count)
",0.0
16,2015,5,2,no_error,"51
",51,,"
def is_nice_string(string):
    has_pair = False
    has_repeat_with_one_between = False
    
    for i in range(len(string)-1):
        pair = string[i:i+2]
        if pair in string[i+2:]:
            has_pair = True
            break
    
    for i in range(len(string)-2):
        if string[i] == string[i+2]:
            has_repeat_with_one_between = True
            break
    
    return has_pair and has_repeat_with_one_between

def count_nice_strings(filename):
    count = 0
    with open(filename, 'r') as file:
        for line in file:
            if is_nice_string(line.strip()):
                count += 1
    return count

nice_strings_count = count_nice_strings('input.txt')
print(nice_strings_count)
",0.0
19,2015,6,1,no_error,"400410
",400410,,"
def process_instructions():
    lights = [[False] * 1000 for _ in range(1000)]

    with open('input.txt', 'r') as file:
        for line in file:
            line = line.strip()
            instruction, start, _, end = line.rsplit(' ', 3)
            start_x, start_y = map(int, start.split(','))
            end_x, end_y = map(int, end.split(','))

            for x in range(start_x, end_x + 1):
                for y in range(start_y, end_y + 1):
                    if instruction == 'turn on':
                        lights[x][y] = True
                    elif instruction == 'turn off':
                        lights[x][y] = False
                    elif instruction == 'toggle':
                        lights[x][y] = not lights[x][y]

    lit_count = sum(sum(row) for row in lights)
    return lit_count


if __name__ == '__main__':
    lit_count = process_instructions()
    print(lit_count)
",0.0
20,2015,6,2,no_error,"15343601
",15343601,,"
def process_instructions():
    brightness = [[0] * 1000 for _ in range(1000)]

    with open('input.txt', 'r') as file:
        for line in file:
            line = line.strip()
            instruction, start, _, end = line.rsplit(' ', 3)
            start_x, start_y = map(int, start.split(','))
            end_x, end_y = map(int, end.split(','))

            for x in range(start_x, end_x + 1):
                for y in range(start_y, end_y + 1):
                    if instruction == 'turn on':
                        brightness[x][y] += 1
                    elif instruction == 'turn off':
                        brightness[x][y] = max(0, brightness[x][y] - 1)
                    elif instruction == 'toggle':
                        brightness[x][y] += 2

    total_brightness = sum(sum(row) for row in brightness)
    return total_brightness


if __name__ == '__main__':
    total_brightness = process_instructions()
    print(total_brightness)
",0.0
23,2015,7,1,no_error,"46065
",46065,,"
def parse_instructions(filename):
    instructions = []
    with open(filename, 'r') as file:
        for line in file:
            line = line.strip()
            if line:
                parts = line.split(' -> ')
                inputs = parts[0].split()
                output = parts[1]
                instructions.append((inputs, output))
    return instructions

def calculate_signal(instructions, wire):
    signals = {}

    def get_signal(wire):
        if wire.isdigit():
            return int(wire)
        if wire in signals:
            return signals[wire]
        
        for inputs, output in instructions:
            if output == wire:
                if len(inputs) == 1:
                    signals[wire] = get_signal(inputs[0])
                elif len(inputs) == 2:
                    operator, input_wire = inputs
                    if operator == 'NOT':
                        signals[wire] = ~get_signal(input_wire) & 0xFFFF
                    else:
                        raise ValueError(f'Invalid instruction: {inputs}')
                elif len(inputs) == 3:
                    input_wire1, operator, input_wire2 = inputs
                    if operator == 'AND':
                        signals[wire] = get_signal(input_wire1) & get_signal(input_wire2)
                    elif operator == 'OR':
                        signals[wire] = get_signal(input_wire1) | get_signal(input_wire2)
                    elif operator == 'LSHIFT':
                        signals[wire] = get_signal(input_wire1) << get_signal(input_wire2)
                    elif operator == 'RSHIFT':
                        signals[wire] = get_signal(input_wire1) >> get_signal(input_wire2)
                    else:
                        raise ValueError(f'Invalid instruction: {inputs}')
                else:
                    raise ValueError(f'Invalid instruction: {inputs}')
        
        return signals[wire]

    return get_signal(wire)

instructions = parse_instructions('input.txt')
signal_a = calculate_signal(instructions, 'a')
print(signal_a)
",0.0
24,2015,7,2,runtime_error,,14134,"Traceback (most recent call last):
  File ""/tmp/tmpxp1j8w_7/tmp.py"", line 7, in <module>
    instructions = parse_instructions('input.txt')
NameError: name 'parse_instructions' is not defined
","
def reset_signals(signals, except_wire):
    for wire in signals.keys():
        if wire != except_wire:
            del signals[wire]

instructions = parse_instructions('input.txt')
signals = {}
reset_signals(signals, 'b')
signal_b = calculate_signal(instructions, 'b')
reset_signals(signals, 'a')
signals['b'] = signal_b
signal_a = calculate_signal(instructions, 'a')
print(signal_a)
",2.0
25,2015,8,1,no_error,"1371
",1371,,"
def calculate_code_difference(line):
    code_length = len(line)
    memory_length = 0
    i = 1 # Skip the starting double quote
    while i < code_length - 1: # Skip the ending double quote
        if line[i] == '\\':
            if line[i+1] == '\\' or line[i+1] == '\""':
                memory_length += 1
                i += 1
            elif line[i+1] == 'x':
                memory_length += 1
                i += 3
        else:
            memory_length += 1
        i += 1

    return code_length - memory_length

total_code_difference = 0

with open('input.txt', 'r') as file:
    for line in file:
        total_code_difference += calculate_code_difference(line.strip())

print(total_code_difference)
",1.0
26,2015,8,2,syntax_error,,2117,"  File ""/tmp/tmpl_oemsch/tmp.py"", line 9
    elif line[i] == '\x':
                        ^
SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 0-1: truncated \xXX escape
","
def calculate_encoded_length(line):
    code_length = len(line)
    encoded_length = 2 # Start and end double quotes
    i = 0
    while i < code_length:
        if line[i] == '\\' or line[i] == '\""':
            encoded_length += 2 # Escaped backslash or double quote
        elif line[i] == '\x':
            encoded_length += 4 # Escaped hexadecimal character
        else:
            encoded_length += 1
        i += 1

    return encoded_length - code_length

total_encoded_difference = 0

with open('input.txt', 'r') as file:
    for line in file:
        total_encoded_difference += calculate_encoded_length(line.strip())

print(total_encoded_difference)
",2.0
27,2015,9,1,no_error,251,251,,"
import itertools

def calculate_distance(locations, distances):
    total_distance = 0
    for i in range(len(locations) - 1):
        location1 = locations[i]
        location2 = locations[i+1]
        total_distance += distances[(location1, location2)]
    return total_distance

def find_shortest_distance(locations, distances):
    shortest_distance = float('inf')
    shortest_route = []
    
    # Generate all possible permutations of locations
    for permutation in itertools.permutations(locations):
        distance = calculate_distance(permutation, distances)
        if distance < shortest_distance:
            shortest_distance = distance
            shortest_route = list(permutation)
    
    return shortest_distance, shortest_route


# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

distances = {}
locations = set()

# Parse the input and store distances in a dictionary
for line in lines:
    location1, _, location2, _, distance = line.split()
    distances[(location1, location2)] = int(distance)
    distances[(location2, location1)] = int(distance)
    locations.add(location1)
    locations.add(location2)

# Find the shortest distance and route
shortest_distance, shortest_route = find_shortest_distance(locations, distances)

print(f""The shortest distance is {shortest_distance}"")
print(f""The shortest route is {' -> '.join(shortest_route)}"")
",1.0
28,2015,9,2,no_error,898,898,,"
import itertools

def calculate_distance(locations, distances):
    total_distance = 0
    for i in range(len(locations) - 1):
        location1 = locations[i]
        location2 = locations[i+1]
        total_distance += distances[(location1, location2)]
    return total_distance

def find_longest_distance(locations, distances):
    longest_distance = 0
    longest_route = []
    
    # Generate all possible permutations of locations
    for permutation in itertools.permutations(locations):
        distance = calculate_distance(permutation, distances)
        if distance > longest_distance:
            longest_distance = distance
            longest_route = list(permutation)
    
    return longest_distance, longest_route


# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

distances = {}
locations = set()

# Parse the input and store distances in a dictionary
for line in lines:
    location1, _, location2, _, distance = line.split()
    distances[(location1, location2)] = int(distance)
    distances[(location2, location1)] = int(distance)
    locations.add(location1)
    locations.add(location2)

# Find the longest distance and route
longest_distance, longest_route = find_longest_distance(locations, distances)

print(f""The longest distance is {longest_distance}"")
print(f""The longest route is {' -> '.join(longest_route)}"")
",0.0
31,2015,10,1,no_error,"329356
",329356,,"import re

def look_and_say(input_str):
    result = ''
    groups = re.findall(r""(\d)(\1*)"", input_str)
    for digit, group in groups:
        result += str(len(group) + 1) + digit
    return result

with open('input.txt', 'r') as file:
    input_str = file.read().strip()

for _ in range(40):
    input_str = look_and_say(input_str)

result = len(input_str)
print(result)",0.0
32,2015,10,2,no_error,"4666278
",4666278,,"import re

def look_and_say(input_str):
    result = ''
    groups = re.findall(r""(\d)(\1*)"", input_str)
    for digit, group in groups:
        result += str(len(group) + 1) + digit
    return result

with open('input.txt', 'r') as file:
    input_str = file.read().strip()

for _ in range(50):
    input_str = look_and_say(input_str)

result = len(input_str)
print(result)",0.0
35,2015,11,1,no_error,"vzbxxyzz
",vzbxxyzz,,"def is_valid_password(password):
    # Check for straight of at least three letters
    for i in range(len(password)-2):
        if ord(password[i+1]) == ord(password[i]) + 1 and ord(password[i+2]) == ord(password[i]) + 2:
            break
    else:
        return False
    
    # Check for valid characters
    if 'i' in password or 'o' in password or 'l' in password:
        return False
    
    # Check for at least two different pairs of letters
    pairs = set()
    for i in range(len(password)-1):
        if password[i] == password[i+1]:
            pairs.add(password[i])
    if len(pairs) < 2:
        return False
    
    return True

def generate_next_password(password):
    password = list(password)
    
    # Increment password
    index = len(password) - 1
    while True:
        password[index] = chr((ord(password[index]) - ord('a') + 1) % 26 + ord('a'))
        if password[index] != 'a':
            break
        index -= 1
    
    return ''.join(password)

with open('input.txt', 'r') as f:
    current_password = f.read().strip()

while True:
    current_password = generate_next_password(current_password)
    if is_valid_password(current_password):
        break

print(current_password)",2.0
36,2015,11,2,wrong_output,"vzbxxyzz
",vzcaabcc,,"def is_valid_password(password):
    # Check for straight of at least three letters
    for i in range(len(password)-2):
        if ord(password[i+1]) == ord(password[i]) + 1 and ord(password[i+2]) == ord(password[i]) + 2:
            break
    else:
        return False
    
    # Check for valid characters
    if 'i' in password or 'o' in password or 'l' in password:
        return False
    
    # Check for at least two different pairs of letters
    pairs = set()
    for i in range(len(password)-1):
        if password[i] == password[i+1]:
            pairs.add(password[i])
    if len(pairs) < 2:
        return False
    
    return True

def generate_next_password(password):
    password = list(password)
    
    # Increment password
    index = len(password) - 1
    while True:
        password[index] = chr((ord(password[index]) - ord('a') + 1) % 26 + ord('a'))
        if password[index] != 'a':
            break
        index -= 1
    
    return ''.join(password)

with open('input.txt', 'r') as f:
    current_password = f.read().strip()

while True:
    current_password = generate_next_password(current_password)
    if is_valid_password(current_password):
        break

print(current_password)",2.0
37,2015,12,1,no_error,"111754
",111754,,"import json

def sum_numbers(json_data):
    total_sum = 0

    def add_numbers(data):
        nonlocal total_sum
        if isinstance(data, int):
            total_sum += data
        elif isinstance(data, list):
            for item in data:
                add_numbers(item)
        elif isinstance(data, dict):
            for key, value in data.items():
                add_numbers(value)

    add_numbers(json_data)
    return total_sum

# Read the input JSON document
with open('input.txt', 'r') as file:
    json_data = json.load(file)

# Calculate the sum of all numbers
result = sum_numbers(json_data)
print(result)",0.0
38,2015,12,2,no_error,"65402
",65402,,"import json

def sum_numbers(json_data):
    total_sum = 0

    def add_numbers(data):
        nonlocal total_sum
        if isinstance(data, int):
            total_sum += data
        elif isinstance(data, list):
            for item in data:
                add_numbers(item)
        elif isinstance(data, dict):
            if ""red"" not in data.values():
                for value in data.values():
                    add_numbers(value)

    add_numbers(json_data)
    return total_sum

# Read the input JSON document
with open('input.txt', 'r') as file:
    json_data = json.load(file)

# Calculate the sum of all numbers, ignoring objects with ""red"" property
result = sum_numbers(json_data)
print(result)",0.0
41,2015,13,1,runtime_error,,733,"Traceback (most recent call last):
  File ""/tmp/tmpdk6uzhbj/tmp.py"", line 40, in <module>
    happiness = parse_input(input_str)
  File ""/tmp/tmpdk6uzhbj/tmp.py"", line 11, in parse_input
    value = int(words[3])
ValueError: invalid literal for int() with base 10: 'by'
","
import itertools

def parse_input(input_str):
    happiness = {}
    for line in input_str.strip().split('\n'):
        line = line.replace('.', '').replace('happiness units', '').replace('would gain', '+').replace('would lose', '-')
        words = line.split()
        person1 = words[0]
        person2 = words[-1]
        value = int(words[3])
        if person1 not in happiness:
            happiness[person1] = {}
        happiness[person1][person2] = value
    return happiness

def calculate_happiness(happiness, arrangement):
    total_happiness = 0
    for i in range(len(arrangement)):
        person = arrangement[i]
        left_person = arrangement[i-1]
        right_person = arrangement[(i+1) % len(arrangement)]
        total_happiness += happiness[person][left_person] + happiness[person][right_person]
    return total_happiness

def find_optimal_arrangement(happiness):
    guests = list(happiness.keys())
    optimal_arrangement = None
    max_happiness = float('-inf')
    for arrangement in itertools.permutations(guests):
        total_happiness = calculate_happiness(happiness, arrangement)
        if total_happiness > max_happiness:
            max_happiness = total_happiness
            optimal_arrangement = arrangement
    return optimal_arrangement, max_happiness

with open('input.txt', 'r') as f:
    input_str = f.read()

happiness = parse_input(input_str)
optimal_arrangement, max_happiness = find_optimal_arrangement(happiness)
print(""Optimal Arrangement:"", optimal_arrangement)
print(""Total Change in Happiness:"", max_happiness)
",2.0
42,2015,13,2,part1_failed,,725,,,
43,2015,14,1,no_error,"2655
",2655,,"
reindeer_descriptions = []

with open('input.txt', 'r') as file:
    for line in file:
        parts = line.strip().split()
        name = parts[0]
        speed = int(parts[3])
        flying_duration = int(parts[6])
        resting_duration = int(parts[13])
        reindeer_descriptions.append((name, speed, flying_duration, resting_duration))


distances = {}

for second in range(1, 2504):
    for name, speed, flying_duration, resting_duration in reindeer_descriptions:
        cycle_duration = flying_duration + resting_duration
        cycle_distance = speed * flying_duration
        cycles_completed = second // cycle_duration
        distance = cycles_completed * cycle_distance
        remaining_time = second % cycle_duration
        distance += min(remaining_time, flying_duration) * speed
        distances[name] = distance


winning_reindeer = max(distances, key=distances.get)
winning_distance = distances[winning_reindeer]

print(winning_distance)
",1.0
44,2015,14,2,no_error,"1059
",1059,,"
reindeer_descriptions = []

with open('input.txt', 'r') as file:
    for line in file:
        parts = line.strip().split()
        name = parts[0]
        speed = int(parts[3])
        flying_duration = int(parts[6])
        resting_duration = int(parts[13])
        reindeer_descriptions.append((name, speed, flying_duration, resting_duration))


scores = {name: 0 for name, _, _, _ in reindeer_descriptions}
distances = {name: 0 for name, _, _, _ in reindeer_descriptions}

for second in range(1, 2504):
    for name, speed, flying_duration, resting_duration in reindeer_descriptions:
        cycle_duration = flying_duration + resting_duration
        cycle_distance = speed * flying_duration
        cycles_completed = second // cycle_duration
        distance = cycles_completed * cycle_distance
        remaining_time = second % cycle_duration
        distance += min(remaining_time, flying_duration) * speed
        distances[name] = distance

    current_leader_distance = max(distances.values())

    for name, distance in distances.items():
        if distance == current_leader_distance:
            scores[name] += 1


winning_score = max(scores.values())

print(winning_score)
",2.0
45,2015,15,1,no_error,"21367368
",21367368,,"import itertools

def calculate_score(ingredients, amounts):
    capacity = max(0, sum(amounts[i] * ingredients[i]['capacity'] for i in range(len(ingredients))))
    durability = max(0, sum(amounts[i] * ingredients[i]['durability'] for i in range(len(ingredients))))
    flavor = max(0, sum(amounts[i] * ingredients[i]['flavor'] for i in range(len(ingredients))))
    texture = max(0, sum(amounts[i] * ingredients[i]['texture'] for i in range(len(ingredients))))
    return capacity * durability * flavor * texture

def parse_input(input_string):
    ingredients = []
    for line in input_string.split('\n'):
        name, properties = line.split(': ')
        properties_dict = {}
        for prop in properties.split(', '):
            key, value = prop.split(' ')
            properties_dict[key] = int(value)
        ingredients.append(properties_dict)
    return ingredients

def find_highest_score(ingredients):
    highest_score = 0
    for amounts in itertools.product(range(101), repeat=len(ingredients)):
        if sum(amounts) == 100:
            score = calculate_score(ingredients, amounts)
            highest_score = max(highest_score, score)
    return highest_score

with open('input.txt', 'r') as file:
    input_string = file.read()

ingredients = parse_input(input_string)
highest_score = find_highest_score(ingredients)
print(highest_score)",2.0
46,2015,15,2,no_error,"1766400
",1766400,,"import itertools

def calculate_score(ingredients, amounts):
    capacity = max(0, sum(amounts[i] * ingredients[i]['capacity'] for i in range(len(ingredients))))
    durability = max(0, sum(amounts[i] * ingredients[i]['durability'] for i in range(len(ingredients))))
    flavor = max(0, sum(amounts[i] * ingredients[i]['flavor'] for i in range(len(ingredients))))
    texture = max(0, sum(amounts[i] * ingredients[i]['texture'] for i in range(len(ingredients))))
    return capacity * durability * flavor * texture

def calculate_calories(ingredients, amounts):
    return sum(amounts[i] * ingredients[i]['calories'] for i in range(len(ingredients)))

def parse_input(input_string):
    ingredients = []
    for line in input_string.split('\n'):
        name, properties = line.split(': ')
        properties_dict = {}
        for prop in properties.split(', '):
            key, value = prop.split(' ')
            properties_dict[key] = int(value)
        ingredients.append(properties_dict)
    return ingredients

def find_highest_score(ingredients, target_calories):
    highest_score = 0
    for amounts in itertools.product(range(101), repeat=len(ingredients)):
        if sum(amounts) == 100 and calculate_calories(ingredients, amounts) == target_calories:
            score = calculate_score(ingredients, amounts)
            highest_score = max(highest_score, score)
    return highest_score

with open('input.txt', 'r') as file:
    input_string = file.read()

ingredients = parse_input(input_string)
highest_score = find_highest_score(ingredients, 500)
print(highest_score)",0.0
49,2015,16,1,runtime_error,,40,"Traceback (most recent call last):
  File ""/tmp/tmpzzrt8ras/tmp.py"", line 32, in <module>
    aunt_sue = match_sue(compounds)
  File ""/tmp/tmpzzrt8ras/tmp.py"", line 13, in match_sue
    if all(compounds[compound] == sue_compounds[compound] for compound in compounds):
  File ""/tmp/tmpzzrt8ras/tmp.py"", line 13, in <genexpr>
    if all(compounds[compound] == sue_compounds[compound] for compound in compounds):
KeyError: 'children'
","
import re

def match_sue(compounds):
    aunt_sue = None

    with open('input.txt', 'r') as file:
        for line in file:
            match = re.search(r'Sue (\d+): (.+)', line)
            sue_number = int(match.group(1))
            sue_compounds = dict(re.findall(r'(\w+): (\d+)', match.group(2)))

            if all(compounds[compound] == sue_compounds[compound] for compound in compounds):
                aunt_sue = sue_number
                break

    return aunt_sue

compounds = {
    'children': 3,
    'cats': 7,
    'samoyeds': 2,
    'pomeranians': 3,
    'akitas': 0,
    'vizslas': 0,
    'goldfish': 5,
    'trees': 3,
    'cars': 2,
    'perfumes': 1
}

aunt_sue = match_sue(compounds)
print(aunt_sue)
",2.0
50,2015,16,2,part1_failed,,241,,,
51,2015,17,1,wrong_output,"0
",1638,,"
def count_combinations(containers, target):
    dp = [0] * (target + 1)
    dp[0] = 1

    for size in containers:
        for i in range(size, target + 1):
            dp[i] += dp[i - size]

    return dp[target]

# Read the input
with open('input.txt', 'r') as file:
    containers = list(map(int, file.readline().split()))
    target = int(file.readline())

# Calculate and print the result
result = count_combinations(containers, target)
print(result)
",2.0
52,2015,17,2,part1_failed,,17,,,
53,2015,18,1,no_error,"814
",814,,"def animate_lights(initial_state, steps):
    grid_size = len(initial_state)
    current_state = initial_state

    def count_neighbors(row, col):
        count = 0
        for i in range(row-1, row+2):
            for j in range(col-1, col+2):
                if i >= 0 and i < grid_size and j >= 0 and j < grid_size and (i != row or j != col):
                    if current_state[i][j] == '#':
                        count += 1
        return count

    def next_state(row, col):
        num_neighbors_on = count_neighbors(row, col)
        if current_state[row][col] == '#':
            if num_neighbors_on == 2 or num_neighbors_on == 3:
                return '#'
            else:
                return '.'
        else:
            if num_neighbors_on == 3:
                return '#'
            else:
                return '.'

    for _ in range(steps):
        next_grid = [['.' for _ in range(grid_size)] for _ in range(grid_size)]
        for i in range(grid_size):
            for j in range(grid_size):
                next_grid[i][j] = next_state(i, j)
        current_state = next_grid

    return sum(row.count('#') for row in current_state)

with open('input.txt') as file:
    initial_state = [list(line.strip()) for line in file.readlines()]

lights_on = animate_lights(initial_state, 100)
print(lights_on)",0.0
54,2015,18,2,no_error,"924
",924,,"def animate_lights(initial_state, steps):
    grid_size = len(initial_state)
    current_state = initial_state

    def count_neighbors(row, col):
        count = 0
        for i in range(row-1, row+2):
            for j in range(col-1, col+2):
                if i >= 0 and i < grid_size and j >= 0 and j < grid_size and (i != row or j != col):
                    if current_state[i][j] == '#':
                        count += 1
        return count

    def next_state(row, col):
        num_neighbors_on = count_neighbors(row, col)
        if current_state[row][col] == '#':
            if num_neighbors_on == 2 or num_neighbors_on == 3:
                return '#'
            else:
                return '.'
        else:
            if num_neighbors_on == 3:
                return '#'
            else:
                return '.'

    # Set the four corners to always be on
    current_state[0][0] = '#'
    current_state[0][grid_size - 1] = '#'
    current_state[grid_size - 1][0] = '#'
    current_state[grid_size - 1][grid_size - 1] = '#'

    for _ in range(steps):
        next_grid = [['.' for _ in range(grid_size)] for _ in range(grid_size)]
        for i in range(grid_size):
            for j in range(grid_size):
                next_grid[i][j] = next_state(i, j)
        current_state = next_grid

        # Reset the four corners to always be on
        current_state[0][0] = '#'
        current_state[0][grid_size - 1] = '#'
        current_state[grid_size - 1][0] = '#'
        current_state[grid_size - 1][grid_size - 1] = '#'

    return sum(row.count('#') for row in current_state)

with open('input.txt') as file:
    initial_state = [list(line.strip()) for line in file.readlines()]

lights_on = animate_lights(initial_state, 100)
print(lights_on)",0.0
56,2015,19,1,syntax_error,,518,"  File ""/tmp/tmpwbg0b8bk/tmp.py"", line 3
    To solve this problem, we need to parse the input to obtain the replacements and the medicine molecule. Then, we can use a recursive approach to generate all possible molecules by applying the replacements.
       ^
SyntaxError: invalid syntax
","# Approach

To solve this problem, we need to parse the input to obtain the replacements and the medicine molecule. Then, we can use a recursive approach to generate all possible molecules by applying the replacements.

1. Parse the input to obtain the replacements and the medicine molecule.
2. Implement a recursive function that takes a molecule and applies all possible replacements to generate new molecules.
3. Use memoization to avoid duplicate calculations.
4. Count the number of distinct molecules generated after applying all possible replacements to the medicine molecule.

Let's start by parsing the input.",2.0
57,2015,19,2,part1_failed,,200,,,
58,2015,20,1,wrong_output,"2006
",776160,,"
def find_house(presents):
    house = 1
    while presents > 0:
        presents -= sum(i * 10 for i in range(1, house + 1) if house % i == 0)
        house += 1
    return house - 1

with open('input.txt', 'r') as f:
    puzzle_input = int(f.read().strip())

result = find_house(puzzle_input)
print(result)
",2.0
59,2015,20,2,part1_failed,,786240,,,
60,2015,21,1,syntax_error,,78,"  File ""/tmp/tmpe7bh5jwf/tmp.py"", line 1
    To find the least amount of gold to spend and still win the fight, we need to consider all possible combinations of items that the player can buy and calculate the outcome of the battle for each combination. We can then determine the minimum cost that results in a victory.
       ^
SyntaxError: invalid syntax
","To find the least amount of gold to spend and still win the fight, we need to consider all possible combinations of items that the player can buy and calculate the outcome of the battle for each combination. We can then determine the minimum cost that results in a victory.

First, let's parse the input and store the item information in appropriate data structures. We can represent each item as a dictionary with keys for ""name"", ""cost"", ""damage"", and ""armor"". We can create separate lists for weapons, armor, and rings.

Next, we can define a function to simulate the battle between the player and the boss. This function will take the player's hit points, damage, and armor as parameters, and return True if the player wins, and False otherwise.

Inside the battle simulation function, we can simulate the turns of the player and the boss until one of them reaches 0 hit points. We can calculate the damage dealt by each attacker based on their damage and armor scores, and reduce the hit points accordingly. We need to account for the fact that the attacker always does at least 1 damage.

We can then iterate through all possible combinations of items using nested loops. For each combination, we can calculate the total cost, damage, and armor, and pass these values to the battle simulation function. If the player wins the battle, we can keep track of the minimum cost encountered so far.

Finally, we can print the minimum cost as the result.

Here's the code that implements the above steps:",2.0
61,2015,21,2,part1_failed,,148,,,
62,2015,22,1,timeout_error,,953,TIMEOUT,"
def simulate_battle(player_hp, player_mana, boss_hp, boss_damage, shield_timer, poison_timer, recharge_timer, mana_spent):
    # Check if player has enough mana to cast the cheapest spell
    if player_mana < 53:
        return float('inf')  # Return a large value to indicate an impossible state
    
    # Apply active effects
    if shield_timer > 0:
        player_armor = 7
        shield_timer -= 1
    else:
        player_armor = 0
    
    if poison_timer > 0:
        boss_hp -= 3
        poison_timer -= 1
    
    if recharge_timer > 0:
        player_mana += 101
        recharge_timer -= 1
    
    # Check if boss is defeated
    if boss_hp <= 0:
        return mana_spent
    
    # Player's turn
    lowest_mana_spent = float('inf')
    
    # Try casting each spell and simulate boss' turn
    for spell in ['Magic Missile', 'Drain', 'Shield', 'Poison', 'Recharge']:
        spell_mana_cost = get_spell_mana_cost(spell)
        
        # Skip if player cannot afford the spell
        if player_mana < spell_mana_cost:
            continue
        
        # Skip if spell is already active
        if spell == 'Shield' and shield_timer > 0:
            continue
        elif spell == 'Poison' and poison_timer > 0:
            continue
        elif spell == 'Recharge' and recharge_timer > 0:
            continue
        
        # Calculate new player and boss states after casting the spell
        new_player_hp = player_hp
        new_player_mana = player_mana - spell_mana_cost
        new_boss_hp = boss_hp
        new_shield_timer = shield_timer
        new_poison_timer = poison_timer
        new_recharge_timer = recharge_timer
        new_mana_spent = mana_spent + spell_mana_cost
        
        if spell == 'Magic Missile':
            new_boss_hp -= 4
        elif spell == 'Drain':
            new_boss_hp -= 2
            new_player_hp += 2
        elif spell == 'Shield':
            new_shield_timer = 6
        elif spell == 'Poison':
            new_poison_timer = 6
        elif spell == 'Recharge':
            new_recharge_timer = 5
        
        # Simulate boss' turn
        damage = max(boss_damage - player_armor, 1)
        new_player_hp -= damage
        
        # Check if player is defeated
        if new_player_hp <= 0:
            continue
        
        # Recursively simulate the rest of the battle
        remaining_mana_spent = simulate_battle(new_player_hp, new_player_mana, new_boss_hp, boss_damage, new_shield_timer, new_poison_timer, new_recharge_timer, new_mana_spent)
        
        # Update lowest_mana_spent if a better solution is found
        lowest_mana_spent = min(lowest_mana_spent, remaining_mana_spent)
    
    return lowest_mana_spent

def get_spell_mana_cost(spell):
    if spell == 'Magic Missile':
        return 53
    elif spell == 'Drain':
        return 73
    elif spell == 'Shield':
        return 113
    elif spell == 'Poison':
        return 173
    elif spell == 'Recharge':
        return 229

# Read boss stats from input.txt
with open('input.txt', 'r') as file:
    boss_hp = int(file.readline().split()[-1])
    boss_damage = int(file.readline().split()[-1])

# Start the battle simulation
lowest_mana_spent = simulate_battle(50, 500, boss_hp, boss_damage, 0, 0, 0, 0)
print(""The least amount of mana spent and still win the fight is:"", lowest_mana_spent)
",2.0
63,2015,22,2,part1_failed,,1289,,,
64,2015,23,1,no_error,"307
",307,,"
def execute_program(instructions):
    a = 0
    b = 0
    pc = 0

    while pc >= 0 and pc < len(instructions):
        instruction = instructions[pc]
        parts = instruction.split()

        if parts[0] == 'hlf':
            register = parts[1]
            if register == 'a':
                a //= 2
            else:
                b //= 2
            pc += 1
        elif parts[0] == 'tpl':
            register = parts[1]
            if register == 'a':
                a *= 3
            else:
                b *= 3
            pc += 1
        elif parts[0] == 'inc':
            register = parts[1]
            if register == 'a':
                a += 1
            else:
                b += 1
            pc += 1
        elif parts[0] == 'jmp':
            offset = int(parts[1])
            pc += offset
        elif parts[0] == 'jie':
            register = parts[1][:-1]
            offset = int(parts[2])
            if (a if register == 'a' else b) % 2 == 0:
                pc += offset
            else:
                pc += 1
        elif parts[0] == 'jio':
            register = parts[1][:-1]
            offset = int(parts[2])
            if (a if register == 'a' else b) == 1:
                pc += offset
            else:
                pc += 1

    return b

# Read the program instructions from the input file
with open('input.txt', 'r') as file:
    instructions = [line.strip() for line in file]

# Execute the program and print the value in register b
print(execute_program(instructions))
",0.0
65,2015,23,2,no_error,"160
",160,,"
def execute_program(instructions):
    a = 1  # Modified: Start with register a as 1
    b = 0
    pc = 0

    while pc >= 0 and pc < len(instructions):
        instruction = instructions[pc]
        parts = instruction.split()

        if parts[0] == 'hlf':
            register = parts[1]
            if register == 'a':
                a //= 2
            else:
                b //= 2
            pc += 1
        elif parts[0] == 'tpl':
            register = parts[1]
            if register == 'a':
                a *= 3
            else:
                b *= 3
            pc += 1
        elif parts[0] == 'inc':
            register = parts[1]
            if register == 'a':
                a += 1
            else:
                b += 1
            pc += 1
        elif parts[0] == 'jmp':
            offset = int(parts[1])
            pc += offset
        elif parts[0] == 'jie':
            register = parts[1][:-1]
            offset = int(parts[2])
            if (a if register == 'a' else b) % 2 == 0:
                pc += offset
            else:
                pc += 1
        elif parts[0] == 'jio':
            register = parts[1][:-1]
            offset = int(parts[2])
            if (a if register == 'a' else b) == 1:
                pc += offset
            else:
                pc += 1

    return b

# Read the program instructions from the input file
with open('input.txt', 'r') as file:
    instructions = [line.strip() for line in file]

# Execute the program with register a starting as 1 and print the value in register b
print(execute_program(instructions))
",0.0
68,2015,24,1,syntax_error,,10439961859,"  File ""/tmp/tmpxf112a0w/tmp.py"", line 1
    To find the quantum entanglement of the first group of packages in the ideal configuration, we need to split the packages into three groups of equal weight, with the first group having the fewest packages possible. We can solve this problem using a recursive approach.
       ^
SyntaxError: invalid syntax
","To find the quantum entanglement of the first group of packages in the ideal configuration, we need to split the packages into three groups of equal weight, with the first group having the fewest packages possible. We can solve this problem using a recursive approach.

First, we'll read the input from the file 'input.txt' and store it in a list called 'packages'. Then, we'll calculate the target weight for each group by dividing the sum of all package weights by 3.

Next, we'll define a recursive function called 'find_groups' that takes the following parameters:
- 'packages': the list of remaining packages to be divided
- 'target_weight': the target weight for each group
- 'group_1': the current configuration of the first group
- 'group_2': the current configuration of the second group
- 'group_3': the current configuration of the third group

In the 'find_groups' function, we'll check the following conditions:
- If 'group_1' has more packages than the current best configuration or 'group_1' exceeds the target weight, we can stop exploring this branch.
- If 'group_1' has the same number of packages as the current best configuration and 'group_1' has a higher quantum entanglement, we can stop exploring this branch.

If none of the above conditions are met, we'll iterate through each package in 'packages' and try adding it to 'group_1', 'group_2', or 'group_3'. We'll make recursive calls to 'find_groups' with the updated configurations and the remaining packages.

Once all packages have been assigned to one of the groups, we'll check if all groups have the same weight. If they do, we'll calculate the quantum entanglement of 'group_1' and update the current best configuration if necessary.

Finally, we'll call the 'find_groups' function with the initial configurations and print the quantum entanglement of the first group in the ideal configuration.

Here's the code that implements the solution:",2.0
69,2015,24,2,part1_failed,,72050269,,,
70,2015,25,1,wrong_output,"The code at row 2978, column 3083 is None.
",9132360,,"
def get_code(row, column):
    code = 20151125
    for i in range(2, row + column):
        for j in range(1, i):
            code = (code * 252533) % 33554393

            if j == column and i - j == row:
                return code

row = 2978
column = 3083
code = get_code(row, column)
print(f""The code at row {row}, column {column} is {code}."")
",2.0
71,2015,25,2,part1_failed,,,,,
72,2016,1,1,no_error,"287
",287,,"
# Read the input from file
with open('input.txt', 'r') as file:
    instructions = file.read().strip().split(', ')

# Initialize variables
x = 0
y = 0
direction = 0

# Process each instruction
for instruction in instructions:
    # Update direction
    if instruction[0] == 'L':
        direction = (direction - 1) % 4
    elif instruction[0] == 'R':
        direction = (direction + 1) % 4

    # Update position
    distance = int(instruction[1:])
    if direction == 0:
        y += distance
    elif direction == 1:
        x += distance
    elif direction == 2:
        y -= distance
    elif direction == 3:
        x -= distance

# Calculate Manhattan distance
distance = abs(x) + abs(y)

print(distance)
",0.0
73,2016,1,2,no_error,"133
",133,,"
# Read the input from file
with open('input.txt', 'r') as file:
    instructions = file.read().strip().split(', ')

# Initialize variables
x = 0
y = 0
direction = 0

# Initialize set of visited locations
visited = set()
visited.add((x, y))

# Process each instruction
for instruction in instructions:
    # Update direction
    if instruction[0] == 'L':
        direction = (direction - 1) % 4
    elif instruction[0] == 'R':
        direction = (direction + 1) % 4

    # Update position
    distance = int(instruction[1:])
    for _ in range(distance):
        # Move one step at a time and check if visited
        if direction == 0:
            y += 1
        elif direction == 1:
            x += 1
        elif direction == 2:
            y -= 1
        elif direction == 3:
            x -= 1

        # Check if visited location
        if (x, y) in visited:
            distance = abs(x) + abs(y)
            print(distance)
            exit()

        # Add current location to visited set
        visited.add((x, y))
",0.0
76,2016,2,1,no_error,"12578
",12578,,"
keypad = {
    (-1, 1): '1',
    (0, 1): '2',
    (1, 1): '3',
    (-1, 0): '4',
    (0, 0): '5',
    (1, 0): '6',
    (-1, -1): '7',
    (0, -1): '8',
    (1, -1): '9',
}

code = ''
current_coordinates = (0, 0)

with open('input.txt', 'r') as f:
    for line in f:
        for move in line.strip():
            if move == 'U':
                new_coordinates = (current_coordinates[0], current_coordinates[1] + 1)
            elif move == 'D':
                new_coordinates = (current_coordinates[0], current_coordinates[1] - 1)
            elif move == 'L':
                new_coordinates = (current_coordinates[0] - 1, current_coordinates[1])
            elif move == 'R':
                new_coordinates = (current_coordinates[0] + 1, current_coordinates[1])

            if new_coordinates in keypad:
                current_coordinates = new_coordinates

        code += keypad[current_coordinates]

print(code)
",1.0
77,2016,2,2,no_error,"516DD
",516DD,,"
keypad = {
    (0, 2): '1',
    (-1, 1): '2',
    (0, 1): '3',
    (1, 1): '4',
    (-2, 0): '5',
    (-1, 0): '6',
    (0, 0): '7',
    (1, 0): '8',
    (2, 0): '9',
    (-1, -1): 'A',
    (0, -1): 'B',
    (1, -1): 'C',
    (0, -2): 'D',
}

code = ''
current_coordinates = (0, -2)

with open('input.txt', 'r') as f:
    for line in f:
        for move in line.strip():
            if move == 'U':
                new_coordinates = (current_coordinates[0], current_coordinates[1] + 1)
            elif move == 'D':
                new_coordinates = (current_coordinates[0], current_coordinates[1] - 1)
            elif move == 'L':
                new_coordinates = (current_coordinates[0] - 1, current_coordinates[1])
            elif move == 'R':
                new_coordinates = (current_coordinates[0] + 1, current_coordinates[1])

            if new_coordinates in keypad:
                current_coordinates = new_coordinates

        code += keypad[current_coordinates]

print(code)
",0.0
80,2016,3,1,no_error,"993
",993,,"
def is_triangle_possible(a, b, c):
    return a + b > c and a + c > b and b + c > a

# Read the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Count the number of possible triangles
possible_count = 0
for line in lines:
    # Parse the triangle side lengths
    a, b, c = map(int, line.strip().split())

    # Check if the triangle is possible
    if is_triangle_possible(a, b, c):
        possible_count += 1

# Print the number of possible triangles
print(possible_count)
",0.0
81,2016,3,2,no_error,"1849
",1849,,"
def is_triangle_possible(a, b, c):
    return a + b > c and a + c > b and b + c > a

# Read the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Transpose the lines to read the triangles column-wise
triangles = []
for line in lines:
    triangle = list(map(int, line.strip().split()))
    triangles.append(triangle)

# Count the number of possible triangles
possible_count = 0
for i in range(0, len(triangles), 3):
    for j in range(3):
        a, b, c = triangles[i][j], triangles[i+1][j], triangles[i+2][j]

        # Check if the triangle is possible
        if is_triangle_possible(a, b, c):
            possible_count += 1

# Print the number of possible triangles
print(possible_count)
",2.0
82,2016,4,1,no_error,"245102
",245102,,"import re

def is_real_room(room):
    encrypted_name, sector_id, checksum = re.match(r'([a-z-]+)-(\d+)\[([a-z]+)\]', room).groups()
    encrypted_name = encrypted_name.replace('-', '')
    letter_count = {}
    for letter in encrypted_name:
        letter_count[letter] = letter_count.get(letter, 0) + 1
    sorted_letters = sorted(letter_count.keys(), key=lambda x: (-letter_count[x], x))
    calculated_checksum = ''.join(sorted_letters[:5])
    return calculated_checksum == checksum

def sum_of_sector_ids(real_rooms):
    sector_ids = [int(re.search(r'-(\d+)\[', room).group(1)) for room in real_rooms]
    return sum(sector_ids)

# Read input from file
with open('input.txt', 'r') as file:
    rooms = file.read().splitlines()

# Filter out decoy rooms
real_rooms = [room for room in rooms if is_real_room(room)]

# Calculate sum of sector IDs
sum_of_ids = sum_of_sector_ids(real_rooms)
print(sum_of_ids)",0.0
83,2016,4,2,no_error,"324
",324,,"import re

def is_real_room(room):
    encrypted_name, sector_id, checksum = re.match(r'([a-z-]+)-(\d+)\[([a-z]+)\]', room).groups()
    encrypted_name = encrypted_name.replace('-', '')
    letter_count = {}
    for letter in encrypted_name:
        letter_count[letter] = letter_count.get(letter, 0) + 1
    sorted_letters = sorted(letter_count.keys(), key=lambda x: (-letter_count[x], x))
    calculated_checksum = ''.join(sorted_letters[:5])
    return calculated_checksum == checksum

def decrypt_room_name(room):
    encrypted_name, sector_id, checksum = re.match(r'([a-z-]+)-(\d+)\[([a-z]+)\]', room).groups()
    decrypted_name = ''
    for letter in encrypted_name:
        if letter == '-':
            decrypted_name += ' '
        else:
            rotated_letter = chr((ord(letter) - ord('a') + int(sector_id)) % 26 + ord('a'))
            decrypted_name += rotated_letter
    return decrypted_name

def find_north_pole_room(real_rooms):
    for room in real_rooms:
        decrypted_name = decrypt_room_name(room)
        if 'northpole' in decrypted_name:
            return room

# Read input from file
with open('input.txt', 'r') as file:
    rooms = file.read().splitlines()

# Filter out decoy rooms
real_rooms = [room for room in rooms if is_real_room(room)]

# Find the North Pole room
north_pole_room = find_north_pole_room(real_rooms)

# Extract the sector ID
sector_id = int(re.search(r'-(\d+)\[', north_pole_room).group(1))
print(sector_id)",0.0
86,2016,5,1,no_error,"1a3099aa
",1a3099aa,,"
import hashlib

def find_password(door_id):
    password = ''
    index = 0
    while len(password) < 8:
        message = door_id + str(index)
        hash = hashlib.md5(message.encode()).hexdigest()
        if hash.startswith('00000'):
            password += hash[5]
        index += 1
    return password

# Read input from file
with open('input.txt', 'r') as file:
    door_id = file.read().strip()

# Find the password for the given door ID
password = find_password(door_id)
print(password)
",0.0
87,2016,5,2,no_error,694190cd,694190cd,,"
import hashlib
import time

def find_password(door_id):
    password = ['_'] * 8
    index = 0
    while '_' in password:
        message = door_id + str(index)
        hash = hashlib.md5(message.encode()).hexdigest()
        if hash.startswith('00000'):
            position = int(hash[5], 16)
            if position < 8 and password[position] == '_':
                password[position] = hash[6]
                print_password(password)
        index += 1
    return ''.join(password)

def print_password(password):
    # Clear previous line
    print('\033[F', end='')
    # Print password with cinematic animation
    print(''.join(['*' if c != '_' else ' ' for c in password]))
    # Sleep for a short time to create animation effect
    time.sleep(0.05)

# Read input from file
with open('input.txt', 'r') as file:
    door_id = file.read().strip()

# Find the password for the given door ID
password = find_password(door_id)
print(password)
",0.0
90,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"
# Read the input file
with open('input.txt', 'r') as file:
    messages = file.readlines()

# Trim the newline character from each message
messages = [message.strip() for message in messages]

# Get the length of each message
message_length = len(messages[0])

# Initialize a list to store the most frequent characters
most_frequent_chars = []

# Iterate over each position in the messages
for i in range(message_length):
    # Initialize a dictionary to count the occurrences of each character
    char_counts = {}

    # Count the occurrences of each character at the current position
    for message in messages:
        char = message[i]
        char_counts[char] = char_counts.get(char, 0) + 1

    # Find the character with the maximum count
    max_count = 0
    max_char = None
    for char, count in char_counts.items():
        if count > max_count:
            max_count = count
            max_char = char

    # Add the most frequent character to the list
    most_frequent_chars.append(max_char)

# Print the error-corrected message
error_corrected_message = ''.join(most_frequent_chars)
print(error_corrected_message)
",0.0
91,2016,6,2,no_error,"pdesmnoz
",pdesmnoz,,"
# Read the input file
with open('input.txt', 'r') as file:
    messages = file.readlines()

# Trim the newline character from each message
messages = [message.strip() for message in messages]

# Get the length of each message
message_length = len(messages[0])

# Initialize a list to store the least frequent characters
least_frequent_chars = []

# Iterate over each position in the messages
for i in range(message_length):
    # Initialize a dictionary to count the occurrences of each character
    char_counts = {}

    # Count the occurrences of each character at the current position
    for message in messages:
        char = message[i]
        char_counts[char] = char_counts.get(char, 0) + 1

    # Find the character with the minimum count
    min_count = float('inf')
    min_char = None
    for char, count in char_counts.items():
        if count < min_count:
            min_count = count
            min_char = char

    # Add the least frequent character to the list
    least_frequent_chars.append(min_char)

# Print the original message
original_message = ''.join(least_frequent_chars)
print(original_message)
",0.0
94,2016,7,1,no_error,"115
",115,,"
def supports_tls(ip):
    in_hypernet = False
    has_abba = False
    for i in range(len(ip) - 3):
        if ip[i] == '[':
            in_hypernet = True
        elif ip[i] == ']':
            in_hypernet = False
        elif ip[i] != ip[i+1] and ip[i] == ip[i+3] and ip[i+1] == ip[i+2]:
            if in_hypernet:
                return False
            has_abba = True
    return has_abba

def count_ips_supporting_tls(ips):
    count = 0
    for ip in ips:
        if supports_tls(ip):
            count += 1
    return count

with open('input.txt', 'r') as file:
    ips = file.read().splitlines()

print(count_ips_supporting_tls(ips))
",0.0
95,2016,7,2,no_error,"231
",231,,"
def supports_ssl(ip):
    supernet_aba = []
    hypernet_bab = []
    in_hypernet = False
    for i in range(len(ip) - 2):
        if ip[i] == '[':
            in_hypernet = True
        elif ip[i] == ']':
            in_hypernet = False
        elif ip[i] != ip[i+1] and ip[i] == ip[i+2]:
            if in_hypernet:
                hypernet_bab.append(ip[i:i+3])
            else:
                supernet_aba.append(ip[i:i+3])
    for aba in supernet_aba:
        bab = aba[1] + aba[0] + aba[1]
        if bab in hypernet_bab:
            return True
    return False

def count_ips_supporting_ssl(ips):
    count = 0
    for ip in ips:
        if supports_ssl(ip):
            count += 1
    return count

with open('input.txt', 'r') as file:
    ips = file.read().splitlines()

print(count_ips_supporting_ssl(ips))
",0.0
98,2016,8,1,no_error,115,115,,"
def parse_rect(instruction, screen):
    width, height = map(int, instruction[5:].split('x'))
    for i in range(height):
        for j in range(width):
            screen[i][j] = '#'
    return screen

def parse_rotate_row(instruction, screen):
    row, shift = map(int, instruction[13:].split(' by '))
    screen[row] = screen[row][-shift:] + screen[row][:-shift]
    return screen

def parse_rotate_column(instruction, screen):
    col, shift = map(int, instruction[16:].split(' by '))
    new_col = [screen[i][col] for i in range(len(screen))]
    new_col = new_col[-shift:] + new_col[:-shift]
    for i in range(len(new_col)):
        screen[i][col] = new_col[i]
    return screen

def count_lit_pixels(screen):
    count = 0
    for i in range(len(screen)):
        for j in range(len(screen[0])):
            if screen[i][j] == '#':
                count += 1
    return count

def main():
    screen = [['.' for _ in range(50)] for _ in range(6)]

    with open('input.txt', 'r') as file:
        instructions = file.read().split('\n')

    for instruction in instructions:
        if instruction.startswith('rect'):
            screen = parse_rect(instruction, screen)
        elif instruction.startswith('rotate row'):
            screen = parse_rotate_row(instruction, screen)
        elif instruction.startswith('rotate column'):
            screen = parse_rotate_column(instruction, screen)

    lit_pixels = count_lit_pixels(screen)
    print(f""The number of lit pixels is: {lit_pixels}"")

if __name__ == ""__main__"":
    main()
",0.0
99,2016,8,2,no_error,"####.####.####.#...##..#.####.###..####..###...##.
#....#....#....#...##.#..#....#..#.#......#.....#.
###..###..###...#.#.##...###..#..#.###....#.....#.
#....#....#......#..#.#..#....###..#......#.....#.
#....#....#......#..#.#..#....#.#..#......#..#..#.
####.#....####...#..#..#.#....#..#.#.....###..##..

","####.####.####.#...##..#.####.###..####..###...##.
#....#....#....#...##.#..#....#..#.#......#.....#.
###..###..###...#.#.##...###..#..#.###....#.....#.
#....#....#......#..#.#..#....###..#......#.....#.
#....#....#......#..#.#..#....#.#..#......#..#..#.
####.#....####...#..#..#.#....#..#.#.....###..##..",,"
def parse_rect(instruction, screen):
    width, height = map(int, instruction[5:].split('x'))
    for i in range(height):
        for j in range(width):
            screen[i][j] = '#'
    return screen

def parse_rotate_row(instruction, screen):
    row, shift = map(int, instruction[13:].split(' by '))
    screen[row] = screen[row][-shift:] + screen[row][:-shift]
    return screen

def parse_rotate_column(instruction, screen):
    col, shift = map(int, instruction[16:].split(' by '))
    new_col = [screen[i][col] for i in range(len(screen))]
    new_col = new_col[-shift:] + new_col[:-shift]
    for i in range(len(new_col)):
        screen[i][col] = new_col[i]
    return screen

def print_screen(screen):
    for row in screen:
        for pixel in row:
            print(pixel, end='')
        print()
    print()

def main():
    screen = [['.' for _ in range(50)] for _ in range(6)]

    with open('input.txt', 'r') as file:
        instructions = file.read().split('\n')

    for instruction in instructions:
        if instruction.startswith('rect'):
            screen = parse_rect(instruction, screen)
        elif instruction.startswith('rotate row'):
            screen = parse_rotate_row(instruction, screen)
        elif instruction.startswith('rotate column'):
            screen = parse_rotate_column(instruction, screen)

    print_screen(screen)

if __name__ == ""__main__"":
    main()
",0.0
101,2016,9,1,syntax_error,,102239,"  File ""/tmp/tmp9apz3z3j/tmp.py"", line 1
    To solve this problem, we can iterate through the input file character by character and keep track of the decompressed length.
       ^
SyntaxError: invalid syntax
","To solve this problem, we can iterate through the input file character by character and keep track of the decompressed length.

Here's the step-by-step algorithm:

1. Read the input file and store its contents in a variable called `data`.
2. Initialize a variable `decompressed_length` to 0.
3. Initialize a variable `i` to 0 to keep track of the current position in `data`.
4. While `i` is less than the length of `data`, do the following:
   - If the current character at index `i` is '(', it means we have encountered a marker. Parse the marker by finding the digits between '(' and 'x' and convert them to integers. Store the parsed length in a variable `length` and the parsed repetition factor in a variable `repetitions`.
   - Increment `i` until the closing ')' character is found.
   - Slice the substring from `i + 1` to `i + length + 1` from `data` and multiply it by `repetitions`.
   - Add the length of the multiplied substring to `decompressed_length`.
   - Increment `i` by `length + 1` (to skip the marker and repeated substring).
5. Print the final value of `decompressed_length`.

Now let's generate the code for this algorithm.",2.0
102,2016,9,2,part1_failed,,10780403063,,,
103,2016,10,1,runtime_error,,118,"Traceback (most recent call last):
  File ""/tmp/tmphambyyv7/tmp.py"", line 64, in <module>
    responsible_bot = find_responsible_bot(instructions, 17, 61)
  File ""/tmp/tmphambyyv7/tmp.py"", line 39, in find_responsible_bot
    receive_chip(bot_num, value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 34, in execute_instructions
    receive_chip(high_dest_num, high_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 27, in execute_instructions
    receive_chip(low_dest_num, low_value)
  File ""/tmp/tmphambyyv7/tmp.py"", line 12, in receive_chip
    execute_instructions(bot_num)
  File ""/tmp/tmphambyyv7/tmp.py"", line 19, in execute_instructions
    low_dest_type, low_dest_num = bot_instructions[bot_num][""low""]
KeyError: 183
","
def find_responsible_bot(instructions, value1, value2):
    bot_values = {}
    bot_instructions = {}
    output_bins = {}

    def receive_chip(bot_num, chip_value):
        if bot_num not in bot_values:
            bot_values[bot_num] = []
        bot_values[bot_num].append(chip_value)
        if len(bot_values[bot_num]) == 2:
            execute_instructions(bot_num)

    def execute_instructions(bot_num):
        low_value = min(bot_values[bot_num])
        high_value = max(bot_values[bot_num])
        bot_values[bot_num] = []

        low_dest_type, low_dest_num = bot_instructions[bot_num][""low""]
        high_dest_type, high_dest_num = bot_instructions[bot_num][""high""]

        if low_dest_type == ""output"":
            if low_dest_num not in output_bins:
                output_bins[low_dest_num] = []
            output_bins[low_dest_num].append(low_value)
        else:
            receive_chip(low_dest_num, low_value)

        if high_dest_type == ""output"":
            if high_dest_num not in output_bins:
                output_bins[high_dest_num] = []
            output_bins[high_dest_num].append(high_value)
        else:
            receive_chip(high_dest_num, high_value)

    for instruction in instructions:
        if instruction.startswith(""value""):
            value, bot_num = map(int, instruction.split()[1::4])
            receive_chip(bot_num, value)
        else:
            parts = instruction.split()
            bot_num = int(parts[1])
            low_dest_type = parts[5]
            low_dest_num = int(parts[6])
            high_dest_type = parts[10]
            high_dest_num = int(parts[11])

            bot_instructions[bot_num] = {
                ""low"": (low_dest_type, low_dest_num),
                ""high"": (high_dest_type, high_dest_num)
            }

    for bot_num, values in bot_values.items():
        if value1 in values and value2 in values:
            return bot_num

    return None

# Read instructions from file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Call the function to find the responsible bot
responsible_bot = find_responsible_bot(instructions, 17, 61)
print(responsible_bot)
",2.0
104,2016,10,2,part1_failed,,143153,,,
105,2016,11,1,syntax_error,,37,"  File ""/tmp/tmph_av3hd1/tmp.py"", line 1
    I will start by reading the input from the file and parsing it.
      ^
SyntaxError: invalid syntax
",I will start by reading the input from the file and parsing it.,2.0
106,2016,11,2,part1_failed,,61,,,
107,2016,12,1,no_error,"318083
",318083,,"
instructions = []

# Read the input file
with open('input.txt', 'r') as file:
    for line in file:
        instructions.append(line.strip())

# Initialize the registers
registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}

# Execute the instructions
i = 0
while i < len(instructions):
    parts = instructions[i].split()
    if parts[0] == 'cpy':
        x = parts[1]
        y = parts[2]
        if x.isdigit():
            registers[y] = int(x)
        else:
            registers[y] = registers[x]
    elif parts[0] == 'inc':
        x = parts[1]
        registers[x] += 1
    elif parts[0] == 'dec':
        x = parts[1]
        registers[x] -= 1
    elif parts[0] == 'jnz':
        x = parts[1]
        y = int(parts[2])
        if (x.isdigit() and int(x) != 0) or (x.isalpha() and registers[x] != 0):
            i += y - 1
    i += 1

# Print the value left in register 'a'
print(registers['a'])
",0.0
108,2016,12,2,no_error,"9227737
",9227737,,"
instructions = []

# Read the input file
with open('input.txt', 'r') as file:
    for line in file:
        instructions.append(line.strip())

# Initialize the registers
registers = {'a': 0, 'b': 0, 'c': 1, 'd': 0}

# Execute the instructions
i = 0
while i < len(instructions):
    parts = instructions[i].split()
    if parts[0] == 'cpy':
        x = parts[1]
        y = parts[2]
        if x.isdigit():
            registers[y] = int(x)
        else:
            registers[y] = registers[x]
    elif parts[0] == 'inc':
        x = parts[1]
        registers[x] += 1
    elif parts[0] == 'dec':
        x = parts[1]
        registers[x] -= 1
    elif parts[0] == 'jnz':
        x = parts[1]
        y = int(parts[2])
        if (x.isdigit() and int(x) != 0) or (x.isalpha() and registers[x] != 0):
            i += y - 1
    i += 1

# Print the value left in register 'a'
print(registers['a'])
",0.0
111,2016,13,1,no_error,"92
",92,,"
from collections import deque

# Read the favorite number from the input file
with open('input.txt') as f:
    favorite_number = int(f.read())

# Define the maze dimensions
target_x, target_y = 31, 39
max_x, max_y = target_x + 10, target_y + 10

# Define the directions to move in the maze
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Initialize the visited set and the queue for BFS
visited = set()
queue = deque([(1, 1, 0)])  # (x, y, steps)

# Perform breadth-first search
while queue:
    x, y, steps = queue.popleft()

    # Check if the target position has been reached
    if x == target_x and y == target_y:
        print(steps)
        break

    # Check if the current position is a wall
    if bin(x*x + 3*x + 2*x*y + y + y*y + favorite_number).count('1') % 2 == 1:
        continue

    # Explore the neighboring positions
    for dx, dy in directions:
        nx, ny = x + dx, y + dy

        # Check if the neighboring position is valid and unvisited
        if 0 <= nx < max_x and 0 <= ny < max_y and (nx, ny) not in visited:
            visited.add((nx, ny))
            queue.append((nx, ny, steps + 1))
",0.0
112,2016,13,2,no_error,"124
",124,,"
from collections import deque

# Read the favorite number from the input file
with open('input.txt') as f:
    favorite_number = int(f.read())

# Define the maze dimensions
max_x, max_y = 50, 50

# Define the directions to move in the maze
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Initialize the visited set and the queue for BFS
visited = set()
queue = deque([(1, 1, 0)])  # (x, y, steps)

# Perform breadth-first search
while queue:
    x, y, steps = queue.popleft()

    # Check if the maximum number of steps has been reached
    if steps > 50:
        break

    # Check if the current position is a wall
    if bin(x*x + 3*x + 2*x*y + y + y*y + favorite_number).count('1') % 2 == 1:
        continue

    # Add the current position to the visited set
    visited.add((x, y))

    # Explore the neighboring positions
    for dx, dy in directions:
        nx, ny = x + dx, y + dy

        # Check if the neighboring position is valid and unvisited
        if 0 <= nx < max_x and 0 <= ny < max_y and (nx, ny) not in visited:
            queue.append((nx, ny, steps + 1))

# Print the number of distinct reachable positions
print(len(visited))
",0.0
114,2016,14,1,no_error,"23890
",23890,,"
import hashlib
import re

def generate_hash(salt, index):
    data = salt + str(index)
    return hashlib.md5(data.encode()).hexdigest()

def find_64th_key(salt):
    index = 0
    keys = []
    while len(keys) < 64:
        hash_value = generate_hash(salt, index)
        match = re.search(r'(.)\1\1', hash_value)
        if match:
            character = match.group(1)
            for i in range(index + 1, index + 1001):
                next_hash_value = generate_hash(salt, i)
                if character * 5 in next_hash_value:
                    keys.append(index)
                    break
        index += 1
    return keys[63]

with open('input.txt', 'r') as file:
    salt = file.read().strip()

index = find_64th_key(salt)
print(index)
",1.0
115,2016,14,2,timeout_error,,22696,TIMEOUT,"
import hashlib
import re

def generate_hash(salt, index, stretching):
    data = salt + str(index)
    hash_value = hashlib.md5(data.encode()).hexdigest()
    for _ in range(stretching):
        hash_value = hashlib.md5(hash_value.encode()).hexdigest()
    return hash_value

def find_64th_key(salt, stretching):
    index = 0
    keys = []
    while len(keys) < 64:
        hash_value = generate_hash(salt, index, stretching)
        match = re.search(r'(.)\1\1', hash_value)
        if match:
            character = match.group(1)
            for i in range(index + 1, index + 1001):
                next_hash_value = generate_hash(salt, i, stretching)
                if character * 5 in next_hash_value:
                    keys.append(index)
                    break
        index += 1
    return keys[63]

with open('input.txt', 'r') as file:
    salt = file.read().strip()

stretching = 2016
index = find_64th_key(salt, stretching)
print(index)
",2.0
116,2016,15,1,no_error,400589,400589,,"def parse_input(input_string):
    discs = []
    for line in input_string.split('\n'):
        if line:
            parts = line.split()
            positions = int(parts[3])
            start = int(parts[-1].strip('.'))
            discs.append((positions, start))
    return discs

def capsule_falls_through(discs, time):
    for i, (positions, start) in enumerate(discs):
        if (start + time + i + 1) % positions != 0:
            return False
    return True

def find_earliest_time(discs):
    time = 0
    while True:
        if capsule_falls_through(discs, time):
            return time
        time += 1

def main():
    with open('input.txt', 'r') as f:
        input_string = f.read()

    discs = parse_input(input_string)
    earliest_time = find_earliest_time(discs)
    print(""The first time you can press the button is:"", earliest_time)

main()",1.0
117,2016,15,2,no_error,3045959,3045959,,"def parse_input(input_string):
    discs = []
    for line in input_string.split('\n'):
        if line:
            parts = line.split()
            positions = int(parts[3])
            start = int(parts[-1].strip('.'))
            discs.append((positions, start))
    return discs

def capsule_falls_through(discs, time):
    for i, (positions, start) in enumerate(discs):
        if (start + time + i + 1) % positions != 0:
            return False
    return True

def find_earliest_time(discs):
    time = 0
    while True:
        if capsule_falls_through(discs, time):
            return time
        time += 1

def main():
    with open('input.txt', 'r') as f:
        input_string = f.read()

    discs = parse_input(input_string)
    discs.append((11, 0))  # Add the new disc
    earliest_time = find_earliest_time(discs)
    print(""The first time you can press the button is:"", earliest_time)

main()",0.0
120,2016,16,1,no_error,10100011010101011,10100011010101011,,"def generate_data(initial_state, disk_length):
    data = initial_state
    while len(data) < disk_length:
        a = data
        b = a[::-1].replace('0', '2').replace('1', '0').replace('2', '1')
        data = a + '0' + b
    return data[:disk_length]

def generate_checksum(data):
    checksum = data
    while len(checksum) % 2 == 0:
        new_checksum = ''
        for i in range(0, len(checksum), 2):
            if checksum[i] == checksum[i+1]:
                new_checksum += '1'
            else:
                new_checksum += '0'
        checksum = new_checksum
    return checksum

def main():
    with open('input.txt', 'r') as file:
        initial_state = file.read().strip()
    
    disk_length = 272
    data = generate_data(initial_state, disk_length)
    checksum = generate_checksum(data)
    
    print(f""The correct checksum for the disk of length {disk_length} is: {checksum}"")

if __name__ == '__main__':
    main()",1.0
121,2016,16,2,no_error,01010001101011001,01010001101011001,,"def generate_data(initial_state, disk_length):
    data = initial_state
    while len(data) < disk_length:
        a = data
        b = a[::-1].replace('0', '2').replace('1', '0').replace('2', '1')
        data = a + '0' + b
    return data[:disk_length]

def generate_checksum(data):
    checksum = data
    while len(checksum) % 2 == 0:
        new_checksum = ''
        for i in range(0, len(checksum), 2):
            if checksum[i] == checksum[i+1]:
                new_checksum += '1'
            else:
                new_checksum += '0'
        checksum = new_checksum
    return checksum

def main():
    with open('input.txt', 'r') as file:
        initial_state = file.read().strip()
    
    disk_length = 35651584
    data = generate_data(initial_state, disk_length)
    checksum = generate_checksum(data)
    
    print(f""The correct checksum for the disk of length {disk_length} is: {checksum}"")

if __name__ == '__main__':
    main()",0.0
124,2016,17,1,no_error,"RDDRULDDRR
",RDDRULDDRR,,"
import hashlib

def calculate_hash(s):
    return hashlib.md5(s.encode()).hexdigest()

def is_door_open(hash, direction):
    return hash[direction] in 'bcdef'


from collections import deque

def shortest_path(passcode):
    start = (0, 0)  # starting position
    target = (3, 3)  # target position

    queue = deque([(start, """")])  # initialize the queue with the starting position and an empty path

    while queue:
        (x, y), path = queue.popleft()  # get the next position and path from the queue

        if (x, y) == target:
            return path  # if we reached the target position, return the path

        hash = calculate_hash(passcode + path)  # calculate the hash of the passcode + current path

        # check if each door is open and add the corresponding position and path to the queue
        if is_door_open(hash, 0) and y > 0:  # up
            queue.append(((x, y - 1), path + ""U""))
        if is_door_open(hash, 1) and y < 3:  # down
            queue.append(((x, y + 1), path + ""D""))
        if is_door_open(hash, 2) and x > 0:  # left
            queue.append(((x - 1, y), path + ""L""))
        if is_door_open(hash, 3) and x < 3:  # right
            queue.append(((x + 1, y), path + ""R""))

    return None  # if no path is found, return None


with open(""input.txt"", ""r"") as file:
    passcode = file.readline().strip()

path = shortest_path(passcode)
print(path)
",0.0
125,2016,17,2,runtime_error,,766,"Traceback (most recent call last):
  File ""/tmp/tmpnpicx49e/tmp.py"", line 36, in <module>
    length = longest_path(passcode)
  File ""/tmp/tmpnpicx49e/tmp.py"", line 18, in longest_path
    hash = calculate_hash(passcode + path)  # calculate the hash of the passcode + current path
NameError: name 'calculate_hash' is not defined
","
from collections import deque

def longest_path(passcode):
    start = (0, 0)  # starting position
    target = (3, 3)  # target position

    queue = deque([(start, """")])  # initialize the queue with the starting position and an empty path

    longest_length = 0  # initialize the longest length
    while queue:
        (x, y), path = queue.popleft()  # get the next position and path from the queue

        if (x, y) == target:
            longest_length = max(longest_length, len(path))  # update the longest length if necessary
            continue  # continue to the next iteration without adding new positions

        hash = calculate_hash(passcode + path)  # calculate the hash of the passcode + current path

        # check if each door is open and add the corresponding position and path to the queue
        if is_door_open(hash, 0) and y > 0:  # up
            queue.append(((x, y - 1), path + ""U""))
        if is_door_open(hash, 1) and y < 3:  # down
            queue.append(((x, y + 1), path + ""D""))
        if is_door_open(hash, 2) and x > 0:  # left
            queue.append(((x - 1, y), path + ""L""))
        if is_door_open(hash, 3) and x < 3:  # right
            queue.append(((x + 1, y), path + ""R""))

    return longest_length


with open(""input.txt"", ""r"") as file:
    passcode = file.readline().strip()

length = longest_path(passcode)
print(length)
",2.0
126,2016,18,1,no_error,"1913
",1913,,"
def count_safe_tiles(input_row, num_rows):
    count = input_row.count('.')
    current_row = input_row

    for _ in range(num_rows - 1):
        next_row = ''
        for i in range(len(current_row)):
            left = '.' if i == 0 else current_row[i-1]
            center = current_row[i]
            right = '.' if i == len(current_row) - 1 else current_row[i+1]

            if (left == '^' and center == '^' and right == '.') or \
               (left == '.' and center == '^' and right == '^') or \
               (left == '^' and center == '.' and right == '.') or \
               (left == '.' and center == '.' and right == '^'):
                next_row += '^'
            else:
                next_row += '.'

        count += next_row.count('.')
        current_row = next_row

    return count

# Read input
with open('input.txt') as f:
    input_row = f.read().strip()

# Calculate number of safe tiles
num_rows = 40
result = count_safe_tiles(input_row, num_rows)
print(result)
",1.0
127,2016,18,2,no_error,"19993564
",19993564,,"
def count_safe_tiles(input_row, num_rows):
    count = input_row.count('.')
    current_row = input_row

    for _ in range(num_rows - 1):
        next_row = ''
        for i in range(len(current_row)):
            left = '.' if i == 0 else current_row[i-1]
            center = current_row[i]
            right = '.' if i == len(current_row) - 1 else current_row[i+1]

            if (left == '^' and center == '^' and right == '.') or \
               (left == '.' and center == '^' and right == '^') or \
               (left == '^' and center == '.' and right == '.') or \
               (left == '.' and center == '.' and right == '^'):
                next_row += '^'
            else:
                next_row += '.'

        count += next_row.count('.')
        current_row = next_row

    return count

# Read input
with open('input.txt') as f:
    input_row = f.read().strip()

# Calculate number of safe tiles
num_rows = 400000
result = count_safe_tiles(input_row, num_rows)
print(result)
",0.0
129,2016,19,1,no_error,"1808357
",1808357,,"
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

def get_last_elf(number_of_elves):
    # Create the circular linked list
    head = Node(1)
    current = head
    for i in range(2, number_of_elves + 1):
        current.next = Node(i)
        current = current.next
    current.next = head

    # Iterate through the list, removing nodes
    current = head
    while current.next != current:
        # Find the node to remove
        node_to_remove = current.next
        current.next = node_to_remove.next

        # Move to the next node
        current = current.next

    return current.value

# Read the number of elves from input.txt
with open('input.txt', 'r') as file:
    number_of_elves = int(file.read().strip())

# Calculate the last elf
last_elf = get_last_elf(number_of_elves)
print(last_elf)
",0.0
130,2016,19,2,wrong_output,"1500665
",1407007,,"
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None
        self.prev = None

def get_last_elf(number_of_elves):
    # Create the circular linked list
    head = Node(1)
    current = head
    for i in range(2, number_of_elves + 1):
        current.next = Node(i)
        current.next.prev = current
        current = current.next
    current.next = head
    head.prev = current

    # Iterate through the list, removing nodes
    current = head
    across = current
    for _ in range(number_of_elves // 2):
        across = across.next

    while current.next != current:
        # Remove the Elf directly across the circle
        across.prev.next = across.next
        across.next.prev = across.prev

        # Move to the next Elf
        current = current.next
        across = across.next

    return current.value

# Read the number of elves from input.txt
with open('input.txt', 'r') as file:
    number_of_elves = int(file.read().strip())

# Calculate the last elf
last_elf = get_last_elf(number_of_elves)
print(last_elf)
",2.0
131,2016,20,1,no_error,32259706,32259706,,"
# Read the input file
with open('input.txt', 'r') as file:
    blocked_ips = []
    for line in file:
        start, end = map(int, line.strip().split('-'))
        blocked_ips.append((start, end))
    
# Sort the blocked IPs by their start value
blocked_ips.sort()

# Find the lowest-valued IP that is not blocked
lowest_ip = 0
for start, end in blocked_ips:
    if lowest_ip < start:
        break
    lowest_ip = max(lowest_ip, end + 1)

print(f""The lowest-valued IP that is not blocked is {lowest_ip}."")
",0.0
132,2016,20,2,no_error,113,113,,"
# Read the input file
with open('input.txt', 'r') as file:
    blocked_ips = []
    for line in file:
        start, end = map(int, line.strip().split('-'))
        blocked_ips.append((start, end))
    
# Sort the blocked IPs by their start value
blocked_ips.sort()

# Count the number of allowed IPs
allowed_ips = 0
current_ip = 0
for start, end in blocked_ips:
    if current_ip < start:
        allowed_ips += start - current_ip
    current_ip = max(current_ip, end + 1)

# Check if there are additional allowed IPs after the last blocked IP
if current_ip < 4294967295:
    allowed_ips += 4294967295 - current_ip

print(f""The number of allowed IPs by the blacklist is {allowed_ips}."")
",0.0
135,2016,21,1,no_error,"gbhafcde
",gbhafcde,,"def swap_position(password, x, y):
    password_list = list(password)
    password_list[x], password_list[y] = password_list[y], password_list[x]
    return ''.join(password_list)


def swap_letter(password, x, y):
    password_list = list(password)
    x_index = password_list.index(x)
    y_index = password_list.index(y)
    password_list[x_index], password_list[y_index] = password_list[y_index], password_list[x_index]
    return ''.join(password_list)


def rotate_left(password, steps):
    steps = steps % len(password)
    return password[steps:] + password[:steps]


def rotate_right(password, steps):
    steps = steps % len(password)
    return password[-steps:] + password[:-steps]


def rotate_based_on_position(password, x):
    x_index = password.index(x)
    steps = 1 + x_index + (1 if x_index >= 4 else 0)
    return rotate_right(password, steps)


def reverse_positions(password, x, y):
    password_list = list(password)
    password_list[x:y+1] = reversed(password_list[x:y+1])
    return ''.join(password_list)


def move_position(password, x, y):
    password_list = list(password)
    letter = password_list.pop(x)
    password_list.insert(y, letter)
    return ''.join(password_list)


def scramble_password(password, operations):
    for operation in operations:
        if operation.startswith('swap position'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = swap_position(password, x, y)
        elif operation.startswith('swap letter'):
            x = operation.split()[2]
            y = operation.split()[-1]
            password = swap_letter(password, x, y)
        elif operation.startswith('rotate left'):
            steps = int(operation.split()[-2])
            password = rotate_left(password, steps)
        elif operation.startswith('rotate right'):
            steps = int(operation.split()[-2])
            password = rotate_right(password, steps)
        elif operation.startswith('rotate based on position'):
            x = operation.split()[-1]
            password = rotate_based_on_position(password, x)
        elif operation.startswith('reverse positions'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = reverse_positions(password, x, y)
        elif operation.startswith('move position'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = move_position(password, x, y)
    return password


# Read input
with open('input.txt', 'r') as file:
    operations = [line.strip() for line in file.readlines()]

# Scramble password
password = 'abcdefgh'
scrambled_password = scramble_password(password, operations)
print(scrambled_password)",1.0
136,2016,21,2,runtime_error,,bcfaegdh,"Traceback (most recent call last):
  File ""/tmp/tmpkcyahl82/tmp.py"", line 46, in <module>
    unscrambled_password = unscramble_password(scrambled_password, operations)
  File ""/tmp/tmpkcyahl82/tmp.py"", line 16, in unscramble_password
    password = rotate_left(password, steps)
NameError: name 'rotate_left' is not defined
","def unscramble_password(password, operations):
    for operation in reversed(operations):
        if operation.startswith('swap position'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = swap_position(password, x, y)
        elif operation.startswith('swap letter'):
            x = operation.split()[2]
            y = operation.split()[-1]
            password = swap_letter(password, x, y)
        elif operation.startswith('rotate left'):
            steps = int(operation.split()[-2])
            password = rotate_right(password, steps)
        elif operation.startswith('rotate right'):
            steps = int(operation.split()[-2])
            password = rotate_left(password, steps)
        elif operation.startswith('rotate based on position'):
            x = operation.split()[-1]
            password = unrotate_based_on_position(password, x)
        elif operation.startswith('reverse positions'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = reverse_positions(password, x, y)
        elif operation.startswith('move position'):
            x = int(operation.split()[2])
            y = int(operation.split()[-1])
            password = move_position(password, y, x)
    return password


def unrotate_based_on_position(password, x):
    x_index = password.index(x)
    if x_index % 2 == 0:
        steps = (x_index // 2) + 1
    else:
        steps = (x_index // 2) + 1 + len(password) // 2
    return rotate_right(password, steps)


# Read input
with open('input.txt', 'r') as file:
    operations = [line.strip() for line in file.readlines()]

# Unscramble password
scrambled_password = 'fbgdceah'
unscrambled_password = unscramble_password(scrambled_password, operations)
print(unscrambled_password)",2.0
137,2016,22,1,no_error,"901
",901,,"# Read the input file

with open('input.txt', 'r') as file:
    input_data = file.read().splitlines()

# Parse the input data

nodes = []

for line in input_data[2:]:
    parts = line.split()
    node = {
        'x': int(parts[0].split('-')[1][1:]),
        'y': int(parts[0].split('-')[2][1:]),
        'size': int(parts[1][:-1]),
        'used': int(parts[2][:-1]),
        'avail': int(parts[3][:-1])
    }
    nodes.append(node)

# Count the number of viable pairs

viable_pairs = 0

for i in range(len(nodes)):
    for j in range(len(nodes)):
        if i != j and nodes[i]['used'] != 0 and nodes[i]['used'] <= nodes[j]['avail']:
            viable_pairs += 1

print(viable_pairs)",2.0
138,2016,22,2,wrong_output,"35
",238,,"# Read the input file

with open('input.txt', 'r') as file:
    input_data = file.read().splitlines()

# Parse the input data

nodes = []

for line in input_data[2:]:
    parts = line.split()
    node = {
        'x': int(parts[0].split('-')[1][1:]),
        'y': int(parts[0].split('-')[2][1:]),
        'size': int(parts[1][:-1]),
        'used': int(parts[2][:-1]),
        'avail': int(parts[3][:-1])
    }
    nodes.append(node)

# Find the target node

target_node = max(nodes, key=lambda node: node['x'])

# Calculate the number of steps required to move the goal data

steps = target_node['x'] + target_node['y'] - 1

print(steps)",2.0
139,2016,23,1,no_error,"12516
",12516,,"
def toggle(instruction):
    if instruction[0] == 'inc':
        instruction[0] = 'dec'
    elif instruction[0] == 'dec' or instruction[0] == 'tgl':
        instruction[0] = 'inc'
    elif instruction[0] == 'jnz':
        instruction[0] = 'cpy'
    elif instruction[0] == 'cpy':
        instruction[0] = 'jnz'

def execute_assembunny(code, registers):
    ip = 0  # instruction pointer

    while ip < len(code):
        instruction = code[ip]
        op = instruction[0]

        if op == 'cpy':
            x = instruction[1]
            y = instruction[2]
            if y.isalpha():
                registers[y] = registers[x] if x.isalpha() else int(x)
        elif op == 'inc':
            x = instruction[1]
            if x.isalpha():
                registers[x] += 1
        elif op == 'dec':
            x = instruction[1]
            if x.isalpha():
                registers[x] -= 1
        elif op == 'jnz':
            x = instruction[1]
            y = instruction[2]
            x_val = registers[x] if x.isalpha() else int(x)
            y_val = registers[y] if y.isalpha() else int(y)
            if x_val != 0:
                ip += y_val - 1
        elif op == 'tgl':
            x = instruction[1]
            x_val = registers[x] if x.isalpha() else int(x)
            toggle_ip = ip + x_val
            if toggle_ip >= 0 and toggle_ip < len(code):
                toggle(code[toggle_ip])

        ip += 1

    return registers['a']

def parse_input(input_str):
    code = []
    for line in input_str.strip().split('\n'):
        parts = line.split()
        instruction = [parts[0]]
        instruction.extend(parts[1:])
        code.append(instruction)
    return code

def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()

    code = parse_input(input_str)
    registers = {'a': 7, 'b': 0, 'c': 0, 'd': 0}
    result = execute_assembunny(code, registers)
    print(result)

if __name__ == '__main__':
    main()
",0.0
140,2016,23,2,runtime_error,,479009076,"Traceback (most recent call last):
  File ""/tmp/tmpg33lmhgk/tmp.py"", line 12, in <module>
    main()
  File ""/tmp/tmpg33lmhgk/tmp.py"", line 6, in main
    code = parse_input(input_str)
NameError: name 'parse_input' is not defined
","
def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()

    code = parse_input(input_str)
    registers = {'a': 12, 'b': 0, 'c': 0, 'd': 0}
    result = execute_assembunny(code, registers)
    print(result)

if __name__ == '__main__':
    main()
",2.0
141,2016,24,1,runtime_error,,498,"Traceback (most recent call last):
  File ""/tmp/tmptegtffiz/tmp.py"", line 22, in <module>
    start_location, locations = find_locations(map)
  File ""/tmp/tmptegtffiz/tmp.py"", line 20, in find_locations
    return start_location, locations
UnboundLocalError: local variable 'start_location' referenced before assignment
","
def read_input():
    with open('input.txt', 'r') as file:
        lines = file.readlines()
    map = [list(line.strip()) for line in lines]
    num_locations = sum([1 for row in map for cell in row if cell.isdigit()])
    return map, num_locations

map, num_locations = read_input()


def find_locations(map):
    locations = {}
    for i, row in enumerate(map):
        for j, cell in enumerate(row):
            if cell.isdigit():
                locations[cell] = (i, j)
            elif cell == '0':
                start_location = (i, j)
    return start_location, locations

start_location, locations = find_locations(map)


from collections import deque

def shortest_path(map, start_location, locations, num_locations):
    queue = deque([(start_location, 0, set())])
    visited = set()
    while queue:
        current_location, steps, visited_locations = queue.popleft()
        if len(visited_locations) == num_locations:
            return steps
        if (current_location, visited_locations) in visited:
            continue
        visited.add((current_location, visited_locations))
        for neighbor in get_neighbors(map, current_location):
            new_location, new_visited_locations = neighbor
            if new_location in visited_locations:
                continue
            new_steps = steps + 1
            new_visited_locations = visited_locations | {new_location}
            queue.append((new_location, new_steps, new_visited_locations))
    return None

def get_neighbors(map, location):
    neighbors = []
    i, j = location
    if i > 0 and map[i - 1][j] != '#':
        neighbors.append(((i - 1, j), map[i - 1][j]))
    if i < len(map) - 1 and map[i + 1][j] != '#':
        neighbors.append(((i + 1, j), map[i + 1][j]))
    if j > 0 and map[i][j - 1] != '#':
        neighbors.append(((i, j - 1), map[i][j - 1]))
    if j < len(map[0]) - 1 and map[i][j + 1] != '#':
        neighbors.append(((i, j + 1), map[i][j + 1]))
    return neighbors

steps = shortest_path(map, start_location, locations, num_locations)
print(steps)
",2.0
142,2016,24,2,part1_failed,,804,,,
143,2016,25,1,runtime_error,,196,"Traceback (most recent call last):
  File ""/tmp/tmp8_quth9w/tmp.py"", line 51, in <module>
    lowest_initial_a = find_lowest_initial_a(instructions)
  File ""/tmp/tmp8_quth9w/tmp.py"", line 44, in find_lowest_initial_a
    if run_code(instructions, initial_a):
  File ""/tmp/tmp8_quth9w/tmp.py"", line 26, in run_code
    offset = int(parts[2]) if parts[2].isdigit() else registers[parts[2]]
KeyError: '-2'
","
def is_clock_signal(signal):
    for i in range(0, len(signal), 2):
        if signal[i] != 0 or signal[i+1] != 1:
            return False
    return True

def run_code(instructions, initial_a):
    registers = {'a': initial_a, 'b': 0, 'c': 0, 'd': 0}
    pc = 0
    clock_signal = []

    while pc < len(instructions):
        instruction = instructions[pc]
        parts = instruction.split()

        if parts[0] == 'cpy':
            value = int(parts[1]) if parts[1].isdigit() else registers[parts[1]]
            registers[parts[2]] = value
        elif parts[0] == 'inc':
            registers[parts[1]] += 1
        elif parts[0] == 'dec':
            registers[parts[1]] -= 1
        elif parts[0] == 'jnz':
            value = int(parts[1]) if parts[1].isdigit() else registers[parts[1]]
            offset = int(parts[2]) if parts[2].isdigit() else registers[parts[2]]
            if value != 0:
                pc += offset - 1
        elif parts[0] == 'out':
            value = int(parts[1]) if parts[1].isdigit() else registers[parts[1]]
            clock_signal.append(value)

            if len(clock_signal) % 2 == 0:
                if not is_clock_signal(clock_signal):
                    return False

        pc += 1

    return True

def find_lowest_initial_a(instructions):
    initial_a = 1
    while True:
        if run_code(instructions, initial_a):
            return initial_a
        initial_a += 1

with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

lowest_initial_a = find_lowest_initial_a(instructions)
print(lowest_initial_a)
",2.0
144,2016,25,2,part1_failed,,,,,
145,2017,1,1,no_error,"1177
",1177,,"
def solve_captcha(captcha):
    total = 0
    length = len(captcha)

    for i, digit in enumerate(captcha):
        next_digit = captcha[(i + 1) % length]
        if digit == next_digit:
            total += int(digit)

    return total

# Read input from file
with open('input.txt', 'r') as file:
    captcha = file.read().strip()

# Solve captcha
solution = solve_captcha(captcha)
print(solution)
",0.0
146,2017,1,2,no_error,"1060
",1060,,"
def solve_captcha(captcha):
    total = 0
    length = len(captcha)

    for i, digit in enumerate(captcha):
        halfway_around = captcha[(i + length // 2) % length]
        if digit == halfway_around:
            total += int(digit)

    return total

# Read input from file
with open('input.txt', 'r') as file:
    captcha = file.read().strip()

# Solve captcha
solution = solve_captcha(captcha)
print(solution)
",0.0
149,2017,2,1,no_error,"45158
",45158,,"
checksum = 0

with open('input.txt', 'r') as file:
    for line in file:
        row = list(map(int, line.strip().split()))
        min_value = min(row)
        max_value = max(row)
        difference = max_value - min_value
        checksum += difference

print(checksum)
",0.0
150,2017,2,2,no_error,"294
",294,,"
checksum = 0

with open('input.txt', 'r') as file:
    for line in file:
        row = list(map(int, line.strip().split()))
        for i in range(len(row)):
            for j in range(len(row)):
                if i != j and row[i] % row[j] == 0:
                    checksum += row[i] // row[j]
                    break

print(checksum)
",0.0
153,2017,3,1,no_error,"438
",438,,"
def calculate_distance(square):
    # Special case for square 1
    if square == 1:
        return 0

    # Find the layer the square belongs to
    layer = 0
    while (2 * layer + 1) ** 2 < square:
        layer += 1

    # Calculate the coordinates of the square
    x = layer
    y = -layer

    current_square = (2 * layer + 1) ** 2
    direction = 'up'

    # Iterate over the layer to find the square
    while current_square != square:
        if direction == 'up':
            y += 1
            if y == layer:
                direction = 'left'
        elif direction == 'left':
            x -= 1
            if x == -layer:
                direction = 'down'
        elif direction == 'down':
            y -= 1
            if y == -layer:
                direction = 'right'
        elif direction == 'right':
            x += 1
            if x == layer + 1:
                direction = 'up'

        current_square -= 1

    # Calculate the Manhattan distance
    distance = abs(x) + abs(y)
    return distance

# Read the input from the file
with open('input.txt', 'r') as file:
    input_square = int(file.read())

# Calculate the distance for the input square
distance = calculate_distance(input_square)
print(distance)
",1.0
154,2017,3,2,wrong_output,"472077
",266330,,"
def generate_grid(target):
    grid = {(0, 0): 1}

    x = 1
    y = 0
    direction = 'right'
    sum_adjacent = 0

    while True:
        # Calculate the sum of adjacent squares
        sum_adjacent = sum(grid.get((x + dx, y + dy), 0) for dx in range(-1, 2) for dy in range(-1, 2))

        # Store the sum in the current square
        grid[(x, y)] = sum_adjacent

        # Check if the value exceeds the target
        if sum_adjacent > target:
            return sum_adjacent

        # Move to the next square
        if direction == 'right':
            x += 1
            if (x, y + 1) not in grid:
                direction = 'up'
        elif direction == 'up':
            y += 1
            if (x - 1, y) not in grid:
                direction = 'left'
        elif direction == 'left':
            x -= 1
            if (x, y - 1) not in grid:
                direction = 'down'
        elif direction == 'down':
            y -= 1
            if (x + 1, y) not in grid:
                direction = 'right'

# Read the input from the file
with open('input.txt', 'r') as file:
    input_value = int(file.read())

# Generate the grid and find the first value larger than the input
first_larger_value = generate_grid(input_value)
print(first_larger_value)
",2.0
155,2017,4,1,no_error,"383
",383,,"
def is_valid_passphrase(passphrase):
    words = passphrase.split()
    unique_words = set(words)
    return len(words) == len(unique_words)

valid_count = 0

with open('input.txt', 'r') as file:
    for line in file:
        if is_valid_passphrase(line.strip()):
            valid_count += 1

print(valid_count)
",1.0
156,2017,4,2,no_error,"265
",265,,"
def is_valid_passphrase(passphrase):
    words = passphrase.split()
    unique_words = set(''.join(sorted(word)) for word in words)
    return len(words) == len(unique_words)

valid_count = 0

with open('input.txt', 'r') as file:
    for line in file:
        if is_valid_passphrase(line.strip()):
            valid_count += 1

print(valid_count)
",0.0
159,2017,5,1,no_error,"391540
",391540,,"
# Read the input file
with open('input.txt', 'r') as file:
    jumps = [int(line.strip()) for line in file]

# Initialize variables
steps = 0
index = 0

# Jump until outside the list
while 0 <= index < len(jumps):
    jump = jumps[index]
    jumps[index] += 1
    index += jump
    steps += 1

# Print the number of steps
print(steps)
",1.0
160,2017,5,2,no_error,"30513679
",30513679,,"
# Read the input file
with open('input.txt', 'r') as file:
    jumps = [int(line.strip()) for line in file]

# Initialize variables
steps = 0
index = 0

# Jump until outside the list
while 0 <= index < len(jumps):
    jump = jumps[index]
    if jump >= 3:
        jumps[index] -= 1
    else:
        jumps[index] += 1
    index += jump
    steps += 1

# Print the number of steps
print(steps)
",0.0
163,2017,6,1,no_error,"6681
",6681,,"
def count_redistribution_cycles(blocks):
    configurations = set()
    count = 0

    while tuple(blocks) not in configurations:
        configurations.add(tuple(blocks))
        redistribute(blocks)
        count += 1

    return count

def redistribute(blocks):
    max_blocks = max(blocks)
    max_index = blocks.index(max_blocks)
    blocks[max_index] = 0

    while max_blocks > 0:
        max_index = (max_index + 1) % len(blocks)
        blocks[max_index] += 1
        max_blocks -= 1

# Read input from file
with open('input.txt', 'r') as file:
    blocks = list(map(int, file.readline().strip().split()))

# Solve the problem
result = count_redistribution_cycles(blocks)

# Print the result
print(result)
",0.0
164,2017,6,2,no_error,"2392
",2392,,"
def find_loop_size(blocks):
    configurations = {}
    count = 0

    while tuple(blocks) not in configurations:
        configurations[tuple(blocks)] = count
        redistribute(blocks)
        count += 1

    return count - configurations[tuple(blocks)]

def redistribute(blocks):
    max_blocks = max(blocks)
    max_index = blocks.index(max_blocks)
    blocks[max_index] = 0

    while max_blocks > 0:
        max_index = (max_index + 1) % len(blocks)
        blocks[max_index] += 1
        max_blocks -= 1

# Read input from file
with open('input.txt', 'r') as file:
    blocks = list(map(int, file.readline().strip().split()))

# Solve the problem
result = find_loop_size(blocks)

# Print the result
print(result)
",0.0
166,2017,7,1,no_error,"cyrupz
",cyrupz,,"
def find_bottom_program(file_name):
    programs = {}
    child_programs = set()

    with open(file_name, 'r') as file:
        for line in file:
            parts = line.strip().split()
            name = parts[0]
            weight = int(parts[1][1:-1])  # Remove parentheses
            programs[name] = weight

            if len(parts) > 2:
                for i in range(3, len(parts)):
                    child_program = parts[i].strip(',')
                    child_programs.add(child_program)

    for program in programs.keys():
        if program not in child_programs:
            return program

    return None

bottom_program = find_bottom_program('input.txt')
print(bottom_program)
",0.0
167,2017,7,2,runtime_error,,193,"Traceback (most recent call last):
  File ""/tmp/tmp4gs_py4y/tmp.py"", line 49, in <module>
    wrong_weight = find_wrong_weight('input.txt')
  File ""/tmp/tmp4gs_py4y/tmp.py"", line 45, in find_wrong_weight
    bottom_program = find_bottom_program(file_name)
NameError: name 'find_bottom_program' is not defined
","
def find_wrong_weight(file_name):
    programs = {}
    child_programs = {}

    with open(file_name, 'r') as file:
        for line in file:
            parts = line.strip().split()
            name = parts[0]
            weight = int(parts[1][1:-1])  # Remove parentheses
            programs[name] = weight

            if len(parts) > 2:
                children = []
                for i in range(3, len(parts)):
                    child_program = parts[i].strip(',')
                    children.append(child_program)
                child_programs[name] = children

    def get_tower_weight(program):
        weight = programs[program]
        if program not in child_programs:
            return weight
        else:
            return weight + sum(get_tower_weight(child) for child in child_programs[program])

    def find_unbalanced_program(program):
        children = child_programs[program]
        weights = [get_tower_weight(child) for child in children]
        if len(set(weights)) == 1:
            return None  # All sub-towers have the same weight
        else:
            wrong_weight = None
            correct_weight = None
            for i in range(len(weights)):
                if weights.count(weights[i]) == 1:
                    wrong_weight = weights[i]
                else:
                    correct_weight = weights[i]
            for i in range(len(children)):
                if get_tower_weight(children[i]) == wrong_weight:
                    return find_unbalanced_program(children[i])
            return programs[children[0]] + (correct_weight - wrong_weight)

    bottom_program = find_bottom_program(file_name)
    return find_unbalanced_program(bottom_program)


wrong_weight = find_wrong_weight('input.txt')
print(wrong_weight)
",2.0
168,2017,8,1,no_error,"4448
",4448,,"
# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

registers = {}  # Dictionary to store the register values

# Function to evaluate the condition
def evaluate_condition(register, operator, value):
    if operator == '>':
        return register > value
    elif operator == '>=':
        return register >= value
    elif operator == '<':
        return register < value
    elif operator == '<=':
        return register <= value
    elif operator == '==':
        return register == value
    elif operator == '!=':
        return register != value

# Process the instructions
for instruction in instructions:
    parts = instruction.split()
    register = parts[0]  # Register to modify
    operation = parts[1]  # Operation: inc or dec
    amount = int(parts[2])  # Amount to modify
    condition_register = parts[4]  # Register in the condition
    condition_operator = parts[5]  # Operator in the condition
    condition_value = int(parts[6])  # Value in the condition

    # Initialize the register if it doesn't exist
    if register not in registers:
        registers[register] = 0

    # Initialize the condition register if it doesn't exist
    if condition_register not in registers:
        registers[condition_register] = 0

    # Evaluate the condition and modify the register if the condition is true
    if evaluate_condition(registers[condition_register], condition_operator, condition_value):
        if operation == 'inc':
            registers[register] += amount
        elif operation == 'dec':
            registers[register] -= amount

# Find the largest value in any register
max_value = max(registers.values())

print(max_value)
",0.0
169,2017,8,2,no_error,"6582
",6582,,"
# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

registers = {}  # Dictionary to store the register values
max_value = 0  # Variable to store the highest value held in any register

# Function to evaluate the condition
def evaluate_condition(register, operator, value):
    if operator == '>':
        return register > value
    elif operator == '>=':
        return register >= value
    elif operator == '<':
        return register < value
    elif operator == '<=':
        return register <= value
    elif operator == '==':
        return register == value
    elif operator == '!=':
        return register != value

# Process the instructions
for instruction in instructions:
    parts = instruction.split()
    register = parts[0]  # Register to modify
    operation = parts[1]  # Operation: inc or dec
    amount = int(parts[2])  # Amount to modify
    condition_register = parts[4]  # Register in the condition
    condition_operator = parts[5]  # Operator in the condition
    condition_value = int(parts[6])  # Value in the condition

    # Initialize the register if it doesn't exist
    if register not in registers:
        registers[register] = 0

    # Initialize the condition register if it doesn't exist
    if condition_register not in registers:
        registers[condition_register] = 0

    # Evaluate the condition and modify the register if the condition is true
    if evaluate_condition(registers[condition_register], condition_operator, condition_value):
        if operation == 'inc':
            registers[register] += amount
        elif operation == 'dec':
            registers[register] -= amount

        # Update the maximum value
        if registers[register] > max_value:
            max_value = registers[register]

print(max_value)
",0.0
171,2017,9,1,no_error,"7640
",7640,,"def calculate_score(stream):
    score = 0
    total_score = 0
    garbage = False
    ignore_next = False

    for char in stream:
        if ignore_next:
            ignore_next = False
            continue

        if char == '!':
            ignore_next = True
            continue

        if garbage:
            if char == '>':
                garbage = False
            continue

        if char == '{':
            score += 1
            total_score += score
        elif char == '}':
            score -= 1
        elif char == '<':
            garbage = True

    return total_score


with open('input.txt', 'r') as file:
    stream = file.read().strip()

score = calculate_score(stream)
print(score)",2.0
172,2017,9,2,no_error,"4368
",4368,,"def count_garbage_characters(stream):
    count = 0
    garbage = False
    ignore_next = False

    for char in stream:
        if ignore_next:
            ignore_next = False
            continue

        if char == '!':
            ignore_next = True
            continue

        if garbage:
            if char != '>':
                count += 1
            else:
                garbage = False
            continue

        if char == '<':
            garbage = True

    return count


with open('input.txt', 'r') as file:
    stream = file.read().strip()

count = count_garbage_characters(stream)
print(count)",0.0
175,2017,10,1,no_error,"46600
",46600,,"
def knot_hash(lengths):
    # Initialize the list with numbers from 0 to 255
    numbers = list(range(256))
    # Initialize current position and skip size
    current_position = 0
    skip_size = 0

    # Perform the knotting process for each length
    for length in lengths:
        # Get the sublist to be reversed
        sublist = []
        for i in range(length):
            sublist.append(numbers[(current_position + i) % 256])

        # Reverse the sublist
        sublist.reverse()

        # Update the numbers list with the reversed sublist
        for i in range(length):
            numbers[(current_position + i) % 256] = sublist[i]

        # Update current position and skip size
        current_position = (current_position + length + skip_size) % 256
        skip_size += 1

    # Multiply the first two numbers in the list
    result = numbers[0] * numbers[1]

    return result

# Read the input lengths from a file
with open('input.txt', 'r') as file:
    lengths = list(map(int, file.readline().strip().split(',')))

# Calculate the result
result = knot_hash(lengths)
print(result)
",0.0
176,2017,10,2,no_error,"23234babdc6afa036749cfa9b597de1b
",23234babdc6afa036749cfa9b597de1b,,"
def knot_hash(lengths):
    # Initialize the list with numbers from 0 to 255
    numbers = list(range(256))
    # Initialize current position and skip size
    current_position = 0
    skip_size = 0

    # Convert the lengths to ASCII codes
    lengths = [ord(char) for char in lengths]
    # Add the standard length suffix values
    lengths += [17, 31, 73, 47, 23]

    # Perform 64 rounds
    for _ in range(64):
        # Perform the knotting process for each length
        for length in lengths:
            # Get the sublist to be reversed
            sublist = []
            for i in range(length):
                sublist.append(numbers[(current_position + i) % 256])

            # Reverse the sublist
            sublist.reverse()

            # Update the numbers list with the reversed sublist
            for i in range(length):
                numbers[(current_position + i) % 256] = sublist[i]

            # Update current position and skip size
            current_position = (current_position + length + skip_size) % 256
            skip_size += 1

    # Calculate the dense hash
    dense_hash = []
    for i in range(0, 256, 16):
        block = numbers[i:i+16]
        xor_result = 0
        for num in block:
            xor_result ^= num
        dense_hash.append(xor_result)

    # Convert the dense hash to a hexadecimal string
    knot_hash = ''.join(format(num, '02x') for num in dense_hash)

    return knot_hash

# Read the input from a file
with open('input.txt', 'r') as file:
    input_str = file.readline().strip()

# Calculate the Knot Hash
result = knot_hash(input_str)
print(result)
",0.0
179,2017,11,1,no_error,"696
",696,,"
def fewest_steps(path):
    # Initialize the coordinate of the child process
    x = 0
    y = 0
    z = 0
    
    # Define the movement vectors for each direction
    directions = {
        'n': (0, 1, -1),
        'ne': (1, 0, -1),
        'se': (1, -1, 0),
        's': (0, -1, 1),
        'sw': (-1, 0, 1),
        'nw': (-1, 1, 0)
    }
    
    # Split the path into individual directions
    steps = path.split(',')
    
    # Iterate through each step in the path
    for step in steps:
        # Update the coordinates based on the movement vector
        dx, dy, dz = directions[step]
        x += dx
        y += dy
        z += dz
    
    # Calculate the fewest number of steps required to reach the child process
    return max(abs(x), abs(y), abs(z))

# Read the input from the file
with open('input.txt', 'r') as file:
    path = file.read().strip()

# Calculate the fewest number of steps required to reach the child process
result = fewest_steps(path)

# Print the result
print(result)
",1.0
180,2017,11,2,no_error,"1461
",1461,,"
def furthest_steps(path):
    # Initialize the coordinate of the child process
    x = 0
    y = 0
    z = 0
    
    # Define the movement vectors for each direction
    directions = {
        'n': (0, 1, -1),
        'ne': (1, 0, -1),
        'se': (1, -1, 0),
        's': (0, -1, 1),
        'sw': (-1, 0, 1),
        'nw': (-1, 1, 0)
    }
    
    # Split the path into individual directions
    steps = path.split(',')
    
    # Initialize the furthest distance from the starting position
    furthest_distance = 0
    
    # Iterate through each step in the path
    for step in steps:
        # Update the coordinates based on the movement vector
        dx, dy, dz = directions[step]
        x += dx
        y += dy
        z += dz
        
        # Calculate the distance from the starting position
        distance = max(abs(x), abs(y), abs(z))
        
        # Update the furthest distance if necessary
        if distance > furthest_distance:
            furthest_distance = distance
    
    # Return the furthest distance
    return furthest_distance

# Read the input from the file
with open('input.txt', 'r') as file:
    path = file.read().strip()

# Calculate the furthest distance the child process ever got from the starting position
result = furthest_steps(path)

# Print the result
print(result)
",0.0
183,2017,12,1,no_error,"288
",288,,"
def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Create a dictionary to represent the graph
graph = {}
for line in lines:
    parts = line.strip().split('<->')
    node = int(parts[0].strip())
    neighbors = [int(x.strip()) for x in parts[1].split(',')]
    graph[node] = neighbors

# Perform DFS to find all the programs connected to program ID 0
visited = set()
dfs(graph, 0, visited)

# Print the number of programs in the group
print(len(visited))
",2.0
184,2017,12,2,no_error,"211
",211,,"
def dfs(graph, node, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Create a dictionary to represent the graph
graph = {}
for line in lines:
    parts = line.strip().split('<->')
    node = int(parts[0].strip())
    neighbors = [int(x.strip()) for x in parts[1].split(',')]
    graph[node] = neighbors

# Perform DFS on each program to find all the groups
visited = set()
groups = 0
for node in graph:
    if node not in visited:
        dfs(graph, node, visited)
        groups += 1

# Print the total number of groups
print(groups)
",0.0
187,2017,13,1,no_error,"1624
",1624,,"
def calculate_severity(firewall):
    severity = 0
    for depth, range in firewall.items():
        if depth % ((range - 1) * 2) == 0:
            severity += depth * range
    return severity

firewall = {}
with open('input.txt', 'r') as file:
    for line in file:
        depth, range = map(int, line.strip().split(': '))
        firewall[depth] = range

trip_severity = calculate_severity(firewall)
print(trip_severity)
",0.0
188,2017,13,2,no_error,"3923436
",3923436,,"
def is_caught(firewall, delay):
    for depth, range in firewall.items():
        if (depth + delay) % ((range - 1) * 2) == 0:
            return True
    return False

def find_min_delay(firewall):
    delay = 0
    while True:
        if not is_caught(firewall, delay):
            return delay
        delay += 1

firewall = {}
with open('input.txt', 'r') as file:
    for line in file:
        depth, range = map(int, line.strip().split(': '))
        firewall[depth] = range

min_delay = find_min_delay(firewall)
print(min_delay)
",0.0
191,2017,14,1,no_error,"8148
",8148,,"
from functools import reduce
from operator import xor

def knot_hash(input_string):
    lengths = [ord(c) for c in input_string] + [17, 31, 73, 47, 23]
    numbers = list(range(256))
    current_position = 0
    skip_size = 0
    
    for _ in range(64):
        for length in lengths:
            sublist = []
            for i in range(current_position, current_position + length):
                sublist.append(numbers[i % len(numbers)])
            sublist.reverse()
            for i in range(current_position, current_position + length):
                numbers[i % len(numbers)] = sublist.pop(0)
            current_position += length + skip_size
            skip_size += 1
    
    dense_hash = []
    for i in range(0, 256, 16):
        block = numbers[i:i+16]
        dense_hash.append(reduce(xor, block))
    
    knot_hash = ''.join(format(num, '02x') for num in dense_hash)
    return knot_hash


def count_used_squares(key_string):
    count = 0
    for row in range(128):
        row_key = f""{key_string}-{row}""
        knot_hash_value = knot_hash(row_key)
        binary_representation = bin(int(knot_hash_value, 16))[2:].zfill(128)
        count += binary_representation.count('1')
    return count


with open('input.txt') as file:
    key_string = file.read().strip()

used_squares = count_used_squares(key_string)
print(used_squares)
",1.0
192,2017,14,2,runtime_error,,1180,"Traceback (most recent call last):
  File ""/tmp/tmpj2513m__/tmp.py"", line 49, in <module>
    region_count = count_regions(key_string)
  File ""/tmp/tmpj2513m__/tmp.py"", line 31, in count_regions
    grid = get_grid(key_string)
  File ""/tmp/tmpj2513m__/tmp.py"", line 6, in get_grid
    knot_hash_value = knot_hash(row_key)
NameError: name 'knot_hash' is not defined
","
def get_grid(key_string):
    grid = []
    for row in range(128):
        row_key = f""{key_string}-{row}""
        knot_hash_value = knot_hash(row_key)
        binary_representation = bin(int(knot_hash_value, 16))[2:].zfill(128)
        grid.append([int(bit) for bit in binary_representation])
    return grid


def explore_region(grid, visited, row, col):
    rows = len(grid)
    cols = len(grid[0])

    if row < 0 or row >= rows or col < 0 or col >= cols:
        return

    if visited[row][col] or grid[row][col] == 0:
        return

    visited[row][col] = True

    explore_region(grid, visited, row - 1, col)
    explore_region(grid, visited, row + 1, col)
    explore_region(grid, visited, row, col - 1)
    explore_region(grid, visited, row, col + 1)


def count_regions(key_string):
    grid = get_grid(key_string)
    rows = len(grid)
    cols = len(grid[0])
    visited = [[False] * cols for _ in range(rows)]
    count = 0

    for row in range(rows):
        for col in range(cols):
            if not visited[row][col] and grid[row][col] == 1:
                count += 1
                explore_region(grid, visited, row, col)

    return count


with open('input.txt') as file:
    key_string = file.read().strip()

region_count = count_regions(key_string)
print(region_count)
",2.0
193,2017,15,1,no_error,"650
",650,,"
def generator(start, factor):
    value = start
    while True:
        value = (value * factor) % 2147483647
        yield value

with open('input.txt', 'r') as file:
    start_a = int(file.readline().strip().split()[-1])
    start_b = int(file.readline().strip().split()[-1])

factor_a = 16807
factor_b = 48271
pairs = 40000000
mask = (1 << 16) - 1
count = 0

gen_a = generator(start_a, factor_a)
gen_b = generator(start_b, factor_b)

for _ in range(pairs):
    value_a = next(gen_a)
    value_b = next(gen_b)
    if (value_a & mask) == (value_b & mask):
        count += 1

print(count)
",0.0
194,2017,15,2,no_error,"336
",336,,"
def generator(start, factor, criteria):
    value = start
    while True:
        value = (value * factor) % 2147483647
        if value % criteria == 0:
            yield value

with open('input.txt', 'r') as file:
    start_a = int(file.readline().strip().split()[-1])
    start_b = int(file.readline().strip().split()[-1])

factor_a = 16807
factor_b = 48271
pairs = 5000000
mask = (1 << 16) - 1
count = 0

gen_a = generator(start_a, factor_a, 4)
gen_b = generator(start_b, factor_b, 8)

for _ in range(pairs):
    value_a = next(gen_a)
    value_b = next(gen_b)
    if (value_a & mask) == (value_b & mask):
        count += 1

print(count)
",0.0
197,2017,16,1,no_error,"nlciboghjmfdapek
",nlciboghjmfdapek,,"
with open('input.txt') as f:
    dance_moves = f.read().strip().split(',')

programs = list('abcdefghijklmnop')

for move in dance_moves:
    if move[0] == 's':
        X = int(move[1:])
        programs = programs[-X:] + programs[:-X]
    elif move[0] == 'x':
        A, B = map(int, move[1:].split('/'))
        programs[A], programs[B] = programs[B], programs[A]
    elif move[0] == 'p':
        A, B = move[1:].split('/')
        A_pos = programs.index(A)
        B_pos = programs.index(B)
        programs[A_pos], programs[B_pos] = programs[B_pos], programs[A_pos]

print(''.join(programs))
",1.0
198,2017,16,2,wrong_output,"nmcihpaoegkbfjld
",nlciboghmkedpfja,,"
with open('input.txt') as f:
    dance_moves = f.read().strip().split(',')

programs = list('abcdefghijklmnop')

# Perform the dance moves until a repeated state is found
states = {}
repeat_found = False
for dance_number in range(1, 1000000001):
    for move in dance_moves:
        if move[0] == 's':
            X = int(move[1:])
            programs = programs[-X:] + programs[:-X]
        elif move[0] == 'x':
            A, B = map(int, move[1:].split('/'))
            programs[A], programs[B] = programs[B], programs[A]
        elif move[0] == 'p':
            A, B = move[1:].split('/')
            A_pos = programs.index(A)
            B_pos = programs.index(B)
            programs[A_pos], programs[B_pos] = programs[B_pos], programs[A_pos]

    state = ''.join(programs)
    if state in states:
        repeat_found = True
        break
    states[state] = dance_number

# Calculate the number of remaining dances after the repetitions
remaining_dances = 1000000000 % (dance_number - 1)

# Perform the remaining dances
for _ in range(remaining_dances):
    for move in dance_moves:
        if move[0] == 's':
            X = int(move[1:])
            programs = programs[-X:] + programs[:-X]
        elif move[0] == 'x':
            A, B = map(int, move[1:].split('/'))
            programs[A], programs[B] = programs[B], programs[A]
        elif move[0] == 'p':
            A, B = move[1:].split('/')
            A_pos = programs.index(A)
            B_pos = programs.index(B)
            programs[A_pos], programs[B_pos] = programs[B_pos], programs[A_pos]

print(''.join(programs))
",2.0
199,2017,17,1,no_error,"640
",640,,"
def spinlock(steps):
    buffer = [0]
    position = 0

    for i in range(1, 2018):
        position = (position + steps) % len(buffer) + 1
        buffer.insert(position, i)

    return buffer[buffer.index(2017) + 1]

with open('input.txt', 'r') as f:
    steps = int(f.read())

result = spinlock(steps)
print(result)
",0.0
200,2017,17,2,no_error,"47949463
",47949463,,"
def spinlock_value_after_zero(steps, iterations):
    buffer_len = 1
    position = 0
    value_after_zero = None

    for i in range(1, iterations + 1):
        position = (position + steps) % buffer_len + 1
        if position == 1:
            value_after_zero = i
        buffer_len += 1

    return value_after_zero

with open('input.txt', 'r') as f:
    steps = int(f.read())

result = spinlock_value_after_zero(steps, 50000000)
print(result)
",0.0
203,2017,18,1,no_error,"4601
",4601,,"
def execute_instructions(instructions):
    registers = {}
    last_sound_frequency = None
    index = 0

    def get_value(x):
        if x.isalpha():
            return registers.get(x, 0)
        else:
            return int(x)

    while 0 <= index < len(instructions):
        instruction = instructions[index].split()

        if instruction[0] == 'snd':
            last_sound_frequency = get_value(instruction[1])
        elif instruction[0] == 'set':
            registers[instruction[1]] = get_value(instruction[2])
        elif instruction[0] == 'add':
            registers[instruction[1]] = get_value(instruction[1]) + get_value(instruction[2])
        elif instruction[0] == 'mul':
            registers[instruction[1]] = get_value(instruction[1]) * get_value(instruction[2])
        elif instruction[0] == 'mod':
            registers[instruction[1]] = get_value(instruction[1]) % get_value(instruction[2])
        elif instruction[0] == 'rcv':
            if get_value(instruction[1]) != 0:
                return last_sound_frequency
        elif instruction[0] == 'jgz':
            if get_value(instruction[1]) > 0:
                index += get_value(instruction[2])
                continue

        index += 1

    return None

if __name__ == '__main__':
    with open('input.txt', 'r') as file:
        instructions = file.read().strip().split('\n')

    recovered_frequency = execute_instructions(instructions)
    print(recovered_frequency)
",0.0
204,2017,18,2,no_error,"6858
",6858,,"
class Program:
    def __init__(self, program_id):
        self.registers = {'p': program_id}
        self.index = 0
        self.message_queue = []
        self.send_counter = 0

    def get_value(self, x):
        if x.isalpha():
            return self.registers.get(x, 0)
        else:
            return int(x)

    def execute_instructions(self, instructions, partner):
        def send_value(value):
            partner.message_queue.append(value)

        def receive_value(register):
            if len(self.message_queue) > 0:
                self.registers[register] = self.message_queue.pop(0)
                return True
            else:
                return False

        while 0 <= self.index < len(instructions):
            instruction = instructions[self.index].split()

            if instruction[0] == 'snd':
                send_value(self.get_value(instruction[1]))
                self.send_counter += 1
            elif instruction[0] == 'set':
                self.registers[instruction[1]] = self.get_value(instruction[2])
            elif instruction[0] == 'add':
                self.registers[instruction[1]] = self.get_value(instruction[1]) + self.get_value(instruction[2])
            elif instruction[0] == 'mul':
                self.registers[instruction[1]] = self.get_value(instruction[1]) * self.get_value(instruction[2])
            elif instruction[0] == 'mod':
                self.registers[instruction[1]] = self.get_value(instruction[1]) % self.get_value(instruction[2])
            elif instruction[0] == 'rcv':
                if not receive_value(instruction[1]):
                    return
            elif instruction[0] == 'jgz':
                if self.get_value(instruction[1]) > 0:
                    self.index += self.get_value(instruction[2])
                    continue

            self.index += 1


def run_concurrent_programs(instructions):
    program_0 = Program(0)
    program_1 = Program(1)

    while True:
        program_0.execute_instructions(instructions, program_1)
        program_1.execute_instructions(instructions, program_0)

        if len(program_0.message_queue) == 0 and len(program_1.message_queue) == 0:
            break

    return program_1.send_counter


if __name__ == '__main__':
    with open('input.txt', 'r') as file:
        instructions = file.read().strip().split('\n')

    send_count = run_concurrent_programs(instructions)
    print(send_count)
",2.0
205,2017,19,1,wrong_output,,GSXDIPWTU,,"def get_path_letters():
    # Read the input file
    with open('input.txt', 'r') as file:
        diagram = [line.strip('\n') for line in file.readlines()]

    # Find the starting position
    start = (0, diagram[0].index('|'))

    # Initialize variables
    direction = 'down'
    current_pos = start
    path_letters = ''
    done = False

    # Function to check if a position is within the diagram boundaries
    def is_valid_position(pos):
        return 0 <= pos[0] < len(diagram) and 0 <= pos[1] < len(diagram[pos[0]])

    # Function to get the next position based on the current position and direction
    def get_next_position(pos, direction):
        if direction == 'up':
            return (pos[0] - 1, pos[1])
        elif direction == 'down':
            return (pos[0] + 1, pos[1])
        elif direction == 'left':
            return (pos[0], pos[1] - 1)
        elif direction == 'right':
            return (pos[0], pos[1] + 1)

    # Function to get the new direction based on the current position and direction
    def get_new_direction(pos, direction):
        if direction in ['up', 'down']:
            if is_valid_position((pos[0], pos[1] - 1)) and diagram[pos[0]][pos[1] - 1] != ' ':
                return 'left'
            elif is_valid_position((pos[0], pos[1] + 1)) and diagram[pos[0]][pos[1] + 1] != ' ':
                return 'right'
        elif direction in ['left', 'right']:
            if is_valid_position((pos[0] - 1, pos[1])) and diagram[pos[0] - 1][pos[1]] != ' ':
                return 'up'
            elif is_valid_position((pos[0] + 1, pos[1])) and diagram[pos[0] + 1][pos[1]] != ' ':
                return 'down'

        return direction

    # Follow the path until reaching the end
    while not done:
        current_pos = get_next_position(current_pos, direction)

        if is_valid_position(current_pos):
            current_char = diagram[current_pos[0]][current_pos[1]]

            if current_char == '+':
                direction = get_new_direction(current_pos, direction)
            elif current_char.isalpha():
                path_letters += current_char
            elif current_char == ' ':
                done = True
        else:
            done = True

    return path_letters",2.0
206,2017,19,2,part1_failed,,16100,,,
207,2017,20,1,no_error,344,344,,"
def simulate_particles(particles, steps):
    for _ in range(steps):
        for particle in particles:
            particle['v'][0] += particle['a'][0]
            particle['v'][1] += particle['a'][1]
            particle['v'][2] += particle['a'][2]
            particle['p'][0] += particle['v'][0]
            particle['p'][1] += particle['v'][1]
            particle['p'][2] += particle['v'][2]

def manhattan_distance(particle):
    return sum(abs(coord) for coord in particle['p'])

def find_closest_particle(particles):
    closest_particle = None
    min_distance = float('inf')

    for i, particle in enumerate(particles):
        distance = manhattan_distance(particle)
        if distance < min_distance:
            closest_particle = i
            min_distance = distance

    return closest_particle

def parse_input(input_str):
    particles = []
    for line in input_str.strip().split('\n'):
        p, v, a = line.split(', ')
        p = [int(x) for x in p[3:-1].split(',')]
        v = [int(x) for x in v[3:-1].split(',')]
        a = [int(x) for x in a[3:-1].split(',')]
        particles.append({'p': p, 'v': v, 'a': a})
    return particles

def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()
    
    particles = parse_input(input_str)
    simulate_particles(particles, steps=1000)
    closest_particle = find_closest_particle(particles)
    
    print(f""The particle that will stay closest to position <0,0,0> is particle {closest_particle}"")

if __name__ == '__main__':
    main()
",0.0
208,2017,20,2,no_error,404,404,,"
def simulate_particles(particles, steps):
    for _ in range(steps):
        positions = {}
        for i, particle in enumerate(particles):
            particle['v'][0] += particle['a'][0]
            particle['v'][1] += particle['a'][1]
            particle['v'][2] += particle['a'][2]
            particle['p'][0] += particle['v'][0]
            particle['p'][1] += particle['v'][1]
            particle['p'][2] += particle['v'][2]
            
            position = tuple(particle['p'])
            if position in positions:
                positions[position].append(i)
            else:
                positions[position] = [i]
        
        collided_particles = []
        for position, particle_indices in positions.items():
            if len(particle_indices) > 1:
                collided_particles.extend(particle_indices)
        
        for index in sorted(collided_particles, reverse=True):
            del particles[index]

def parse_input(input_str):
    particles = []
    for line in input_str.strip().split('\n'):
        p, v, a = line.split(', ')
        p = [int(x) for x in p[3:-1].split(',')]
        v = [int(x) for x in v[3:-1].split(',')]
        a = [int(x) for x in a[3:-1].split(',')]
        particles.append({'p': p, 'v': v, 'a': a})
    return particles

def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()
    
    particles = parse_input(input_str)
    simulate_particles(particles, steps=1000)
    
    remaining_particles = len(particles)
    print(f""The number of particles left after all collisions are resolved is {remaining_particles}"")

if __name__ == '__main__':
    main()
",2.0
209,2017,21,1,runtime_error,,179,"Traceback (most recent call last):
  File ""/tmp/tmp5l8rlx6c/tmp.py"", line 55, in <module>
    result = count_pixels_on(num_iterations, initial_pattern, enhancement_rules)
  File ""/tmp/tmp5l8rlx6c/tmp.py"", line 41, in count_pixels_on
    pattern = enhance_pattern(pattern, rules)
  File ""/tmp/tmp5l8rlx6c/tmp.py"", line 32, in enhance_pattern
    enhanced_subpatterns.append(rules[subpattern])
KeyError: '.#.'
","
def parse_input(input_string):
    rules = {}
    for line in input_string.strip().split('\n'):
        pattern, result = line.split(' => ')
        rules[pattern] = result
    return rules


def split_pattern(pattern, size):
    subpatterns = []
    rows = pattern.split('/')
    for i in range(0, len(rows), size):
        subpattern = []
        for j in range(0, len(rows), size):
            subpattern.append('/'.join(rows[i:i+size])[j:j+size])
        subpatterns.append('/'.join(subpattern))
    return subpatterns


def join_subpatterns(subpatterns):
    rows = []
    for i in range(0, len(subpatterns), len(subpatterns[0].split('/'))):
        rows.extend(subpatterns[i].split('/'))
    return '/'.join(rows)


def enhance_pattern(pattern, rules):
    subpatterns = split_pattern(pattern, 2 if len(pattern.split('/')) % 2 == 0 else 3)
    enhanced_subpatterns = []
    for subpattern in subpatterns:
        enhanced_subpatterns.append(rules[subpattern])
    enhanced_pattern = join_subpatterns(enhanced_subpatterns)
    return enhanced_pattern


def count_pixels_on(iterations, input_pattern, input_rules):
    pattern = input_pattern
    rules = input_rules
    for _ in range(iterations):
        pattern = enhance_pattern(pattern, rules)
    return pattern.count('#')


input_string = '''../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#'''

initial_pattern = '''.#.
..#
###'''

enhancement_rules = parse_input(input_string)

num_iterations = 5
result = count_pixels_on(num_iterations, initial_pattern, enhancement_rules)
print(result)
",2.0
210,2017,21,2,part1_failed,,2766750,,,
211,2017,22,1,runtime_error,,5280,"Traceback (most recent call last):
  File ""/tmp/tmpiu3yiegq/tmp.py"", line 51, in <module>
    num_infections = simulate_bursts(num_bursts)
  File ""/tmp/tmpiu3yiegq/tmp.py"", line 42, in simulate_bursts
    turn()
  File ""/tmp/tmpiu3yiegq/tmp.py"", line 20, in turn
    if grid[y][x] == 1:
IndexError: list index out of range
","
grid = []
with open('input.txt') as f:
    for line in f:
        row = []
        for char in line.strip():
            if char == '#':
                row.append(1)
            else:
                row.append(0)
        grid.append(row)

x = 0
y = 0
direction = 0


def turn():
    global direction
    if grid[y][x] == 1:
        direction = (direction + 1) % 4
    else:
        direction = (direction - 1) % 4


def move():
    global x, y
    if direction == 0:
        y -= 1
    elif direction == 1:
        x += 1
    elif direction == 2:
        y += 1
    elif direction == 3:
        x -= 1


def simulate_bursts(num_bursts):
    global x, y
    num_infections = 0
    for _ in range(num_bursts):
        turn()
        if grid[y][x] == 0:
            num_infections += 1
        grid[y][x] = 1 - grid[y][x]  # toggle the current node
        move()
    return num_infections


num_bursts = 10000
num_infections = simulate_bursts(num_bursts)
print(num_infections)
",2.0
212,2017,22,2,part1_failed,,2512261,,,
213,2017,23,1,no_error,"6724
",6724,,"
def parse_instructions(filename):
    with open(filename, 'r') as file:
        instructions = []
        for line in file:
            opcode, arg1, arg2 = line.strip().split()
            instructions.append((opcode, arg1, arg2))
    return instructions

def execute_program(instructions):
    registers = {chr(i): 0 for i in range(ord('a'), ord('h')+1)}
    pc = 0
    mul_count = 0

    def get_value(arg):
        if arg.isalpha():
            return registers[arg]
        return int(arg)

    while pc >= 0 and pc < len(instructions):
        opcode, arg1, arg2 = instructions[pc]
        if opcode == 'set':
            registers[arg1] = get_value(arg2)
        elif opcode == 'sub':
            registers[arg1] -= get_value(arg2)
        elif opcode == 'mul':
            registers[arg1] *= get_value(arg2)
            mul_count += 1
        elif opcode == 'jnz':
            if get_value(arg1) != 0:
                pc += get_value(arg2) - 1
        pc += 1

    return mul_count

instructions = parse_instructions('input.txt')
mul_count = execute_program(instructions)
print(mul_count)
",1.0
214,2017,23,2,runtime_error,,903,"Traceback (most recent call last):
  File ""/tmp/tmphv4xmsr7/tmp.py"", line 4, in <module>
    if a != 0:
NameError: name 'a' is not defined
","
b = 93
c = b
if a != 0:
    b = b * 100 + 100000
    c = b + 17000


while True:
    f = 1
    d = 2
    while d != b:
        e = 2
        while e != b:
            if d * e == b:
                f = 0
            e += 1
        d += 1
    if f == 0:
        h += 1
    if b == c:
        break
    b += 17


def is_prime(n):
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    for i in range(3, int(n ** 0.5) + 1, 2):
        if n % i == 0:
            return False
    return True

a = 1
b = 93 * 100 + 100000
c = b + 17000
h = 0

for i in range(b, c + 1, 17):
    if not is_prime(i):
        h += 1

print(h)
",2.0
215,2017,24,1,no_error,"2006
",2006,,"
def find_strongest_bridge(components, current_port, current_strength):
    # Find all components that can be connected to the current port
    compatible_components = [comp for comp in components if current_port in comp]

    # Base case: no compatible components found, return current strength
    if not compatible_components:
        return current_strength

    # Recursive step: try connecting each compatible component and calculate the strength
    strengths = []
    for comp in compatible_components:
        # Determine the other port in the component
        other_port = comp[0] if comp[1] == current_port else comp[1]
        # Remove the component from the list to avoid reusing it
        remaining_components = [c for c in components if c != comp]
        # Recursively find the strength of the bridge with the connected component
        strength = find_strongest_bridge(remaining_components, other_port, current_strength + sum(comp))
        strengths.append(strength)

    # Return the maximum strength among all possible bridges
    return max(strengths)


# Read input from file
with open('input.txt', 'r') as file:
    components = [tuple(map(int, line.strip().split('/'))) for line in file]

# Find the strength of the strongest bridge
strongest_bridge_strength = find_strongest_bridge(components, 0, 0)
print(strongest_bridge_strength)
",1.0
216,2017,24,2,no_error,"1994
",1994,,"
def find_longest_bridge(components, current_port, current_length, current_strength):
    # Find all components that can be connected to the current port
    compatible_components = [comp for comp in components if current_port in comp]

    # Base case: no compatible components found, return current length and strength
    if not compatible_components:
        return current_length, current_strength

    # Recursive step: try connecting each compatible component and calculate the length and strength
    longest_bridge_length = 0
    strongest_bridge_strength = 0
    for comp in compatible_components:
        # Determine the other port in the component
        other_port = comp[0] if comp[1] == current_port else comp[1]
        # Remove the component from the list to avoid reusing it
        remaining_components = [c for c in components if c != comp]
        # Recursively find the length and strength of the bridge with the connected component
        length, strength = find_longest_bridge(remaining_components, other_port, current_length + 1, current_strength + sum(comp))
        # Update the longest bridge if necessary
        if length > longest_bridge_length or (length == longest_bridge_length and strength > strongest_bridge_strength):
            longest_bridge_length = length
            strongest_bridge_strength = strength

    # Return the longest bridge length and strongest bridge strength
    return longest_bridge_length, strongest_bridge_strength


# Read input from file
with open('input.txt', 'r') as file:
    components = [tuple(map(int, line.strip().split('/'))) for line in file]

# Find the longest bridge with the strongest strength
longest_bridge_length, strongest_bridge_strength = find_longest_bridge(components, 0, 0, 0)
print(strongest_bridge_strength)
",0.0
218,2017,25,1,no_error,"2846
",2846,,"
def parse_blueprint(input_file):
    with open(input_file, 'r') as file:
        lines = file.readlines()
    
    # Extract the initial state
    initial_state = lines[0].strip().split()[-1][0]
    
    # Extract the number of steps for the diagnostic checksum
    checksum_steps = int(lines[1].strip().split()[-2])
    
    # Parse the state rules
    state_rules = {}
    i = 3  # Start from line 3 to skip the empty line after each state rule
    while i < len(lines):
        state = lines[i].strip().split()[-1][0]
        state_rules[state] = {}
        
        # Parse the rules for the current state
        for j in range(i + 1, i + 9, 4):
            value = int(lines[j].strip().split()[-1][0])
            
            # Parse the actions for the current value
            write_value = int(lines[j+1].strip().split()[-1][0])
            move_direction = 1 if lines[j+2].strip().split()[-1] == 'right.' else -1
            next_state = lines[j+3].strip().split()[-1][0]
            
            state_rules[state][value] = (write_value, move_direction, next_state)
        
        i += 10
    
    return initial_state, checksum_steps, state_rules

initial_state, checksum_steps, state_rules = parse_blueprint('input.txt')


def simulate_turing_machine(initial_state, checksum_steps, state_rules):
    tape = {0: 0}  # Start with a tape containing 0 repeated infinitely
    cursor = 0
    current_state = initial_state
    
    for _ in range(checksum_steps):
        # Get the current value under the cursor
        current_value = tape.get(cursor, 0)
        
        # Apply the state rules for the current value and state
        write_value, move_direction, next_state = state_rules[current_state][current_value]
        
        # Write the new value at the current position
        tape[cursor] = write_value
        
        # Move the cursor to the new position
        cursor += move_direction
        
        # Update the current state
        current_state = next_state
    
    # Count the number of times 1 appears on the tape
    checksum = sum(value == 1 for value in tape.values())
    
    return checksum

checksum = simulate_turing_machine(initial_state, checksum_steps, state_rules)
print(checksum)
",2.0
219,2018,1,1,no_error,"490
",490,,"# Read input from file
with open('input.txt', 'r') as file:
    frequency_changes = file.read().splitlines()

# Calculate resulting frequency
resulting_frequency = 0
for change in frequency_changes:
    resulting_frequency += int(change)

print(resulting_frequency)",0.0
220,2018,1,2,no_error,"70357
",70357,,"# Read input from file
with open('input.txt', 'r') as file:
    frequency_changes = file.read().splitlines()

# Calculate the first frequency reached twice
current_frequency = 0
reached_frequencies = set([current_frequency])
found_duplicate = False

while not found_duplicate:
    for change in frequency_changes:
        current_frequency += int(change)
        if current_frequency in reached_frequencies:
            found_duplicate = True
            break
        reached_frequencies.add(current_frequency)

print(current_frequency)",0.0
223,2018,2,1,no_error,"7163
",7163,,"def calculate_checksum(box_ids):
    count_two = 0
    count_three = 0

    for box_id in box_ids:
        char_count = {}
        for char in box_id:
            char_count[char] = char_count.get(char, 0) + 1

        if 2 in char_count.values():
            count_two += 1
        if 3 in char_count.values():
            count_three += 1

    checksum = count_two * count_three
    return checksum

def read_input():
    with open('input.txt', 'r') as file:
        box_ids = file.read().splitlines()
    return box_ids

box_ids = read_input()
checksum = calculate_checksum(box_ids)
print(checksum)",0.0
224,2018,2,2,no_error,"ighfbyijnoumxjlxevacpwqtr
",ighfbyijnoumxjlxevacpwqtr,,"def find_common_letters(box_ids):
    for i in range(len(box_ids)):
        for j in range(i + 1, len(box_ids)):
            diff_count = 0
            common_letters = []

            for k in range(len(box_ids[i])):
                if box_ids[i][k] != box_ids[j][k]:
                    diff_count += 1
                else:
                    common_letters.append(box_ids[i][k])

                if diff_count > 1:
                    break

            if diff_count == 1:
                return ''.join(common_letters)

    return None

def read_input():
    with open('input.txt', 'r') as file:
        box_ids = file.read().splitlines()
    return box_ids

box_ids = read_input()
common_letters = find_common_letters(box_ids)
print(common_letters)",0.0
227,2018,3,1,no_error,"109716
",109716,,"def parse_claim(claim):
    claim_parts = claim.split()
    claim_id = int(claim_parts[0][1:])
    left_edge, top_edge = map(int, claim_parts[2][:-1].split(','))
    width, height = map(int, claim_parts[3].split('x'))
    return claim_id, left_edge, top_edge, width, height


def mark_claimed_fabric(fabric, claim):
    claim_id, left_edge, top_edge, width, height = claim
    for i in range(left_edge, left_edge + width):
        for j in range(top_edge, top_edge + height):
            fabric[i][j] += 1


def count_overlapping_inches(fabric):
    count = 0
    for i in range(len(fabric)):
        for j in range(len(fabric[0])):
            if fabric[i][j] >= 2:
                count += 1
    return count


def main():
    fabric_size = 1000
    fabric = [[0] * fabric_size for _ in range(fabric_size)]

    with open('input.txt') as file:
        claims = [parse_claim(line.strip()) for line in file]

    for claim in claims:
        mark_claimed_fabric(fabric, claim)

    overlapping_inches = count_overlapping_inches(fabric)
    print(overlapping_inches)


if __name__ == '__main__':
    main()",0.0
228,2018,3,2,no_error,"124
",124,,"def parse_claim(claim):
    claim_parts = claim.split()
    claim_id = int(claim_parts[0][1:])
    left_edge, top_edge = map(int, claim_parts[2][:-1].split(','))
    width, height = map(int, claim_parts[3].split('x'))
    return claim_id, left_edge, top_edge, width, height


def mark_claimed_fabric(fabric, claim):
    claim_id, left_edge, top_edge, width, height = claim
    for i in range(left_edge, left_edge + width):
        for j in range(top_edge, top_edge + height):
            fabric[i][j].append(claim_id)


def find_non_overlapping_claim(fabric, claims):
    for claim in claims:
        claim_id, left_edge, top_edge, width, height = claim
        is_overlapping = False
        for i in range(left_edge, left_edge + width):
            for j in range(top_edge, top_edge + height):
                if len(fabric[i][j]) > 1:
                    is_overlapping = True
                    break
            if is_overlapping:
                break
        if not is_overlapping:
            return claim_id


def main():
    fabric_size = 1000
    fabric = [[[] for _ in range(fabric_size)] for _ in range(fabric_size)]

    with open('input.txt') as file:
        claims = [parse_claim(line.strip()) for line in file]

    for claim in claims:
        mark_claimed_fabric(fabric, claim)

    non_overlapping_claim = find_non_overlapping_claim(fabric, claims)
    print(non_overlapping_claim)


if __name__ == '__main__':
    main()",2.0
229,2018,4,1,no_error,"73646
",73646,,"
from datetime import datetime

def parse_records(records):
    parsed_records = []
    for record in records:
        timestamp_str, event = record.split('] ')
        timestamp = datetime.strptime(timestamp_str[1:], '%Y-%m-%d %H:%M')
        parsed_records.append((timestamp, event))
    return parsed_records


def sort_records(records):
    return sorted(records, key=lambda x: x[0])


def calculate_sleep_times(records):
    sleep_times = {}
    current_guard = None
    sleep_start = None

    for timestamp, event in records:
        if 'Guard' in event:
            current_guard = int(event.split()[1][1:])
            if current_guard not in sleep_times:
                sleep_times[current_guard] = [0] * 60
        elif 'falls asleep' in event:
            sleep_start = timestamp.minute
        elif 'wakes up' in event:
            sleep_end = timestamp.minute
            for minute in range(sleep_start, sleep_end):
                sleep_times[current_guard][minute] += 1

    return sleep_times


def find_most_asleep_guard(sleep_times):
    most_asleep_guard = None
    most_asleep_minute = None
    max_sleep_time = 0

    for guard, sleep_pattern in sleep_times.items():
        total_sleep_time = sum(sleep_pattern)
        if total_sleep_time > max_sleep_time:
            max_sleep_time = total_sleep_time
            most_asleep_guard = guard
            most_asleep_minute = sleep_pattern.index(max(sleep_pattern))

    return most_asleep_guard, most_asleep_minute


with open('input.txt', 'r') as file:
    records = file.read().splitlines()

parsed_records = parse_records(records)
sorted_records = sort_records(parsed_records)
sleep_times = calculate_sleep_times(sorted_records)
most_asleep_guard, most_asleep_minute = find_most_asleep_guard(sleep_times)

result = most_asleep_guard * most_asleep_minute
print(result)
",0.0
230,2018,4,2,runtime_error,,4727,"Traceback (most recent call last):
  File ""/tmp/tmpey9ye96e/tmp.py"", line 17, in <module>
    most_frequently_asleep_guard, most_frequently_asleep_minute = find_most_frequently_asleep_guard(sleep_times)
NameError: name 'sleep_times' is not defined
","
def find_most_frequently_asleep_guard(sleep_times):
    most_frequently_asleep_guard = None
    most_frequently_asleep_minute = None
    max_frequency = 0

    for guard, sleep_pattern in sleep_times.items():
        max_minute_count = max(sleep_pattern)
        if max_minute_count > max_frequency:
            max_frequency = max_minute_count
            most_frequently_asleep_guard = guard
            most_frequently_asleep_minute = sleep_pattern.index(max_minute_count)

    return most_frequently_asleep_guard, most_frequently_asleep_minute


most_frequently_asleep_guard, most_frequently_asleep_minute = find_most_frequently_asleep_guard(sleep_times)

result = most_frequently_asleep_guard * most_frequently_asleep_minute
print(result)
",2.0
231,2018,5,1,no_error,9686,9686,,"
def react_polymer(polymer):
    stack = []
    for unit in polymer:
        if stack and unit != stack[-1] and unit.lower() == stack[-1].lower():
            stack.pop()
        else:
            stack.append(unit)
    return stack

# Read the polymer from input.txt
with open('input.txt', 'r') as file:
    polymer = file.read().strip()

# React the polymer
reacted_polymer = react_polymer(polymer)

# Calculate the number of remaining units
remaining_units = len(reacted_polymer)

print(""Number of remaining units:"", remaining_units)
",1.0
232,2018,5,2,no_error,5524,5524,,"
def react_polymer(polymer):
    stack = []
    for unit in polymer:
        if stack and unit != stack[-1] and unit.lower() == stack[-1].lower():
            stack.pop()
        else:
            stack.append(unit)
    return stack

def remove_unit_type(polymer, unit_type):
    return polymer.replace(unit_type, '').replace(unit_type.upper(), '')

# Read the polymer from input.txt
with open('input.txt', 'r') as file:
    polymer = file.read().strip()

# Set the initial minimum length to a large value
min_length = float('inf')

# Iterate through each unit type
for unit_type in set(polymer.lower()):
    # Remove all instances of the unit type from the polymer
    modified_polymer = remove_unit_type(polymer, unit_type)
    # React the modified polymer
    reacted_polymer = react_polymer(modified_polymer)
    # Calculate the length of the reacted polymer
    length = len(reacted_polymer)
    # Update the minimum length if necessary
    if length < min_length:
        min_length = length

print(""Length of the shortest polymer:"", min_length)
",0.0
235,2018,6,1,syntax_error,,3909,"  File ""/tmp/tmpce4kwq7e/tmp.py"", line 1
    To solve this problem, we'll follow these steps:
       ^
SyntaxError: invalid syntax
","To solve this problem, we'll follow these steps:

1. Read the coordinates from the input file.
2. Find the minimum and maximum x and y coordinates to define the grid boundaries.
3. Create a grid of cells covering the entire area between the minimum and maximum coordinates.
4. For each cell in the grid, calculate the Manhattan distance to all coordinates and determine the closest one.
5. Count the number of cells closest to each coordinate.
6. Ignore coordinates with infinite areas by checking if they have cells on the grid boundaries.
7. Find the coordinate with the largest finite area.
8. Return the size of the largest finite area.

Let's implement this solution in code:",2.0
236,2018,6,2,part1_failed,,36238,,,
237,2018,7,1,no_error,"GKRVWBESYAMZDPTIUCFXQJLHNO
",GKRVWBESYAMZDPTIUCFXQJLHNO,,"
def parse_instructions(instructions):
    graph = {}
    for line in instructions:
        words = line.split()
        step, requirement = words[1], words[7]
        if step not in graph:
            graph[step] = set()
        if requirement not in graph:
            graph[requirement] = set()
        graph[requirement].add(step)
    return graph

def topological_sort(graph):
    order = []
    while graph:
        available_steps = [step for step in graph if not graph[step]]
        next_step = min(available_steps)
        order.append(next_step)
        del graph[next_step]
        for step in graph:
            graph[step].discard(next_step)
    return order

with open('input.txt', 'r') as file:
    instructions = file.read().strip().split('\n')

graph = parse_instructions(instructions)
order = topological_sort(graph)
result = ''.join(order)
print(result)
",1.0
238,2018,7,2,no_error,"903
",903,,"
def parse_instructions(instructions):
    graph = {}
    for line in instructions:
        words = line.split()
        step, requirement = words[1], words[7]
        if step not in graph:
            graph[step] = set()
        if requirement not in graph:
            graph[requirement] = set()
        graph[requirement].add(step)
    return graph

def calculate_step_duration(step):
    return ord(step) - ord('A') + 1

def calculate_total_time(graph, num_workers):
    order = []
    in_progress = {}
    time = 0

    while graph or in_progress:
        available_steps = [step for step in graph if not graph[step] and step not in in_progress]
        available_steps.sort()

        for i in range(min(num_workers, len(available_steps))):
            step = available_steps[i]
            in_progress[step] = calculate_step_duration(step) + 60

        if not in_progress:
            break

        min_time = min(in_progress.values())
        time += min_time

        for step in list(in_progress.keys()):
            in_progress[step] -= min_time
            if in_progress[step] == 0:
                order.append(step)
                del in_progress[step]
                del graph[step]
                for remaining_step in graph:
                    graph[remaining_step].discard(step)

    return time

with open('input.txt', 'r') as file:
    instructions = file.read().strip().split('\n')

graph = parse_instructions(instructions)
num_workers = 5
total_time = calculate_total_time(graph, num_workers)
print(total_time)
",0.0
240,2018,8,1,no_error,"47244
",47244,,"
class Node:
    def __init__(self, children, metadata):
        self.children = children
        self.metadata = metadata

def parse_input(input_str):
    numbers = list(map(int, input_str.strip().split()))
    return parse_tree(numbers)

def parse_tree(numbers):
    num_children = numbers.pop(0)
    num_metadata = numbers.pop(0)
    children = []
    metadata = []

    for _ in range(num_children):
        child = parse_tree(numbers)
        children.append(child)
    
    for _ in range(num_metadata):
        metadata.append(numbers.pop(0))
    
    return Node(children, metadata)

def sum_metadata(node):
    total_sum = sum(node.metadata)
    for child in node.children:
        total_sum += sum_metadata(child)
    return total_sum

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

# Parse input and calculate sum of metadata
root_node = parse_input(input_str)
metadata_sum = sum_metadata(root_node)
print(metadata_sum)
",1.0
241,2018,8,2,no_error,"17267
",17267,,"
class Node:
    def __init__(self, children, metadata):
        self.children = children
        self.metadata = metadata

def parse_input(input_str):
    numbers = list(map(int, input_str.strip().split()))
    return parse_tree(numbers)

def parse_tree(numbers):
    num_children = numbers.pop(0)
    num_metadata = numbers.pop(0)
    children = []
    metadata = []

    for _ in range(num_children):
        child = parse_tree(numbers)
        children.append(child)
    
    for _ in range(num_metadata):
        metadata.append(numbers.pop(0))
    
    return Node(children, metadata)

def calculate_value(node):
    if len(node.children) == 0:
        return sum(node.metadata)
    
    value = 0
    for entry in node.metadata:
        if entry > 0 and entry <= len(node.children):
            value += calculate_value(node.children[entry - 1])
    
    return value

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

# Parse input and calculate value of root node
root_node = parse_input(input_str)
root_value = calculate_value(root_node)
print(root_value)
",0.0
244,2018,9,1,no_error,"384288
",384288,,"
def play_marble_game(num_players, last_marble):
    circle = [0]  # Initialize the circle with the first marble
    current_marble_index = 0  # Index of the current marble in the circle
    scores = {player: 0 for player in range(num_players)}  # Initialize scores

    for marble in range(1, last_marble + 1):
        player = marble % num_players  # Determine the current player

        if marble % 23 == 0:
            scores[player] += marble  # Add current marble to player's score
            remove_index = (current_marble_index - 7) % len(circle)
            scores[player] += circle.pop(remove_index)  # Remove marble and add to score
            current_marble_index = remove_index
        else:
            insert_index = (current_marble_index + 2) % len(circle)
            circle.insert(insert_index, marble)  # Insert marble into the circle
            current_marble_index = insert_index

    return max(scores.values())  # Return the highest score


# Read input from file
with open('input.txt', 'r') as file:
    input_data = file.readline().split()
    num_players = int(input_data[0])
    last_marble = int(input_data[6])

# Solve the game and print the winning score
winning_score = play_marble_game(num_players, last_marble)
print(winning_score)
",2.0
245,2018,9,2,timeout_error,,3189426841,TIMEOUT,"
def play_marble_game(num_players, last_marble):
    circle = [0]  # Initialize the circle with the first marble
    current_marble_index = 0  # Index of the current marble in the circle
    scores = {player: 0 for player in range(num_players)}  # Initialize scores

    for marble in range(1, last_marble + 1):
        player = marble % num_players  # Determine the current player

        if marble % 23 == 0:
            scores[player] += marble  # Add current marble to player's score
            remove_index = (current_marble_index - 7) % len(circle)
            scores[player] += circle.pop(remove_index)  # Remove marble and add to score
            current_marble_index = remove_index
        else:
            insert_index = (current_marble_index + 2) % len(circle)
            circle.insert(insert_index, marble)  # Insert marble into the circle
            current_marble_index = insert_index

    return max(scores.values())  # Return the highest score


# Read input from file
with open('input.txt', 'r') as file:
    input_data = file.readline().split()
    num_players = int(input_data[0])
    last_marble = int(input_data[6]) * 100  # Multiply last_marble by 100

# Solve the game and print the winning score
winning_score = play_marble_game(num_players, last_marble)
print(winning_score)
",2.0
246,2018,10,1,syntax_error,,GFNKCGGH,"  File ""/tmp/tmprj0s878g/tmp.py"", line 1
    To solve this problem, we need to simulate the movement of the points in the sky until they align to form a message. We can start by parsing the input and storing the positions and velocities of the points in a list.
       ^
SyntaxError: invalid syntax
","To solve this problem, we need to simulate the movement of the points in the sky until they align to form a message. We can start by parsing the input and storing the positions and velocities of the points in a list.

Then, we can simulate the movement of the points by iterating over a range of seconds. In each iteration, we update the positions of the points by adding their velocities. After each iteration, we check if the points are aligned by calculating the range of x and y coordinates. If the range is small enough, we assume that the points have formed a message.

Finally, we can print the message formed by the points.

Here's the code to solve the problem:",2.0
247,2018,10,2,part1_failed,,10274,,,
248,2018,11,1,syntax_error,,"235,63","  File ""/tmp/tmp_heiwfi1/tmp.py"", line 1
    To solve this problem, we can iterate through each possible 3x3 square in the grid and calculate its total power. We will keep track of the square with the largest total power and return its top-left coordinate.
       ^
SyntaxError: invalid syntax
","To solve this problem, we can iterate through each possible 3x3 square in the grid and calculate its total power. We will keep track of the square with the largest total power and return its top-left coordinate.

First, we need to read the input from the file 'input.txt' and convert it into a grid of fuel cells.",2.0
249,2018,11,2,part1_failed,,"229,251,16",,,
250,2018,12,1,syntax_error,,4110,"  File ""/tmp/tmpkv1y5hc6/tmp.py"", line 1
    To solve this task, we need to simulate the growth of plants for 20 generations. We'll start by parsing the input and representing the state of the pots as a string.
       ^
SyntaxError: invalid syntax
","To solve this task, we need to simulate the growth of plants for 20 generations. We'll start by parsing the input and representing the state of the pots as a string.

Here's the step-by-step plan to solve the task:

1. Read the input from the file.
2. Extract the initial state from the input.
3. Extract the rules for plant growth from the input.
4. Simulate the growth of plants for 20 generations:
   - Add padding to the state to handle growth near the edges.
   - Apply the rules to determine the next generation state.
   - Update the current state with the next generation state.
5. Calculate the sum of the numbers of all pots which contain a plant.

Let's write the code to solve the task:",2.0
251,2018,12,2,part1_failed,,2650000000466,,,
252,2018,13,1,syntax_error,,"79,128","  File ""/tmp/tmp1z2709r5/tmp.py"", line 3
    To begin with, we need to parse the input and represent it in a data structure that we can easily work with.
       ^
SyntaxError: invalid syntax
","# Parsing the Input

To begin with, we need to parse the input and represent it in a data structure that we can easily work with.

Let's start by reading the input file and storing each line as a separate string in a list.",2.0
253,2018,13,2,part1_failed,,"3,42",,,
254,2018,14,1,no_error,9411137133,9411137133,,"
with open('input.txt', 'r') as f:
    num_recipes = int(f.readline())


scoreboard = [3, 7]
elf1_pos = 0
elf2_pos = 1


while len(scoreboard) < num_recipes + 10:
    # Combine the current recipes to create new recipes
    new_recipe_scores = [int(digit) for digit in str(scoreboard[elf1_pos] + scoreboard[elf2_pos])]
    scoreboard.extend(new_recipe_scores)

    # Move the Elves to their new positions
    elf1_pos = (elf1_pos + scoreboard[elf1_pos] + 1) % len(scoreboard)
    elf2_pos = (elf2_pos + scoreboard[elf2_pos] + 1) % len(scoreboard)


result = ''.join(str(score) for score in scoreboard[num_recipes:num_recipes + 10])
print(result)


with open('input.txt', 'r') as f:
    num_recipes = int(f.readline())

scoreboard = [3, 7]
elf1_pos = 0
elf2_pos = 1

while len(scoreboard) < num_recipes + 10:
    new_recipe_scores = [int(digit) for digit in str(scoreboard[elf1_pos] + scoreboard[elf2_pos])]
    scoreboard.extend(new_recipe_scores)

    elf1_pos = (elf1_pos + scoreboard[elf1_pos] + 1) % len(scoreboard)
    elf2_pos = (elf2_pos + scoreboard[elf2_pos] + 1) % len(scoreboard)

result = ''.join(str(score) for score in scoreboard[num_recipes:num_recipes + 10])
print(result)
",1.0
255,2018,14,2,no_error,20317612,20317612,,"
with open('input.txt', 'r') as f:
    score_sequence = f.readline().strip()


scoreboard = '37'
elf1_pos = 0
elf2_pos = 1


while score_sequence not in scoreboard[-(len(score_sequence) + 1):]:
    # Combine the current recipes to create new recipes
    new_recipe_scores = str(int(scoreboard[elf1_pos]) + int(scoreboard[elf2_pos]))
    scoreboard += new_recipe_scores

    # Move the Elves to their new positions
    elf1_pos = (elf1_pos + int(scoreboard[elf1_pos]) + 1) % len(scoreboard)
    elf2_pos = (elf2_pos + int(scoreboard[elf2_pos]) + 1) % len(scoreboard)


result = len(scoreboard) - len(score_sequence) - 1
print(result)


with open('input.txt', 'r') as f:
    score_sequence = f.readline().strip()

scoreboard = '37'
elf1_pos = 0
elf2_pos = 1

while score_sequence not in scoreboard[-(len(score_sequence) + 1):]:
    new_recipe_scores = str(int(scoreboard[elf1_pos]) + int(scoreboard[elf2_pos]))
    scoreboard += new_recipe_scores

    elf1_pos = (elf1_pos + int(scoreboard[elf1_pos]) + 1) % len(scoreboard)
    elf2_pos = (elf2_pos + int(scoreboard[elf2_pos]) + 1) % len(scoreboard)

result = len(scoreboard) - len(score_sequence) - 1
print(result)
",1.0
257,2018,15,1,wrong_output,"218366
",201638,,"
from collections import deque

class Unit:
    def __init__(self, unit_type, position, hit_points=200, attack_power=3):
        self.type = unit_type
        self.position = position
        self.hit_points = hit_points
        self.attack_power = attack_power

def parse_input(filename):
    units = []
    map = []
    with open(filename, 'r') as file:
        for y, line in enumerate(file):
            line = line.strip()
            map.append(list(line))
            for x, char in enumerate(line):
                if char == 'E':
                    units.append(Unit('elf', (x, y)))
                elif char == 'G':
                    units.append(Unit('goblin', (x, y)))
    return map, units

def get_adjacent_squares(position):
    x, y = position
    return [(x, y-1), (x-1, y), (x+1, y), (x, y+1)]

def find_targets(map, units, unit_type):
    return [unit for unit in units if unit.type == unit_type]

def is_in_range(position, targets):
    for target in targets:
        if position in get_adjacent_squares(target.position):
            return True
    return False

def get_open_squares(map, units):
    open_squares = set()
    for unit in units:
        for square in get_adjacent_squares(unit.position):
            if map[square[1]][square[0]] == '.':
                open_squares.add(square)
    return open_squares

def find_nearest_square(map, start, targets):
    queue = deque([(start, 0, None)])
    visited = set([start])
    nearest_squares = []
    while queue:
        position, distance, prev = queue.popleft()
        if position in targets:
            nearest_squares.append((position, distance, prev))
        for adjacent in get_adjacent_squares(position):
            if map[adjacent[1]][adjacent[0]] == '.' and adjacent not in visited:
                queue.append((adjacent, distance + 1, prev or adjacent))
                visited.add(adjacent)
    nearest_squares.sort()
    if nearest_squares:
        return nearest_squares[0][2]
    return None

def move_unit(map, unit, targets):
    open_squares = get_open_squares(map, targets)
    nearest_square = find_nearest_square(map, unit.position, open_squares)
    if nearest_square is not None:
        map[unit.position[1]][unit.position[0]] = '.'
        map[nearest_square[1]][nearest_square[0]] = unit.type[0].upper()
        unit.position = nearest_square

def attack_unit(map, unit, targets):
    adjacent_squares = get_adjacent_squares(unit.position)
    adjacent_targets = [target for target in targets if target.position in adjacent_squares]
    if adjacent_targets:
        target = min(adjacent_targets, key=lambda t: (t.hit_points, t.position))
        target.hit_points -= unit.attack_power
        if target.hit_points <= 0:
            map[target.position[1]][target.position[0]] = '.'

def simulate_combat(map, units):
    rounds = 0
    while True:
        units.sort(key=lambda u: u.position)
        for unit in units[:]:
            targets = find_targets(map, units, 'goblin' if unit.type == 'elf' else 'elf')
            if not targets:
                return rounds * sum(unit.hit_points for unit in units)
            if not is_in_range(unit.position, targets):
                move_unit(map, unit, targets)
            attack_unit(map, unit, targets)
            units = [u for u in units if u.hit_points > 0]
        rounds += 1

map, units = parse_input('input.txt')
outcome = simulate_combat(map, units)
print(outcome)
",2.0
258,2018,15,2,part1_failed,,95764,,,
259,2018,16,1,no_error,"642
",642,,"
import re

def addr(registers, A, B, C):
    registers[C] = registers[A] + registers[B]

def addi(registers, A, B, C):
    registers[C] = registers[A] + B

def mulr(registers, A, B, C):
    registers[C] = registers[A] * registers[B]

def muli(registers, A, B, C):
    registers[C] = registers[A] * B

def banr(registers, A, B, C):
    registers[C] = registers[A] & registers[B]

def bani(registers, A, B, C):
    registers[C] = registers[A] & B

def borr(registers, A, B, C):
    registers[C] = registers[A] | registers[B]

def bori(registers, A, B, C):
    registers[C] = registers[A] | B

def setr(registers, A, B, C):
    registers[C] = registers[A]

def seti(registers, A, B, C):
    registers[C] = A

def gtir(registers, A, B, C):
    registers[C] = 1 if A > registers[B] else 0

def gtri(registers, A, B, C):
    registers[C] = 1 if registers[A] > B else 0

def gtrr(registers, A, B, C):
    registers[C] = 1 if registers[A] > registers[B] else 0

def eqir(registers, A, B, C):
    registers[C] = 1 if A == registers[B] else 0

def eqri(registers, A, B, C):
    registers[C] = 1 if registers[A] == B else 0

def eqrr(registers, A, B, C):
    registers[C] = 1 if registers[A] == registers[B] else 0

def parse_sample(sample):
    match = re.match(r'Before: \[(\d+), (\d+), (\d+), (\d+)\]\n(\d+) (\d+) (\d+) (\d+)\nAfter:  \[(\d+), (\d+), (\d+), (\d+)\]', sample)
    before = [int(match.group(1)), int(match.group(2)), int(match.group(3)), int(match.group(4))]
    opcode = [int(match.group(5)), int(match.group(6)), int(match.group(7)), int(match.group(8))]
    after = [int(match.group(9)), int(match.group(10)), int(match.group(11)), int(match.group(12))]
    return before, opcode, after

def possible_opcodes(sample):
    before, opcode, after = sample
    possible = []
    for op in [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]:
        registers = before[:]
        op(registers, *opcode[1:])
        if registers == after:
            possible.append(op)
    return opcode[0], possible

def part1(samples):
    count = 0
    for sample in samples:
        opcode, possible = possible_opcodes(sample)
        if len(possible) >= 3:
            count += 1
    return count

with open('input.txt', 'r') as f:
    input_str = f.read()

samples_str, _ = input_str.split('\n\n\n\n')
samples = [parse_sample(sample) for sample in samples_str.strip().split('\n\n')]
result = part1(samples)
print(result)
",2.0
260,2018,16,2,runtime_error,,481,"Traceback (most recent call last):
  File ""/tmp/tmpd69dkgl1/tmp.py"", line 31, in <module>
    program_str = input_str.split('\n\n\n\n')[1].strip()
NameError: name 'input_str' is not defined
","
def parse_program(program):
    return [list(map(int, line.split())) for line in program.strip().split('\n')]

def execute_program(program, opcode_mapping):
    registers = [0, 0, 0, 0]
    for opcode, A, B, C in program:
        opcode_func = opcode_mapping[opcode]
        opcode_func(registers, A, B, C)
    return registers[0]

def determine_opcode_mapping(samples):
    opcode_mapping = {}
    possible_opcodes = {i: set() for i in range(16)}
    for sample in samples:
        opcode, possible = possible_opcodes(sample)
        possible_opcodes[opcode].update(possible)
    while len(opcode_mapping) < 16:
        for opcode, possible in possible_opcodes.items():
            if len(possible) == 1:
                opcode_func = possible.pop()
                opcode_mapping[opcode] = opcode_func
                for possible_set in possible_opcodes.values():
                    possible_set.discard(opcode_func)
    return opcode_mapping

def part2(samples, program):
    opcode_mapping = determine_opcode_mapping(samples)
    return execute_program(program, opcode_mapping)

program_str = input_str.split('\n\n\n\n')[1].strip()
program = parse_program(program_str)
result = part2(samples, program)
print(result)
",2.0
261,2018,17,1,wrong_output,"35
35
",31788,,"
with open('input.txt', 'r') as file:
    lines = file.readlines()

clay = set()
min_y = float('inf')
max_y = float('-inf')
max_x = float('-inf')

for line in lines:
    parts = line.strip().split(', ')
    fixed = int(parts[0][2:])
    range_parts = parts[1][2:].split('..')
    start = int(range_parts[0])
    end = int(range_parts[1])

    if parts[0][0] == 'x':
        for y in range(start, end + 1):
            clay.add((fixed, y))
            min_y = min(min_y, y)
            max_y = max(max_y, y)
            max_x = max(max_x, fixed)
    else:
        for x in range(start, end + 1):
            clay.add((x, fixed))
            min_y = min(min_y, fixed)
            max_y = max(max_y, fixed)
            max_x = max(max_x, x)

grid = [['.' for _ in range(max_x + 3)] for _ in range(max_y + 1)]
for (x, y) in clay:
    grid[y][x] = '#'


def flow_water(x, y):
    if grid[y][x] in '#~':
        return

    if grid[y][x] == '.':
        grid[y][x] = '|'

    if y + 1 >= len(grid):
        return

    if grid[y + 1][x] == '.':
        flow_water(x, y + 1)

    if grid[y + 1][x] in '#~':
        left_x = x - 1
        while grid[y][left_x] == '.':
            grid[y][left_x] = '|'
            if grid[y + 1][left_x] == '.':
                flow_water(left_x, y + 1)
                break
            left_x -= 1

        right_x = x + 1
        while grid[y][right_x] == '.':
            grid[y][right_x] = '|'
            if grid[y + 1][right_x] == '.':
                flow_water(right_x, y + 1)
                break
            right_x += 1

        if all(grid[y][left_x] in '#~' for left_x in range(left_x + 1, right_x)) and \
                all(grid[y][right_x] in '#~' for right_x in range(right_x + 1, x)):
            for fill_x in range(left_x + 1, right_x):
                grid[y][fill_x] = '~'
            flow_water(x, y - 1)


flow_water(500, 0)

count = sum(1 for row in grid[min_y:max_y + 1] for tile in row if tile in '|~')
print(count)


with open('input.txt', 'r') as file:
    lines = file.readlines()

clay = set()
min_y = float('inf')
max_y = float('-inf')
max_x = float('-inf')

for line in lines:
    parts = line.strip().split(', ')
    fixed = int(parts[0][2:])
    range_parts = parts[1][2:].split('..')
    start = int(range_parts[0])
    end = int(range_parts[1])

    if parts[0][0] == 'x':
        for y in range(start, end + 1):
            clay.add((fixed, y))
            min_y = min(min_y, y)
            max_y = max(max_y, y)
            max_x = max(max_x, fixed)
    else:
        for x in range(start, end + 1):
            clay.add((x, fixed))
            min_y = min(min_y, fixed)
            max_y = max(max_y, fixed)
            max_x = max(max_x, x)

grid = [['.' for _ in range(max_x + 3)] for _ in range(max_y + 1)]
for (x, y) in clay:
    grid[y][x] = '#'


def flow_water(x, y):
    if grid[y][x] in '#~':
        return

    if grid[y][x] == '.':
        grid[y][x] = '|'

    if y + 1 >= len(grid):
        return

    if grid[y + 1][x] == '.':
        flow_water(x, y + 1)

    if grid[y + 1][x] in '#~':
        left_x = x - 1
        while grid[y][left_x] == '.':
            grid[y][left_x] = '|'
            if grid[y + 1][left_x] == '.':
                flow_water(left_x, y + 1)
                break
            left_x -= 1

        right_x = x + 1
        while grid[y][right_x] == '.':
            grid[y][right_x] = '|'
            if grid[y + 1][right_x] == '.':
                flow_water(right_x, y + 1)
                break
            right_x += 1

        if all(grid[y][left_x] in '#~' for left_x in range(left_x + 1, right_x)) and \
                all(grid[y][right_x] in '#~' for right_x in range(right_x + 1, x)):
            for fill_x in range(left_x + 1, right_x):
                grid[y][fill_x] = '~'
            flow_water(x, y - 1)


flow_water(500, 0)

count = sum(1 for row in grid[min_y:max_y + 1] for tile in row if tile in '|~')
print(count)
",2.0
262,2018,17,2,part1_failed,,25800,,,
263,2018,18,1,no_error,"653184
",653184,,"
def read_input():
    with open('input.txt', 'r') as file:
        return [list(line.strip()) for line in file.readlines()]

def count_adjacent_acres(grid, x, y, acre_type):
    count = 0
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            if dx == 0 and dy == 0:
                continue
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == acre_type:
                count += 1
    return count

def update_acre(grid, x, y):
    acre = grid[x][y]
    if acre == '.':
        if count_adjacent_acres(grid, x, y, '|') >= 3:
            return '|'
    elif acre == '|':
        if count_adjacent_acres(grid, x, y, '#') >= 3:
            return '#'
    elif acre == '#':
        if count_adjacent_acres(grid, x, y, '#') >= 1 and count_adjacent_acres(grid, x, y, '|') >= 1:
            return '#'
        else:
            return '.'
    return acre

def update_landscape(grid):
    new_grid = [[None] * len(grid[0]) for _ in range(len(grid))]
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            new_grid[i][j] = update_acre(grid, i, j)
    return new_grid

def calculate_resource_value(grid):
    wooded_acres = sum(row.count('|') for row in grid)
    lumberyards = sum(row.count('#') for row in grid)
    return wooded_acres * lumberyards

def simulate(minutes):
    grid = read_input()
    for _ in range(minutes):
        grid = update_landscape(grid)
    return calculate_resource_value(grid)

resource_value = simulate(10)
print(resource_value)
",1.0
264,2018,18,2,no_error,"169106
",169106,,"
def read_input():
    with open('input.txt', 'r') as file:
        return [list(line.strip()) for line in file.readlines()]

def count_adjacent_acres(grid, x, y, acre_type):
    count = 0
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            if dx == 0 and dy == 0:
                continue
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == acre_type:
                count += 1
    return count

def update_acre(grid, x, y):
    acre = grid[x][y]
    if acre == '.':
        if count_adjacent_acres(grid, x, y, '|') >= 3:
            return '|'
    elif acre == '|':
        if count_adjacent_acres(grid, x, y, '#') >= 3:
            return '#'
    elif acre == '#':
        if count_adjacent_acres(grid, x, y, '#') >= 1 and count_adjacent_acres(grid, x, y, '|') >= 1:
            return '#'
        else:
            return '.'
    return acre

def update_landscape(grid):
    new_grid = [[None] * len(grid[0]) for _ in range(len(grid))]
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            new_grid[i][j] = update_acre(grid, i, j)
    return new_grid

def calculate_resource_value(grid):
    wooded_acres = sum(row.count('|') for row in grid)
    lumberyards = sum(row.count('#') for row in grid)
    return wooded_acres * lumberyards

def simulate(minutes):
    grid = read_input()
    seen_states = []
    repeating_start = None
    for i in range(minutes):
        grid_str = ''.join([''.join(row) for row in grid])
        if grid_str in seen_states:
            repeating_start = seen_states.index(grid_str)
            break
        seen_states.append(grid_str)
        grid = update_landscape(grid)
    if repeating_start is not None:
        repeated_states = seen_states[repeating_start:]
        remaining_minutes = minutes - repeating_start
        final_state = repeated_states[remaining_minutes % len(repeated_states)]
        grid = [list(row) for row in final_state]
    return calculate_resource_value(grid)

resource_value = simulate(1000000000)
print(resource_value)
",2.0
265,2018,19,1,no_error,"2520
",2520,,"# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input
ip_register = int(lines[0].split()[1])
instructions = []

for line in lines[1:]:
    instruction = line.split()
    opcode = instruction[0]
    a = int(instruction[1])
    b = int(instruction[2])
    c = int(instruction[3])
    instructions.append((opcode, a, b, c))

# Execute the program
registers = [0] * 6
instruction_pointer = 0

while 0 <= instruction_pointer < len(instructions):
    registers[ip_register] = instruction_pointer
    opcode, a, b, c = instructions[instruction_pointer]
    
    if opcode == 'addr':
        registers[c] = registers[a] + registers[b]
    elif opcode == 'addi':
        registers[c] = registers[a] + b
    elif opcode == 'mulr':
        registers[c] = registers[a] * registers[b]
    elif opcode == 'muli':
        registers[c] = registers[a] * b
    elif opcode == 'banr':
        registers[c] = registers[a] & registers[b]
    elif opcode == 'bani':
        registers[c] = registers[a] & b
    elif opcode == 'borr':
        registers[c] = registers[a] | registers[b]
    elif opcode == 'bori':
        registers[c] = registers[a] | b
    elif opcode == 'setr':
        registers[c] = registers[a]
    elif opcode == 'seti':
        registers[c] = a
    elif opcode == 'gtir':
        registers[c] = 1 if a > registers[b] else 0
    elif opcode == 'gtri':
        registers[c] = 1 if registers[a] > b else 0
    elif opcode == 'gtrr':
        registers[c] = 1 if registers[a] > registers[b] else 0
    elif opcode == 'eqir':
        registers[c] = 1 if a == registers[b] else 0
    elif opcode == 'eqri':
        registers[c] = 1 if registers[a] == b else 0
    elif opcode == 'eqrr':
        registers[c] = 1 if registers[a] == registers[b] else 0
    
    instruction_pointer = registers[ip_register]
    instruction_pointer += 1

# Print the value in register 0
print(registers[0])",0.0
266,2018,19,2,timeout_error,,27941760,TIMEOUT,"# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input
ip_register = int(lines[0].split()[1])
instructions = []

for line in lines[1:]:
    instruction = line.split()
    opcode = instruction[0]
    a = int(instruction[1])
    b = int(instruction[2])
    c = int(instruction[3])
    instructions.append((opcode, a, b, c))

# Execute the program
registers = [1] + [0] * 5
instruction_pointer = 0

while 0 <= instruction_pointer < len(instructions):
    registers[ip_register] = instruction_pointer
    opcode, a, b, c = instructions[instruction_pointer]
    
    if opcode == 'addr':
        registers[c] = registers[a] + registers[b]
    elif opcode == 'addi':
        registers[c] = registers[a] + b
    elif opcode == 'mulr':
        registers[c] = registers[a] * registers[b]
    elif opcode == 'muli':
        registers[c] = registers[a] * b
    elif opcode == 'banr':
        registers[c] = registers[a] & registers[b]
    elif opcode == 'bani':
        registers[c] = registers[a] & b
    elif opcode == 'borr':
        registers[c] = registers[a] | registers[b]
    elif opcode == 'bori':
        registers[c] = registers[a] | b
    elif opcode == 'setr':
        registers[c] = registers[a]
    elif opcode == 'seti':
        registers[c] = a
    elif opcode == 'gtir':
        registers[c] = 1 if a > registers[b] else 0
    elif opcode == 'gtri':
        registers[c] = 1 if registers[a] > b else 0
    elif opcode == 'gtrr':
        registers[c] = 1 if registers[a] > registers[b] else 0
    elif opcode == 'eqir':
        registers[c] = 1 if a == registers[b] else 0
    elif opcode == 'eqri':
        registers[c] = 1 if registers[a] == b else 0
    elif opcode == 'eqrr':
        registers[c] = 1 if registers[a] == registers[b] else 0
    
    instruction_pointer = registers[ip_register]
    instruction_pointer += 1

# Print the value in register 0
print(registers[0])",2.0
267,2018,20,1,wrong_output,"The largest number of doors required to reach a room is: 0
The fewest doors required to reach a room is: 0
",4432,,"import re

def parse_regex(regex):
    stack = []
    map = {}
    index = 0

    for char in regex:
        if char == '^':
            stack.append(index)
        elif char == '$':
            index = stack.pop()
        elif char == '(':
            stack.append(index)
        elif char == '|':
            index = stack[-1]
        elif char == ')':
            stack.pop()
        else:
            map.setdefault(index, []).append((char, index + 1))
            index += 1

    return map

def build_map(regex_map):
    queue = [(0, 0)]
    distances = {(0, 0): 0}

    while queue:
        x, y = queue.pop(0)

        for char, (dx, dy) in regex_map.get((x, y), []):
            nx, ny = x + dx, y + dy

            if (nx, ny) not in distances:
                distances[(nx, ny)] = distances[(x, y)] + 1
                queue.append((nx, ny))

    return distances

def furthest_room_distance(regex):
    regex_map = parse_regex(regex)
    distances = build_map(regex_map)
    return max(distances.values())

def fewest_doors(regex):
    regex_map = parse_regex(regex)
    distances = build_map(regex_map)
    return sum(1 for distance in distances.values() if distance >= 1000)

with open('input.txt', 'r') as file:
    regex = file.read().strip()

furthest_distance = furthest_room_distance(regex)
fewest_doors = fewest_doors(regex)

print(""The largest number of doors required to reach a room is:"", furthest_distance)
print(""The fewest doors required to reach a room is:"", fewest_doors)",2.0
268,2018,20,2,part1_failed,,8681,,,
269,2018,21,1,timeout_error,,2159153,TIMEOUT,"
with open('input.txt', 'r') as file:
    lines = file.readlines()

ip_register = int(lines[0].split()[1])

instructions = []
for line in lines[1:]:
    parts = line.strip().split()
    opcode = parts[0]
    A = int(parts[1])
    B = int(parts[2])
    C = int(parts[3])
    instructions.append((opcode, A, B, C))


registers = [0] * 6

while 0 <= registers[ip_register] < len(instructions):
    opcode, A, B, C = instructions[registers[ip_register]]

    # Execute the instruction based on the opcode
    if opcode == 'addr':
        registers[C] = registers[A] + registers[B]
    elif opcode == 'addi':
        registers[C] = registers[A] + B
    elif opcode == 'mulr':
        registers[C] = registers[A] * registers[B]
    elif opcode == 'muli':
        registers[C] = registers[A] * B
    elif opcode == 'banr':
        registers[C] = registers[A] & registers[B]
    elif opcode == 'bani':
        registers[C] = registers[A] & B
    elif opcode == 'borr':
        registers[C] = registers[A] | registers[B]
    elif opcode == 'bori':
        registers[C] = registers[A] | B
    elif opcode == 'setr':
        registers[C] = registers[A]
    elif opcode == 'seti':
        registers[C] = A
    elif opcode == 'gtir':
        registers[C] = 1 if A > registers[B] else 0
    elif opcode == 'gtri':
        registers[C] = 1 if registers[A] > B else 0
    elif opcode == 'gtrr':
        registers[C] = 1 if registers[A] > registers[B] else 0
    elif opcode == 'eqir':
        registers[C] = 1 if A == registers[B] else 0
    elif opcode == 'eqri':
        registers[C] = 1 if registers[A] == B else 0
    elif opcode == 'eqrr':
        registers[C] = 1 if registers[A] == registers[B] else 0

    # Increment the instruction pointer
    registers[ip_register] += 1


# Test different values for register 0
for value in range(100000000):
    registers = [value] + [0] * 5
    instruction_count = 0

    while 0 <= registers[ip_register] < len(instructions):
        opcode, A, B, C = instructions[registers[ip_register]]

        # ...

        # Increment the instruction pointer
        registers[ip_register] += 1
        instruction_count += 1

    # Check if the program halted
    if registers[0] == 0:
        print(f""The lowest non-negative integer value for register 0 is {value}"")
        break
",2.0
270,2018,21,2,part1_failed,,7494885,,,
271,2018,22,1,runtime_error,,11972,"Traceback (most recent call last):
  File ""/tmp/tmp6iy3zpc1/tmp.py"", line 27, in <module>
    risk_level += erosion_level(x, y, depth, target_x, target_y) % 3
  File ""/tmp/tmp6iy3zpc1/tmp.py"", line 21, in erosion_level
    return (geologic_index(x, y, target_x, target_y) + depth) % 20183
  File ""/tmp/tmp6iy3zpc1/tmp.py"", line 17, in geologic_index
    return erosion_level(x - 1, y, target_x, target_y) * erosion_level(x, y - 1, target_x, target_y)
TypeError: erosion_level() missing 1 required positional argument: 'target_y'
","
with open('input.txt', 'r') as file:
    lines = file.readlines()

depth = int(lines[0].split(':')[1].strip())
target_x, target_y = map(int, lines[1].split(':')[1].strip().split(','))


def geologic_index(x, y, target_x, target_y):
    if (x, y) == (0, 0) or (x, y) == (target_x, target_y):
        return 0
    elif y == 0:
        return x * 16807
    elif x == 0:
        return y * 48271
    else:
        return erosion_level(x - 1, y, target_x, target_y) * erosion_level(x, y - 1, target_x, target_y)


def erosion_level(x, y, depth, target_x, target_y):
    return (geologic_index(x, y, target_x, target_y) + depth) % 20183


risk_level = 0
for y in range(target_y + 1):
    for x in range(target_x + 1):
        risk_level += erosion_level(x, y, depth, target_x, target_y) % 3

print(risk_level)
",2.0
272,2018,22,2,part1_failed,,1092,,,
273,2018,23,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmpjmta2yik/tmp.py"", line 30, in <module>
    print(main(input_string))
  File ""/tmp/tmpjmta2yik/tmp.py"", line 24, in main
    nanobots = parse_input(input_string)
  File ""/tmp/tmpjmta2yik/tmp.py"", line 19, in parse_input
    x, y, z, r = map(int, line[line.index('<')+1:line.index('>')].split(','))
ValueError: not enough values to unpack (expected 4, got 3)
","def calculate_distance(x1, y1, z1, x2, y2, z2):
    return abs(x1 - x2) + abs(y1 - y2) + abs(z1 - z2)

def count_nano_in_range(x, y, z, nanobots):
    count = 0
    for nano in nanobots:
        distance = calculate_distance(x, y, z, nano[0], nano[1], nano[2])
        if distance <= nano[3]:
            count += 1
    return count

def find_strongest_nanobot(nanobots):
    strongest_nanobot = max(nanobots, key=lambda x: x[3])
    return strongest_nanobot

def parse_input(input_string):
    nanobots = []
    for line in input_string.strip().split('\n'):
        x, y, z, r = map(int, line[line.index('<')+1:line.index('>')].split(','))
        nanobots.append((x, y, z, r))
    return nanobots

def main(input_string):
    nanobots = parse_input(input_string)
    strongest_nanobot = find_strongest_nanobot(nanobots)
    count = count_nano_in_range(strongest_nanobot[0], strongest_nanobot[1], strongest_nanobot[2], nanobots)
    return count

input_string = open('input.txt').read()
print(main(input_string))",2.0
274,2018,23,2,part1_failed,,106323091,,,
275,2018,24,1,runtime_error,,14377,"Traceback (most recent call last):
  File ""/tmp/tmpo0gt74jk/tmp.py"", line 107, in <module>
    main()
  File ""/tmp/tmpo0gt74jk/tmp.py"", line 101, in main
    immune_system, infection = parse_input(input_string)
  File ""/tmp/tmpo0gt74jk/tmp.py"", line 12, in parse_input
    units, hit_points, attributes = line.split('each with')
ValueError: not enough values to unpack (expected 3, got 2)
","def parse_input(input_string):
    immune_system = []
    infection = []
    current_army = None

    for line in input_string.strip().split('\n'):
        if line.startswith('Immune System:'):
            current_army = immune_system
        elif line.startswith('Infection:'):
            current_army = infection
        elif line.strip() != '':
            units, hit_points, attributes = line.split('each with')
            units = int(units.strip())
            hit_points = int(hit_points.strip().split()[0])
            attributes = attributes.strip().split('with an attack that does')
            attack_damage = int(attributes[1].split()[0])
            attack_type = attributes[1].split()[1]
            initiative = int(attributes[1].split()[-1])
            weaknesses = []
            immunities = []
            if '(' in attributes[0]:
                attributes_list = attributes[0].split('(')[1].split(')')[0].split(';')
                for attr in attributes_list:
                    attr = attr.strip()
                    if attr.startswith('weak to'):
                        weaknesses = attr[8:].split(', ')
                    elif attr.startswith('immune to'):
                        immunities = attr[10:].split(', ')
            group = {
                'units': units,
                'hit_points': hit_points,
                'attack_damage': attack_damage,
                'attack_type': attack_type,
                'initiative': initiative,
                'weaknesses': weaknesses,
                'immunities': immunities
            }
            current_army.append(group)

    return immune_system, infection


def target_selection(immune_system, infection):
    targets = {}
    groups = sorted(immune_system + infection, key=lambda x: (x['units'] * x['attack_damage'], x['initiative']), reverse=True)
    for group in groups:
        if group in immune_system:
            enemies = infection
        else:
            enemies = immune_system
        potential_targets = [enemy for enemy in enemies if enemy not in targets.values() and group['attack_type'] not in enemy['immunities']]
        if potential_targets:
            target = max(potential_targets, key=lambda x: (calculate_damage(group, x), x['units'] * x['attack_damage'], x['initiative']))
            if calculate_damage(group, target) > 0:
                targets[group] = target

    return targets


def calculate_damage(attacker, defender):
    if attacker['attack_type'] in defender['weaknesses']:
        return 2 * attacker['units'] * attacker['attack_damage']
    return attacker['units'] * attacker['attack_damage']


def attacking(immune_system, infection, targets):
    groups = sorted(immune_system + infection, key=lambda x: x['initiative'], reverse=True)
    for group in groups:
        if group['units'] > 0:
            if group in immune_system:
                enemies = infection
            else:
                enemies = immune_system
            if group in targets:
                target = targets[group]
                damage = calculate_damage(group, target)
                units_destroyed = min(target['units'], damage // target['hit_points'])
                target['units'] -= units_destroyed


def simulate_combat(immune_system, infection):
    while immune_system and infection:
        targets = target_selection(immune_system, infection)
        attacking(immune_system, infection, targets)
        immune_system = [group for group in immune_system if group['units'] > 0]
        infection = [group for group in infection if group['units'] > 0]

    return immune_system, infection


def calculate_winning_units(immune_system, infection):
    immune_system, infection = simulate_combat(immune_system, infection)
    units = sum(group['units'] for group in immune_system + infection)
    return units


def main():
    with open('input.txt', 'r') as file:
        input_string = file.read()

    immune_system, infection = parse_input(input_string)
    winning_units = calculate_winning_units(immune_system, infection)
    print(f""The winning army would have {winning_units} units."")


if __name__ == '__main__':
    main()",2.0
276,2018,24,2,part1_failed,,6947,,,
277,2018,25,1,no_error,"363
",363,,"
def manhattan_distance(p1, p2):
    return sum(abs(c1 - c2) for c1, c2 in zip(p1, p2))

def dfs(node, graph, visited):
    visited.add(node)
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs(neighbor, graph, visited)

def count_constellations(points):
    graph = {point: [] for point in points}
    for i in range(len(points)):
        for j in range(i + 1, len(points)):
            if manhattan_distance(points[i], points[j]) <= 3:
                graph[points[i]].append(points[j])
                graph[points[j]].append(points[i])

    visited = set()
    constellation_count = 0
    for node in graph:
        if node not in visited:
            dfs(node, graph, visited)
            constellation_count += 1

    return constellation_count

# Read input from file
with open('input.txt', 'r') as file:
    points = [tuple(map(int, line.strip().split(','))) for line in file]

# Count constellations
constellation_count = count_constellations(points)
print(constellation_count)
",0.0
278,2019,1,1,no_error,"3336439
",3336439,,"
def calculate_fuel(mass):
    fuel = (mass // 3) - 2
    return fuel

total_fuel = 0

with open('input.txt', 'r') as file:
    for line in file:
        mass = int(line.strip())
        fuel = calculate_fuel(mass)
        total_fuel += fuel

print(total_fuel)
",0.0
279,2019,1,2,no_error,"5001791
",5001791,,"
def calculate_fuel(mass):
    fuel = (mass // 3) - 2
    if fuel <= 0:
        return 0
    else:
        return fuel + calculate_fuel(fuel)

total_fuel = 0

with open('input.txt', 'r') as file:
    for line in file:
        mass = int(line.strip())
        fuel = calculate_fuel(mass)
        total_fuel += fuel

print(total_fuel)
",0.0
282,2019,2,1,no_error,4138658,4138658,,"
with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))


program[1] = 12
program[2] = 2


index = 0
while program[index] != 99:
    opcode = program[index]
    if opcode == 1:
        operand1 = program[program[index + 1]]
        operand2 = program[program[index + 2]]
        program[program[index + 3]] = operand1 + operand2
    elif opcode == 2:
        operand1 = program[program[index + 1]]
        operand2 = program[program[index + 2]]
        program[program[index + 3]] = operand1 * operand2
    index += 4


print(program[0])


with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))

program[1] = 12
program[2] = 2

index = 0
while program[index] != 99:
    opcode = program[index]
    if opcode == 1:
        operand1 = program[program[index + 1]]
        operand2 = program[program[index + 2]]
        program[program[index + 3]] = operand1 + operand2
    elif opcode == 2:
        operand1 = program[program[index + 1]]
        operand2 = program[program[index + 2]]
        program[program[index + 3]] = operand1 * operand2
    index += 4

print(program[0])
",0.0
283,2019,2,2,no_error,7264,7264,,"
with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))


def execute_program(noun, verb):
    program_copy = program.copy()
    program_copy[1] = noun
    program_copy[2] = verb

    index = 0
    while program_copy[index] != 99:
        opcode = program_copy[index]
        if opcode == 1:
            operand1 = program_copy[program_copy[index + 1]]
            operand2 = program_copy[program_copy[index + 2]]
            program_copy[program_copy[index + 3]] = operand1 + operand2
        elif opcode == 2:
            operand1 = program_copy[program_copy[index + 1]]
            operand2 = program_copy[program_copy[index + 2]]
            program_copy[program_copy[index + 3]] = operand1 * operand2
        index += 4

    return program_copy[0]


for noun in range(100):
    for verb in range(100):
        if execute_program(noun, verb) == 19690720:
            answer = 100 * noun + verb
            print(answer)
            break


with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))

def execute_program(noun, verb):
    program_copy = program.copy()
    program_copy[1] = noun
    program_copy[2] = verb

    index = 0
    while program_copy[index] != 99:
        opcode = program_copy[index]
        if opcode == 1:
            operand1 = program_copy[program_copy[index + 1]]
            operand2 = program_copy[program_copy[index + 2]]
            program_copy[program_copy[index + 3]] = operand1 + operand2
        elif opcode == 2:
            operand1 = program_copy[program_copy[index + 1]]
            operand2 = program_copy[program_copy[index + 2]]
            program_copy[program_copy[index + 3]] = operand1 * operand2
        index += 4

    return program_copy[0]

for noun in range(100):
    for verb in range(100):
        if execute_program(noun, verb) == 19690720:
            answer = 100 * noun + verb
            print(answer)
            break
",0.0
286,2019,3,1,wrong_output,"0
",248,,"
def parse_wire_path(path):
    """"""
    Parses a wire path string and returns a list of points that the wire passes through.
    """"""
    points = [(0, 0)]  # Start at the central port
    
    for move in path.split(','):
        direction = move[0]
        distance = int(move[1:])
        
        if direction == 'R':
            points.extend((points[-1][0] + i, points[-1][1]) for i in range(1, distance + 1))
        elif direction == 'L':
            points.extend((points[-1][0] - i, points[-1][1]) for i in range(1, distance + 1))
        elif direction == 'U':
            points.extend((points[-1][0], points[-1][1] + i) for i in range(1, distance + 1))
        elif direction == 'D':
            points.extend((points[-1][0], points[-1][1] - i) for i in range(1, distance + 1))
    
    return points


def find_intersection_points(wire1, wire2):
    """"""
    Finds the intersection points between two wires.
    """"""
    return set(wire1) & set(wire2)


def manhattan_distance(point1, point2):
    """"""
    Calculates the Manhattan distance between two points.
    """"""
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])


with open('input.txt', 'r') as f:
    wire1_path, wire2_path = f.read().splitlines()

wire1 = parse_wire_path(wire1_path)
wire2 = parse_wire_path(wire2_path)

intersection_points = find_intersection_points(wire1, wire2)

min_distance = float('inf')
for point in intersection_points:
    distance = manhattan_distance((0, 0), point)
    min_distance = min(min_distance, distance)

print(min_distance)
",2.0
287,2019,3,2,part1_failed,,28580,,,
288,2019,4,1,no_error,"454
",454,,"
def is_valid_password(password):
    password = str(password)
    has_adjacent_duplicate = False
    for i in range(len(password) - 1):
        if password[i] == password[i + 1]:
            has_adjacent_duplicate = True
        if int(password[i]) > int(password[i + 1]):
            return False
    return has_adjacent_duplicate

def count_valid_passwords(start, end):
    count = 0
    for password in range(start, end + 1):
        if is_valid_password(password):
            count += 1
    return count

# Read input range from file
with open('input.txt', 'r') as file:
    input_range = file.readline().split('-')
    start = int(input_range[0])
    end = int(input_range[1])

# Count valid passwords
valid_passwords = count_valid_passwords(start, end)
print(valid_passwords)
",0.0
289,2019,4,2,no_error,"288
",288,,"
def is_valid_password(password):
    password = str(password)
    has_adjacent_duplicate = False
    for i in range(len(password) - 1):
        if password[i] == password[i + 1]:
            if (i == 0 or password[i - 1] != password[i]) and (i == len(password) - 2 or password[i + 2] != password[i]):
                has_adjacent_duplicate = True
        if int(password[i]) > int(password[i + 1]):
            return False
    return has_adjacent_duplicate

def count_valid_passwords(start, end):
    count = 0
    for password in range(start, end + 1):
        if is_valid_password(password):
            count += 1
    return count

# Read input range from file
with open('input.txt', 'r') as file:
    input_range = file.readline().split('-')
    start = int(input_range[0])
    end = int(input_range[1])

# Count valid passwords
valid_passwords = count_valid_passwords(start, end)
print(valid_passwords)
",0.0
292,2019,5,1,syntax_error,,6069343,"  File ""/tmp/tmpnt42p46j/tmp.py"", line 1
    I will start by parsing the input file and extracting the diagnostic program.
      ^
SyntaxError: invalid syntax
",I will start by parsing the input file and extracting the diagnostic program.,2.0
293,2019,5,2,part1_failed,,3188550,,,
294,2019,6,1,no_error,142497,142497,,"
class Node:
    def __init__(self, name):
        self.name = name
        self.children = []

    def add_child(self, child):
        self.children.append(child)


def count_orbits(node, depth):
    count = depth
    for child in node.children:
        count += count_orbits(child, depth + 1)
    return count


# Parse input data
orbit_map = {}
with open('input.txt', 'r') as file:
    for line in file:
        parent, child = line.strip().split(')')
        if parent not in orbit_map:
            orbit_map[parent] = Node(parent)
        if child not in orbit_map:
            orbit_map[child] = Node(child)
        orbit_map[parent].add_child(orbit_map[child])

# Count direct and indirect orbits
root = orbit_map['COM']
total_orbits = count_orbits(root, 0)

print(""Total number of direct and indirect orbits:"", total_orbits)
",0.0
295,2019,6,2,no_error,301,301,,"
class Node:
    def __init__(self, name):
        self.name = name
        self.children = []
        self.parent = None

    def add_child(self, child):
        self.children.append(child)


def find_path(start, end):
    visited = set()
    queue = [(start, 0)]

    while queue:
        node, distance = queue.pop(0)
        visited.add(node)

        if node == end:
            return distance

        for child in node.children + [node.parent]:
            if child and child not in visited:
                queue.append((child, distance + 1))
                visited.add(child)

    return None


# Parse input data
orbit_map = {}
with open('input.txt', 'r') as file:
    for line in file:
        parent, child = line.strip().split(')')
        if parent not in orbit_map:
            orbit_map[parent] = Node(parent)
        if child not in orbit_map:
            orbit_map[child] = Node(child)
        orbit_map[parent].add_child(orbit_map[child])
        orbit_map[child].parent = orbit_map[parent]

# Find the shortest path between YOU and SAN
you = orbit_map['YOU']
san = orbit_map['SAN']
min_transfers = find_path(you.parent, san.parent)

print(""Minimum number of orbital transfers required:"", min_transfers)
",0.0
297,2019,7,1,runtime_error,,77500,"Traceback (most recent call last):
  File ""/tmp/tmphirmqodf/tmp.py"", line 33, in <module>
    max_signal = find_max_thruster_signal(program)
  File ""/tmp/tmphirmqodf/tmp.py"", line 24, in find_max_thruster_signal
    signal = run_amplifiers(program, phase_settings)
  File ""/tmp/tmphirmqodf/tmp.py"", line 5, in run_amplifiers
    amplifiers = [IntcodeComputer(program) for _ in range(5)]
  File ""/tmp/tmphirmqodf/tmp.py"", line 5, in <listcomp>
    amplifiers = [IntcodeComputer(program) for _ in range(5)]
NameError: name 'IntcodeComputer' is not defined
","
import itertools

def run_amplifiers(program, phase_settings):
    amplifiers = [IntcodeComputer(program) for _ in range(5)]

    for i, amplifier in enumerate(amplifiers):
        amplifier.add_input(phase_settings[i])

    input_signal = 0

    while not amplifiers[-1].is_halted():
        for amplifier in amplifiers:
            amplifier.add_input(input_signal)
            amplifier.run()
            input_signal = amplifier.get_output()

    return input_signal

def find_max_thruster_signal(program):
    max_signal = float('-inf')

    for phase_settings in itertools.permutations(range(5)):
        signal = run_amplifiers(program, phase_settings)
        max_signal = max(max_signal, signal)

    return max_signal

# Read the input program from file
with open('input.txt', 'r') as f:
    program = list(map(int, f.readline().split(',')))

max_signal = find_max_thruster_signal(program)
print(max_signal)
",2.0
298,2019,7,2,part1_failed,,22476942,,,
299,2019,8,1,no_error,"1742
",1742,,"
# Read the input from the file
with open('input.txt', 'r') as file:
    image_data = file.read().strip()

# Define the width and height of the image
width = 25
height = 6

# Calculate the number of layers
layer_size = width * height
num_layers = len(image_data) // layer_size

# Initialize variables to store the number of zeros, ones, and twos in each layer
min_zeros = float('inf')
result = 0

# Iterate over each layer
for i in range(num_layers):
    layer_data = image_data[i * layer_size: (i + 1) * layer_size]
    zeros = layer_data.count('0')
    ones = layer_data.count('1')
    twos = layer_data.count('2')
    
    # Check if the current layer has fewer zeros than the previous minimum
    if zeros < min_zeros:
        min_zeros = zeros
        result = ones * twos

# Output the result
print(result)
",0.0
300,2019,8,2,wrong_output,"0110000110100011111001100
1001000010100011000010010
1000000010010101110010010
1011000010001001000011110
1001010010001001000010010
0111001100001001111010010
",GJYEA,,"
# Read the input from the file
with open('input.txt', 'r') as file:
    image_data = file.read().strip()

# Define the width and height of the image
width = 25
height = 6

# Calculate the number of layers
layer_size = width * height
num_layers = len(image_data) // layer_size

# Initialize the final image as a list of transparent pixels
final_image = ['2'] * layer_size

# Iterate over each pixel position
for i in range(layer_size):
    # Iterate over each layer
    for j in range(num_layers):
        pixel = image_data[j * layer_size + i]
        
        # Check if the pixel is transparent
        if pixel != '2':
            final_image[i] = pixel
            break

# Reshape the final image into the desired width and height
final_image = [final_image[i:i+width] for i in range(0, layer_size, width)]

# Output the final image
for row in final_image:
    print(''.join(row))
",2.0
301,2019,9,1,no_error,3780860499,3780860499,,"
class IntcodeComputer:
    def __init__(self, program):
        self.program = program.copy()
        self.program.extend([0] * 10000)  # Extend memory

        self.ip = 0  # Instruction pointer
        self.rb = 0  # Relative base

    def get_value(self, parameter, mode):
        if mode == 0:  # Position mode
            return self.program[parameter]
        elif mode == 1:  # Immediate mode
            return parameter
        elif mode == 2:  # Relative mode
            return self.program[self.rb + parameter]
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    def set_value(self, parameter, mode, value):
        if mode == 0 or mode == 1:  # Position mode or immediate mode
            self.program[parameter] = value
        elif mode == 2:  # Relative mode
            self.program[self.rb + parameter] = value
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    def run(self, inputs):
        outputs = []
        input_index = 0

        while True:
            instruction = self.program[self.ip]
            opcode = instruction % 100
            modes = [(instruction // (10 ** i)) % 10 for i in range(2, 5)]

            if opcode == 1:  # Add
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                result = param1 + param2
                self.set_value(self.program[self.ip + 3], modes[2], result)
                self.ip += 4
            elif opcode == 2:  # Multiply
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                result = param1 * param2
                self.set_value(self.program[self.ip + 3], modes[2], result)
                self.ip += 4
            elif opcode == 3:  # Input
                self.set_value(self.program[self.ip + 1], modes[0], inputs[input_index])
                input_index += 1
                self.ip += 2
            elif opcode == 4:  # Output
                output = self.get_value(self.program[self.ip + 1], modes[0])
                outputs.append(output)
                self.ip += 2
            elif opcode == 5:  # Jump if true
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                if param1 != 0:
                    self.ip = param2
                else:
                    self.ip += 3
            elif opcode == 6:  # Jump if false
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                if param1 == 0:
                    self.ip = param2
                else:
                    self.ip += 3
            elif opcode == 7:  # Less than
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                result = 1 if param1 < param2 else 0
                self.set_value(self.program[self.ip + 3], modes[2], result)
                self.ip += 4
            elif opcode == 8:  # Equals
                param1 = self.get_value(self.program[self.ip + 1], modes[0])
                param2 = self.get_value(self.program[self.ip + 2], modes[1])
                result = 1 if param1 == param2 else 0
                self.set_value(self.program[self.ip + 3], modes[2], result)
                self.ip += 4
            elif opcode == 9:  # Relative base offset
                param = self.get_value(self.program[self.ip + 1], modes[0])
                self.rb += param
                self.ip += 2
            elif opcode == 99:  # Halt
                break
            else:
                raise ValueError(f""Invalid opcode: {opcode}"")

        return outputs


def load_program(filename):
    with open(filename) as file:
        program = [int(x) for x in file.read().strip().split("","")]
    return program

program = load_program(""input.txt"")
computer = IntcodeComputer(program)
output = computer.run([1])

BOOST_keycode = output[0]
print(f""BOOST keycode: {BOOST_keycode}"")
",0.0
302,2019,9,2,runtime_error,,33343,"Traceback (most recent call last):
  File ""/tmp/tmpsea_xrgg/tmp.py"", line 2, in <module>
    program = load_program(""input.txt"")
NameError: name 'load_program' is not defined
","
program = load_program(""input.txt"")
computer = IntcodeComputer(program)
output = computer.run([2])

distress_signal_coordinates = output[0]
print(f""Distress signal coordinates: {distress_signal_coordinates}"")
",2.0
303,2019,10,1,no_error,"309
",309,,"
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def count_visible_asteroids(asteroids, source):
    visible = set()
    for asteroid in asteroids:
        if asteroid == source:
            continue
        dx = asteroid[0] - source[0]
        dy = asteroid[1] - source[1]
        gcd_val = gcd(abs(dx), abs(dy))
        slope = (dx // gcd_val, dy // gcd_val)
        visible.add(slope)
    return len(visible)

def find_best_location(asteroids):
    max_visible = 0
    for asteroid in asteroids:
        visible = count_visible_asteroids(asteroids, asteroid)
        if visible > max_visible:
            max_visible = visible
    return max_visible

def parse_input(input_str):
    asteroids = []
    lines = input_str.strip().split('\n')
    for y, line in enumerate(lines):
        for x, char in enumerate(line):
            if char == '#':
                asteroids.append((x, y))
    return asteroids

with open('input.txt', 'r') as f:
    input_str = f.read()

asteroids = parse_input(input_str)
result = find_best_location(asteroids)
print(result)
",0.0
304,2019,10,2,wrong_output,"1308
",416,,"
import math

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def count_visible_asteroids(asteroids, source):
    visible = set()
    for asteroid in asteroids:
        if asteroid == source:
            continue
        dx = asteroid[0] - source[0]
        dy = asteroid[1] - source[1]
        gcd_val = gcd(abs(dx), abs(dy))
        slope = (dx // gcd_val, dy // gcd_val)
        visible.add(slope)
    return len(visible)

def find_best_location(asteroids):
    max_visible = 0
    best_location = None
    for asteroid in asteroids:
        visible = count_visible_asteroids(asteroids, asteroid)
        if visible > max_visible:
            max_visible = visible
            best_location = asteroid
    return best_location

def vaporize_asteroids(asteroids, station, num):
    vaporized = []
    while len(vaporized) < num:
        vaporize_order = []
        for asteroid in asteroids:
            if asteroid == station:
                continue
            dx = asteroid[0] - station[0]
            dy = asteroid[1] - station[1]
            angle = math.atan2(dy, dx)
            angle = (angle - math.pi / 2) % (2 * math.pi)
            distance = dx**2 + dy**2
            vaporize_order.append((angle, distance, asteroid))
        vaporize_order.sort()
        vaporized_group = []
        for _, _, asteroid in vaporize_order:
            asteroids.remove(asteroid)
            vaporized_group.append(asteroid)
        vaporized.extend(vaporized_group)
    return vaporized[num - 1]

def parse_input(input_str):
    asteroids = []
    lines = input_str.strip().split('\n')
    for y, line in enumerate(lines):
        for x, char in enumerate(line):
            if char == '#':
                asteroids.append((x, y))
    return asteroids

with open('input.txt', 'r') as f:
    input_str = f.read()

asteroids = parse_input(input_str)
station = find_best_location(asteroids)
result = vaporize_asteroids(asteroids, station, 200)
answer = result[0] * 100 + result[1]
print(answer)
",2.0
305,2019,11,1,no_error,"2336
",2336,,"
class IntcodeComputer:
    def __init__(self):
        self.memory = []
        self.input = []
        self.output = []
        self.ip = 0
        self.relative_base = 0

    def load_program(self, program):
        self.memory = program[:]
        self.memory += [0] * 10000  # Extend memory

    def get_parameter(self, mode, offset):
        parameter = self.memory[self.ip + offset]
        if mode == 0:  # Position mode
            return self.memory[parameter]
        elif mode == 1:  # Immediate mode
            return parameter
        elif mode == 2:  # Relative mode
            return self.memory[self.relative_base + parameter]
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    def set_parameter(self, mode, offset, value):
        parameter = self.memory[self.ip + offset]
        if mode == 0:  # Position mode
            self.memory[parameter] = value
        elif mode == 2:  # Relative mode
            self.memory[self.relative_base + parameter] = value
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    def run(self):
        while True:
            instruction = self.memory[self.ip]
            opcode = instruction % 100
            mode1 = (instruction // 100) % 10
            mode2 = (instruction // 1000) % 10
            mode3 = (instruction // 10000) % 10

            if opcode == 1:  # Addition
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                self.set_parameter(mode3, 3, param1 + param2)
                self.ip += 4
            elif opcode == 2:  # Multiplication
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                self.set_parameter(mode3, 3, param1 * param2)
                self.ip += 4
            elif opcode == 3:  # Input
                if not self.input:
                    return
                value = self.input.pop(0)
                self.set_parameter(mode1, 1, value)
                self.ip += 2
            elif opcode == 4:  # Output
                value = self.get_parameter(mode1, 1)
                self.output.append(value)
                self.ip += 2
            elif opcode == 5:  # Jump if True
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 != 0:
                    self.ip = param2
                else:
                    self.ip += 3
            elif opcode == 6:  # Jump if False
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 == 0:
                    self.ip = param2
                else:
                    self.ip += 3
            elif opcode == 7:  # Less than
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                value = int(param1 < param2)
                self.set_parameter(mode3, 3, value)
                self.ip += 4
            elif opcode == 8:  # Equals
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                value = int(param1 == param2)
                self.set_parameter(mode3, 3, value)
                self.ip += 4
            elif opcode == 9:  # Adjust relative base
                param1 = self.get_parameter(mode1, 1)
                self.relative_base += param1
                self.ip += 2
            elif opcode == 99:  # Halt
                return
            else:
                raise ValueError(f""Invalid opcode: {opcode}"")

    def get_output(self):
        return self.output


def paint_hull(program):
    hull = {}
    x, y = 0, 0
    dx, dy = 0, -1  # Initial direction: up

    computer = IntcodeComputer()
    computer.load_program(program)

    while True:
        panel_color = hull.get((x, y), 0)  # 0 if panel is not painted
        computer.input.append(panel_color)

        computer.run()

        if not computer.output:
            break

        color_to_paint = computer.output.pop(0)
        turn_direction = computer.output.pop(0)

        hull[(x, y)] = color_to_paint

        if turn_direction == 0:  # Turn left 90 degrees
            dx, dy = -dy, dx
        elif turn_direction == 1:  # Turn right 90 degrees
            dx, dy = dy, -dx
        else:
            raise ValueError(f""Invalid turn direction: {turn_direction}"")

        x += dx
        y += dy

    return len(hull)


with open('input.txt', 'r') as f:
    program = list(map(int, f.readline().strip().split(',')))

panels_painted = paint_hull(program)
print(panels_painted)
",0.0
306,2019,11,2,runtime_error,,UZAEKBLP,"Traceback (most recent call last):
  File ""/tmp/tmp588eo_c6/tmp.py"", line 64, in <module>
    paint_hull(program)
  File ""/tmp/tmp588eo_c6/tmp.py"", line 9, in paint_hull
    computer = IntcodeComputer()
NameError: name 'IntcodeComputer' is not defined
","
def paint_hull(program):
    hull = {}
    x, y = 0, 0
    dx, dy = 0, -1  # Initial direction: up
    min_x, min_y = float('inf'), float('inf')
    max_x, max_y = float('-inf'), float('-inf')

    computer = IntcodeComputer()
    computer.load_program(program)

    # Start the robot on a white panel
    hull[(x, y)] = 1

    while True:
        panel_color = hull.get((x, y), 0)  # 0 if panel is not painted
        computer.input.append(panel_color)

        computer.run()

        if not computer.output:
            break

        color_to_paint = computer.output.pop(0)
        turn_direction = computer.output.pop(0)

        hull[(x, y)] = color_to_paint

        min_x = min(min_x, x)
        min_y = min(min_y, y)
        max_x = max(max_x, x)
        max_y = max(max_y, y)

        if turn_direction == 0:  # Turn left 90 degrees
            dx, dy = -dy, dx
        elif turn_direction == 1:  # Turn right 90 degrees
            dx, dy = dy, -dx
        else:
            raise ValueError(f""Invalid turn direction: {turn_direction}"")

        x += dx
        y += dy

    # Determine the size of the hull
    width = max_x - min_x + 1
    height = max_y - min_y + 1

    # Initialize the hull grid with black panels
    hull_grid = [['.' for _ in range(width)] for _ in range(height)]

    # Convert the hull dictionary to the hull grid
    for panel, color in hull.items():
        x, y = panel
        hull_grid[y - min_y][x - min_x] = '#' if color else '.'

    # Print the registration identifier
    for row in hull_grid:
        print(''.join(row))


with open('input.txt', 'r') as f:
    program = list(map(int, f.readline().strip().split(',')))

paint_hull(program)
",2.0
307,2019,12,1,no_error,"6220
",6220,,"from itertools import combinations

class Moon:
    def __init__(self, x, y, z):
        self.pos = [x, y, z]
        self.vel = [0, 0, 0]

    def update_velocity(self, other_moon):
        for i in range(3):
            if self.pos[i] < other_moon.pos[i]:
                self.vel[i] += 1
                other_moon.vel[i] -= 1
            elif self.pos[i] > other_moon.pos[i]:
                self.vel[i] -= 1
                other_moon.vel[i] += 1

    def update_position(self):
        for i in range(3):
            self.pos[i] += self.vel[i]

    def potential_energy(self):
        return sum(abs(x) for x in self.pos)

    def kinetic_energy(self):
        return sum(abs(x) for x in self.vel)

    def total_energy(self):
        return self.potential_energy() * self.kinetic_energy()

# Read input
moons = []
with open('input.txt') as f:
    for line in f:
        coords = line.strip().replace('<', '').replace('>', '').replace('x=', '').replace('y=', '').replace('z=', '').split(',')
        x, y, z = map(int, coords)
        moons.append(Moon(x, y, z))

# Simulate motion
for _ in range(1000):
    for moon1, moon2 in combinations(moons, 2):
        moon1.update_velocity(moon2)

    for moon in moons:
        moon.update_position()

# Calculate total energy
total_energy = sum(moon.total_energy() for moon in moons)
print(total_energy)",0.0
308,2019,12,2,no_error,"548525804273976
",548525804273976,,"from itertools import combinations

class Moon:
    def __init__(self, x, y, z):
        self.pos = [x, y, z]
        self.vel = [0, 0, 0]

    def update_velocity(self, other_moon):
        for i in range(3):
            if self.pos[i] < other_moon.pos[i]:
                self.vel[i] += 1
                other_moon.vel[i] -= 1
            elif self.pos[i] > other_moon.pos[i]:
                self.vel[i] -= 1
                other_moon.vel[i] += 1

    def update_position(self):
        for i in range(3):
            self.pos[i] += self.vel[i]

    def potential_energy(self):
        return sum(abs(x) for x in self.pos)

    def kinetic_energy(self):
        return sum(abs(x) for x in self.vel)

    def total_energy(self):
        return self.potential_energy() * self.kinetic_energy()

def find_cycle_length(moons):
    initial_states = []
    for i in range(3):
        initial_state = [(moon.pos[i], moon.vel[i]) for moon in moons]
        initial_states.append(initial_state)

    cycle_lengths = [None, None, None]
    steps = 0

    while not all(cycle_lengths):
        for moon1, moon2 in combinations(moons, 2):
            moon1.update_velocity(moon2)

        for moon in moons:
            moon.update_position()

        steps += 1

        for i, initial_state in enumerate(initial_states):
            if cycle_lengths[i] is None and all((moon.pos[i], moon.vel[i]) == initial_state[j] for j, moon in enumerate(moons)):
                cycle_lengths[i] = steps

    return lcm(lcm(cycle_lengths[0], cycle_lengths[1]), cycle_lengths[2])

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

# Read input
moons = []
with open('input.txt') as f:
    for line in f:
        coords = line.strip().replace('<', '').replace('>', '').replace('x=', '').replace('y=', '').replace('z=', '').split(',')
        x, y, z = map(int, coords)
        moons.append(Moon(x, y, z))

# Find cycle length
cycle_length = find_cycle_length(moons)
print(cycle_length)",0.0
310,2019,13,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmpln2fdgay/tmp.py"", line 182, in <module>
    main()
  File ""/tmp/tmpln2fdgay/tmp.py"", line 177, in main
    game.play()
  File ""/tmp/tmpln2fdgay/tmp.py"", line 153, in play
    self.computer.run_program()
  File ""/tmp/tmpln2fdgay/tmp.py"", line 53, in run_program
    raise ValueError(f""Invalid opcode: {opcode}"")
ValueError: Invalid opcode: 80
","
from collections import defaultdict
from enum import Enum, auto
from typing import List, Tuple

class Tile(Enum):
    EMPTY = 0
    WALL = 1
    BLOCK = 2
    PADDLE = 3
    BALL = 4

class Joystick(Enum):
    NEUTRAL = 0
    LEFT = -1
    RIGHT = 1

class IntcodeComputer:
    def __init__(self, program: List[int]):
        self.memory = defaultdict(int)
        for i, instruction in enumerate(program):
            self.memory[i] = instruction
        self.relative_base = 0
        self.input_queue = []
        self.output_queue = []
        self.is_halted = False

    def run_program(self):
        while not self.is_halted:
            instruction = self.memory[self.pointer]
            opcode, modes = self.parse_instruction(instruction)
            if opcode == 1:
                self.add(modes)
            elif opcode == 2:
                self.multiply(modes)
            elif opcode == 3:
                self.input(modes)
            elif opcode == 4:
                self.output(modes)
            elif opcode == 5:
                self.jump_if_true(modes)
            elif opcode == 6:
                self.jump_if_false(modes)
            elif opcode == 7:
                self.less_than(modes)
            elif opcode == 8:
                self.equals(modes)
            elif opcode == 9:
                self.adjust_relative_base(modes)
            elif opcode == 99:
                self.halt()
            else:
                raise ValueError(f""Invalid opcode: {opcode}"")

    @property
    def pointer(self):
        return self.memory[self.relative_base]

    def parse_instruction(self, instruction: int) -> Tuple[int, List[int]]:
        opcode = instruction % 100
        modes = [int(d) for d in str(instruction // 100)][::-1]
        return opcode, modes

    def get_value(self, parameter: int, mode: int) -> int:
        if mode == 0:
            return self.memory[parameter]
        elif mode == 1:
            return parameter
        elif mode == 2:
            return self.memory[self.relative_base + parameter]

    def get_address(self, parameter: int, mode: int) -> int:
        if mode == 0:
            return parameter
        elif mode == 2:
            return self.relative_base + parameter

    def add(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        address = self.get_address(self.memory[self.pointer + 3], modes[2])
        self.memory[address] = operand1 + operand2
        self.relative_base += 4

    def multiply(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        address = self.get_address(self.memory[self.pointer + 3], modes[2])
        self.memory[address] = operand1 * operand2
        self.relative_base += 4

    def input(self, modes: List[int]):
        address = self.get_address(self.memory[self.pointer + 1], modes[0])
        self.memory[address] = self.input_queue.pop(0)
        self.relative_base += 2

    def output(self, modes: List[int]):
        value = self.get_value(self.memory[self.pointer + 1], modes[0])
        self.output_queue.append(value)
        self.relative_base += 2

    def jump_if_true(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        if operand1 != 0:
            self.relative_base = operand2
        else:
            self.relative_base += 3

    def jump_if_false(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        if operand1 == 0:
            self.relative_base = operand2
        else:
            self.relative_base += 3

    def less_than(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        address = self.get_address(self.memory[self.pointer + 3], modes[2])
        if operand1 < operand2:
            self.memory[address] = 1
        else:
            self.memory[address] = 0
        self.relative_base += 4

    def equals(self, modes: List[int]):
        operand1 = self.get_value(self.memory[self.pointer + 1], modes[0])
        operand2 = self.get_value(self.memory[self.pointer + 2], modes[1])
        address = self.get_address(self.memory[self.pointer + 3], modes[2])
        if operand1 == operand2:
            self.memory[address] = 1
        else:
            self.memory[address] = 0
        self.relative_base += 4

    def adjust_relative_base(self, modes: List[int]):
        self.relative_base += self.get_value(self.memory[self.pointer + 1], modes[0])
        self.relative_base += 2

    def halt(self):
        self.is_halted = True

class ArcadeGame:
    def __init__(self, program: List[int]):
        self.computer = IntcodeComputer(program)
        self.screen = defaultdict(int)
        self.score = 0

    def play(self):
        while not self.computer.is_halted:
            self.computer.run_program()
            self.update_screen()

    def update_screen(self):
        while self.computer.output_queue:
            x = self.computer.output_queue.pop(0)
            y = self.computer.output_queue.pop(0)
            tile_id = self.computer.output_queue.pop(0)
            if x == -1 and y == 0:
                self.score = tile_id
            else:
                self.screen[(x, y)] = tile_id

    def count_block_tiles(self) -> int:
        return sum(tile == Tile.BLOCK.value for tile in self.screen.values())

    def set_joystick_position(self, position: Joystick):
        self.computer.input_queue.append(position.value)

def main():
    with open('input.txt', 'r') as f:
        program = list(map(int, f.read().strip().split(',')))

    game = ArcadeGame(program)
    game.play()
    block_tiles = game.count_block_tiles()
    print(f""Number of block tiles: {block_tiles}"")

if __name__ == '__main__':
    main()
",2.0
311,2019,13,2,part1_failed,,12535,,,
312,2019,14,1,no_error,532506,532506,,"def parse_input(input_str):
    reactions = {}
    for line in input_str.strip().split('\n'):
        inputs, output = line.split(' => ')
        input_chemicals = []
        for input_chemical in inputs.split(', '):
            quantity, chemical = input_chemical.split(' ')
            input_chemicals.append((int(quantity), chemical))
        output_quantity, output_chemical = output.split(' ')
        reactions[output_chemical] = (int(output_quantity), input_chemicals)
    return reactions

def calculate_ore(reactions, fuel_quantity=1):
    surplus = {}
    required = {'FUEL': fuel_quantity}
    ore_count = 0
    
    while len(required) > 0:
        chemical = next(iter(required))
        quantity = required.pop(chemical)
        
        if chemical == 'ORE':
            ore_count += quantity
        else:
            if surplus.get(chemical, 0) >= quantity:
                surplus[chemical] -= quantity
            else:
                quantity -= surplus.get(chemical, 0)
                surplus[chemical] = 0
                output_quantity, inputs = reactions[chemical]
                multiplier = (quantity + output_quantity - 1) // output_quantity
                for input_quantity, input_chemical in inputs:
                    required[input_chemical] = required.get(input_chemical, 0) + input_quantity * multiplier
                surplus[chemical] = output_quantity * multiplier - quantity
    
    return ore_count

def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()
    
    reactions = parse_input(input_str)
    ore_count = calculate_ore(reactions)
    print(f""The minimum amount of ORE required to produce 1 FUEL is {ore_count}."")

if __name__ == '__main__':
    main()",2.0
313,2019,14,2,runtime_error,,2595245,"Traceback (most recent call last):
  File ""/tmp/tmpwye73e_o/tmp.py"", line 21, in <module>
    main()
  File ""/tmp/tmpwye73e_o/tmp.py"", line 15, in main
    reactions = parse_input(input_str)
NameError: name 'parse_input' is not defined
","def binary_search(reactions, lower_bound, upper_bound, target):
    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound + 1) // 2
        ore_count = calculate_ore(reactions, mid)
        if ore_count <= target:
            lower_bound = mid
        else:
            upper_bound = mid - 1
    return lower_bound

def main():
    with open('input.txt', 'r') as f:
        input_str = f.read()
    
    reactions = parse_input(input_str)
    ore_capacity = 1000000000000
    max_fuel = binary_search(reactions, 0, ore_capacity, ore_capacity)
    print(f""The maximum amount of FUEL that can be produced with 1 trillion ORE is {max_fuel}."")

if __name__ == '__main__':
    main()",2.0
314,2019,15,1,syntax_error,,300,"  File ""/tmp/tmpzkpq68g2/tmp.py"", line 1
    To solve this problem, we need to implement an Intcode computer that can interpret the program given in the input file. We'll simulate the movement commands and track the droid's position and the area of the ship that has been explored.
       ^
SyntaxError: invalid syntax
","To solve this problem, we need to implement an Intcode computer that can interpret the program given in the input file. We'll simulate the movement commands and track the droid's position and the area of the ship that has been explored.

First, let's define a few helper functions and classes.

1. `parse_program`: This function reads the program from the input file and converts it into a list of integers.
2. `IntcodeComputer`: This class represents the Intcode computer. It has methods to load the program, execute instructions, and handle input/output.
3. `Point`: This class represents a point in the ship area. It has methods to calculate neighboring points and check if it is a valid position in the ship.

Let's start by implementing the `parse_program` function.",2.0
315,2019,15,2,part1_failed,,312,,,
316,2019,16,1,no_error,"68317988
",68317988,,"
def read_input():
    with open('input.txt', 'r') as file:
        return [int(digit) for digit in file.read().strip()]

def calculate_phase(input_signal):
    pattern = [0, 1, 0, -1]
    output_signal = []
    for i in range(len(input_signal)):
        total = 0
        for j, digit in enumerate(input_signal):
            pattern_index = ((j + 1) // (i + 1)) % len(pattern)
            total += digit * pattern[pattern_index]
        output_signal.append(abs(total) % 10)
    return output_signal

input_signal = read_input()
for _ in range(100):
    input_signal = calculate_phase(input_signal)

print(''.join(str(digit) for digit in input_signal[:8]))
",0.0
317,2019,16,2,no_error,"53850800
",53850800,,"
def read_input():
    with open('input.txt', 'r') as file:
        return [int(digit) for digit in file.read().strip()]

def calculate_phase(input_signal):
    pattern = [0, 1, 0, -1]
    output_signal = []
    for i in range(len(input_signal)):
        total = 0
        for j, digit in enumerate(input_signal):
            pattern_index = ((j + 1) // (i + 1)) % len(pattern)
            total += digit * pattern[pattern_index]
        output_signal.append(abs(total) % 10)
    return output_signal

input_signal = read_input()
offset = int(''.join(str(digit) for digit in input_signal[:7]))
input_signal *= 10000
input_signal = input_signal[offset:]

for _ in range(100):
    output_signal = []
    total = 0
    for digit in reversed(input_signal):
        total += digit
        output_signal.append(total % 10)
    input_signal = list(reversed(output_signal))

print(''.join(str(digit) for digit in input_signal[:8]))
",1.0
319,2019,17,1,runtime_error,,9876,"Traceback (most recent call last):
  File ""/tmp/tmp3s434rtf/tmp.py"", line 25, in <module>
    alignment_sum = get_alignment_parameters(program)
  File ""/tmp/tmp3s434rtf/tmp.py"", line 4, in get_alignment_parameters
    camera_output = """".join(chr(x) for x in program)
  File ""/tmp/tmp3s434rtf/tmp.py"", line 4, in <genexpr>
    camera_output = """".join(chr(x) for x in program)
ValueError: chr() arg not in range(0x110000)
","
def get_alignment_parameters(program):
    # Parse the camera output and find the scaffold intersections
    camera_output = """".join(chr(x) for x in program)
    lines = camera_output.strip().split(""\n"")
    scaffold_intersections = []
    for y in range(1, len(lines) - 1):
        for x in range(1, len(lines[y]) - 1):
            if lines[y][x] == ""#"" and lines[y-1][x] == ""#"" and lines[y+1][x] == ""#"" and lines[y][x-1] == ""#"" and lines[y][x+1] == ""#"":
                scaffold_intersections.append((x, y))

    # Calculate the sum of the alignment parameters
    alignment_sum = 0
    for intersection in scaffold_intersections:
        alignment_sum += intersection[0] * intersection[1]

    return alignment_sum


# Read the program from input.txt
with open(""input.txt"", ""r"") as file:
    program = [int(x) for x in file.readline().strip().split("","")]

# Calculate and print the sum of the alignment parameters
alignment_sum = get_alignment_parameters(program)
print(alignment_sum)
",2.0
320,2019,17,2,part1_failed,,1234055,,,
321,2019,18,1,runtime_error,,6316,"Traceback (most recent call last):
  File ""/tmp/tmp1bfyb7dt/tmp.py"", line 101, in <module>
    steps = shortest_path(input_map)
  File ""/tmp/tmp1bfyb7dt/tmp.py"", line 42, in shortest_path
    steps = visited[(x, y, keys, doors)]
TypeError: 'set' object is not subscriptable
","
from collections import deque

def shortest_path(input_map):
    # Parse the input map
    grid = input_map.strip().split('\n')
    height = len(grid)
    width = len(grid[0])
    
    # Find the initial position of the robot
    for y in range(height):
        for x in range(width):
            if grid[y][x] == '@':
                start_pos = (x, y)
    
    # Define the possible directions to move
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
    
    # Define a helper function to check if a position is valid
    def is_valid(x, y):
        return 0 <= x < width and 0 <= y < height
    
    # Define a helper function to check if a position is a key
    def is_key(x, y):
        return 'a' <= grid[y][x] <= 'z'
    
    # Define a helper function to check if a position is a door
    def is_door(x, y):
        return 'A' <= grid[y][x] <= 'Z'
    
    # Define a helper function to get the key corresponding to a door
    def get_key(door):
        return door.lower()
    
    # Initialize the queue and the visited set
    queue = deque([(start_pos[0], start_pos[1], set(), set())])
    visited = set([(start_pos[0], start_pos[1], frozenset(), frozenset())])
    
    # Start the BFS algorithm
    while queue:
        x, y, keys, doors = queue.popleft()
        steps = visited[(x, y, keys, doors)]
        
        # Check if all keys have been collected
        if len(keys) == num_keys:
            return steps
        
        # Generate all possible next states
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            
            # Check if the next position is valid
            if not is_valid(nx, ny):
                continue
            
            # Check if the next position is a wall
            if grid[ny][nx] == '#':
                continue
            
            # Check if the next position is a key
            if is_key(nx, ny):
                key = grid[ny][nx]
                new_keys = keys | {key}
                new_doors = doors
                new_state = (nx, ny, new_keys, new_doors)
                
                if new_state not in visited:
                    visited.add(new_state)
                    queue.append((nx, ny, new_keys, new_doors))
            
            # Check if the next position is a door
            if is_door(nx, ny):
                door = grid[ny][nx]
                key = get_key(door)
                
                if key in keys:
                    new_keys = keys
                    new_doors = doors - {door}
                    new_state = (nx, ny, new_keys, new_doors)
                    
                    if new_state not in visited:
                        visited.add(new_state)
                        queue.append((nx, ny, new_keys, new_doors))
            
            # Move to the next position
            new_keys = keys
            new_doors = doors
            new_state = (nx, ny, new_keys, new_doors)
            
            if new_state not in visited:
                visited.add(new_state)
                queue.append((nx, ny, new_keys, new_doors))
    
    # If all keys couldn't be collected, return None
    return None


with open('input.txt', 'r') as f:
    input_map = f.read()

steps = shortest_path(input_map)
print(steps)
",2.0
322,2019,18,2,part1_failed,,1648,,,
323,2019,19,1,timeout_error,,150,TIMEOUT,"
def run_program(program, inputs):
    pc = 0
    ip = 0

    while True:
        opcode = program[pc] % 100

        if opcode == 1:
            param_modes = str(program[pc] // 100).zfill(3)[::-1]
            param1 = program[pc + 1] if param_modes[0] == '1' else program[program[pc + 1]]
            param2 = program[pc + 2] if param_modes[1] == '1' else program[program[pc + 2]]
            program[program[pc + 3]] = param1 + param2
            pc += 4
        elif opcode == 2:
            param_modes = str(program[pc] // 100).zfill(3)[::-1]
            param1 = program[pc + 1] if param_modes[0] == '1' else program[program[pc + 1]]
            param2 = program[pc + 2] if param_modes[1] == '1' else program[program[pc + 2]]
            program[program[pc + 3]] = param1 * param2
            pc += 4
        elif opcode == 3:
            program[program[pc + 1]] = inputs[ip]
            ip += 1
            pc += 2
        elif opcode == 4:
            param_modes = str(program[pc] // 100).zfill(3)[::-1]
            output = program[pc + 1] if param_modes[0] == '1' else program[program[pc + 1]]
            pc += 2
            return output
        elif opcode == 99:
            break

def count_tractor_beam(program):
    count = 0

    for x in range(50):
        for y in range(50):
            output = run_program(program.copy(), [x, y])
            count += output

    return count

with open('input.txt', 'r') as file:
    program = list(map(int, file.read().strip().split(',')))

result = count_tractor_beam(program)
print(result)
",2.0
324,2019,19,2,part1_failed,,12201460,,,
325,2019,20,1,syntax_error,,608,"  File ""/tmp/tmpzctwtjnl/tmp.py"", line 1
    To solve this problem, we need to implement a breadth-first search algorithm to find the shortest path from the start tile (`AA`) to the end tile (`ZZ`) in the given maze.
       ^
SyntaxError: invalid syntax
","To solve this problem, we need to implement a breadth-first search algorithm to find the shortest path from the start tile (`AA`) to the end tile (`ZZ`) in the given maze.

We can represent the maze as a 2D grid, where each cell represents a tile. The value of each cell can be either a wall (`#`), an open passage (`.`), or a label (`A-Z`).

First, we need to parse the input file and create a representation of the maze. We'll store the maze as a dictionary with coordinates as keys and cell values as values.

Next, we'll identify all the portals in the maze and create a dictionary that maps each portal label to its corresponding coordinates. We'll also create a reverse mapping that maps each coordinate to its corresponding portal label.

Then, we'll implement the breadth-first search algorithm to find the shortest path from the start tile to the end tile. We'll maintain a queue of tiles to visit and a set of visited tiles to avoid revisiting the same tile multiple times. We'll also maintain a distance dictionary to keep track of the distance from the start tile to each visited tile.

Finally, we'll output the distance from the start tile to the end tile.

Here's the code to solve the problem:",2.0
326,2019,20,2,part1_failed,,6706,,,
327,2019,21,1,runtime_error,,19358688,"Traceback (most recent call last):
  File ""/tmp/tmpltiyh0e6/tmp.py"", line 37, in <module>
    springscript_code = generate_springscript_code(input_str)
  File ""/tmp/tmpltiyh0e6/tmp.py"", line 16, in generate_springscript_code
    register1 = words[1]
IndexError: list index out of range
","
def generate_springscript_code(input_str):
    # Split the input into lines
    lines = input_str.strip().split(""\n"")

    # Initialize an empty list to store the springscript instructions
    springscript_code = []

    # Generate the springscript instructions based on the input
    for line in lines:
        # Split each line into words
        words = line.split()

        # Extract the registers and operator from the line
        operator = words[0]
        register1 = words[1]
        register2 = words[2]

        # Generate the springscript instruction
        springscript_instruction = f""{operator} {register1} {register2}""
        springscript_code.append(springscript_instruction)

    # Add the final instruction to start the surveying
    springscript_code.append(""WALK"")

    # Join the springscript instructions with newlines
    springscript_code_str = ""\n"".join(springscript_code)

    return springscript_code_str


# Read the input from the file
with open(""input.txt"", ""r"") as file:
    input_str = file.read()

# Generate the springscript code
springscript_code = generate_springscript_code(input_str)

# Print the generated code
print(springscript_code)
",2.0
328,2019,21,2,part1_failed,,1141236756,,,
329,2019,22,1,no_error,"1252
",1252,,"
def deal_into_new_stack(deck):
    return deck[::-1]


def cut_cards(deck, N):
    return deck[N:] + deck[:N]


def deal_with_increment(deck, N):
    new_deck = [None] * len(deck)
    pos = 0
    for card in deck:
        new_deck[pos] = card
        pos = (pos + N) % len(deck)
    return new_deck


# Read input from file
with open('input.txt', 'r') as file:
    input_lines = file.read().strip().split('\n')

# Initialize the starting deck
deck = list(range(10007))

# Apply each shuffle technique
for line in input_lines:
    if line.startswith('deal into new stack'):
        deck = deal_into_new_stack(deck)
    elif line.startswith('cut'):
        N = int(line.split(' ')[-1])
        deck = cut_cards(deck, N)
    elif line.startswith('deal with increment'):
        N = int(line.split(' ')[-1])
        deck = deal_with_increment(deck, N)

# Find the position of card 2019
position = deck.index(2019)
print(position)
",1.0
330,2019,22,2,wrong_output,"47180291375364
",46116012647793,,"
def deal_into_new_stack(position, deck_size):
    return deck_size - 1 - position


def cut_cards(position, N, deck_size):
    return (position + N) % deck_size


def deal_with_increment(position, N, deck_size):
    return (position * N) % deck_size


# Read input from file
with open('input.txt', 'r') as file:
    input_lines = file.read().strip().split('\n')

# Define the deck size and number of iterations
deck_size = 119315717514047
iterations = 101741582076661

# Reverse the shuffle process
position = 2020
for line in reversed(input_lines):
    if line.startswith('deal into new stack'):
        position = deal_into_new_stack(position, deck_size)
    elif line.startswith('cut'):
        N = int(line.split(' ')[-1])
        position = cut_cards(position, -N, deck_size)
    elif line.startswith('deal with increment'):
        N = int(line.split(' ')[-1])
        position = deal_with_increment(position, pow(N, deck_size - 2, deck_size), deck_size)

# Apply the reverse shuffle process multiple times
increment = (position - 2020) % deck_size
offset = (2020 - increment * pow(position, iterations * (deck_size - 2), deck_size)) % deck_size

# Calculate the number on the card in position 2020
number = (offset + increment * 2020) % deck_size

print(number)
",2.0
331,2019,23,1,syntax_error,,24922,"  File ""/tmp/tmpfu7d9iu1/tmp.py"", line 1
    I will start by reading the input from the 'input.txt' file.
      ^
SyntaxError: invalid syntax
",I will start by reading the input from the 'input.txt' file.,2.0
332,2019,23,2,part1_failed,,19478,,,
333,2019,24,1,no_error,"1151290
",1151290,,"
def calculate_biodiversity_rating(grid):
    rating = 0
    power_of_two = 1
    for row in grid:
        for tile in row:
            if tile == '#':
                rating += power_of_two
            power_of_two *= 2
    return rating

def update_grid(grid):
    new_grid = [['.' for _ in range(5)] for _ in range(5)]
    for i in range(5):
        for j in range(5):
            adjacent_bugs = 0
            if i > 0 and grid[i - 1][j] == '#':
                adjacent_bugs += 1
            if i < 4 and grid[i + 1][j] == '#':
                adjacent_bugs += 1
            if j > 0 and grid[i][j - 1] == '#':
                adjacent_bugs += 1
            if j < 4 and grid[i][j + 1] == '#':
                adjacent_bugs += 1
            if grid[i][j] == '#' and adjacent_bugs != 1:
                new_grid[i][j] = '.'
            elif grid[i][j] == '.' and (adjacent_bugs == 1 or adjacent_bugs == 2):
                new_grid[i][j] = '#'
            else:
                new_grid[i][j] = grid[i][j]
    return new_grid

def find_first_repeated_layout(grid):
    seen_layouts = set()
    while True:
        rating = calculate_biodiversity_rating(grid)
        if rating in seen_layouts:
            return rating
        seen_layouts.add(rating)
        grid = update_grid(grid)

# Read the input grid from the file
with open('input.txt', 'r') as file:
    grid = [list(line.strip()) for line in file]

# Find the first repeated layout
result = find_first_repeated_layout(grid)
print(result)
",1.0
334,2019,24,2,runtime_error,,1953,"Traceback (most recent call last):
  File ""/tmp/tmpzpdpknsx/tmp.py"", line 80, in <module>
    grid_levels = update_grid_levels(grid_levels)
  File ""/tmp/tmpzpdpknsx/tmp.py"", line 55, in update_grid_levels
    adjacent_bugs = count_adjacent_bugs(grid_levels, level, i, j)
  File ""/tmp/tmpzpdpknsx/tmp.py"", line 16, in count_adjacent_bugs
    for adjacent_tile in get_adjacent_tiles(grid_levels[level], i, j):
KeyError: -1
","
def get_adjacent_tiles(grid, i, j):
    adjacent_tiles = []
    if i > 0:
        adjacent_tiles.append((i - 1, j))
    if i < 4:
        adjacent_tiles.append((i + 1, j))
    if j > 0:
        adjacent_tiles.append((i, j - 1))
    if j < 4:
        adjacent_tiles.append((i, j + 1))
    return adjacent_tiles

def count_adjacent_bugs(grid_levels, level, i, j):
    adjacent_bugs = 0
    for adjacent_tile in get_adjacent_tiles(grid_levels[level], i, j):
        if grid_levels[level][adjacent_tile[0]][adjacent_tile[1]] == '#':
            adjacent_bugs += 1
    if i == 0 and (1, 2) in get_adjacent_tiles(grid_levels[level - 1], 2, 2):
        adjacent_bugs += 1
    if i == 4 and (3, 2) in get_adjacent_tiles(grid_levels[level - 1], 2, 2):
        adjacent_bugs += 1
    if j == 0 and (2, 1) in get_adjacent_tiles(grid_levels[level - 1], 2, 2):
        adjacent_bugs += 1
    if j == 4 and (2, 3) in get_adjacent_tiles(grid_levels[level - 1], 2, 2):
        adjacent_bugs += 1
    if i == 2 and j == 1:
        for k in range(5):
            if grid_levels[level + 1][k][0] == '#':
                adjacent_bugs += 1
    if i == 2 and j == 3:
        for k in range(5):
            if grid_levels[level + 1][k][4] == '#':
                adjacent_bugs += 1
    if i == 1 and j == 2:
        for k in range(5):
            if grid_levels[level + 1][0][k] == '#':
                adjacent_bugs += 1
    if i == 3 and j == 2:
        for k in range(5):
            if grid_levels[level + 1][4][k] == '#':
                adjacent_bugs += 1
    return adjacent_bugs

def update_grid_levels(grid_levels):
    new_grid_levels = {}
    min_level = min(grid_levels.keys())
    max_level = max(grid_levels.keys())
    for level in range(min_level - 1, max_level + 2):
        new_grid_levels[level] = [['.' for _ in range(5)] for _ in range(5)]
        for i in range(5):
            for j in range(5):
                if i == 2 and j == 2:
                    continue
                adjacent_bugs = count_adjacent_bugs(grid_levels, level, i, j)
                if grid_levels[level][i][j] == '#' and adjacent_bugs != 1:
                    new_grid_levels[level][i][j] = '.'
                elif grid_levels[level][i][j] == '.' and (adjacent_bugs == 1 or adjacent_bugs == 2):
                    new_grid_levels[level][i][j] = '#'
                else:
                    new_grid_levels[level][i][j] = grid_levels[level][i][j]
    return new_grid_levels

def count_total_bugs(grid_levels):
    total_bugs = 0
    for level in grid_levels:
        for row in grid_levels[level]:
            total_bugs += row.count('#')
    return total_bugs

# Read the input grid from the file
with open('input.txt', 'r') as file:
    input_grid = [list(line.strip()) for line in file]

# Initialize the grid levels dictionary with level 0 containing the input grid
grid_levels = {0: input_grid}

# Simulate 200 minutes of the recursive grid
for _ in range(200):
    grid_levels = update_grid_levels(grid_levels)

# Count the total number of bugs present
result = count_total_bugs(grid_levels)
print(result)
",2.0
335,2019,25,1,runtime_error,,25166400,"Traceback (most recent call last):
  File ""/tmp/tmpjnpuopb5/tmp.py"", line 87, in <module>
    password = find_password(program)
  File ""/tmp/tmpjnpuopb5/tmp.py"", line 53, in find_password
    visited, items = explore_ship(program)
  File ""/tmp/tmpjnpuopb5/tmp.py"", line 48, in explore_ship
    explore_room()
  File ""/tmp/tmpjnpuopb5/tmp.py"", line 27, in explore_room
    response = send_command(program, 'inv')
  File ""/tmp/tmpjnpuopb5/tmp.py"", line 5, in send_command
    intcode = Intcode(program)
NameError: name 'Intcode' is not defined
","
def send_command(program, command):
    input_values = [ord(c) for c in command] + [10]  # Convert command to ASCII codes and append newline
    output = []
    intcode = Intcode(program)
    intcode.run(inputs=input_values, output=output)  # Run the Intcode program with the command as input
    return ''.join(chr(c) for c in output)


def explore_ship(program):
    directions = ['north', 'south', 'east', 'west']
    visited = set()
    items = set()

    def backtrack(direction):
        if direction == 'north':
            return 'south'
        elif direction == 'south':
            return 'north'
        elif direction == 'east':
            return 'west'
        elif direction == 'west':
            return 'east'

    def explore_room():
        nonlocal visited
        response = send_command(program, 'inv')
        if 'Command?' in response:
            # Room is already explored
            return

        visited.add(current_room)

        # Check for items in the room
        if 'Items here:' in response:
            lines = response.splitlines()
            item_start = lines.index('Items here:') + 1
            item_end = lines.index('', item_start)
            items.update(lines[item_start:item_end])

        # Recursively explore adjacent rooms
        for direction in directions:
            next_room = send_command(program, direction)
            if next_room not in visited:
                explore_room()
                send_command(program, backtrack(direction))  # Backtrack to the current room

    explore_room()
    return visited, items


def find_password(program):
    visited, items = explore_ship(program)

    def try_combinations(items_to_try):
        if len(items_to_try) == 0:
            # No more items to try, return
            return

        for item in items_to_try:
            # Try taking the item
            send_command(program, f'take {item}')

            # Try dropping the item in the pressure-sensitive floor room
            response = send_command(program, 'south')
            if 'Alert!' not in response:
                # Found the correct combination, extract the password
                password = response.splitlines()[-1]
                return password.strip()

            # Try combinations without the current item
            password = try_combinations(items_to_try - {item})
            if password:
                return password

            # Drop the item and backtrack
            send_command(program, f'drop {item}')
            send_command(program, 'north')

    password = try_combinations(items)
    return password


with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))

password = find_password(program)
print(f""The password for the main airlock is: {password}"")
",2.0
336,2019,25,2,part1_failed,,,,,
337,2020,1,1,no_error,"928896
",928896,,"import itertools

def find_expense_report(expenses):
    for expense1, expense2 in itertools.combinations(expenses, 2):
        if expense1 + expense2 == 2020:
            return expense1 * expense2

# Read input from file
with open('input.txt', 'r') as file:
    expenses = [int(line.strip()) for line in file]

result = find_expense_report(expenses)
print(result)",0.0
338,2020,1,2,no_error,"295668576
",295668576,,"import itertools

def find_expense_report(expenses):
    for expense1, expense2, expense3 in itertools.combinations(expenses, 3):
        if expense1 + expense2 + expense3 == 2020:
            return expense1 * expense2 * expense3

# Read input from file
with open('input.txt', 'r') as file:
    expenses = [int(line.strip()) for line in file]

result = find_expense_report(expenses)
print(result)",0.0
341,2020,2,1,no_error,"434
",434,,"
def parse_line(line):
    parts = line.split(':')
    policy = parts[0].strip()
    password = parts[1].strip()
    return policy, password

def is_password_valid(policy, password):
    range_str, letter = policy.split()
    min_occurrences, max_occurrences = map(int, range_str.split('-'))
    count = password.count(letter)
    return min_occurrences <= count <= max_occurrences

def count_valid_passwords(lines):
    count = 0
    for line in lines:
        policy, password = parse_line(line)
        if is_password_valid(policy, password):
            count += 1
    return count

with open('input.txt', 'r') as file:
    lines = file.readlines()
    valid_passwords = count_valid_passwords(lines)
    print(valid_passwords)
",2.0
342,2020,2,2,runtime_error,,509,"Traceback (most recent call last):
  File ""/tmp/tmpgedd_s2s/tmp.py"", line 10, in <module>
    valid_passwords = count_valid_passwords(lines)
NameError: name 'count_valid_passwords' is not defined
","
def is_password_valid(policy, password):
    positions_str, letter = policy.split()
    positions = map(int, positions_str.split('-'))
    count = sum(password[pos - 1] == letter for pos in positions)
    return count == 1

with open('input.txt', 'r') as file:
    lines = file.readlines()
    valid_passwords = count_valid_passwords(lines)
    print(valid_passwords)
",2.0
343,2020,3,1,no_error,"292
",292,,"# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Remove newline characters from the end of each line
lines = [line.strip() for line in lines]

# Count the number of trees encountered
tree_count = 0
x = 0
y = 0
width = len(lines[0])
height = len(lines)

while y < height:
    if lines[y][x % width] == '#':
        tree_count += 1
    x += 3
    y += 1

print(tree_count)",0.0
344,2020,3,2,no_error,"9354744432
",9354744432,,"# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Remove newline characters from the end of each line
lines = [line.strip() for line in lines]

# Calculate the product of the number of trees encountered on each slope
slopes = [(1, 1), (3, 1), (5, 1), (7, 1), (1, 2)]
tree_product = 1

for slope in slopes:
    tree_count = 0
    x = 0
    y = 0
    width = len(lines[0])
    height = len(lines)

    while y < height:
        if lines[y][x % width] == '#':
            tree_count += 1
        x += slope[0]
        y += slope[1]

    tree_product *= tree_count

print(tree_product)",0.0
347,2020,4,1,no_error,"233
",233,,"
def is_valid_passport(passport):
    required_fields = {'byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid'}
    fields = passport.split()
    field_names = set([field.split(':')[0] for field in fields])
    return required_fields.issubset(field_names)

def count_valid_passports(batch_file):
    passports = batch_file.split('\n\n')
    count = 0
    for passport in passports:
        if is_valid_passport(passport):
            count += 1
    return count

with open('input.txt', 'r') as file:
    batch_file = file.read()
    valid_passports = count_valid_passports(batch_file)
    print(valid_passports)
",0.0
348,2020,4,2,no_error,"111
",111,,"
import re

def is_valid_passport(passport):
    required_fields = {'byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid'}
    fields = passport.split()
    field_names = set([field.split(':')[0] for field in fields])
    if not required_fields.issubset(field_names):
        return False
    
    for field in fields:
        key, value = field.split(':')
        if key == 'byr':
            if not re.match(r'^\d{4}$', value):
                return False
            if not 1920 <= int(value) <= 2002:
                return False
        elif key == 'iyr':
            if not re.match(r'^\d{4}$', value):
                return False
            if not 2010 <= int(value) <= 2020:
                return False
        elif key == 'eyr':
            if not re.match(r'^\d{4}$', value):
                return False
            if not 2020 <= int(value) <= 2030:
                return False
        elif key == 'hgt':
            if not re.match(r'^\d+(cm|in)$', value):
                return False
            height = int(value[:-2])
            unit = value[-2:]
            if unit == 'cm':
                if not 150 <= height <= 193:
                    return False
            elif unit == 'in':
                if not 59 <= height <= 76:
                    return False
        elif key == 'hcl':
            if not re.match(r'^#[0-9a-f]{6}$', value):
                return False
        elif key == 'ecl':
            if value not in {'amb', 'blu', 'brn', 'gry', 'grn', 'hzl', 'oth'}:
                return False
        elif key == 'pid':
            if not re.match(r'^\d{9}$', value):
                return False
    
    return True

def count_valid_passports(batch_file):
    passports = batch_file.split('\n\n')
    count = 0
    for passport in passports:
        if is_valid_passport(passport):
            count += 1
    return count

with open('input.txt', 'r') as file:
    batch_file = file.read()
    valid_passports = count_valid_passports(batch_file)
    print(valid_passports)
",0.0
351,2020,5,1,no_error,"987
",987,,"
def calculate_seat_id(boarding_pass):
    row = int(boarding_pass[:7].replace('F', '0').replace('B', '1'), 2)
    column = int(boarding_pass[7:].replace('L', '0').replace('R', '1'), 2)
    return row * 8 + column

def find_highest_seat_id(boarding_passes):
    highest_seat_id = 0
    for boarding_pass in boarding_passes:
        seat_id = calculate_seat_id(boarding_pass)
        highest_seat_id = max(highest_seat_id, seat_id)
    return highest_seat_id

with open('input.txt', 'r') as file:
    boarding_passes = [line.strip() for line in file.readlines()]

highest_seat_id = find_highest_seat_id(boarding_passes)
print(highest_seat_id)
",1.0
352,2020,5,2,no_error,"603
",603,,"
def calculate_seat_id(boarding_pass):
    row = int(boarding_pass[:7].replace('F', '0').replace('B', '1'), 2)
    column = int(boarding_pass[7:].replace('L', '0').replace('R', '1'), 2)
    return row * 8 + column

def find_missing_seat_id(boarding_passes):
    seat_ids = set()
    for boarding_pass in boarding_passes:
        seat_id = calculate_seat_id(boarding_pass)
        seat_ids.add(seat_id)
    
    for seat_id in range(min(seat_ids), max(seat_ids)):
        if seat_id not in seat_ids:
            return seat_id

with open('input.txt', 'r') as file:
    boarding_passes = [line.strip() for line in file.readlines()]

missing_seat_id = find_missing_seat_id(boarding_passes)
print(missing_seat_id)
",0.0
355,2020,6,1,no_error,"6775
",6775,,"
def count_yes_answers():
    with open('input.txt', 'r') as file:
        groups = file.read().split('\n\n')

    total_count = 0
    for group in groups:
        group_answers = set()
        for person_answers in group.split('\n'):
            group_answers.update(person_answers)
        total_count += len(group_answers)

    return total_count

print(count_yes_answers())
",0.0
356,2020,6,2,no_error,"3356
",3356,,"
def count_all_yes_answers():
    with open('input.txt', 'r') as file:
        groups = file.read().split('\n\n')

    total_count = 0
    for group in groups:
        group_answers = {}
        people = group.split('\n')
        for person_answers in people:
            for answer in person_answers:
                group_answers[answer] = group_answers.get(answer, 0) + 1
        total_count += sum(1 for answer_count in group_answers.values() if answer_count == len(people))

    return total_count

print(count_all_yes_answers())
",0.0
359,2020,7,1,no_error,"226
",226,,"
def can_contain_shiny_gold(bag_rules, bag_color):
    if 'shiny gold' in bag_rules[bag_color]:
        return True
    for color in bag_rules[bag_color]:
        if can_contain_shiny_gold(bag_rules, color):
            return True
    return False

def count_valid_bags(rules):
    bag_rules = {}
    for rule in rules:
        rule = rule.replace(' bags', '').replace(' bag', '').replace('.', '')
        color, contents = rule.split(' contain ')
        bag_rules[color] = {}
        if contents != 'no other':
            for bag in contents.split(', '):
                quantity, bag_color = bag.split(' ', 1)
                bag_rules[color][bag_color] = int(quantity)
    
    count = 0
    for color in bag_rules:
        if can_contain_shiny_gold(bag_rules, color):
            count += 1
    
    return count

with open('input.txt', 'r') as file:
    rules = file.read().splitlines()

print(count_valid_bags(rules))
",2.0
360,2020,7,2,no_error,"9569
",9569,,"
def count_inner_bags(bag_rules, bag_color):
    count = 0
    for color, quantity in bag_rules[bag_color].items():
        count += quantity + quantity * count_inner_bags(bag_rules, color)
    return count

def count_required_bags(rules):
    bag_rules = {}
    for rule in rules:
        rule = rule.replace(' bags', '').replace(' bag', '').replace('.', '')
        color, contents = rule.split(' contain ')
        bag_rules[color] = {}
        if contents != 'no other':
            for bag in contents.split(', '):
                quantity, bag_color = bag.split(' ', 1)
                bag_rules[color][bag_color] = int(quantity)
    
    return count_inner_bags(bag_rules, 'shiny gold')

with open('input.txt', 'r') as file:
    rules = file.read().splitlines()

print(count_required_bags(rules))
",0.0
363,2020,8,1,no_error,1384,1384,,"
def run_boot_code(instructions):
    accumulator = 0
    visited = set()
    pc = 0

    while pc < len(instructions):
        if pc in visited:
            return accumulator

        visited.add(pc)
        instruction, argument = instructions[pc].split()

        if instruction == 'acc':
            accumulator += int(argument)
            pc += 1
        elif instruction == 'jmp':
            pc += int(argument)
        elif instruction == 'nop':
            pc += 1

    return accumulator


def main():
    with open('input.txt', 'r') as file:
        instructions = file.read().splitlines()

    accumulator = run_boot_code(instructions)
    print(f""The value in the accumulator before the infinite loop is: {accumulator}"")


if __name__ == '__main__':
    main()
",0.0
364,2020,8,2,no_error,761,761,,"
def fix_boot_code(instructions):
    for i in range(len(instructions)):
        modified_instructions = list(instructions)
        if 'jmp' in modified_instructions[i]:
            modified_instructions[i] = modified_instructions[i].replace('jmp', 'nop')
        elif 'nop' in modified_instructions[i]:
            modified_instructions[i] = modified_instructions[i].replace('nop', 'jmp')

        accumulator, terminated = run_boot_code(modified_instructions)
        if terminated:
            return accumulator

    return None


def run_boot_code(instructions):
    accumulator = 0
    visited = set()
    pc = 0

    while pc < len(instructions):
        if pc in visited:
            return accumulator, False

        visited.add(pc)
        instruction, argument = instructions[pc].split()

        if instruction == 'acc':
            accumulator += int(argument)
            pc += 1
        elif instruction == 'jmp':
            pc += int(argument)
        elif instruction == 'nop':
            pc += 1

    return accumulator, True


def main():
    with open('input.txt', 'r') as file:
        instructions = file.read().splitlines()

    accumulator = fix_boot_code(instructions)
    print(f""The value of the accumulator after the program terminates is: {accumulator}"")


if __name__ == '__main__':
    main()
",0.0
367,2020,9,1,no_error,"258585477
",258585477,,"
def find_invalid_number(preamble, numbers):
    for i in range(preamble, len(numbers)):
        target = numbers[i]
        found = False
        for j in range(i - preamble, i):
            for k in range(j + 1, i):
                if numbers[j] + numbers[k] == target:
                    found = True
                    break
            if found:
                break
        if not found:
            return target

def main():
    with open('input.txt', 'r') as file:
        numbers = [int(line.strip()) for line in file]

    preamble = 25
    invalid_number = find_invalid_number(preamble, numbers)
    print(invalid_number)

if __name__ == '__main__':
    main()
",0.0
368,2020,9,2,runtime_error,,36981213,"Traceback (most recent call last):
  File ""/tmp/tmpwhsln2l2/tmp.py"", line 22, in <module>
    main()
  File ""/tmp/tmpwhsln2l2/tmp.py"", line 17, in main
    invalid_number = find_invalid_number(preamble, numbers)
NameError: name 'find_invalid_number' is not defined
","
def find_contiguous_set(numbers, target):
    for i in range(len(numbers)):
        for j in range(i + 2, len(numbers)):
            if sum(numbers[i:j+1]) == target:
                return numbers[i:j+1]

def find_encryption_weakness(numbers, target):
    contiguous_set = find_contiguous_set(numbers, target)
    return min(contiguous_set) + max(contiguous_set)

def main():
    with open('input.txt', 'r') as file:
        numbers = [int(line.strip()) for line in file]

    preamble = 25
    invalid_number = find_invalid_number(preamble, numbers)
    encryption_weakness = find_encryption_weakness(numbers, invalid_number)
    print(encryption_weakness)

if __name__ == '__main__':
    main()
",2.0
369,2020,10,1,no_error,"2263
",2263,,"def count_joltage_differences(adapters):
    adapters.sort()
    joltage_diff_count = {1: 0, 3: 0}
    curr_joltage = 0
    for adapter in adapters:
        diff = adapter - curr_joltage
        joltage_diff_count[diff] += 1
        curr_joltage = adapter
    joltage_diff_count[3] += 1
    return joltage_diff_count[1] * joltage_diff_count[3]

adapters = []

with open('input.txt', 'r') as file:
    for line in file:
        adapters.append(int(line.strip()))

result = count_joltage_differences(adapters)
print(result)",0.0
370,2020,10,2,no_error,"396857386627072
",396857386627072,,"def count_arrangements(adapters):
    adapters.sort()
    arrangements = [0] * (adapters[-1] + 1)
    arrangements[0] = 1
    for adapter in adapters:
        arrangements[adapter] = arrangements[adapter - 1] + arrangements[adapter - 2] + arrangements[adapter - 3]
    return arrangements[-1]

adapters = []

with open('input.txt', 'r') as file:
    for line in file:
        adapters.append(int(line.strip()))

result = count_arrangements(adapters)
print(result)",1.0
372,2020,11,1,no_error,2368,2368,,"
# Function to read the input file and return the initial seating area
def read_input(file_name):
    seating_area = []
    with open(file_name, 'r') as file:
        for line in file:
            seating_area.append(list(line.strip()))
    return seating_area

# Function to apply the seating rules to a given seat and return its new state
def apply_rules(seating_area, row, col):
    seat = seating_area[row][col]
    if seat == 'L' and count_adjacent_occupied(seating_area, row, col) == 0:
        return '#'
    elif seat == '#' and count_adjacent_occupied(seating_area, row, col) >= 4:
        return 'L'
    else:
        return seat

# Function to count the number of occupied seats adjacent to a given seat
def count_adjacent_occupied(seating_area, row, col):
    count = 0
    for i in range(max(0, row-1), min(row+2, len(seating_area))):
        for j in range(max(0, col-1), min(col+2, len(seating_area[0]))):
            if i == row and j == col:
                continue
            if seating_area[i][j] == '#':
                count += 1
    return count

# Function to apply the seating rules to the entire seating area and return the new seating area
def apply_seating_rules(seating_area):
    new_seating_area = [row[:] for row in seating_area]  # Create a copy of the seating area
    changes = 0  # Variable to keep track of the changes in the seating area
    for row in range(len(seating_area)):
        for col in range(len(seating_area[0])):
            new_state = apply_rules(seating_area, row, col)
            if new_state != seating_area[row][col]:
                changes += 1
            new_seating_area[row][col] = new_state
    return new_seating_area, changes

# Main function to solve the task
def main():
    seating_area = read_input('input.txt')
    changes = 1
    while changes > 0:
        seating_area, changes = apply_seating_rules(seating_area)
    occupied_seats = sum(row.count('#') for row in seating_area)
    print(""Number of occupied seats:"", occupied_seats)

if __name__ == '__main__':
    main()
",0.0
373,2020,11,2,no_error,2124,2124,,"
# Function to read the input file and return the initial seating area
def read_input(file_name):
    seating_area = []
    with open(file_name, 'r') as file:
        for line in file:
            seating_area.append(list(line.strip()))
    return seating_area

# Function to apply the seating rules to a given seat and return its new state
def apply_rules(seating_area, row, col):
    seat = seating_area[row][col]
    if seat == 'L' and count_visible_occupied(seating_area, row, col) == 0:
        return '#'
    elif seat == '#' and count_visible_occupied(seating_area, row, col) >= 5:
        return 'L'
    else:
        return seat

# Function to count the number of occupied seats visible from a given seat in all eight directions
def count_visible_occupied(seating_area, row, col):
    count = 0
    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
    for dx, dy in directions:
        x, y = row + dx, col + dy
        while 0 <= x < len(seating_area) and 0 <= y < len(seating_area[0]):
            if seating_area[x][y] == 'L':
                break
            if seating_area[x][y] == '#':
                count += 1
                break
            x += dx
            y += dy
    return count

# Function to apply the seating rules to the entire seating area and return the new seating area
def apply_seating_rules(seating_area):
    new_seating_area = [row[:] for row in seating_area]  # Create a copy of the seating area
    changes = 0  # Variable to keep track of the changes in the seating area
    for row in range(len(seating_area)):
        for col in range(len(seating_area[0])):
            new_state = apply_rules(seating_area, row, col)
            if new_state != seating_area[row][col]:
                changes += 1
            new_seating_area[row][col] = new_state
    return new_seating_area, changes

# Main function to solve the task
def main():
    seating_area = read_input('input.txt')
    changes = 1
    while changes > 0:
        seating_area, changes = apply_seating_rules(seating_area)
    occupied_seats = sum(row.count('#') for row in seating_area)
    print(""Number of occupied seats:"", occupied_seats)

if __name__ == '__main__':
    main()
",0.0
376,2020,12,1,no_error,"962
",962,,"
with open('input.txt', 'r') as f:
    instructions = [(line[0], int(line[1:])) for line in f]


def navigate(instructions):
    x, y = 0, 0  # ship's position
    dx, dy = 1, 0  # ship's direction (facing east initially)

    for action, value in instructions:
        if action == 'N':
            y += value
        elif action == 'S':
            y -= value
        elif action == 'E':
            x += value
        elif action == 'W':
            x -= value
        elif action == 'L':
            for _ in range(value // 90):
                dx, dy = -dy, dx
        elif action == 'R':
            for _ in range(value // 90):
                dx, dy = dy, -dx
        elif action == 'F':
            x += dx * value
            y += dy * value

    return abs(x) + abs(y)


print(navigate(instructions))
",1.0
377,2020,12,2,no_error,"56135
",56135,,"
with open('input.txt', 'r') as f:
    instructions = [(line[0], int(line[1:])) for line in f]


def navigate(instructions):
    ship_x, ship_y = 0, 0  # ship's position
    waypoint_x, waypoint_y = 10, 1  # waypoint's relative position

    for action, value in instructions:
        if action == 'N':
            waypoint_y += value
        elif action == 'S':
            waypoint_y -= value
        elif action == 'E':
            waypoint_x += value
        elif action == 'W':
            waypoint_x -= value
        elif action == 'L':
            for _ in range(value // 90):
                waypoint_x, waypoint_y = -waypoint_y, waypoint_x
        elif action == 'R':
            for _ in range(value // 90):
                waypoint_x, waypoint_y = waypoint_y, -waypoint_x
        elif action == 'F':
            ship_x += waypoint_x * value
            ship_y += waypoint_y * value

    return abs(ship_x) + abs(ship_y)


print(navigate(instructions))
",0.0
379,2020,13,1,no_error,"2095
",2095,,"
def calculate_wait_time(earliest_timestamp, bus_id):
    wait_time = bus_id - (earliest_timestamp % bus_id)
    return wait_time

def find_earliest_bus(earliest_timestamp, bus_ids):
    earliest_bus_id = None
    shortest_wait_time = float('inf')

    for bus_id in bus_ids:
        if bus_id == 'x':
            continue

        bus_id = int(bus_id)
        wait_time = calculate_wait_time(earliest_timestamp, bus_id)

        if wait_time < shortest_wait_time:
            earliest_bus_id = bus_id
            shortest_wait_time = wait_time

    return earliest_bus_id * shortest_wait_time

# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()
    earliest_timestamp = int(lines[0].strip())
    bus_ids = lines[1].strip().split(',')

# Find the earliest bus and wait time
result = find_earliest_bus(earliest_timestamp, bus_ids)
print(result)
",0.0
380,2020,13,2,no_error,"598411311431841
",598411311431841,,"
from math import prod

def find_earliest_timestamp(bus_ids):
    remainders = []
    moduli = []

    for i, bus_id in enumerate(bus_ids):
        if bus_id == 'x':
            continue

        bus_id = int(bus_id)
        remainders.append((bus_id - i) % bus_id)
        moduli.append(bus_id)

    timestamp = chinese_remainder(remainders, moduli)
    return timestamp

def chinese_remainder(remainders, moduli):
    product = prod(moduli)
    result = 0

    for remainder, modulus in zip(remainders, moduli):
        p = product // modulus
        result += remainder * modular_inverse(p, modulus) * p

    return result % product

def modular_inverse(a, m):
    # Extended Euclidean Algorithm
    if m == 1:
        return 1

    m0 = m
    y = 0
    x = 1

    while a > 1:
        q = a // m
        a, m = m, a % m
        x, y = y, x - q * y

    if x < 0:
        x += m0

    return x

# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()
    bus_ids = lines[1].strip().split(',')

# Find the earliest timestamp
result = find_earliest_timestamp(bus_ids)
print(result)
",1.0
382,2020,14,1,no_error,14553106347726,14553106347726,,"
def apply_mask(mask, value):
    # Convert the value to binary and pad it with leading zeros
    bin_value = list(format(value, '036b'))
    
    # Apply the mask
    for i in range(len(mask)):
        if mask[i] != 'X':
            bin_value[i] = mask[i]
    
    # Convert the binary value back to an integer
    return int(''.join(bin_value), 2)

def execute_program(program):
    memory = {}
    mask = ''
    
    for line in program:
        if line.startswith('mask'):
            mask = line.split(' = ')[1]
        else:
            address, value = line.split(' = ')
            address = int(address[4:-1])
            value = int(value)
            memory[address] = apply_mask(mask, value)
    
    return sum(memory.values())

def main():
    with open('input.txt', 'r') as file:
        program = [line.strip() for line in file.readlines()]
    
    sum_of_values = execute_program(program)
    print(f""The sum of all values left in memory is: {sum_of_values}"")

if __name__ == '__main__':
    main()
",0.0
383,2020,14,2,no_error,2737766154126,2737766154126,,"
def apply_mask_v2(mask, address):
    # Convert the address to binary and pad it with leading zeros
    bin_address = list(format(address, '036b'))
    
    # Apply the mask
    for i in range(len(mask)):
        if mask[i] == '1':
            bin_address[i] = '1'
        elif mask[i] == 'X':
            bin_address[i] = 'X'
    
    # Generate all possible addresses by replacing floating bits with all combinations of 0s and 1s
    addresses = []
    floating_bits = [i for i, bit in enumerate(bin_address) if bit == 'X']
    num_combinations = 2 ** len(floating_bits)
    
    for i in range(num_combinations):
        combination = list(format(i, f'0{len(floating_bits)}b'))
        new_address = bin_address.copy()
        
        for j, bit in enumerate(combination):
            new_address[floating_bits[j]] = bit
        
        addresses.append(int(''.join(new_address), 2))
    
    return addresses

def execute_program_v2(program):
    memory = {}
    mask = ''
    
    for line in program:
        if line.startswith('mask'):
            mask = line.split(' = ')[1]
        else:
            address, value = line.split(' = ')
            address = int(address[4:-1])
            value = int(value)
            addresses = apply_mask_v2(mask, address)
            
            for addr in addresses:
                memory[addr] = value
    
    return sum(memory.values())

def main():
    with open('input.txt', 'r') as file:
        program = [line.strip() for line in file.readlines()]
    
    sum_of_values = execute_program_v2(program)
    print(f""The sum of all values left in memory is: {sum_of_values}"")

if __name__ == '__main__':
    main()
",1.0
385,2020,15,1,no_error,"468
",468,,"
def find_nth_number(starting_numbers, n):
    spoken_numbers = {}
    for turn, number in enumerate(starting_numbers[:-1], start=1):
        spoken_numbers[number] = turn
    
    last_number = starting_numbers[-1]
    for turn in range(len(starting_numbers), n):
        if last_number in spoken_numbers:
            new_number = turn - spoken_numbers[last_number]
        else:
            new_number = 0
        spoken_numbers[last_number] = turn
        last_number = new_number
    
    return last_number


# Read the input
with open('input.txt', 'r') as file:
    starting_numbers = list(map(int, file.read().strip().split(',')))

# Solve the problem
result = find_nth_number(starting_numbers, 2020)
print(result)
",0.0
386,2020,15,2,no_error,"1801753
",1801753,,"
def find_nth_number(starting_numbers, n):
    spoken_numbers = {}
    for turn, number in enumerate(starting_numbers[:-1], start=1):
        spoken_numbers[number] = turn
    
    last_number = starting_numbers[-1]
    for turn in range(len(starting_numbers), n):
        if last_number in spoken_numbers:
            new_number = turn - spoken_numbers[last_number]
        else:
            new_number = 0
        spoken_numbers[last_number] = turn
        last_number = new_number
    
    return last_number


# Read the input
with open('input.txt', 'r') as file:
    starting_numbers = list(map(int, file.read().strip().split(',')))

# Solve the problem
result = find_nth_number(starting_numbers, 30000000)
print(result)
",0.0
389,2020,16,1,no_error,"26026
",26026,,"
def parse_input(input_file):
    with open(input_file, 'r') as file:
        lines = file.read().splitlines()

    rules = {}
    your_ticket = []
    nearby_tickets = []

    # Parse rules
    i = 0
    while lines[i] != '':
        field, ranges = lines[i].split(': ')
        ranges = ranges.split(' or ')
        rules[field] = []
        for r in ranges:
            start, end = map(int, r.split('-'))
            rules[field].append(range(start, end+1))
        i += 1

    # Parse your ticket
    i += 2
    your_ticket = list(map(int, lines[i].split(',')))

    # Parse nearby tickets
    i += 3
    for j in range(i, len(lines)):
        nearby_tickets.append(list(map(int, lines[j].split(','))))

    return rules, your_ticket, nearby_tickets


def is_valid_value(value, rules):
    for ranges in rules.values():
        for r in ranges:
            if value in r:
                return True
    return False


def get_ticket_scanning_error_rate(rules, nearby_tickets):
    error_rate = 0
    for ticket in nearby_tickets:
        for value in ticket:
            if not is_valid_value(value, rules):
                error_rate += value
    return error_rate


# Parse input
rules, _, nearby_tickets = parse_input('input.txt')

# Calculate ticket scanning error rate
error_rate = get_ticket_scanning_error_rate(rules, nearby_tickets)
print(error_rate)
",0.0
390,2020,16,2,runtime_error,,1305243193339,"Traceback (most recent call last):
  File ""/tmp/tmpz4j6v_z3/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np


def parse_input(input_file):
    with open(input_file, 'r') as file:
        lines = file.read().splitlines()

    rules = {}
    your_ticket = []
    nearby_tickets = []

    # Parse rules
    i = 0
    while lines[i] != '':
        field, ranges = lines[i].split(': ')
        ranges = ranges.split(' or ')
        rules[field] = []
        for r in ranges:
            start, end = map(int, r.split('-'))
            rules[field].append(range(start, end+1))
        i += 1

    # Parse your ticket
    i += 2
    your_ticket = list(map(int, lines[i].split(',')))

    # Parse nearby tickets
    i += 3
    for j in range(i, len(lines)):
        nearby_tickets.append(list(map(int, lines[j].split(','))))

    return rules, your_ticket, nearby_tickets


def is_valid_value(value, ranges):
    for r in ranges:
        if value in r:
            return True
    return False


def get_valid_tickets(rules, nearby_tickets):
    valid_tickets = []
    for ticket in nearby_tickets:
        is_valid = True
        for value in ticket:
            if not any(is_valid_value(value, ranges) for ranges in rules.values()):
                is_valid = False
                break
        if is_valid:
            valid_tickets.append(ticket)
    return valid_tickets


def determine_field_order(rules, valid_tickets):
    num_fields = len(rules)
    field_order = [set(rules.keys()) for _ in range(num_fields)]

    for ticket in valid_tickets:
        for i, value in enumerate(ticket):
            for field, ranges in rules.items():
                if not is_valid_value(value, ranges):
                    field_order[i].discard(field)

    while any(len(fields) > 1 for fields in field_order):
        for i in range(num_fields):
            if len(field_order[i]) == 1:
                field = next(iter(field_order[i]))
                for j in range(num_fields):
                    if i != j:
                        field_order[j].discard(field)

    return [next(iter(fields)) for fields in field_order]


# Parse input
rules, your_ticket, nearby_tickets = parse_input('input.txt')

# Get valid tickets
valid_tickets = get_valid_tickets(rules, nearby_tickets)

# Determine field order
field_order = determine_field_order(rules, valid_tickets)

# Multiply departure values on your ticket
departure_values = [your_ticket[i] for i, field in enumerate(field_order) if field.startswith('departure')]
result = np.prod(departure_values)
print(result)
",2.0
391,2020,17,1,no_error,"263
",263,,"
def parse_input(input_str):
    lines = input_str.strip().split('\n')
    pocket_dimension = {}
    for y, line in enumerate(lines):
        for x, char in enumerate(line):
            if char == '#':
                pocket_dimension[(x, y, 0)] = True
    return pocket_dimension

def count_active_cubes(pocket_dimension):
    return len(pocket_dimension)

def get_neighbors(cube):
    x, y, z = cube
    neighbors = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            for dz in [-1, 0, 1]:
                if dx != 0 or dy != 0 or dz != 0:
                    neighbors.append((x + dx, y + dy, z + dz))
    return neighbors

def simulate_cycles(pocket_dimension, num_cycles):
    for _ in range(num_cycles):
        new_pocket_dimension = {}
        cubes_to_check = set(pocket_dimension.keys())
        for cube in pocket_dimension.keys():
            cubes_to_check.update(get_neighbors(cube))
        for cube in cubes_to_check:
            active_neighbors = sum(pocket_dimension.get(neighbor, False) for neighbor in get_neighbors(cube))
            if pocket_dimension.get(cube, False) and active_neighbors in [2, 3]:
                new_pocket_dimension[cube] = True
            elif not pocket_dimension.get(cube, False) and active_neighbors == 3:
                new_pocket_dimension[cube] = True
        pocket_dimension = new_pocket_dimension
    return pocket_dimension

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

# Parse input
pocket_dimension = parse_input(input_str)

# Simulate cycles
pocket_dimension = simulate_cycles(pocket_dimension, 6)

# Count active cubes
active_cubes = count_active_cubes(pocket_dimension)
print(active_cubes)
",0.0
392,2020,17,2,no_error,"1680
",1680,,"
def parse_input(input_str):
    lines = input_str.strip().split('\n')
    pocket_dimension = {}
    for y, line in enumerate(lines):
        for x, char in enumerate(line):
            if char == '#':
                pocket_dimension[(x, y, 0, 0)] = True
    return pocket_dimension

def count_active_cubes(pocket_dimension):
    return len(pocket_dimension)

def get_neighbors(hypercube):
    x, y, z, w = hypercube
    neighbors = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            for dz in [-1, 0, 1]:
                for dw in [-1, 0, 1]:
                    if dx != 0 or dy != 0 or dz != 0 or dw != 0:
                        neighbors.append((x + dx, y + dy, z + dz, w + dw))
    return neighbors

def simulate_cycles(pocket_dimension, num_cycles):
    for _ in range(num_cycles):
        new_pocket_dimension = {}
        cubes_to_check = set(pocket_dimension.keys())
        for hypercube in pocket_dimension.keys():
            cubes_to_check.update(get_neighbors(hypercube))
        for hypercube in cubes_to_check:
            active_neighbors = sum(pocket_dimension.get(neighbor, False) for neighbor in get_neighbors(hypercube))
            if pocket_dimension.get(hypercube, False) and active_neighbors in [2, 3]:
                new_pocket_dimension[hypercube] = True
            elif not pocket_dimension.get(hypercube, False) and active_neighbors == 3:
                new_pocket_dimension[hypercube] = True
        pocket_dimension = new_pocket_dimension
    return pocket_dimension

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

# Parse input
pocket_dimension = parse_input(input_str)

# Simulate cycles
pocket_dimension = simulate_cycles(pocket_dimension, 6)

# Count active cubes
active_cubes = count_active_cubes(pocket_dimension)
print(active_cubes)
",0.0
395,2020,18,1,no_error,"31142189909908
",31142189909908,,"
def precedence(operator):
    if operator == '+':
        return 1
    elif operator == '*':
        return 1
    else:
        return 0


def infix_to_postfix(expression):
    output = []
    operator_stack = []

    for token in expression:
        if token.isdigit():
            output.append(token)
        elif token == '(':
            operator_stack.append(token)
        elif token == ')':
            while operator_stack and operator_stack[-1] != '(':
                output.append(operator_stack.pop())
            operator_stack.pop()  # Discard '('
        else:
            while operator_stack and precedence(operator_stack[-1]) >= precedence(token):
                output.append(operator_stack.pop())
            operator_stack.append(token)

    while operator_stack:
        output.append(operator_stack.pop())

    return output


def evaluate_postfix(expression):
    stack = []

    for token in expression:
        if token.isdigit():
            stack.append(int(token))
        else:
            operand2 = stack.pop()
            operand1 = stack.pop()

            if token == '+':
                stack.append(operand1 + operand2)
            elif token == '*':
                stack.append(operand1 * operand2)

    return stack[0]


total_sum = 0

with open('input.txt', 'r') as file:
    for line in file:
        expression = line.strip().replace(' ', '')
        postfix_expression = infix_to_postfix(expression)
        result = evaluate_postfix(postfix_expression)
        total_sum += result

print(total_sum)
",2.0
396,2020,18,2,no_error,"323912478287549
",323912478287549,,"
def precedence(operator):
    if operator == '+':
        return 2
    elif operator == '*':
        return 1
    else:
        return 0


def infix_to_postfix(expression):
    output = []
    operator_stack = []

    for token in expression:
        if token.isdigit():
            output.append(token)
        elif token == '(':
            operator_stack.append(token)
        elif token == ')':
            while operator_stack and operator_stack[-1] != '(':
                output.append(operator_stack.pop())
            operator_stack.pop()  # Discard '('
        else:
            while operator_stack and precedence(operator_stack[-1]) >= precedence(token):
                output.append(operator_stack.pop())
            operator_stack.append(token)

    while operator_stack:
        output.append(operator_stack.pop())

    return output


def evaluate_postfix(expression):
    stack = []

    for token in expression:
        if token.isdigit():
            stack.append(int(token))
        else:
            operand2 = stack.pop()
            operand1 = stack.pop()

            if token == '+':
                stack.append(operand1 + operand2)
            elif token == '*':
                stack.append(operand1 * operand2)

    return stack[0]


total_sum = 0

with open('input.txt', 'r') as file:
    for line in file:
        expression = line.strip().replace(' ', '')
        postfix_expression = infix_to_postfix(expression)
        result = evaluate_postfix(postfix_expression)
        total_sum += result

print(total_sum)
",1.0
398,2020,19,1,no_error,173,173,,"
def parse_input(input_text):
    rules_text, messages_text = input_text.strip().split(""\n\n"")
    rules = {}
    for rule_text in rules_text.split(""\n""):
        rule_id, rule_data = rule_text.split("": "")
        if '""' in rule_data:
            rules[int(rule_id)] = rule_data.strip('""')
        else:
            rules[int(rule_id)] = [list(map(int, subrule.split())) for subrule in rule_data.split("" | "")]
    messages = messages_text.strip().split(""\n"")
    return rules, messages

# Read input from file
with open(""input.txt"") as f:
    input_text = f.read()

rules, messages = parse_input(input_text)


def match_rule(rule_id, message, rules):
    rule = rules[rule_id]

    if isinstance(rule, str):
        if message.startswith(rule):
            return [len(rule)]
        else:
            return []

    matches = []
    for subrule in rule:
        submatches = [0]
        for subrule_id in subrule:
            new_submatches = []
            for submatch in submatches:
                submessage = message[submatch:]
                new_submatches += [submatch + match_len for match_len in match_rule(subrule_id, submessage, rules)]
            submatches = new_submatches
        matches += submatches

    return matches


count = 0
for message in messages:
    matches = match_rule(0, message, rules)
    if len(message) in matches:
        count += 1

print(count)


def parse_input(input_text):
    rules_text, messages_text = input_text.strip().split(""\n\n"")
    rules = {}
    for rule_text in rules_text.split(""\n""):
        rule_id, rule_data = rule_text.split("": "")
        if '""' in rule_data:
            rules[int(rule_id)] = rule_data.strip('""')
        else:
            rules[int(rule_id)] = [list(map(int, subrule.split())) for subrule in rule_data.split("" | "")]
    messages = messages_text.strip().split(""\n"")
    return rules, messages

def match_rule(rule_id, message, rules):
    rule = rules[rule_id]

    if isinstance(rule, str):
        if message.startswith(rule):
            return [len(rule)]
        else:
            return []

    matches = []
    for subrule in rule:
        submatches = [0]
        for subrule_id in subrule:
            new_submatches = []
            for submatch in submatches:
                submessage = message[submatch:]
                new_submatches += [submatch + match_len for match_len in match_rule(subrule_id, submessage, rules)]
            submatches = new_submatches
        matches += submatches

    return matches

# Read input from file
with open(""input.txt"") as f:
    input_text = f.read()

rules, messages = parse_input(input_text)

count = 0
for message in messages:
    matches = match_rule(0, message, rules)
    if len(message) in matches:
        count += 1

print(count)
",0.0
399,2020,19,2,runtime_error,,367,"Traceback (most recent call last):
  File ""/tmp/tmpl8akvewm/tmp.py"", line 25, in <module>
    rules[8] = [[42], [42, 8]]
NameError: name 'rules' is not defined
","
def match_rule(rule_id, message, rules):
    rule = rules[rule_id]

    if isinstance(rule, str):
        if message.startswith(rule):
            return [len(rule)]
        else:
            return []

    matches = []
    for subrule in rule:
        submatches = [0]
        for subrule_id in subrule:
            new_submatches = []
            for submatch in submatches:
                submessage = message[submatch:]
                new_submatches += [submatch + match_len for match_len in match_rule(subrule_id, submessage, rules)]
            submatches = new_submatches
        matches += submatches

    return matches


rules[8] = [[42], [42, 8]]
rules[11] = [[42, 31], [42, 11, 31]]


count = 0
for message in messages:
    matches = match_rule(0, message, rules)
    if len(message) in matches:
        count += 1

print(count)


def parse_input(input_text):
    rules_text, messages_text = input_text.strip().split(""\n\n"")
    rules = {}
    for rule_text in rules_text.split(""\n""):
        rule_id, rule_data = rule_text.split("": "")
        if '""' in rule_data:
            rules[int(rule_id)] = rule_data.strip('""')
        else:
            rules[int(rule_id)] = [list(map(int, subrule.split())) for subrule in rule_data.split("" | "")]
    messages = messages_text.strip().split(""\n"")
    return rules, messages

def match_rule(rule_id, message, rules):
    rule = rules[rule_id]

    if isinstance(rule, str):
        if message.startswith(rule):
            return [len(rule)]
        else:
            return []

    matches = []
    for subrule in rule:
        submatches = [0]
        for subrule_id in subrule:
            new_submatches = []
            for submatch in submatches:
                submessage = message[submatch:]
                new_submatches += [submatch + match_len for match_len in match_rule(subrule_id, submessage, rules)]
            submatches = new_submatches
        matches += submatches

    return matches

# Read input from file
with open(""input.txt"") as f:
    input_text = f.read()

rules, messages = parse_input(input_text)

# Update rules 8 and 11
rules[8] = [[42], [42, 8]]
rules[11] = [[42, 31], [42, 11, 31]]

count = 0
for message in messages:
    matches = match_rule(0, message, rules)
    if len(message) in matches:
        count += 1

print(count)
",2.0
400,2020,20,1,no_error,"15003787688423
",15003787688423,,"from typing import List, Dict

class Tile:
    def __init__(self, tile_id: int, data: List[str]):
        self.tile_id = tile_id
        self.data = data
        self.edges = self.get_edges()
    
    def get_edges(self) -> List[str]:
        top = self.data[0]
        bottom = self.data[-1]
        left = ''.join(row[0] for row in self.data)
        right = ''.join(row[-1] for row in self.data)
        return [top, bottom, left, right]
    
    def rotate(self):
        self.data = [''.join(row[i] for row in self.data[::-1]) for i in range(len(self.data[0]))]
        self.edges = self.get_edges()
    
    def flip(self):
        self.data = self.data[::-1]
        self.edges = self.get_edges()

def parse_input(input_lines: List[str]) -> Dict[int, Tile]:
    tiles = {}
    i = 0
    while i < len(input_lines):
        tile_id = int(input_lines[i].split()[1][:-1])
        data = []
        i += 1
        while i < len(input_lines) and input_lines[i] != '':
            data.append(input_lines[i])
            i += 1
        tiles[tile_id] = Tile(tile_id, data)
        i += 1
    return tiles

def find_corner_tiles(tiles: Dict[int, Tile]) -> List[int]:
    edge_count = {}
    for tile in tiles.values():
        for edge in tile.edges:
            edge_count[edge] = edge_count.get(edge, 0) + 1
            edge_count[edge[::-1]] = edge_count.get(edge[::-1], 0) + 1
    
    corner_tiles = []
    for tile in tiles.values():
        unique_edge_count = sum(1 for edge in tile.edges if edge_count[edge] == 1)
        if unique_edge_count == 2:
            corner_tiles.append(tile.tile_id)
    
    return corner_tiles

def main():
    with open('input.txt', 'r') as f:
        input_lines = f.read().splitlines()
    
    tiles = parse_input(input_lines)
    corner_tiles = find_corner_tiles(tiles)
    result = 1
    for tile_id in corner_tiles:
        result *= tile_id
    
    print(result)

if __name__ == '__main__':
    main()",0.0
401,2020,20,2,runtime_error,,1705,"Traceback (most recent call last):
  File ""/tmp/tmpo95gstqj/tmp.py"", line 165, in <module>
    main()
  File ""/tmp/tmpo95gstqj/tmp.py"", line 159, in main
    image = get_image(tiles)
  File ""/tmp/tmpo95gstqj/tmp.py"", line 62, in get_image
    while (tiles[starting_tile.tile_id].edges[0] not in edge_count) or (tiles[starting_tile.tile_id].edges[2] not in edge_count):
NameError: name 'edge_count' is not defined
","from typing import List, Dict

class Tile:
    def __init__(self, tile_id: int, data: List[str]):
        self.tile_id = tile_id
        self.data = data
        self.edges = self.get_edges()
    
    def get_edges(self) -> List[str]:
        top = self.data[0]
        bottom = self.data[-1]
        left = ''.join(row[0] for row in self.data)
        right = ''.join(row[-1] for row in self.data)
        return [top, bottom, left, right]
    
    def rotate(self):
        self.data = [''.join(row[i] for row in self.data[::-1]) for i in range(len(self.data[0]))]
        self.edges = self.get_edges()
    
    def flip(self):
        self.data = self.data[::-1]
        self.edges = self.get_edges()

def parse_input(input_lines: List[str]) -> Dict[int, Tile]:
    tiles = {}
    i = 0
    while i < len(input_lines):
        tile_id = int(input_lines[i].split()[1][:-1])
        data = []
        i += 1
        while i < len(input_lines) and input_lines[i] != '':
            data.append(input_lines[i])
            i += 1
        tiles[tile_id] = Tile(tile_id, data)
        i += 1
    return tiles

def find_corner_tiles(tiles: Dict[int, Tile]) -> List[int]:
    edge_count = {}
    for tile in tiles.values():
        for edge in tile.edges:
            edge_count[edge] = edge_count.get(edge, 0) + 1
            edge_count[edge[::-1]] = edge_count.get(edge[::-1], 0) + 1
    
    corner_tiles = []
    for tile in tiles.values():
        unique_edge_count = sum(1 for edge in tile.edges if edge_count[edge] == 1)
        if unique_edge_count == 2:
            corner_tiles.append(tile.tile_id)
    
    return corner_tiles

def remove_borders(tile: Tile) -> Tile:
    new_data = [row[1:-1] for row in tile.data[1:-1]]
    return Tile(tile.tile_id, new_data)

def get_image(tiles: Dict[int, Tile]) -> List[List[Tile]]:
    corner_tiles = find_corner_tiles(tiles)
    starting_tile = tiles[corner_tiles[0]]
    
    # Rotate and flip the starting tile until it is in the top-left corner
    while (tiles[starting_tile.tile_id].edges[0] not in edge_count) or (tiles[starting_tile.tile_id].edges[2] not in edge_count):
        starting_tile.rotate()
    
    # Build the top row of the image
    image = [[starting_tile]]
    while True:
        current_tile = image[-1][-1]
        current_edge = current_tile.edges[3]
        next_tile_id = edge_count[current_edge]
        next_tile = tiles[next_tile_id]
        
        # Rotate and flip the next tile until its left edge matches the current tile's right edge
        while next_tile.edges[2] != current_edge:
            next_tile.rotate()
        
        # Flip the next tile if necessary to match the orientation of the current tile
        if next_tile.edges[0] != current_tile.edges[1]:
            next_tile.flip()
        
        image[-1].append(next_tile)
        
        # Check if we have reached the end of the top row
        if edge_count[next_tile.edges[3]] is None:
            break
    
    # Build the remaining rows of the image
    while True:
        previous_row = image[-1]
        new_row = []
        for i in range(len(previous_row)):
            current_tile = previous_row[i]
            current_edge = current_tile.edges[1]
            next_tile_id = edge_count[current_edge]
            next_tile = tiles[next_tile_id]
            
            # Rotate and flip the next tile until its top edge matches the current tile's bottom edge
            while next_tile.edges[0] != current_edge:
                next_tile.rotate()
            
            # Flip the next tile if necessary to match the orientation of the current tile
            if next_tile.edges[2] != current_tile.edges[3]:
                next_tile.flip()
            
            new_row.append(next_tile)
        
        # Check if we have reached the end of the image
        if edge_count[new_row[0].edges[1]] is None:
            break
        
        image.append(new_row)
    
    return image

def get_roughness(image: List[List[Tile]]) -> int:
    # Remove borders from tiles
    for row in image:
        for tile in row:
            tile = remove_borders(tile)
    
    # Combine tiles into a single image
    combined_image = []
    for i in range(len(image)):
        for j in range(len(image[0][0].data)):
            row_data = ''
            for tile in image[i]:
                row_data += tile.data[j]
            combined_image.append(row_data)
    
    # Count the number of sea monsters
    monster_pattern = [
        ""                  # "",
        ""#    ##    ##    ###"",
        "" #  #  #  #  #  #   ""
    ]
    monster_count = 0
    for i in range(len(combined_image) - len(monster_pattern)):
        for j in range(len(combined_image[0]) - len(monster_pattern[0])):
            is_monster = True
            for k in range(len(monster_pattern)):
                for l in range(len(monster_pattern[0])):
                    if monster_pattern[k][l] == '#' and combined_image[i+k][j+l] != '#':
                        is_monster = False
                        break
                if not is_monster:
                    break
            if is_monster:
                monster_count += 1
    
    # Count the number of '#' that are not part of a sea monster
    roughness = sum(row.count('#') for row in combined_image) - (monster_count * sum(row.count('#') for row in monster_pattern))
    return roughness

def main():
    with open('input.txt', 'r') as f:
        input_lines = f.read().splitlines()
    
    tiles = parse_input(input_lines)
    image = get_image(tiles)
    roughness = get_roughness(image)
    
    print(roughness)

if __name__ == '__main__':
    main()",2.0
402,2020,21,1,no_error,"2542
",2542,,"
import re

def parse_input(input_str):
    foods = []
    for line in input_str.strip().split('\n'):
        match = re.match(r'^(.*?) \(contains (.*?)\)$', line)
        ingredients = match.group(1).split()
        allergens = match.group(2).split(', ')
        foods.append((ingredients, allergens))
    return foods

def get_ingredient_counts(foods):
    ingredient_count = {}
    all_ingredients = set()
    for ingredients, _ in foods:
        for ingredient in ingredients:
            ingredient_count[ingredient] = ingredient_count.get(ingredient, 0) + 1
            all_ingredients.add(ingredient)
    return ingredient_count, all_ingredients

def get_possible_allergen_candidates(foods):
    allergen_candidates = {}
    for ingredients, allergens in foods:
        for allergen in allergens:
            if allergen not in allergen_candidates:
                allergen_candidates[allergen] = set(ingredients)
            else:
                allergen_candidates[allergen] &= set(ingredients)
    return allergen_candidates

def get_safe_ingredients_count(foods):
    ingredient_count, all_ingredients = get_ingredient_counts(foods)
    allergen_candidates = get_possible_allergen_candidates(foods)
    definitely_contains_allergens = set()
    for allergen in allergen_candidates:
        definitely_contains_allergens |= allergen_candidates[allergen]
    safe_ingredients = all_ingredients - definitely_contains_allergens
    return sum(ingredient_count[ingredient] for ingredient in safe_ingredients)

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

foods = parse_input(input_str)
safe_ingredients_count = get_safe_ingredients_count(foods)
print(safe_ingredients_count)
",1.0
403,2020,21,2,no_error,"hkflr,ctmcqjf,bfrq,srxphcm,snmxl,zvx,bd,mqvk
","hkflr,ctmcqjf,bfrq,srxphcm,snmxl,zvx,bd,mqvk",,"
import re

def parse_input(input_str):
    foods = []
    for line in input_str.strip().split('\n'):
        match = re.match(r'^(.*?) \(contains (.*?)\)$', line)
        ingredients = match.group(1).split()
        allergens = match.group(2).split(', ')
        foods.append((ingredients, allergens))
    return foods

def get_possible_allergen_candidates(foods):
    allergen_candidates = {}
    for ingredients, allergens in foods:
        for allergen in allergens:
            if allergen not in allergen_candidates:
                allergen_candidates[allergen] = set(ingredients)
            else:
                allergen_candidates[allergen] &= set(ingredients)
    return allergen_candidates

def get_canonical_dangerous_ingredient_list(foods):
    allergen_candidates = get_possible_allergen_candidates(foods)
    allergen_ingredients = {}
    while allergen_candidates:
        allergen, ingredients = min(allergen_candidates.items(), key=lambda x: len(x[1]))
        ingredient = ingredients.pop()
        allergen_ingredients[allergen] = ingredient
        del allergen_candidates[allergen]
        for other_ingredients in allergen_candidates.values():
            other_ingredients.discard(ingredient)
    allergens = sorted(allergen_ingredients.keys())
    ingredients = [allergen_ingredients[allergen] for allergen in allergens]
    return ','.join(ingredients)

# Read input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

foods = parse_input(input_str)
canonical_dangerous_ingredient_list = get_canonical_dangerous_ingredient_list(foods)
print(canonical_dangerous_ingredient_list)
",0.0
406,2020,22,1,no_error,34255,34255,,"
def calculate_score(deck):
    return sum((i + 1) * card for i, card in enumerate(deck[::-1]))

def play_combat(player1_deck, player2_deck):
    while player1_deck and player2_deck:
        player1_card = player1_deck.pop(0)
        player2_card = player2_deck.pop(0)

        if player1_card > player2_card:
            player1_deck.extend([player1_card, player2_card])
        else:
            player2_deck.extend([player2_card, player1_card])

    return player1_deck if player1_deck else player2_deck

# Read input
with open('input.txt', 'r') as file:
    player1_deck, player2_deck = file.read().strip().split('\n\n')

player1_deck = list(map(int, player1_deck.split('\n')[1:]))
player2_deck = list(map(int, player2_deck.split('\n')[1:]))

# Play Combat
winning_deck = play_combat(player1_deck, player2_deck)
winning_score = calculate_score(winning_deck)

print(""The winning player's score is:"", winning_score)
",2.0
407,2020,22,2,no_error,33369,33369,,"
def calculate_score(deck):
    return sum((i + 1) * card for i, card in enumerate(deck[::-1]))

def play_recursive_combat(player1_deck, player2_deck):
    previous_configurations = set()

    while player1_deck and player2_deck:
        # Check for previous configuration
        configuration = (tuple(player1_deck), tuple(player2_deck))
        if configuration in previous_configurations:
            return player1_deck, []  # Player 1 wins

        previous_configurations.add(configuration)

        player1_card = player1_deck.pop(0)
        player2_card = player2_deck.pop(0)

        if player1_card <= len(player1_deck) and player2_card <= len(player2_deck):
            # Play sub-game
            sub_player1_deck = player1_deck[:player1_card]
            sub_player2_deck = player2_deck[:player2_card]
            sub_player1_deck, sub_player2_deck = play_recursive_combat(sub_player1_deck, sub_player2_deck)

            if sub_player1_deck:
                player1_deck.extend([player1_card, player2_card])
            else:
                player2_deck.extend([player2_card, player1_card])
        else:
            # Higher-value card wins
            if player1_card > player2_card:
                player1_deck.extend([player1_card, player2_card])
            else:
                player2_deck.extend([player2_card, player1_card])

    return player1_deck, player2_deck

# Read input
with open('input.txt', 'r') as file:
    player1_deck, player2_deck = file.read().strip().split('\n\n')

player1_deck = list(map(int, player1_deck.split('\n')[1:]))
player2_deck = list(map(int, player2_deck.split('\n')[1:]))

# Play Recursive Combat
winning_deck, _ = play_recursive_combat(player1_deck, player2_deck)
winning_score = calculate_score(winning_deck)

print(""The winning player's score is:"", winning_score)
",0.0
410,2020,23,1,syntax_error,,49576328,"  File ""/tmp/tmpp48jbnd1/tmp.py"", line 1
    To solve this problem, we need to simulate the moves of the crab for 100 rounds. We can start by parsing the input and representing the cups as a circular linked list. Each cup will have a value and a next pointer to the next cup in the circle.
       ^
SyntaxError: invalid syntax
","To solve this problem, we need to simulate the moves of the crab for 100 rounds. We can start by parsing the input and representing the cups as a circular linked list. Each cup will have a value and a next pointer to the next cup in the circle.

We will then simulate the moves of the crab by picking up three cups after the current cup, selecting a destination cup, and moving the picked cups immediately after the destination cup. The current cup will then be updated to the next cup in the circle.

After simulating the 100 moves, we can start from cup 1 and collect the labels of the cups clockwise into a string, excluding the label of cup 1 itself.

Let's write the code to solve the problem.",2.0
411,2020,23,2,part1_failed,,511780369955,,,
412,2020,24,1,no_error,"356
",356,,"
def flip_tiles(input):
    directions = {
        'e': (1, 0, -1),
        'se': (0, 1, -1),
        'sw': (-1, 1, 0),
        'w': (-1, 0, 1),
        'nw': (0, -1, 1),
        'ne': (1, -1, 0)
    }
    
    tiles = {}
    
    for line in input:
        x, y, z = 0, 0, 0
        i = 0
        
        while i < len(line):
            if line[i] in ['e', 'w']:
                dx, dy, dz = directions[line[i]]
                x += dx
                y += dy
                z += dz
                i += 1
            else:
                dx, dy, dz = directions[line[i:i+2]]
                x += dx
                y += dy
                z += dz
                i += 2
                
        if (x, y, z) in tiles:
            tiles[(x, y, z)] = not tiles[(x, y, z)]
        else:
            tiles[(x, y, z)] = True
    
    return sum(1 for tile in tiles.values() if tile)

with open('input.txt', 'r') as file:
    input = file.read().splitlines()

result = flip_tiles(input)
print(result)
",0.0
413,2020,24,2,no_error,"3887
",3887,,"
def flip_tiles(input):
    directions = {
        'e': (1, 0, -1),
        'se': (0, 1, -1),
        'sw': (-1, 1, 0),
        'w': (-1, 0, 1),
        'nw': (0, -1, 1),
        'ne': (1, -1, 0)
    }

    tiles = {}

    for line in input:
        x, y, z = 0, 0, 0
        i = 0

        while i < len(line):
            if line[i] in ['e', 'w']:
                dx, dy, dz = directions[line[i]]
                x += dx
                y += dy
                z += dz
                i += 1
            else:
                dx, dy, dz = directions[line[i:i + 2]]
                x += dx
                y += dy
                z += dz
                i += 2

        if (x, y, z) in tiles:
            tiles[(x, y, z)] = not tiles[(x, y, z)]
        else:
            tiles[(x, y, z)] = True

    return tiles


def get_adjacent_tiles(x, y, z):
    directions = {
        'e': (1, 0, -1),
        'se': (0, 1, -1),
        'sw': (-1, 1, 0),
        'w': (-1, 0, 1),
        'nw': (0, -1, 1),
        'ne': (1, -1, 0)
    }

    adjacent_tiles = []
    for direction in directions.values():
        dx, dy, dz = direction
        adjacent_tiles.append((x + dx, y + dy, z + dz))

    return adjacent_tiles


def flip_tiles_daily(tiles):
    new_tiles = {}

    all_tiles = set(tiles.keys())
    for tile in tiles:
        all_tiles.update(get_adjacent_tiles(*tile))

    for tile in all_tiles:
        black_adjacent = sum(tiles.get(adjacent, False) for adjacent in get_adjacent_tiles(*tile))
        if tiles.get(tile, False):
            if black_adjacent == 0 or black_adjacent > 2:
                new_tiles[tile] = False
            else:
                new_tiles[tile] = True
        else:
            if black_adjacent == 2:
                new_tiles[tile] = True
            else:
                new_tiles[tile] = False

    return new_tiles


def count_black_tiles(tiles):
    return sum(1 for tile in tiles.values() if tile)


with open('input.txt', 'r') as file:
    input = file.read().splitlines()

tiles = flip_tiles(input)
for _ in range(100):
    tiles = flip_tiles_daily(tiles)

result = count_black_tiles(tiles)
print(result)
",0.0
415,2020,25,1,no_error,711945,711945,,"
def transform(subject_number, loop_size):
    value = 1
    for _ in range(loop_size):
        value *= subject_number
        value %= 20201227
    return value


with open('input.txt', 'r') as file:
    card_public_key, door_public_key = map(int, file.read().strip().split('\n'))

card_loop_size = None
door_loop_size = None
encryption_key = None


subject_number = 7
value = 1
loop_size = 0

while card_loop_size is None or door_loop_size is None:
    loop_size += 1
    value *= subject_number
    value %= 20201227
    
    if value == card_public_key and card_loop_size is None:
        card_loop_size = loop_size
    
    if value == door_public_key and door_loop_size is None:
        door_loop_size = loop_size


encryption_key = transform(door_public_key, card_loop_size)


def transform(subject_number, loop_size):
    value = 1
    for _ in range(loop_size):
        value *= subject_number
        value %= 20201227
    return value

with open('input.txt', 'r') as file:
    card_public_key, door_public_key = map(int, file.read().strip().split('\n'))

card_loop_size = None
door_loop_size = None
encryption_key = None

subject_number = 7
value = 1
loop_size = 0

while card_loop_size is None or door_loop_size is None:
    loop_size += 1
    value *= subject_number
    value %= 20201227
    
    if value == card_public_key and card_loop_size is None:
        card_loop_size = loop_size
    
    if value == door_public_key and door_loop_size is None:
        door_loop_size = loop_size

encryption_key = transform(door_public_key, card_loop_size)

print(""Encryption Key:"", encryption_key)
",0.0
416,2021,1,1,no_error,"1532
",1532,,"# Reading the input

with open('input.txt', 'r') as file:
    data = file.read().splitlines()

# Counting the number of measurements larger than the previous measurement

count = 0
for i in range(1, len(data)):
    if int(data[i]) > int(data[i-1]):
        count += 1

# Displaying the result

print(count)",1.0
417,2021,1,2,runtime_error,,1571,"Traceback (most recent call last):
  File ""/tmp/tmp6h3da8it/tmp.py"", line 11, in <module>
    sum_current = int(data[i-1]) + int(data[i]) + int(data[i+1])
IndexError: list index out of range
","# Reading the input

with open('input.txt', 'r') as file:
    data = file.read().splitlines()

# Counting the number of sums larger than the previous sum

count = 0
for i in range(2, len(data)):
    sum_prev = int(data[i-2]) + int(data[i-1]) + int(data[i-2])
    sum_current = int(data[i-1]) + int(data[i]) + int(data[i+1])
    if sum_current > sum_prev:
        count += 1

# Displaying the result

print(count)",2.0
418,2021,2,1,no_error,"1990000
",1990000,,"
# Read the commands from the input file
with open('input.txt', 'r') as file:
    commands = file.read().splitlines()

# Initialize horizontal position and depth
horizontal_position = 0
depth = 0

# Process each command
for command in commands:
    # Split the command into operation and value
    operation, value = command.split(' ')

    # Perform the corresponding operation
    if operation == 'forward':
        horizontal_position += int(value)
    elif operation == 'down':
        depth += int(value)
    elif operation == 'up':
        depth -= int(value)

# Calculate the product of the final horizontal position and depth
result = horizontal_position * depth
print(result)
",0.0
419,2021,2,2,no_error,"1975421260
",1975421260,,"
# Read the commands from the input file
with open('input.txt', 'r') as file:
    commands = file.read().splitlines()

# Initialize horizontal position, depth, and aim
horizontal_position = 0
depth = 0
aim = 0

# Process each command
for command in commands:
    # Split the command into operation and value
    operation, value = command.split(' ')

    # Perform the corresponding operation
    if operation == 'forward':
        horizontal_position += int(value)
        depth += aim * int(value)
    elif operation == 'down':
        aim += int(value)
    elif operation == 'up':
        aim -= int(value)

# Calculate the product of the final horizontal position and depth
result = horizontal_position * depth
print(result)
",0.0
422,2021,3,1,no_error,3549854,3549854,,"
from collections import Counter

# Read the diagnostic report from the input file
with open('input.txt', 'r') as file:
    diagnostic_report = [line.strip() for line in file]

# Calculate the gamma rate
gamma_rate = ''
for i in range(len(diagnostic_report[0])):
    counts = Counter([number[i] for number in diagnostic_report])
    most_common_bit = counts.most_common(1)[0][0]
    gamma_rate += most_common_bit

# Calculate the epsilon rate
epsilon_rate = ''
for i in range(len(diagnostic_report[0])):
    counts = Counter([number[i] for number in diagnostic_report])
    least_common_bit = counts.most_common()[-1][0]
    epsilon_rate += least_common_bit

# Calculate the power consumption
power_consumption = int(gamma_rate, 2) * int(epsilon_rate, 2)

print(""Power Consumption:"", power_consumption)
",0.0
423,2021,3,2,wrong_output,"Life Support Rating: 3549854
",3765399,,"
from collections import Counter

# Read the diagnostic report from the input file
with open('input.txt', 'r') as file:
    diagnostic_report = [line.strip() for line in file]

# Calculate the oxygen generator rating
oxygen_generator_rating = ''
for i in range(len(diagnostic_report[0])):
    counts = Counter([number[i] for number in diagnostic_report])
    most_common_bit = counts.most_common(1)[0][0]
    oxygen_generator_rating += most_common_bit

# Calculate the CO2 scrubber rating
co2_scrubber_rating = ''
for i in range(len(diagnostic_report[0])):
    counts = Counter([number[i] for number in diagnostic_report])
    least_common_bit = counts.most_common()[-1][0]
    co2_scrubber_rating += least_common_bit

# Calculate the life support rating
life_support_rating = int(oxygen_generator_rating, 2) * int(co2_scrubber_rating, 2)

print(""Life Support Rating:"", life_support_rating)
",2.0
424,2021,4,1,runtime_error,,49860,"Traceback (most recent call last):
  File ""/tmp/tmp79pby7ap/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np

# Step 1: Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

numbers = list(map(int, lines[0].strip().split(',')))
boards = [list(map(int, line.strip().split())) for line in lines[1:]]

# Step 2: Function to check if a board has a winning configuration
def is_winning(board):
    board = np.array(board)
    for i in range(5):
        # Check rows and columns
        if np.all(board[i, :] != 0) or np.all(board[:, i] != 0):
            return True
    return False

# Step 3-6: Iterate over the numbers and find the winning board with the minimum score
scores = {}
for number in numbers:
    for i, board in enumerate(boards):
        if is_winning(board):
            unmarked_sum = np.sum(np.array(board)[board == 0])
            score = unmarked_sum * number
            scores[i] = score
        else:
            # Mark the number on the board
            for j in range(5):
                for k in range(5):
                    if board[j][k] == number:
                        board[j][k] = 0
                        break
                if board[j][k] == 0:
                    break

# Print the final score
min_score = min(scores.values())
print(min_score)
",2.0
425,2021,4,2,part1_failed,,24628,,,
426,2021,5,1,runtime_error,,6710,"Traceback (most recent call last):
  File ""/tmp/tmpyszufezf/tmp.py"", line 30, in <module>
    x1, y1, x2, y2 = map(int, line.strip().replace(' ', '').replace(',', '').split('->'))
ValueError: not enough values to unpack (expected 4, got 2)
","
def count_overlapping_points(lines):
    # Find the maximum x and y coordinates
    max_x = max(max(x1, x2) for (x1, _, x2, _) in lines)
    max_y = max(max(y1, y2) for (_, y1, _, y2) in lines)
    
    # Create a grid
    grid = [[0] * (max_y + 1) for _ in range(max_x + 1)]
    
    # Mark each point covered by a line
    for line in lines:
        x1, y1, x2, y2 = line
        if x1 == x2:  # Vertical line
            for y in range(y1, y2 + 1):
                grid[x1][y] += 1
        elif y1 == y2:  # Horizontal line
            for x in range(x1, x2 + 1):
                grid[x][y1] += 1
    
    # Count the number of points with at least two lines
    count = sum(1 for row in grid for point in row if point >= 2)
    
    return count


# Read the input from a file
with open('input.txt', 'r') as file:
    lines = []
    for line in file:
        x1, y1, x2, y2 = map(int, line.strip().replace(' ', '').replace(',', '').split('->'))
        lines.append((x1, y1, x2, y2))
    
    # Count the number of points with at least two lines
    overlapping_points = count_overlapping_points(lines)
    print(overlapping_points)
",2.0
427,2021,5,2,part1_failed,,20121,,,
428,2021,6,1,no_error,"380243
",380243,,"
def simulate_lanternfish(ages, days):
    for _ in range(days):
        new_ages = []
        for age in ages:
            if age == 0:
                new_ages.extend([6, 8])
            else:
                new_ages.append(age - 1)
        ages = new_ages
    return len(ages)

with open('input.txt', 'r') as file:
    ages = [int(age) for age in file.readline().strip().split(',')]
    
result = simulate_lanternfish(ages, 80)
print(result)
",1.0
429,2021,6,2,timeout_error,,1708791884591,TIMEOUT,"
def simulate_lanternfish(ages, days):
    for _ in range(days):
        new_ages = []
        for age in ages:
            if age == 0:
                new_ages.extend([6, 8])
            else:
                new_ages.append(age - 1)
        ages = new_ages
    return len(ages)

with open('input.txt', 'r') as file:
    ages = [int(age) for age in file.readline().strip().split(',')]
    
result = simulate_lanternfish(ages, 256)
print(result)
",2.0
430,2021,7,1,no_error,344297,344297,,"
def calculate_fuel_cost(positions):
    min_fuel_cost = float('inf')
    optimal_position = None

    for position in positions:
        fuel_cost = sum(abs(position - crab_position) for crab_position in positions)
        if fuel_cost < min_fuel_cost:
            min_fuel_cost = fuel_cost
            optimal_position = position

    return optimal_position, min_fuel_cost

# Read the input from the file
with open('input.txt', 'r') as file:
    input_positions = [int(position) for position in file.readline().split(',')]

# Calculate the optimal position and fuel cost
optimal_position, fuel_cost = calculate_fuel_cost(input_positions)

print(f""The crabs should align at position {optimal_position} with a fuel cost of {fuel_cost}."")
",0.0
431,2021,7,2,wrong_output,"The crabs should align at position 365 with a fuel cost of 175758785.
",97164301,,"
def calculate_fuel_cost(positions):
    min_fuel_cost = float('inf')
    optimal_position = None

    for position in positions:
        fuel_cost = 0
        for index, crab_position in enumerate(positions):
            fuel_cost += (abs(position - crab_position) * (index + 1))
        
        if fuel_cost < min_fuel_cost:
            min_fuel_cost = fuel_cost
            optimal_position = position

    return optimal_position, min_fuel_cost

# Read the input from the file
with open('input.txt', 'r') as file:
    input_positions = [int(position) for position in file.readline().split(',')]

# Calculate the optimal position and fuel cost
optimal_position, fuel_cost = calculate_fuel_cost(input_positions)

print(f""The crabs should align at position {optimal_position} with a fuel cost of {fuel_cost}."")
",2.0
432,2021,8,1,wrong_output,,440,,"def count_unique_digits(input):
    count = 0
    
    # Split the input into lines
    lines = input.split(""\n"")
    
    # Iterate over each line
    for line in lines:
        # Split the line into patterns and output value
        patterns, output = line.split(""|"")
        
        # Check if the output value contains a unique digit
        if '1' in output or '4' in output or '7' in output or '8' in output:
            count += 1
    
    return count",2.0
433,2021,8,2,part1_failed,,1046281,,,
434,2021,9,1,wrong_output,"1412
",462,,"# Read input from file
with open('input.txt', 'r') as file:
    heightmap = [list(map(int, line.strip())) for line in file.readlines()]

# Function to check if a point is a low point
def is_low_point(heightmap, i, j):
    height = heightmap[i][j]
    if i > 0 and height > heightmap[i-1][j]:
        return False
    if j > 0 and height > heightmap[i][j-1]:
        return False
    if i < len(heightmap) - 1 and height > heightmap[i+1][j]:
        return False
    if j < len(heightmap[0]) - 1 and height > heightmap[i][j+1]:
        return False
    return True

# Calculate sum of risk levels of all low points
sum_risk_levels = 0
for i in range(len(heightmap)):
    for j in range(len(heightmap[0])):
        if is_low_point(heightmap, i, j):
            risk_level = heightmap[i][j] + 1
            sum_risk_levels += risk_level

# Print the result
print(sum_risk_levels)",2.0
435,2021,9,2,part1_failed,,1397760,,,
436,2021,10,1,wrong_output,"186393
",299793,,"
def find_corrupted_lines(input_str):
    corrupted_lines = []
    for line in input_str.split('\n'):
        if line:
            open_chars = []
            for char in line:
                if char in '([{<':
                    open_chars.append(char)
                elif char in ')]}>':
                    if not open_chars:
                        corrupted_lines.append(line)
                        break
                    last_open_char = open_chars.pop()
                    if (last_open_char == '(' and char != ')') or \
                       (last_open_char == '[' and char != ']') or \
                       (last_open_char == '{' and char != '}') or \
                       (last_open_char == '<' and char != '>'):
                        corrupted_lines.append(line)
                        break
    return corrupted_lines

def calculate_syntax_error_score(corrupted_lines):
    score = 0
    for line in corrupted_lines:
        for char in line:
            if char in ')]}>':
                if char == ')':
                    score += 3
                elif char == ']':
                    score += 57
                elif char == '}':
                    score += 1197
                elif char == '>':
                    score += 25137
                break
    return score

with open('input.txt', 'r') as f:
    input_str = f.read()

corrupted_lines = find_corrupted_lines(input_str)
syntax_error_score = calculate_syntax_error_score(corrupted_lines)
print(syntax_error_score)
",2.0
437,2021,10,2,part1_failed,,3654963618,,,
438,2021,11,1,wrong_output,"524
",1793,,"
def simulate_steps(steps, energy_levels):
    height = len(energy_levels)
    width = len(energy_levels[0])

    # Convert the input into a 2D list of integers
    energy_grid = [[int(energy) for energy in row] for row in energy_levels]

    for _ in range(steps):
        # Increase the energy level of each octopus by 1
        for i in range(height):
            for j in range(width):
                energy_grid[i][j] += 1

        # Perform the flashing process
        flashes = []
        for i in range(height):
            for j in range(width):
                if energy_grid[i][j] > 9:
                    flashes.append((i, j))

        for i, j in flashes:
            energy_grid[i][j] = 0

            # Increase the energy level of adjacent octopuses
            for di in range(-1, 2):
                for dj in range(-1, 2):
                    if (di == 0 and dj == 0) or (i + di < 0) or (i + di >= height) or (j + dj < 0) or (j + dj >= width):
                        continue
                    energy_grid[i + di][j + dj] += 1

    # Count the total number of flashes
    total_flashes = sum(sum(row) for row in energy_grid)
    return total_flashes


# Read the input from the file
with open('input.txt', 'r') as file:
    energy_levels = [line.strip() for line in file.readlines()]

# Simulate 100 steps and calculate the total number of flashes
result = simulate_steps(100, energy_levels)
print(result)
",2.0
439,2021,11,2,part1_failed,,247,,,
440,2021,12,1,wrong_output,"0
",3887,,"
def find_paths(caves, current_cave, visited_small_caves):
    # If we've reached the end cave, return 1 to indicate a valid path
    if current_cave == ""end"":
        return 1

    # Initialize the total number of paths from the current cave
    total_paths = 0

    # Loop through each connection from the current cave
    for cave in caves:
        if cave.startswith(current_cave):
            # Get the next cave in the connection
            next_cave = cave.split(""-"")[1]

            # Check if the next cave is a small cave and has already been visited
            if next_cave.islower() and next_cave in visited_small_caves:
                continue

            # Add the next cave to the visited small caves if it is a small cave
            if next_cave.islower():
                visited_small_caves.add(next_cave)

            # Recursively find paths from the next cave
            total_paths += find_paths(caves, next_cave, visited_small_caves)

            # Remove the next cave from the visited small caves if it is a small cave
            if next_cave.islower():
                visited_small_caves.remove(next_cave)

    return total_paths

# Read the cave connections from the input file
with open('input.txt', 'r') as file:
    cave_connections = [line.strip() for line in file]

# Find the number of paths
total_paths = find_paths(cave_connections, ""start"", set())

# Print the result
print(total_paths)
",2.0
441,2021,12,2,part1_failed,,104834,,,
442,2021,13,1,syntax_error,,712,"  File ""/tmp/tmp2ktxpbti/tmp.py"", line 1
    To solve this problem, we need to simulate the folding of the transparent paper based on the given fold instructions. We will keep track of the visible dots after each fold and count the total number of visible dots after all the folds.
       ^
SyntaxError: invalid syntax
","To solve this problem, we need to simulate the folding of the transparent paper based on the given fold instructions. We will keep track of the visible dots after each fold and count the total number of visible dots after all the folds.

First, we need to parse the input file and extract the list of dots and fold instructions. We can read the input file and split it into lines to separate the dots and fold instructions. We can then process the dots by splitting each line into x and y coordinates. For the fold instructions, we can split each line by the ""fold along"" keyword and extract the line number and fold direction.

Next, we need to simulate the folding process. We can start with a set of visible dots, initialized with all the dots from the input. For each fold instruction, we can iterate over the visible dots and determine if each dot should be folded based on the fold direction. If a dot should be folded, we can calculate its new position after folding and check if it overlaps with any other dots. If it does overlap, we can remove the overlapping dots from the visible set.

Finally, we can count the total number of visible dots and print the result.

Here's the code to solve the problem:",2.0
443,2021,13,2,part1_failed,,BLHFJPJF,,,
444,2021,14,1,runtime_error,,2233,"Traceback (most recent call last):
  File ""/tmp/tmp57syj7np/tmp.py"", line 33, in <module>
    pair_insertion_rules[rule[0]] = rule[1]
IndexError: list index out of range
","
def apply_pair_insertion(polymer, rules):
    new_polymer = ''
    i = 0
    while i < len(polymer):
        pair = polymer[i:i+2]
        if pair in rules:
            new_polymer += rules[pair]
            i += 2
        else:
            new_polymer += polymer[i]
            i += 1
    return new_polymer

def count_elements(polymer):
    element_count = {}
    for element in polymer:
        if element in element_count:
            element_count[element] += 1
        else:
            element_count[element] = 1
    return element_count

# Read input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

polymer_template = lines[0].strip()
pair_insertion_rules = {}

for line in lines[1:]:
    rule = line.strip().split(' -> ')
    pair_insertion_rules[rule[0]] = rule[1]

# Apply 10 steps of pair insertion
polymer = polymer_template
for _ in range(10):
    polymer = apply_pair_insertion(polymer, pair_insertion_rules)

# Count occurrences of each element in the resulting polymer
element_count = count_elements(polymer)

# Find the most and least common elements
most_common_element = max(element_count, key=element_count.get)
least_common_element = min(element_count, key=element_count.get)

# Calculate the desired result
result = element_count[most_common_element] - element_count[least_common_element]

print(result)
",2.0
445,2021,14,2,part1_failed,,2884513602164,,,
446,2021,15,1,no_error,"423
",423,,"
# Read input from file
with open('input.txt', 'r') as file:
    cave_map = [[int(x) for x in line.strip()] for line in file]

# Get the dimensions of the cave
rows = len(cave_map)
cols = len(cave_map[0])

# Create a grid to store the minimum total risk
min_risk_grid = [[0] * cols for _ in range(rows)]

# Calculate the minimum total risk for each position
for i in range(rows):
    for j in range(cols):
        if i == 0 and j == 0:
            # The starting position has no risk
            min_risk_grid[i][j] = 0
        elif i == 0:
            # Calculate minimum risk for the first row
            min_risk_grid[i][j] = min_risk_grid[i][j-1] + cave_map[i][j-1]
        elif j == 0:
            # Calculate minimum risk for the first column
            min_risk_grid[i][j] = min_risk_grid[i-1][j] + cave_map[i-1][j]
        else:
            # Calculate minimum risk for other positions
            min_risk_grid[i][j] = min(min_risk_grid[i-1][j], min_risk_grid[i][j-1]) + cave_map[i][j]

# The lowest total risk is the value at the bottom right position
lowest_total_risk = min_risk_grid[rows-1][cols-1]

# Print the result
print(lowest_total_risk)
",1.0
447,2021,15,2,wrong_output,"2087
",2778,,"
# Read input from file
with open('input.txt', 'r') as file:
    cave_map = [[int(x) for x in line.strip()] for line in file]

# Get the dimensions of the original map
original_rows = len(cave_map)
original_cols = len(cave_map[0])

# Calculate the dimensions of the full map
rows = original_rows * 5
cols = original_cols * 5

# Create a grid to store the minimum total risk
min_risk_grid = [[0] * cols for _ in range(rows)]

# Calculate the minimum total risk for each position
for i in range(rows):
    for j in range(cols):
        original_i = i % original_rows
        original_j = j % original_cols

        if i == 0 and j == 0:
            # The starting position has no risk
            min_risk_grid[i][j] = 0
        elif i == 0:
            # Calculate minimum risk for the first row
            min_risk_grid[i][j] = min_risk_grid[i][j-1] + cave_map[original_i][original_j-1]
        elif j == 0:
            # Calculate minimum risk for the first column
            min_risk_grid[i][j] = min_risk_grid[i-1][j] + cave_map[original_i-1][original_j]
        else:
            # Calculate minimum risk for other positions
            min_risk_grid[i][j] = min(min_risk_grid[i-1][j], min_risk_grid[i][j-1]) + cave_map[original_i][original_j]

# The lowest total risk is the value at the bottom right position
lowest_total_risk = min_risk_grid[rows-1][cols-1]

# Print the result
print(lowest_total_risk)
",2.0
448,2021,16,1,syntax_error,,947,"  File ""/tmp/tmpvn6z2pdg/tmp.py"", line 1
    To solve this task, we need to parse the hexadecimal representation of the BITS transmission and calculate the sum of all the version numbers in the packets. We'll start by reading the input from the 'input.txt' file. Let's begin by writing a function to convert a hexadecimal character to its binary representation.
       ^
SyntaxError: invalid syntax
","To solve this task, we need to parse the hexadecimal representation of the BITS transmission and calculate the sum of all the version numbers in the packets. We'll start by reading the input from the 'input.txt' file. Let's begin by writing a function to convert a hexadecimal character to its binary representation.",2.0
449,2021,16,2,part1_failed,,660797830937,,,
450,2021,17,1,syntax_error,,8646,"  File ""/tmp/tmpmawym1_o/tmp.py"", line 1
    To solve this problem, we can iterate through all possible initial velocities and simulate the trajectory of the probe. We will keep track of the maximum `y` position reached and check if the probe is within the target area after each step.
       ^
SyntaxError: invalid syntax
","To solve this problem, we can iterate through all possible initial velocities and simulate the trajectory of the probe. We will keep track of the maximum `y` position reached and check if the probe is within the target area after each step.

First, let's read the target area from the input file 'input.txt':",2.0
451,2021,17,2,part1_failed,,5945,,,
452,2021,18,1,runtime_error,,4184,"Traceback (most recent call last):
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 72, in <module>
    main()
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 66, in main
    result = solve_homework(homework)
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 53, in solve_homework
    result = reduce(homework[0])
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 44, in reduce
    snailfish = explode(snailfish)
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 19, in explode
    left = explode(snailfish[0])
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 19, in explode
    left = explode(snailfish[0])
  File ""/tmp/tmp11kxm2ey/tmp.py"", line 27, in explode
    return [left + right, 0]
TypeError: unsupported operand type(s) for +: 'int' and 'list'
","
import re
import ast

def magnitude(snailfish):
    if isinstance(snailfish, int):
        return snailfish

    left = magnitude(snailfish[0])
    right = magnitude(snailfish[1])

    return (3 * left) + (2 * right)

def explode(snailfish):
    if isinstance(snailfish, int):
        return snailfish

    if isinstance(snailfish[0], list):
        left = explode(snailfish[0])
        right = magnitude(snailfish[1])

        return [0, left + right]

    left = magnitude(snailfish[0])
    right = explode(snailfish[1])

    return [left + right, 0]

def split(snailfish):
    if isinstance(snailfish, int):
        if snailfish >= 10:
            return [snailfish // 2, snailfish // 2 + snailfish % 2]
        return snailfish

    left = split(snailfish[0])
    right = split(snailfish[1])

    return [left, right]

def reduce(snailfish):
    if isinstance(snailfish, int):
        return snailfish

    snailfish = explode(snailfish)
    snailfish = split(snailfish)
    
    return snailfish

def add(snailfish1, snailfish2):
    return [snailfish1, snailfish2]

def solve_homework(homework):
    result = reduce(homework[0])

    for snailfish in homework[1:]:
        snailfish = reduce(snailfish)
        result = add(result, snailfish)

    return result

def main():
    with open(""input.txt"", ""r"") as f:
        input_lines = f.read().strip().split(""\n"")

    homework = [ast.literal_eval(line) for line in input_lines]
    result = solve_homework(homework)
    magnitude_result = magnitude(result)

    print(magnitude_result)

if __name__ == ""__main__"":
    main()
",2.0
453,2021,18,2,part1_failed,,4731,,,
454,2021,19,1,wrong_output,"1
",405,,"
import re

# Parse the input file and store the scanner reports
scanners = []
with open('input.txt', 'r') as file:
    scanner_report = []
    for line in file:
        if line.startswith('--- scanner'):
            if scanner_report:
                scanners.append(scanner_report)
            scanner_report = []
        else:
            beacon = tuple(map(int, re.findall(r'-?\d+', line)))
            scanner_report.append(beacon)
    scanners.append(scanner_report)

# Find the overlapping beacons for each pair of scanners
overlapping_beacons = {}
for i in range(len(scanners)):
    for j in range(i + 1, len(scanners)):
        scanner1 = scanners[i]
        scanner2 = scanners[j]
        common_beacons = set(scanner1).intersection(scanner2)
        if len(common_beacons) >= 12:
            overlapping_beacons[(i, j)] = common_beacons

# Determine the relative positions of the scanners
relative_positions = {}
for (i, j), common_beacons in overlapping_beacons.items():
    for beacon in common_beacons:
        x1, y1, z1 = beacon
        for beacon2 in common_beacons:
            x2, y2, z2 = beacon2
            relative_positions[(i, j)] = (x2 - x1, y2 - y1, z2 - z1)
            break
        break

# Determine the position of scanner 0
position_0 = (0, 0, 0)

# Calculate the absolute positions of all beacons
absolute_positions = {position_0: 0}
for scanner_pair, relative_position in relative_positions.items():
    scanner1, scanner2 = scanner_pair
    absolute_position = tuple(map(sum, zip(position_0, relative_position)))
    absolute_positions[absolute_position] = scanner2

# Calculate the number of beacons
num_beacons = len(absolute_positions)

print(num_beacons)
",2.0
455,2021,19,2,part1_failed,,12306,,,
456,2021,20,1,runtime_error,,5682,"Traceback (most recent call last):
  File ""/tmp/tmp0cyecrqm/tmp.py"", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","import numpy as np

def enhance_image(input_image, enhancement_algorithm):
    output_image = []
    for row in range(len(input_image)):
        new_row = """"
        for col in range(len(input_image[row])):
            neighbors = """"
            for i in range(row-1, row+2):
                for j in range(col-1, col+2):
                    if i >= 0 and i < len(input_image) and j >= 0 and j < len(input_image[row]):
                        neighbors += input_image[i][j]
            
            index = int(neighbors, 2)
            new_row += enhancement_algorithm[index]
        
        output_image.append(new_row)
    
    return output_image

def count_lit_pixels(image):
    count = 0
    for row in image:
        count += row.count(""#"")
    return count

# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

enhancement_algorithm = lines[0].strip()
input_image = [line.strip() for line in lines[1:]]

# Enhance image twice
enhanced_image = enhance_image(input_image, enhancement_algorithm)
enhanced_image = enhance_image(enhanced_image, enhancement_algorithm)

# Count lit pixels in the resulting image
lit_pixels = count_lit_pixels(enhanced_image)
print(lit_pixels)",2.0
457,2021,20,2,part1_failed,,17628,,,
458,2021,21,1,wrong_output,"744000
",504972,,"
import itertools

def simulate_game(player1_start, player2_start):
    scores = [0, 0]
    die = itertools.cycle(range(1, 101))
    num_rolls = 0

    while True:
        # Player 1's turn
        roll1, roll2, roll3 = next(die), next(die), next(die)
        total_roll = roll1 + roll2 + roll3
        player1_start = (player1_start + total_roll - 1) % 10 + 1
        scores[0] += player1_start

        if scores[0] >= 1000:
            return scores[0] * num_rolls

        # Player 2's turn
        roll1, roll2, roll3 = next(die), next(die), next(die)
        total_roll = roll1 + roll2 + roll3
        player2_start = (player2_start + total_roll - 1) % 10 + 1
        scores[1] += player2_start

        if scores[1] >= 1000:
            return scores[1] * num_rolls

        num_rolls += 6

# Read the starting positions from input.txt
with open('input.txt', 'r') as file:
    player1_start = int(file.readline().split()[-1])
    player2_start = int(file.readline().split()[-1])

# Simulate the game and calculate the result
result = simulate_game(player1_start, player2_start)
print(result)
",2.0
459,2021,21,2,part1_failed,,446968027750017,,,
460,2021,22,1,wrong_output,,600458,,"
def parse_input(input_str):
    steps = []
    for line in input_str.split(""\n""):
        if line:
            step = {}
            parts = line.split("" "")
            if parts[0] == ""on"":
                step[""state""] = True
            elif parts[0] == ""off"":
                step[""state""] = False
            coords = parts[1].split("","")
            x_range = coords[0].split(""="")[1].split("".."")
            y_range = coords[1].split(""="")[1].split("".."")
            z_range = coords[2].split(""="")[1].split("".."")
            step[""x_range""] = (int(x_range[0]), int(x_range[1]))
            step[""y_range""] = (int(y_range[0]), int(y_range[1]))
            step[""z_range""] = (int(z_range[0]), int(z_range[1]))
            steps.append(step)
    return steps

def initialize_grid():
    grid = {}
    for x in range(-50, 51):
        for y in range(-50, 51):
            for z in range(-50, 51):
                grid[(x, y, z)] = False
    return grid

def perform_reboot(steps):
    grid = initialize_grid()
    for step in steps:
        for x in range(step[""x_range""][0], step[""x_range""][1] + 1):
            for y in range(step[""y_range""][0], step[""y_range""][1] + 1):
                for z in range(step[""z_range""][0], step[""z_range""][1] + 1):
                    grid[(x, y, z)] = step[""state""]
    return grid

def count_on_cubes(grid):
    count = 0
    for cube in grid.values():
        if cube:
            count += 1
    return count

def main():
    with open(""input.txt"", ""r"") as file:
        input_str = file.read()
    steps = parse_input(input_str)
    grid = perform_reboot(steps)
    count = count_on_cubes(grid)
    print(count)

if __name__ == ""__main__"":
    main()
",2.0
461,2021,22,2,part1_failed,,1334275219162622,,,
462,2021,23,1,runtime_error,,19019,"Traceback (most recent call last):
  File ""/tmp/tmphkauf0vu/tmp.py"", line 61, in <module>
    min_energy = memo[end_node]
KeyError: None
","
import sys
from collections import deque

# Read the input
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Parse the input and initialize the graph
graph = {}
start_node = None
end_node = None
for y, line in enumerate(lines):
    for x, char in enumerate(line.strip()):
        if char in 'ABCD':
            node = (x, y, char)
            graph[node] = []
            if char == 'A':
                start_node = node
            if char == 'D' and x == len(line.strip()) - 1:
                end_node = node

# Add edges to the graph
for node in graph:
    x, y, _ = node
    for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:
        nx, ny = x + dx, y + dy
        if (nx, ny) in graph:
            graph[node].append((nx, ny))

# Perform BFS
memo = {}  # Memoization table to store the minimum energy required to reach each node
queue = deque([(start_node, 0)])  # Start BFS from the initial configuration with energy 0
while queue:
    node, energy = queue.popleft()
    memo[node] = energy

    # Stop BFS if we reach the final configuration
    if node == end_node:
        break

    x, y, _ = node
    for nx, ny in graph[node]:
        next_node = (nx, ny, graph[ny, nx])  # Note the change in coordinates and type
        next_energy = energy
        if next_node[2] != node[2]:  # If the type changes, add the corresponding energy
            if next_node[2] == 'A':
                next_energy += 1
            elif next_node[2] == 'B':
                next_energy += 10
            elif next_node[2] == 'C':
                next_energy += 100
            elif next_node[2] == 'D':
                next_energy += 1000

        # Only add the node to the queue if we haven't visited it before with a lower energy
        if next_node not in memo or next_energy < memo[next_node]:
            queue.append((next_node, next_energy))

# Retrieve the minimum energy required to reach the final configuration
min_energy = memo[end_node]

print(min_energy)
",2.0
463,2021,23,2,part1_failed,,47533,,,
464,2021,24,1,runtime_error,,49917929934999,"Traceback (most recent call last):
  File ""/tmp/tmpxf9fabpj/tmp.py"", line 109, in <module>
    largest_model_number = find_largest_model_number()
  File ""/tmp/tmpxf9fabpj/tmp.py"", line 104, in find_largest_model_number
    if validate_model_number(model_number):
  File ""/tmp/tmpxf9fabpj/tmp.py"", line 98, in validate_model_number
    execute_program(program)
  File ""/tmp/tmpxf9fabpj/tmp.py"", line 9, in execute_program
    opcode, a, b = instruction.split()
ValueError: not enough values to unpack (expected 3, got 2)
","
def execute_program(program):
    w = 0
    x = 0
    y = 0
    z = 0

    for instruction in program:
        opcode, a, b = instruction.split()
        a = get_variable(a)

        if opcode == 'inp':
            a = int(input())
        elif opcode == 'add':
            b = get_variable_or_number(b)
            a += b
        elif opcode == 'mul':
            b = get_variable_or_number(b)
            a *= b
        elif opcode == 'div':
            b = get_variable_or_number(b)
            a //= b
        elif opcode == 'mod':
            b = get_variable_or_number(b)
            a %= b
        elif opcode == 'eql':
            b = get_variable_or_number(b)
            a = 1 if a == b else 0

        set_variable(a)

def get_variable(variable):
    if variable == 'w':
        return w
    elif variable == 'x':
        return x
    elif variable == 'y':
        return y
    elif variable == 'z':
        return z

def set_variable(value):
    global w, x, y, z

    if a == 'w':
        w = value
    elif a == 'x':
        x = value
    elif a == 'y':
        y = value
    elif a == 'z':
        z = value

def get_variable_or_number(value):
    if value in ['w', 'x', 'y', 'z']:
        return get_variable(value)
    else:
        return int(value)

def generate_model_numbers():
    current_number = 99999999999999

    while current_number > 0:
        digits = [int(d) for d in str(current_number)]

        if all(d != 0 for d in digits):
            yield digits

        current_number -= 1

def validate_model_number(model_number):
    program = [
        'inp z',
        'inp x',
        'inp y',
        'inp w',
        'inp z',
        'inp x',
        'inp y',
        'inp w',
        'inp z',
        'inp x',
        'inp y',
        'inp w',
        'inp z',
        'inp x',
        'inp y',
        'eql z 1',
        'add z x',
        'eql z 1',
        'add z y',
        'eql z 1',
        'add z w',
        'eql z 1',
        'eql z z'
    ]

    execute_program(program)

    return z == 0

def find_largest_model_number():
    for model_number in generate_model_numbers():
        if validate_model_number(model_number):
            return ''.join(str(d) for d in model_number)

    return None

largest_model_number = find_largest_model_number()
print(largest_model_number)
",2.0
465,2021,24,2,part1_failed,,11911316711816,,,
466,2021,25,1,timeout_error,,489,TIMEOUT,"
def find_safe_landing(input_map):
    map_rows = len(input_map)
    map_cols = len(input_map[0])
    step = 0

    while True:
        new_map = [['.'] * map_cols for _ in range(map_rows)]
        moved = False

        for row in range(map_rows):
            for col in range(map_cols):
                current = input_map[row][col]
                new_row = row
                new_col = col

                if current == '>':
                    new_col = (col + 1) % map_cols
                    if new_map[new_row][new_col] == '.':
                        new_map[new_row][new_col] = '>'
                        moved = True

                elif current == 'v':
                    new_row = (row + 1) % map_rows
                    if new_map[new_row][new_col] == '.':
                        new_map[new_row][new_col] = 'v'
                        moved = True

                elif current == '<':
                    new_col = (col - 1) % map_cols
                    if new_map[new_row][new_col] == '.':
                        new_map[new_row][new_col] = '<'
                        moved = True

                elif current == '^':
                    new_row = (row - 1) % map_rows
                    if new_map[new_row][new_col] == '.':
                        new_map[new_row][new_col] = '^'
                        moved = True

        if not moved:
            return step

        input_map = new_map
        step += 1


def main():
    with open('input.txt', 'r') as f:
        input_map = [list(line.strip()) for line in f.readlines()]

    safe_step = find_safe_landing(input_map)
    print(f""The first step on which no sea cucumbers move is: {safe_step}"")


if __name__ == '__main__':
    main()
",2.0
467,2021,25,2,part1_failed,,,,,
468,2022,1,1,no_error,"70116
",70116,,"
def find_max_calories(file_path):
    with open(file_path, 'r') as file:
        lines = file.read().splitlines()

    elves_calories = []
    current_elf_calories = 0

    for line in lines:
        if line == """":
            if current_elf_calories > 0:
                elves_calories.append(current_elf_calories)
                current_elf_calories = 0
        else:
            current_elf_calories += int(line)

    if current_elf_calories > 0:
        elves_calories.append(current_elf_calories)

    max_calories = max(elves_calories)
    return max_calories


file_path = 'input.txt'
max_calories = find_max_calories(file_path)
print(max_calories)
",0.0
469,2022,1,2,no_error,"206582
",206582,,"
def find_top_three_calories(file_path):
    with open(file_path, 'r') as file:
        lines = file.read().splitlines()

    elves_calories = []
    current_elf_calories = 0

    for line in lines:
        if line == """":
            if current_elf_calories > 0:
                elves_calories.append(current_elf_calories)
                current_elf_calories = 0
        else:
            current_elf_calories += int(line)

    if current_elf_calories > 0:
        elves_calories.append(current_elf_calories)

    elves_calories.sort(reverse=True)
    top_three_calories = sum(elves_calories[:3])
    return top_three_calories


file_path = 'input.txt'
top_three_calories = find_top_three_calories(file_path)
print(top_three_calories)
",0.0
472,2022,2,1,wrong_output,"15831
",12276,,"
def calculate_score(strategy_guide):
    score = 0
    with open(strategy_guide, 'r') as file:
        lines = file.readlines()
        for line in lines:
            opponent, response = line.strip().split()
            if opponent == 'A':
                if response == 'X':
                    score += 8
                elif response == 'Y':
                    score += 1
                else:
                    score += 6
            elif opponent == 'B':
                if response == 'X':
                    score += 1
                elif response == 'Y':
                    score += 6
                else:
                    score += 8
            else:
                if response == 'X':
                    score += 6
                elif response == 'Y':
                    score += 8
                else:
                    score += 3
    return score

strategy_guide = 'input.txt'
total_score = calculate_score(strategy_guide)
print(total_score)
",2.0
473,2022,2,2,part1_failed,,9975,,,
474,2022,3,1,syntax_error,,8053,"  File ""/tmp/tmp4w68dda4/tmp.py"", line 1
    First, we need to read the input from the file 'input.txt' and store it in a list.
                                     ^
SyntaxError: invalid syntax
","First, we need to read the input from the file 'input.txt' and store it in a list.",2.0
475,2022,3,2,part1_failed,,2425,,,
476,2022,4,1,no_error,"441
",441,,"def count_overlapping_pairs(pairs):
    count = 0
    for pair in pairs:
        first_range = pair[0]
        second_range = pair[1]

        if (first_range[0] >= second_range[0] and first_range[1] <= second_range[1]) or \
           (second_range[0] >= first_range[0] and second_range[1] <= first_range[1]):
            count += 1

    return count


def parse_input(input_str):
    pairs = []
    for line in input_str.split('\n'):
        if line:
            ranges = line.split(',')
            first_range = tuple(map(int, ranges[0].split('-')))
            second_range = tuple(map(int, ranges[1].split('-')))
            pairs.append((first_range, second_range))

    return pairs


with open('input.txt', 'r') as f:
    input_str = f.read()

pairs = parse_input(input_str)
count = count_overlapping_pairs(pairs)
print(count)",1.0
477,2022,4,2,runtime_error,,861,"Traceback (most recent call last):
  File ""/tmp/tmpvsyi9ddb/tmp.py"", line 17, in <module>
    pairs = parse_input(input_str)
NameError: name 'parse_input' is not defined
","def count_any_overlapping_pairs(pairs):
    count = 0
    for i in range(len(pairs)):
        for j in range(i + 1, len(pairs)):
            first_range = pairs[i][0]
            second_range = pairs[j][0]

            if (first_range[0] >= second_range[0] and first_range[0] <= second_range[1]) or \
               (first_range[1] >= second_range[0] and first_range[1] <= second_range[1]) or \
               (second_range[0] >= first_range[0] and second_range[0] <= first_range[1]) or \
               (second_range[1] >= first_range[0] and second_range[1] <= first_range[1]):
                count += 1

    return count


pairs = parse_input(input_str)
count = count_any_overlapping_pairs(pairs)
print(count)",2.0
478,2022,5,1,runtime_error,,FCVRLMVQP,"Traceback (most recent call last):
  File ""/tmp/tmpp7n4ofx4/tmp.py"", line 22, in <module>
    destination_stack = int(move[4]) - 1
ValueError: invalid literal for int() with base 10: 'to'
","# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the starting stacks of crates
stacks = []
for line in lines:
    if line.strip() == '':
        break
    stack = line.strip().split(' ')
    stacks.append(stack)

# Parse the rearrangement procedure
moves = []
for line in lines[len(stacks)+1:]:
    move = line.strip().split(' ')
    moves.append(move)

# Rearrange the crates
for move in moves:
    source_stack = int(move[1]) - 1
    destination_stack = int(move[4]) - 1
    crate = stacks[source_stack].pop()
    stacks[destination_stack].append(crate)

# Get the top crate of each stack
top_crates = [stack[-1] for stack in stacks]

# Combine the top crates into a message
message = '*' + ''.join(top_crates) + '*'

# Print the message
print(message)",2.0
479,2022,5,2,part1_failed,,RWLWGJGFD,,,
480,2022,6,1,no_error,"1109
",1109,,"
def find_marker(datastream):
    for i in range(3, len(datastream)):
        if len(set(datastream[i-3:i+1])) == 4:
            return i + 1

# Read input from file
with open('input.txt', 'r') as file:
    datastream = file.read().strip()

# Find the position of the first marker
marker_position = find_marker(datastream)

# Print the result
print(marker_position)
",2.0
481,2022,6,2,no_error,"3965
",3965,,"
def find_message(datastream):
    for i in range(13, len(datastream)):
        if len(set(datastream[i-13:i+1])) == 14:
            return i + 1

# Read input from file
with open('input.txt', 'r') as file:
    datastream = file.read().strip()

# Find the position of the first message marker
message_position = find_message(datastream)

# Print the result
print(message_position)
",0.0
484,2022,7,1,runtime_error,,1443806,"Traceback (most recent call last):
  File ""/tmp/tmp66asl_rw/tmp.py"", line 56, in <module>
    root = parse_input(input_str)
  File ""/tmp/tmp66asl_rw/tmp.py"", line 23, in parse_input
    curr_dir = curr_dir.parent
AttributeError: 'Directory' object has no attribute 'parent'
","
import re

class Directory:
    def __init__(self, name):
        self.name = name
        self.size = 0
        self.children = []

    def add_child(self, child):
        self.children.append(child)

def parse_input(input_str):
    lines = input_str.strip().split('\n')
    root = Directory('/')
    curr_dir = root

    for line in lines:
        if line.startswith('$ cd'):
            parts = line.split(' ')
            path = parts[2]
            if path == '..':
                curr_dir = curr_dir.parent
            elif path == '/':
                curr_dir = root
            else:
                child_dir = next((child for child in curr_dir.children if child.name == path), None)
                if child_dir is None:
                    child_dir = Directory(path)
                    curr_dir.add_child(child_dir)
                curr_dir = child_dir
        elif line.startswith('$ ls'):
            parts = line.split(' ')
            curr_dir.size += sum(int(size) for size in re.findall(r'\d+', parts[1]))
    
    return root

def get_total_size(root, max_size):
    total_size = 0

    def dfs(dir):
        nonlocal total_size

        if dir.size <= max_size:
            total_size += dir.size

        for child in dir.children:
            dfs(child)

    dfs(root)
    return total_size

with open('input.txt', 'r') as f:
    input_str = f.read()

root = parse_input(input_str)
max_size = 100000
output = get_total_size(root, max_size)
print(output)
",2.0
485,2022,7,2,part1_failed,,942298,,,
486,2022,8,1,runtime_error,,1807,"Traceback (most recent call last):
  File ""/tmp/tmp0e3czzca/tmp.py"", line 11, in <module>
    if all(row[i] > max(row[:i]) for i in range(len(row))):
  File ""/tmp/tmp0e3czzca/tmp.py"", line 11, in <genexpr>
    if all(row[i] > max(row[:i]) for i in range(len(row))):
ValueError: max() arg is an empty sequence
","
# Read the input from file
with open('input.txt', 'r') as file:
    data = [list(map(int, line.strip())) for line in file.readlines()]


# Count visible trees from left and right
visible_trees = 0
for row in data:
    # Check left side
    if all(row[i] > max(row[:i]) for i in range(len(row))):
        visible_trees += 1
    # Check right side
    if all(row[i] > max(row[i+1:]) for i in range(len(row))):
        visible_trees += 1

# Count visible trees from top and bottom
for col in range(len(data[0])):
    # Check top side
    if all(data[i][col] > max(data[:i], key=lambda x: x[col]) for i in range(len(data))):
        visible_trees += 1
    # Check bottom side
    if all(data[i][col] > max(data[i+1:], key=lambda x: x[col]) for i in range(len(data))):
        visible_trees += 1

print(visible_trees)
",2.0
487,2022,8,2,part1_failed,,480000,,,
488,2022,9,1,wrong_output,"6949
",6087,,"
def simulate_rope_motion(motions):
    visited_positions = set()
    x, y = 0, 0  # Initial position of head and tail

    visited_positions.add((x, y))  # Mark initial position as visited

    for motion in motions:
        direction, steps = motion[0], int(motion[1:])

        for _ in range(steps):
            if direction == 'R':
                x += 1
            elif direction == 'L':
                x -= 1
            elif direction == 'U':
                y += 1
            elif direction == 'D':
                y -= 1

            visited_positions.add((x, y))  # Mark current position as visited

    return visited_positions

# Read input from file
with open('input.txt', 'r') as file:
    motions = file.read().strip().split('\n')

visited_positions = simulate_rope_motion(motions)
print(len(visited_positions))
",2.0
489,2022,9,2,part1_failed,,2493,,,
490,2022,10,1,wrong_output,"7680
",15360,,"
def calculate_signal_strength(program):
    X = 1
    cycle = 0
    signal_strength = 0

    for instruction in program:
        if instruction.startswith('addx'):
            value = int(instruction.split()[1])
            X += value
            cycle += 2
        elif instruction == 'noop':
            cycle += 1

        if cycle % 40 == 20:
            signal_strength += cycle * X
    
    return signal_strength

def main():
    with open('input.txt', 'r') as file:
        program = [line.strip() for line in file.readlines()]

    signal_strength = calculate_signal_strength(program)
    print(signal_strength)

if __name__ == '__main__':
    main()
",2.0
491,2022,10,2,part1_failed,,PHLHJGZA,,,
492,2022,11,1,syntax_error,,69918,"  File ""/tmp/tmp71j9gznr/tmp.py"", line 1
    First, we need to parse the input and represent it in a data structure. We can use a dictionary to store the information about each monkey. For each monkey, we store its starting items as a list, the operation to update the worry level, the test condition, and the actions to take if the test is true or false.
                                                                                                                                                                                             ^
SyntaxError: invalid syntax
","First, we need to parse the input and represent it in a data structure. We can use a dictionary to store the information about each monkey. For each monkey, we store its starting items as a list, the operation to update the worry level, the test condition, and the actions to take if the test is true or false.

Next, we need to simulate the rounds of stuff-slinging. We iterate for 20 rounds and for each round, we iterate over the monkeys in order. For each monkey, we iterate over its items, update the worry level based on the operation, divide the worry level by 3, and check the test condition. Depending on the result of the test, we throw the item to the appropriate monkey.

Finally, we count the number of times each monkey inspects items over the 20 rounds and calculate the level of monkey business by multiplying the counts of the two most active monkeys.

Here's the code:",2.0
493,2022,11,2,part1_failed,,19573408701,,,
494,2022,12,1,syntax_error,,504,"  File ""/tmp/tmppch179b4/tmp.py"", line 1
    The problem can be solved using a modified version of Breadth First Search (BFS) algorithm. We will keep track of the current position, the number of steps taken to reach that position, and the visited positions. At each step, we will explore all valid neighboring positions and add them to the queue for further exploration.
        ^
SyntaxError: invalid syntax
","The problem can be solved using a modified version of Breadth First Search (BFS) algorithm. We will keep track of the current position, the number of steps taken to reach that position, and the visited positions. At each step, we will explore all valid neighboring positions and add them to the queue for further exploration.

Here's the code that implements the solution:",2.0
495,2022,12,2,part1_failed,,500,,,
496,2022,13,1,wrong_output,"36
1305.0
",5503,,"
def compare_values(left, right):
    if isinstance(left, int) and isinstance(right, int):
        if left < right:
            return -1
        elif left > right:
            return 1
        else:
            return 0
    elif isinstance(left, list) and isinstance(right, list):
        for i in range(min(len(left), len(right))):
            cmp_result = compare_values(left[i], right[i])
            if cmp_result != 0:
                return cmp_result
        if len(left) < len(right):
            return -1
        elif len(left) > len(right):
            return 1
        else:
            return 0
    elif isinstance(left, int):
        return compare_values([left], right)
    elif isinstance(right, int):
        return compare_values(left, [right])

def is_pair_in_order(pair):
    return compare_values(pair[0], pair[1]) == -1

def find_ordered_pairs(packets):
    count = 0
    for i in range(0, len(packets), 2):
        pair = (packets[i], packets[i+1])
        if is_pair_in_order(pair):
            count += 1
    return count

def sum_ordered_pair_indices(packets):
    count = 0
    for i in range(0, len(packets), 2):
        pair = (packets[i], packets[i+1])
        if is_pair_in_order(pair):
            count += i / 2 + 1
    return count

def main():
    # Read input from file
    with open('input.txt', 'r') as file:
        lines = file.readlines()

    # Remove newline characters
    lines = [line.strip() for line in lines]

    # Group packets into pairs
    packets = []
    pair = []
    for line in lines:
        if line == '':
            packets.append(pair)
            pair = []
        else:
            pair.append(eval(line))
    packets.append(pair)

    # Find the number of ordered pairs
    ordered_pairs_count = find_ordered_pairs(packets)
    print(ordered_pairs_count)

    # Find the sum of the indices of ordered pairs
    sum_indices = sum_ordered_pair_indices(packets)
    print(sum_indices)

if __name__ == '__main__':
    main()
",2.0
497,2022,13,2,part1_failed,,20952,,,
498,2022,14,1,syntax_error,,825,"  File ""/tmp/tmp575dv2w3/tmp.py"", line 1
    I will begin by reading the input from the file 'input.txt' and parsing it into a data structure that can be easily processed.
      ^
SyntaxError: invalid syntax
",I will begin by reading the input from the file 'input.txt' and parsing it into a data structure that can be easily processed.,2.0
499,2022,14,2,part1_failed,,26729,,,
500,2022,15,1,syntax_error,,4861076,"  File ""/tmp/tmpe911rnby/tmp.py"", line 1
    I will write a function that takes the input data as a string and returns the number of positions in the given row that cannot contain a beacon.
      ^
SyntaxError: invalid syntax
",I will write a function that takes the input data as a string and returns the number of positions in the given row that cannot contain a beacon.,2.0
501,2022,15,2,part1_failed,,10649103160102,,,
502,2022,16,1,runtime_error,,2080,"Traceback (most recent call last):
  File ""/tmp/tmpho5fq6tb/tmp.py"", line 38, in <module>
    valves = parse_input(input_str)
  File ""/tmp/tmpho5fq6tb/tmp.py"", line 6, in parse_input
    flow_rate, tunnels = rest.split('; tunnels lead to ')
ValueError: not enough values to unpack (expected 2, got 1)
","
def parse_input(input_str):
    valves = {}
    for line in input_str.strip().split('\n'):
        valve, rest = line.split(' has flow rate=')
        flow_rate, tunnels = rest.split('; tunnels lead to ')
        tunnels = tunnels.split(', ')
        valves[valve] = (int(flow_rate), tunnels)
    return valves

def dfs(valves, current_valve, remaining_time, total_pressure):
    if remaining_time == 0 or current_valve in open_valves:
        return total_pressure
    
    max_pressure = 0
    for tunnel in valves[current_valve][1]:
        flow_rate = valves[current_valve][0]
        pressure = flow_rate * remaining_time
        next_valve = tunnel.split(' ')[-1]
        next_time = remaining_time - 1
        max_pressure = max(max_pressure, dfs(valves, next_valve, next_time, total_pressure + pressure))
    
    return max_pressure

input_str = '''
Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
'''

valves = parse_input(input_str)

open_valves = set()

max_pressure = dfs(valves, 'AA', 30, 0)

print(max_pressure)
",2.0
503,2022,16,2,part1_failed,,2752,,,
504,2022,17,1,runtime_error,,3235,"Traceback (most recent call last):
  File ""/tmp/tmpx_pc56yu/tmp.py"", line 64, in <module>
    chamber = simulate_falling_rocks(jet_pattern, rock_shapes, 2022)
  File ""/tmp/tmpx_pc56yu/tmp.py"", line 31, in simulate_falling_rocks
    rock_shape = rock_shapes[current_rock_index]
IndexError: list index out of range
","
def read_input():
    with open('input.txt') as f:
        lines = f.read().strip().split('\n')
        jet_pattern = lines[0]
        rock_shapes = []
        for i in range(1, len(lines), 7):
            rock_shapes.append([list(line) for line in lines[i:i+7]])
        return jet_pattern, rock_shapes


jet_pattern, rock_shapes = read_input()


def initialize_chamber():
    chamber = [['.' for _ in range(7)] for _ in range(10)]
    return chamber


def print_chamber(chamber):
    for row in chamber:
        print(''.join(row))


def simulate_falling_rocks(jet_pattern, rock_shapes, num_stopped_rocks):
    chamber = initialize_chamber()
    stopped_rocks = 0
    current_rock_index = 0

    while stopped_rocks < num_stopped_rocks:
        rock_shape = rock_shapes[current_rock_index]
        current_rock_index = (current_rock_index + 1) % len(rock_shapes)
        falling = True

        while falling:
            falling = False

            for i in range(len(chamber) - 1, -1, -1):
                for j in range(len(chamber[0])):
                    if chamber[i][j] == '@':
                        if i + 1 < len(chamber) and chamber[i+1][j] != '#' and rock_shape[i+1][j] == '.':
                            chamber[i][j] = '.'
                            chamber[i+1][j] = '@'
                            falling = True
                        else:
                            chamber[i][j] = '#'
                            stopped_rocks += 1

            for i in range(len(chamber)):
                for j in range(len(chamber[0])):
                    if chamber[i][j] == '@':
                        if jet_pattern[current_rock_index % len(jet_pattern)] == '<' and j > 0 and chamber[i][j-1] != '#' and rock_shape[i][j-1] == '.':
                            chamber[i][j] = '.'
                            chamber[i][j-1] = '@'
                            falling = True
                        elif jet_pattern[current_rock_index % len(jet_pattern)] == '>' and j < len(chamber[0]) - 1 and chamber[i][j+1] != '#' and rock_shape[i][j+1] == '.':
                            chamber[i][j] = '.'
                            chamber[i][j+1] = '@'
                            falling = True

    return chamber


chamber = simulate_falling_rocks(jet_pattern, rock_shapes, 2022)


def get_tower_height(chamber):
    return sum(1 for cell in chamber[0] if cell == '#')


tower_height = get_tower_height(chamber)
print(tower_height)
",2.0
505,2022,17,2,part1_failed,,1591860465110,,,
506,2022,18,1,no_error,"4310
",4310,,"
def count_surface_area(input_file):
    # Read the input file
    with open(input_file, 'r') as file:
        lines = file.readlines()

    # Parse the coordinates of the cubes
    cubes = [tuple(map(int, line.strip().split(','))) for line in lines]

    # Define the directions to check for neighboring cubes
    directions = [(0, 1, 0), (0, -1, 0), (1, 0, 0), (-1, 0, 0), (0, 0, 1), (0, 0, -1)]

    # Initialize the surface area count
    surface_area = 0

    # Check each cube for exposed sides
    for cube in cubes:
        x, y, z = cube
        exposed_sides = 0
        for dx, dy, dz in directions:
            if (x + dx, y + dy, z + dz) not in cubes:
                exposed_sides += 1
        surface_area += exposed_sides

    return surface_area

# Test the function with the example input
print(count_surface_area('input.txt'))
",0.0
507,2022,18,2,wrong_output,"4310
",2466,,"
def count_exterior_surface_area(input_file):
    # Read the input file
    with open(input_file, 'r') as file:
        lines = file.readlines()

    # Parse the coordinates of the cubes
    cubes = [tuple(map(int, line.strip().split(','))) for line in lines]

    # Define the directions to check for neighboring cubes
    directions = [(0, 1, 0), (0, -1, 0), (1, 0, 0), (-1, 0, 0), (0, 0, 1), (0, 0, -1)]

    # Initialize the exterior surface area count
    exterior_surface_area = 0

    # Check each cube for exposed sides, excluding air pockets
    for cube in cubes:
        x, y, z = cube
        exposed_sides = 0
        for dx, dy, dz in directions:
            neighbor = (x + dx, y + dy, z + dz)
            if neighbor not in cubes and neighbor != cube:
                exposed_sides += 1
        exterior_surface_area += exposed_sides

    return exterior_surface_area

# Test the function with the example input
print(count_exterior_surface_area('input.txt'))
",2.0
508,2022,19,1,runtime_error,,1613,"Traceback (most recent call last):
  File ""/tmp/tmpl2byn4jk/tmp.py"", line 48, in <module>
    main()
  File ""/tmp/tmpl2byn4jk/tmp.py"", line 42, in main
    blueprints = [parse_blueprint(bp) for bp in blueprint_strs]
  File ""/tmp/tmpl2byn4jk/tmp.py"", line 42, in <listcomp>
    blueprints = [parse_blueprint(bp) for bp in blueprint_strs]
  File ""/tmp/tmpl2byn4jk/tmp.py"", line 4, in parse_blueprint
    blueprint_id = int(lines[0].split()[1])
ValueError: invalid literal for int() with base 10: '1:'
","
def parse_blueprint(blueprint_str):
    lines = blueprint_str.strip().split('\n')
    blueprint_id = int(lines[0].split()[1])
    costs = {}
    for line in lines[1:]:
        resource, amount = line.split()[-2:]
        costs[resource] = int(amount)
    return blueprint_id, costs

def calculate_geodes(blueprint, minutes):
    ore, clay, obsidian = 0, 0, 0
    geodes = 0
    for minute in range(1, minutes + 1):
        ore += 1
        if minute % 3 == 0:
            ore -= blueprint['ore_collector']
        if minute % 4 == 0:
            clay -= blueprint['clay_collector']
        if minute % 5 == 0:
            obsidian -= blueprint['obsidian_collector']
        if minute % 6 == 0:
            clay += blueprint['clay_collector']
        if minute % 11 == 0:
            obsidian += blueprint['obsidian_collector']
        if minute % 18 == 0:
            geodes += blueprint['geode_cracker']
    return geodes

def calculate_quality_level(blueprints):
    quality_levels = []
    for blueprint in blueprints:
        blueprint_id, costs = blueprint
        max_geodes = calculate_geodes(costs, 24)
        quality_level = blueprint_id * max_geodes
        quality_levels.append(quality_level)
    return sum(quality_levels)

def main():
    with open('input.txt', 'r') as file:
        blueprint_strs = file.read().strip().split('\n\n')
        blueprints = [parse_blueprint(bp) for bp in blueprint_strs]

    total_quality = calculate_quality_level(blueprints)
    print(total_quality)

if __name__ == '__main__':
    main()
",2.0
509,2022,19,2,part1_failed,,46816,,,
510,2022,20,1,wrong_output,"The sum of the grove coordinates is: -8472
",18257,,"
def mix_file(file):
    numbers = [int(line) for line in file]
    num_moves = len(numbers)
    for i, num in enumerate(numbers):
        if num != 0:
            move = num % num_moves
            numbers = numbers[:i] + numbers[i+1:] + [num]
            numbers = numbers[move:] + numbers[:move]
    return numbers

def find_grove_coordinates(numbers):
    grove_coordinates = []
    current_index = 0
    for _ in range(3):
        for _ in range(1000):
            current_index = (current_index + numbers[current_index] + 1) % len(numbers)
        grove_coordinates.append(numbers[current_index])
    return grove_coordinates

# Read the encrypted file
with open('input.txt', 'r') as file:
    # Mix the file
    mixed_file = mix_file(file)

    # Find the grove coordinates
    grove_coordinates = find_grove_coordinates(mixed_file)

    # Calculate the sum of the grove coordinates
    sum_of_coordinates = sum(grove_coordinates)

    print(f""The sum of the grove coordinates is: {sum_of_coordinates}"")
",2.0
511,2022,20,2,part1_failed,,4148032160983,,,
512,2022,21,1,runtime_error,,118565889858886,"Traceback (most recent call last):
  File ""/tmp/tmpzjtuhmh_/tmp.py"", line 48, in <module>
    result = find_number('input.txt')
  File ""/tmp/tmpzjtuhmh_/tmp.py"", line 26, in find_number
    operand1 = monkey_numbers[operands[0]]
KeyError: 'gcpq'
","def find_number(input_file):
    # Read the input file
    with open(input_file, 'r') as f:
        input_data = f.readlines()

    # Create a dictionary to store the numbers yelled by each monkey
    monkey_numbers = {}

    # Process each line in the input data
    for line in input_data:
        # Split the line into monkey name and job
        monkey_name, job = line.strip().split(':')

        # Check if the job is a lone number
        if job.isdigit():
            # Store the number yelled by the monkey
            monkey_numbers[monkey_name] = int(job)
        else:
            # Split the job into operand names
            operands = job.split()

            # Check if the operands are numbers or monkey names
            if operands[0].isdigit():
                operand1 = int(operands[0])
            else:
                operand1 = monkey_numbers[operands[0]]

            if operands[2].isdigit():
                operand2 = int(operands[2])
            else:
                operand2 = monkey_numbers[operands[2]]

            # Perform the specified operation and store the result
            if operands[1] == '+':
                result = operand1 + operand2
            elif operands[1] == '-':
                result = operand1 - operand2
            elif operands[1] == '*':
                result = operand1 * operand2
            elif operands[1] == '/':
                result = operand1 / operand2

            monkey_numbers[monkey_name] = result

    # Return the number yelled by the monkey named 'root'
    return monkey_numbers['root']

result = find_number('input.txt')
print(result)",2.0
513,2022,21,2,part1_failed,,3032671800353,,,
514,2022,22,1,runtime_error,,93226,"Traceback (most recent call last):
  File ""/tmp/tmpw2ydphkl/tmp.py"", line 24, in <module>
    steps = int(path[i])
ValueError: invalid literal for int() with base 10: '.'
","
# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Extract board and path from input
board = [list(line.strip()) for line in lines[:len(lines)//2]]
path = lines[len(lines)//2].strip()

# Get board dimensions
rows = len(board)
cols = len(board[0])

# Define directions: right, down, left, up
directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

# Start position and facing
row = 0
col = 0
facing = 0  # 0: right, 1: down, 2: left, 3: up

# Simulate path movement
for i in range(0, len(path), 2):
    steps = int(path[i])
    turn = path[i + 1]

    # Move forward in the current direction
    for _ in range(steps):
        row += directions[facing][0]
        col += directions[facing][1]

        # Wrap around if necessary
        if row < 0:
            row = rows - 1
        elif row >= rows:
            row = 0
        if col < 0:
            col = cols - 1
        elif col >= cols:
            col = 0

        # Stop if hitting a wall
        if board[row][col] == '#':
            break

    # Update facing based on turn
    if turn == 'R':
        facing = (facing + 1) % 4
    elif turn == 'L':
        facing = (facing - 1) % 4

# Calculate password
password = 1000 * (row + 1) + 4 * (col + 1) + facing

# Print the final password
print(password)
",2.0
515,2022,22,2,part1_failed,,37415,,,
516,2022,23,1,runtime_error,,4109,"Traceback (most recent call last):
  File ""/tmp/tmp3ro4qrq0/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np

def simulate_elves_process(grid):
    rows, cols = grid.shape
    directions = ['N', 'NE', 'NW', 'S', 'SE', 'SW', 'W', 'E']
    direction_order = ['N', 'S', 'W', 'E']
    
    for _ in range(10):
        proposed_moves = {}
        for i in range(rows):
            for j in range(cols):
                if grid[i, j] == '#':
                    continue
                adjacent_positions = get_adjacent_positions(i, j, rows, cols)
                proposed_moves[(i, j)] = None
                for direction in direction_order:
                    proposed_position = move(i, j, direction)
                    if proposed_position in adjacent_positions:
                        proposed_moves[(i, j)] = direction
                        break
        
        for i in range(rows):
            for j in range(cols):
                if grid[i, j] == '#':
                    continue
                proposed_direction = proposed_moves[(i, j)]
                if proposed_direction:
                    proposed_position = move(i, j, proposed_direction)
                    if not any(proposed_position == move(i, j, d) for d in directions):
                        grid[proposed_position] = grid[i, j]
                        grid[i, j] = '.'
    
    return grid

def get_adjacent_positions(i, j, rows, cols):
    positions = []
    if i > 0:
        positions.append((i - 1, j))
        if j > 0:
            positions.append((i - 1, j - 1))
        if j < cols - 1:
            positions.append((i - 1, j + 1))
    if i < rows - 1:
        positions.append((i + 1, j))
        if j > 0:
            positions.append((i + 1, j - 1))
        if j < cols - 1:
            positions.append((i + 1, j + 1))
    if j > 0:
        positions.append((i, j - 1))
    if j < cols - 1:
        positions.append((i, j + 1))
    return positions

def move(i, j, direction):
    if direction == 'N':
        return i - 1, j
    elif direction == 'NE':
        return i - 1, j + 1
    elif direction == 'NW':
        return i - 1, j - 1
    elif direction == 'S':
        return i + 1, j
    elif direction == 'SE':
        return i + 1, j + 1
    elif direction == 'SW':
        return i + 1, j - 1
    elif direction == 'W':
        return i, j - 1
    elif direction == 'E':
        return i, j + 1

def count_empty_ground(grid):
    rows, cols = grid.shape
    min_row, max_row = rows, -1
    min_col, max_col = cols, -1
    for i in range(rows):
        for j in range(cols):
            if grid[i, j] == '#':
                min_row = min(min_row, i)
                max_row = max(max_row, i)
                min_col = min(min_col, j)
                max_col = max(max_col, j)
    return np.sum(grid[min_row:max_row+1, min_col:max_col+1] == '.')

with open('input.txt', 'r') as file:
    lines = file.readlines()

grid = np.array([list(line.strip()) for line in lines])

grid = simulate_elves_process(grid)

empty_ground_count = count_empty_ground(grid)

print(empty_ground_count)
",2.0
517,2022,23,2,part1_failed,,1055,,,
518,2022,24,1,runtime_error,,279,"Traceback (most recent call last):
  File ""/tmp/tmpps7g8gr0/tmp.py"", line 69, in <module>
    print(find_goal_time('input.txt'))
  File ""/tmp/tmpps7g8gr0/tmp.py"", line 31, in find_goal_time
    x, y = queue.pop(0)
TypeError: cannot unpack non-iterable NoneType object
","def find_goal_time(input_file):
    with open(input_file, 'r') as file:
        lines = file.read().splitlines()

    rows = len(lines)
    cols = len(lines[0])

    grid = [[0]*cols for _ in range(rows)]
    directions = {'^': (-1, 0), 'v': (1, 0), '<': (0, -1), '>': (0, 1)}

    start = None
    goal = None
    blizzards = []

    for i in range(rows):
        for j in range(cols):
            if lines[i][j] == '#':
                grid[i][j] = -1
            elif lines[i][j] == '.':
                grid[i][j] = float('inf')
            elif lines[i][j] == 'E':
                start = (i, j)
                grid[i][j] = 0
            elif lines[i][j] == '>':
                blizzards.append((i, j, 'right'))
            elif lines[i][j] == 'v':
                blizzards.append((i, j, 'down'))

    queue = [start]
    while queue:
        x, y = queue.pop(0)
        if (x, y) == goal:
            return grid[x][y]

        for direction in directions.values():
            dx, dy = direction
            nx, ny = x + dx, y + dy

            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == float('inf'):
                grid[nx][ny] = grid[x][y] + 1
                queue.append((nx, ny))

        for bx, by, bd in blizzards:
            if x == bx and y == by:
                continue

            if bd == 'right':
                if by < y:
                    if by < cols - 1 and grid[bx][by + 1] == float('inf'):
                        grid[bx][by + 1] = grid[bx][by] + 1
                        queue.append((bx, by + 1))
                else:
                    if by > 0 and grid[bx][by - 1] == float('inf'):
                        grid[bx][by - 1] = grid[bx][by] + 1
                        queue.append((bx, by - 1))

            elif bd == 'down':
                if bx < x:
                    if bx < rows - 1 and grid[bx + 1][by] == float('inf'):
                        grid[bx + 1][by] = grid[bx][by] + 1
                        queue.append((bx + 1, by))
                else:
                    if bx > 0 and grid[bx - 1][by] == float('inf'):
                        grid[bx - 1][by] = grid[bx][by] + 1
                        queue.append((bx - 1, by))

    return -1

print(find_goal_time('input.txt'))",2.0
519,2022,24,2,part1_failed,,762,,,
520,2022,25,1,runtime_error,,2=0=02-0----2-=02-10,"Traceback (most recent call last):
  File ""/tmp/tmp3ue0gd18/tmp.py"", line 29, in <module>
    decimal = int(file.readline())
ValueError: invalid literal for int() with base 10: '11=22-1-1-10=1\n'
","
def decimal_to_snafu(decimal):
    snafu_digits = []
    
    if decimal == 0:
        return '0'
    
    while decimal != 0:
        remainder = decimal % 5
        
        if remainder == 0:
            snafu_digits.append('0')
        elif remainder == 1:
            snafu_digits.append('1')
        elif remainder == 2:
            snafu_digits.append('2')
        elif remainder == 3:
            snafu_digits.append('=')
        elif remainder == 4:
            snafu_digits.append('-')
        
        decimal = decimal // 5
    
    return ''.join(snafu_digits[::-1])


# Read the decimal number from the input file
with open('input.txt', 'r') as file:
    decimal = int(file.readline())

# Convert the decimal number to SNAFU representation
snafu = decimal_to_snafu(decimal)

# Print the SNAFU number
print(snafu)
",2.0
521,2022,25,2,part1_failed,,,,,
