,year,day,part,status,output,expected_output,error,code,kpass
0,2015,1,1,no_error,"74
",74,,"def find_floor(parentheses):
    floor = 0
    for p in parentheses:
        if p == ""("":
            floor += 1
        elif p == "")"":
            floor -= 1
    return floor

# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Call the function
result = find_floor(input_string)

# Print the result
print(result)",0.0
1,2015,1,2,no_error,"1795
",1795,,"def find_basement_position(parentheses):
    floor = 0
    position = 0
    for p in parentheses:
        position += 1
        if p == ""("":
            floor += 1
        elif p == "")"":
            floor -= 1
        if floor == -1:
            return position
    return -1

# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Call the function
result = find_basement_position(input_string)

# Print the result
print(result)",0.0
2,2015,2,1,no_error,1586300,1586300,,"
def calculate_wrapping_paper(dimensions):
    total_paper = 0
    for dimension in dimensions:
        l, w, h = map(int, dimension.split('x'))
        surface_area = 2*l*w + 2*w*h + 2*h*l
        slack = min(l*w, w*h, h*l)
        total_paper += surface_area + slack
    return total_paper

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        dimensions = f.read().split('\n')
    wrapping_paper_required = calculate_wrapping_paper(dimensions)
    print(""Total square feet of wrapping paper required:"", wrapping_paper_required)
",0.0
3,2015,2,2,no_error,3737498,3737498,,"
def calculate_ribbon(dimensions):
    total_ribbon = 0
    for dimension in dimensions:
        l, w, h = map(int, dimension.split('x'))
        shortest_distance = min(2*l + 2*w, 2*w + 2*h, 2*h + 2*l)
        volume = l * w * h
        total_ribbon += shortest_distance + volume
    return total_ribbon

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        dimensions = f.read().split('\n')
    ribbon_required = calculate_ribbon(dimensions)
    print(""Total feet of ribbon required:"", ribbon_required)
",0.0
4,2015,3,1,no_error,"2565
",2565,,"# Read the input
with open('input.txt', 'r') as file:
    moves = file.read().strip()

# Initialize variables
visited_houses = set()
x = 0
y = 0

# Santa starts at the origin
visited_houses.add((x, y))

# Process each move
for move in moves:
    if move == '^':
        y += 1
    elif move == 'v':
        y -= 1
    elif move == '>':
        x += 1
    elif move == '<':
        x -= 1

    # Add the current house to the set of visited houses
    visited_houses.add((x, y))

# Output the number of visited houses
print(len(visited_houses))",0.0
5,2015,3,2,wrong_output,"2565
",2639,,"# Read the input
with open('input.txt', 'r') as file:
    moves = file.read().strip()

# Initialize variables
visited_houses = set()
x = 0
y = 0

# Santa starts at the origin
visited_houses.add((x, y))

# Process each move
for i, move in enumerate(moves):
    if i % 2 == 0:  # Santa's turn
        if move == '^':
            y += 1
        elif move == 'v':
            y -= 1
        elif move == '>':
            x += 1
        elif move == '<':
            x -= 1
    else:  # Robo-Santa's turn
        if move == '^':
            y += 1
        elif move == 'v':
            y -= 1
        elif move == '>':
            x += 1
        elif move == '<':
            x -= 1

    # Add the current house to the set of visited houses
    visited_houses.add((x, y))

# Output the number of visited houses
print(len(visited_houses))",0.0
6,2015,4,1,no_error,"117946
",117946,,"import hashlib

def find_lowest_number(secret_key):
    number = 0
    while True:
        number += 1
        hash_string = secret_key + str(number)
        hash_value = hashlib.md5(hash_string.encode()).hexdigest()
        if hash_value.startswith('00000'):
            return number

# Read input from file
with open('input.txt', 'r') as file:
    secret_key = file.read().strip()

# Find the lowest number
lowest_number = find_lowest_number(secret_key)

# Print the result
print(lowest_number)",0.0
7,2015,4,2,no_error,"3938038
",3938038,,"import hashlib

def find_lowest_number(secret_key):
    number = 0
    while True:
        number += 1
        hash_string = secret_key + str(number)
        hash_value = hashlib.md5(hash_string.encode()).hexdigest()
        if hash_value.startswith('000000'):
            return number

# Read input from file
with open('input.txt', 'r') as file:
    secret_key = file.read().strip()

# Find the lowest number
lowest_number = find_lowest_number(secret_key)

# Print the result
print(lowest_number)",0.0
8,2015,5,1,no_error,"236
",236,,"# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()
    
# Remove newline characters
strings = [line.strip() for line in lines]

# Define function to check if a string is nice
def is_nice(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    
    # Condition 1: Check if string contains at least three vowels
    vowel_count = sum([1 for char in string if char in vowels])
    if vowel_count < 3:
        return False
    
    # Condition 2: Check if string contains a double letter
    for i in range(len(string) - 1):
        if string[i] == string[i+1]:
            break
    else:
        return False
    
    # Condition 3: Check if string contains any disallowed substrings
    disallowed_substrings = ['ab', 'cd', 'pq', 'xy']
    for substring in disallowed_substrings:
        if substring in string:
            return False
    
    return True

# Count the number of nice strings
nice_count = sum([1 for string in strings if is_nice(string)])

# Print the result
print(nice_count)",0.0
9,2015,5,2,wrong_output,"69
",51,,"# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()
    
# Remove newline characters
strings = [line.strip() for line in lines]

# Define function to check if a string is nice
def is_nice(string):
    # Condition 1: Check if string contains a pair of any two letters that appears at least twice
    pairs = [string[i:i+2] for i in range(len(string)-1)]
    if len(set(pairs)) == len(pairs):
        return False
    
    # Condition 2: Check if string contains at least one letter which repeats with exactly one letter between them
    for i in range(len(string)-2):
        if string[i] == string[i+2]:
            break
    else:
        return False
    
    return True

# Count the number of nice strings
nice_count = sum([1 for string in strings if is_nice(string)])

# Print the result
print(nice_count)",0.0
10,2015,6,1,runtime_error,,400410,"Traceback (most recent call last):
  File ""/tmp/tmpdwwb7j9x/tmp.py"", line 45, in <module>
    result = process_instructions(instructions)
  File ""/tmp/tmpdwwb7j9x/tmp.py"", line 31, in process_instructions
    x1 = int(coordinates[0])
ValueError: invalid literal for int() with base 10: 'off'
","
def turn_on_lights(lights, x1, y1, x2, y2):
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            lights[i][j] = True

def turn_off_lights(lights, x1, y1, x2, y2):
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            lights[i][j] = False

def toggle_lights(lights, x1, y1, x2, y2):
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            lights[i][j] = not lights[i][j]

def count_on_lights(lights):
    count = 0
    for i in range(len(lights)):
        for j in range(len(lights[i])):
            if lights[i][j]:
                count += 1
    return count

def process_instructions(instructions):
    lights = [[False] * 1000 for _ in range(1000)]
    for instruction in instructions:
        parts = instruction.split(' ')
        command = parts[0]
        coordinates = parts[1].split(',')
        x1 = int(coordinates[0])
        y1 = int(coordinates[1])
        x2 = int(parts[3].split(',')[0])
        y2 = int(parts[3].split(',')[1])
        if command == 'turn on':
            turn_on_lights(lights, x1, y1, x2, y2)
        elif command == 'turn off':
            turn_off_lights(lights, x1, y1, x2, y2)
        elif command == 'toggle':
            toggle_lights(lights, x1, y1, x2, y2)
    return count_on_lights(lights)

with open('input.txt', 'r') as file:
    instructions = file.readlines()
    result = process_instructions(instructions)
    print(result)
",0.0
11,2015,6,2,part1_failed,,15343601,,,
12,2015,7,1,runtime_error,,46065,"Traceback (most recent call last):
  File ""/tmp/tmpdg5mom6q/tmp.py"", line 49, in <module>
    main()
  File ""/tmp/tmpdg5mom6q/tmp.py"", line 45, in main
    signal = find_wire_signal(instructions, 'a')
  File ""/tmp/tmpdg5mom6q/tmp.py"", line 41, in find_wire_signal
    return evaluate_instruction(instructions, wire, values)
  File ""/tmp/tmpdg5mom6q/tmp.py"", line 23, in evaluate_instruction
    op, input1, input2, output = parse_instruction(instr)
ValueError: not enough values to unpack (expected 4, got 3)
","
def read_input_file(filename):
    with open(filename, 'r') as file:
        instructions = file.read().splitlines()
    return instructions

def parse_instruction(instruction):
    parts = instruction.split(' ')
    if len(parts) == 3:
        return ('ASSIGN', parts[0], parts[2])
    elif len(parts) == 4:
        return ('NOT', parts[1], parts[3])
    else:
        return (parts[1], parts[0], parts[2], parts[4])

def evaluate_instruction(instructions, wire, values):
    if wire.isdigit():
        return int(wire)
    elif wire in values:
        return values[wire]
    else:
        for instr in instructions:
            op, input1, input2, output = parse_instruction(instr)
            if output == wire:
                if op == 'ASSIGN':
                    values[output] = evaluate_instruction(instructions, input1, values)
                elif op == 'AND':
                    values[output] = evaluate_instruction(instructions, input1, values) & evaluate_instruction(instructions, input2, values)
                elif op == 'OR':
                    values[output] = evaluate_instruction(instructions, input1, values) | evaluate_instruction(instructions, input2, values)
                elif op == 'LSHIFT':
                    values[output] = evaluate_instruction(instructions, input1, values) << int(input2)
                elif op == 'RSHIFT':
                    values[output] = evaluate_instruction(instructions, input1, values) >> int(input2)
                elif op == 'NOT':
                    values[output] = ~evaluate_instruction(instructions, input1, values)
                return values[output]

def find_wire_signal(instructions, wire):
    values = {}
    return evaluate_instruction(instructions, wire, values)

def main():
    instructions = read_input_file('input.txt')
    signal = find_wire_signal(instructions, 'a')
    print(f""The signal provided to wire 'a' is: {signal}"")

if __name__ == '__main__':
    main()
",0.0
13,2015,7,2,part1_failed,,14134,,,
14,2015,8,1,wrong_output,"1124
",1371,,"# Open the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Initialize variables for code characters and memory characters
code_chars = 0
memory_chars = 0

# Iterate over each line in the file
for line in lines:
    # Remove leading and trailing whitespace
    line = line.strip()
    
    # Update code characters count by adding the length of the line
    code_chars += len(line)
    
    # Remove the surrounding double quotes
    line = line[1:-1]
    
    # Replace escape sequences with a single character
    line = line.replace('\\\\', '\\').replace('\\""', '""')
    line = line.replace('\\x', 'x')
    
    # Update memory characters count by adding the length of the updated line
    memory_chars += len(line)

# Calculate the difference between code and memory characters
difference = code_chars - memory_chars

# Print the difference
print(difference)",0.0
15,2015,8,2,part1_failed,,2117,,,
16,2015,9,1,no_error,"251
",251,,"from itertools import permutations

def find_shortest_distance(distances):
    locations = set()
    distance_map = {}
    
    # Parse the input and create a distance map
    for distance in distances:
        location1, location2, distance_value = parse_distance(distance)
        locations.add(location1)
        locations.add(location2)
        distance_map[(location1, location2)] = distance_value
        distance_map[(location2, location1)] = distance_value
    
    # Find the shortest distance by generating all possible routes
    shortest_distance = float('inf')
    for route in permutations(locations):
        distance = calculate_distance(route, distance_map)
        shortest_distance = min(shortest_distance, distance)
    
    return shortest_distance

def parse_distance(distance):
    location1, rest = distance.split(' to ')
    location2, distance_value = rest.split(' = ')
    return location1, location2, int(distance_value)

def calculate_distance(route, distance_map):
    distance = 0
    for i in range(len(route) - 1):
        location1 = route[i]
        location2 = route[i+1]
        distance += distance_map[(location1, location2)]
    return distance

# Read input from file
with open('input.txt', 'r') as file:
    distances = file.readlines()

# Remove line breaks and leading/trailing spaces
distances = [distance.strip() for distance in distances]

# Find the shortest distance
shortest_distance = find_shortest_distance(distances)

# Print the result
print(shortest_distance)",0.0
17,2015,9,2,no_error,"898
",898,,"from itertools import permutations

def find_longest_distance(distances):
    locations = set()
    distance_map = {}
    
    # Parse the input and create a distance map
    for distance in distances:
        location1, location2, distance_value = parse_distance(distance)
        locations.add(location1)
        locations.add(location2)
        distance_map[(location1, location2)] = distance_value
        distance_map[(location2, location1)] = distance_value
    
    # Find the longest distance by generating all possible routes
    longest_distance = 0
    for route in permutations(locations):
        distance = calculate_distance(route, distance_map)
        longest_distance = max(longest_distance, distance)
    
    return longest_distance

def parse_distance(distance):
    location1, rest = distance.split(' to ')
    location2, distance_value = rest.split(' = ')
    return location1, location2, int(distance_value)

def calculate_distance(route, distance_map):
    distance = 0
    for i in range(len(route) - 1):
        location1 = route[i]
        location2 = route[i+1]
        distance += distance_map[(location1, location2)]
    return distance

# Read input from file
with open('input.txt', 'r') as file:
    distances = file.readlines()

# Remove line breaks and leading/trailing spaces
distances = [distance.strip() for distance in distances]

# Find the longest distance
longest_distance = find_longest_distance(distances)

# Print the result
print(longest_distance)",0.0
18,2015,10,1,no_error,"329356
",329356,,"
def look_and_say_sequence(s):
    for _ in range(40):
        result = """"
        count = 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                count += 1
            else:
                result += str(count) + s[i - 1]
                count = 1
        result += str(count) + s[-1]
        s = result
    return len(s)


# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read().strip()

# Generate and print the length of the resulting sequence
print(look_and_say_sequence(input_string))
",0.0
19,2015,10,2,no_error,"4666278
",4666278,,"
def look_and_say_sequence(s):
    for _ in range(50):
        result = """"
        count = 1
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                count += 1
            else:
                result += str(count) + s[i - 1]
                count = 1
        result += str(count) + s[-1]
        s = result
    return len(s)


# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read().strip()

# Generate and print the length of the resulting sequence
print(look_and_say_sequence(input_string))
",0.0
20,2015,11,1,timeout_error,,vzbxxyzz,TIMEOUT,"password = input()

def is_valid(password):
    # Check if password is exactly eight lowercase letters
    if len(password) != 8 or not password.islower():
        return False
    
    # Check if password contains increasing straight of at least three letters
    straight_count = 1
    for i in range(len(password)-1):
        if ord(password[i+1]) - ord(password[i]) == 1:
            straight_count += 1
            if straight_count == 3:
                break
        else:
            straight_count = 1
    if straight_count < 3:
        return False
    
    # Check if password does not contain 'i', 'o', or 'l'
    if 'i' in password or 'o' in password or 'l' in password:
        return False
    
    # Check if password contains at least two different, non-overlapping pairs of letters
    pair_count = 0
    i = 0
    while i < len(password)-1:
        if password[i] == password[i+1]:
            pair_count += 1
            i += 1
            if pair_count == 2:
                break
        i += 1
    if pair_count < 2:
        return False
    
    return True

def generate_next_password(password):
    password = list(password)
    while True:
        # Find the rightmost non-'z' character
        i = len(password) - 1
        while i >= 0 and password[i] == 'z':
            i -= 1
        
        if i < 0:
            # All characters are 'z', increment password length
            password.append('a')
            continue
        
        # Increment the rightmost non-'z' character
        password[i] = chr(ord(password[i]) + 1)
        
        # Reset all characters to the right of the incremented character to 'a'
        for j in range(i+1, len(password)):
            password[j] = 'a'
        
        new_password = ''.join(password)
        if is_valid(new_password):
            return new_password

next_password = generate_next_password(password)
print(next_password)",0.0
21,2015,11,2,part1_failed,,vzcaabcc,,,
22,2015,12,1,no_error,"111754
",111754,,"import json

def find_numbers_sum(json_doc):
    def recursive_find_numbers_sum(obj):
        if isinstance(obj, int) or isinstance(obj, float):
            return obj
        elif isinstance(obj, list):
            return sum(recursive_find_numbers_sum(item) for item in obj)
        elif isinstance(obj, dict):
            return sum(recursive_find_numbers_sum(value) for value in obj.values())
        else:
            return 0

    parsed_json = json.loads(json_doc)
    return recursive_find_numbers_sum(parsed_json)

# Read input from file
with open('input.txt', 'r') as file:
    json_doc = file.read()

result = find_numbers_sum(json_doc)
print(result)",0.0
23,2015,12,2,no_error,"65402
",65402,,"import json

def find_numbers_sum(json_doc):
    def recursive_find_numbers_sum(obj):
        if isinstance(obj, int) or isinstance(obj, float):
            return obj
        elif isinstance(obj, list):
            return sum(recursive_find_numbers_sum(item) for item in obj)
        elif isinstance(obj, dict):
            if ""red"" in obj.values():
                return 0
            else:
                return sum(recursive_find_numbers_sum(value) for value in obj.values())
        else:
            return 0

    parsed_json = json.loads(json_doc)
    return recursive_find_numbers_sum(parsed_json)

# Read input from file
with open('input.txt', 'r') as file:
    json_doc = file.read()

result = find_numbers_sum(json_doc)
print(result)",0.0
24,2015,13,1,no_error,733,733,,"import itertools

def calculate_happiness(arrangement, attendees, happiness):
    total_happiness = 0
    for i in range(len(arrangement)):
        attendee = arrangement[i]
        left_neighbor = arrangement[i-1]
        right_neighbor = arrangement[(i+1)%len(arrangement)]
        
        total_happiness += happiness[(attendee, left_neighbor)]
        total_happiness += happiness[(attendee, right_neighbor)]
    
    return total_happiness

def find_optimal_seating(attendees, happiness):
    max_happiness = float('-inf')
    optimal_seating = []
    
    # Generate all possible seating arrangements
    arrangements = list(itertools.permutations(attendees))
    
    # Calculate happiness for each seating arrangement
    for arrangement in arrangements:
        arrangement_happiness = calculate_happiness(arrangement, attendees, happiness)
        
        if arrangement_happiness > max_happiness:
            max_happiness = arrangement_happiness
            optimal_seating = arrangement
    
    return optimal_seating, max_happiness

def parse_input(input_string):
    attendees = set()
    happiness = {}
    
    lines = input_string.strip().split('\n')
    for line in lines:
        tokens = line.split()
        attendee1 = tokens[0]
        attendee2 = tokens[10][:-1]  # Remove the trailing period
        
        value = int(tokens[3])
        if tokens[2] == 'gain':
            happiness[(attendee1, attendee2)] = value
        else:
            happiness[(attendee1, attendee2)] = -value
        
        attendees.add(attendee1)
        attendees.add(attendee2)
    
    return list(attendees), happiness

# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Parse input
attendees, happiness = parse_input(input_string)

# Find optimal seating arrangement
optimal_seating, max_happiness = find_optimal_seating(attendees, happiness)

# Print results
print(""Optimal Seating Arrangement:"", optimal_seating)
print(""Max Happiness Change:"", max_happiness)",0.0
25,2015,13,2,no_error,725,725,,"import itertools

def calculate_happiness(arrangement, attendees, happiness):
    total_happiness = 0
    for i in range(len(arrangement)):
        attendee = arrangement[i]
        left_neighbor = arrangement[i-1]
        right_neighbor = arrangement[(i+1)%len(arrangement)]
        
        total_happiness += happiness.get((attendee, left_neighbor), 0)
        total_happiness += happiness.get((attendee, right_neighbor), 0)
    
    return total_happiness

def find_optimal_seating(attendees, happiness):
    max_happiness = float('-inf')
    optimal_seating = []
    
    # Generate all possible seating arrangements
    arrangements = list(itertools.permutations(attendees))
    
    # Calculate happiness for each seating arrangement
    for arrangement in arrangements:
        arrangement_happiness = calculate_happiness(arrangement, attendees, happiness)
        
        if arrangement_happiness > max_happiness:
            max_happiness = arrangement_happiness
            optimal_seating = arrangement
    
    return optimal_seating, max_happiness

def parse_input(input_string):
    attendees = set()
    happiness = {}
    
    lines = input_string.strip().split('\n')
    for line in lines:
        tokens = line.split()
        attendee1 = tokens[0]
        attendee2 = tokens[10][:-1]  # Remove the trailing period
        
        value = int(tokens[3])
        if tokens[2] == 'gain':
            happiness[(attendee1, attendee2)] = value
        else:
            happiness[(attendee1, attendee2)] = -value
        
        attendees.add(attendee1)
        attendees.add(attendee2)
    
    return list(attendees), happiness

# Read input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Parse input
attendees, happiness = parse_input(input_string)

# Add yourself to the list of attendees
attendees.append('Yourself')

# Set all happiness relationships involving yourself to 0
for attendee in attendees:
    happiness[('Yourself', attendee)] = 0
    happiness[(attendee, 'Yourself')] = 0

# Find optimal seating arrangement
optimal_seating, max_happiness = find_optimal_seating(attendees, happiness)

# Print results
print(""Optimal Seating Arrangement:"", optimal_seating)
print(""Max Happiness Change:"", max_happiness)",0.0
26,2015,14,1,runtime_error,,2655,"Traceback (most recent call last):
  File ""/tmp/tmpdosq37qd/tmp.py"", line 8, in <module>
    name, speed, fly_time, rest_time = line.strip().split()
ValueError: too many values to unpack (expected 4)
","# Read the input from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input and calculate the distance traveled by each reindeer
distances = []
for line in lines:
    name, speed, fly_time, rest_time = line.strip().split()
    speed = int(speed)
    fly_time = int(fly_time)
    rest_time = int(rest_time)
    
    cycle_time = fly_time + rest_time
    num_cycles = int(seconds / cycle_time)
    remaining_time = seconds % cycle_time
    
    distance = num_cycles * speed * fly_time + min(speed * remaining_time, speed * fly_time)
    distances.append(distance)

# Find the maximum distance traveled
max_distance = max(distances)

# Print the maximum distance
print(max_distance)",0.0
27,2015,14,2,part1_failed,,1059,,,
28,2015,15,1,wrong_output,"Highest Score: 21367368
Highest Score Calories: 620
Ingredient Amounts: (17, 19, 38, 26)
",21367368,,"
import itertools

def calculate_score(ingredients, amounts):
    total_capacity = 0
    total_durability = 0
    total_flavor = 0
    total_texture = 0
    total_calories = 0
    
    for i in range(len(ingredients)):
        total_capacity += ingredients[i]['capacity'] * amounts[i]
        total_durability += ingredients[i]['durability'] * amounts[i]
        total_flavor += ingredients[i]['flavor'] * amounts[i]
        total_texture += ingredients[i]['texture'] * amounts[i]
        total_calories += ingredients[i]['calories'] * amounts[i]
    
    # Negative totals become 0
    total_capacity = max(total_capacity, 0)
    total_durability = max(total_durability, 0)
    total_flavor = max(total_flavor, 0)
    total_texture = max(total_texture, 0)
    
    # Calculate score
    score = total_capacity * total_durability * total_flavor * total_texture
    
    return score, total_calories

def find_highest_score(ingredients):
    highest_score = 0
    highest_score_calories = 0
    highest_score_amounts = None
    
    # Generate all possible combinations of ingredient amounts
    amounts_combinations = list(itertools.product(range(101), repeat=len(ingredients)))
    
    for amounts in amounts_combinations:
        if sum(amounts) == 100:  # The amount of each ingredient used must add up to 100 teaspoons
            score, total_calories = calculate_score(ingredients, amounts)
            
            if score > highest_score:
                highest_score = score
                highest_score_calories = total_calories
                highest_score_amounts = amounts
    
    return highest_score, highest_score_calories, highest_score_amounts

# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

ingredients = []

# Parse input
for line in lines:
    parts = line.strip().split(': ')
    name = parts[0]
    properties = parts[1].split(', ')
    ingredient = {}
    for prop in properties:
        prop_parts = prop.split(' ')
        prop_name = prop_parts[0]
        prop_value = int(prop_parts[1])
        ingredient[prop_name] = prop_value
    ingredients.append(ingredient)

# Find highest score
highest_score, highest_score_calories, highest_score_amounts = find_highest_score(ingredients)

print(""Highest Score:"", highest_score)
print(""Highest Score Calories:"", highest_score_calories)
print(""Ingredient Amounts:"", highest_score_amounts)
",0.0
29,2015,15,2,part1_failed,,1766400,,,
30,2015,16,1,runtime_error,,40,"Traceback (most recent call last):
  File ""/tmp/tmp1wvikzao/tmp.py"", line 35, in <module>
    main()
  File ""/tmp/tmp1wvikzao/tmp.py"", line 31, in main
    result = find_aunt_sue_gift(aunt_sue_list, gift_characteristics)
  File ""/tmp/tmp1wvikzao/tmp.py"", line 6, in find_aunt_sue_gift
    name, value = characteristic.split("": "")
ValueError: not enough values to unpack (expected 2, got 1)
","def find_aunt_sue_gift(aunt_sue_list, gift_characteristics):
    for aunt_sue in aunt_sue_list:
        characteristics = aunt_sue.split("": "")[1:]
        match = True
        for characteristic in characteristics:
            name, value = characteristic.split("": "")
            if name in gift_characteristics and gift_characteristics[name] != value:
                match = False
                break
        if match:
            return aunt_sue.split("":"")[0]
    return None

def parse_input(input_file):
    aunt_sue_list = []
    with open(input_file, 'r') as f:
        for line in f:
            aunt_sue_list.append(line.strip())
    return aunt_sue_list

def parse_gift_characteristics(gift_characteristics):
    characteristics = {}
    for characteristic in gift_characteristics:
        name, value = characteristic.split("": "")
        characteristics[name] = value
    return characteristics

def main():
    aunt_sue_list = parse_input('input.txt')
    gift_characteristics = parse_gift_characteristics([""children: 3"", ""cats: 7"", ""samoyeds: 2"", ""pomeranians: 0"", ""akitas: 0"", ""vizslas: 0"", ""goldfish: 5"", ""trees: 3"", ""cars: 2"", ""perfumes: 1""])
    result = find_aunt_sue_gift(aunt_sue_list, gift_characteristics)
    print(""The Aunt Sue who gave the gift is:"", result)

if __name__ == ""__main__"":
    main()",0.0
31,2015,16,2,part1_failed,,241,,,
32,2015,17,1,wrong_output,"19
",1638,,"import itertools

def count_combinations(containers, target):
    count = 0
    for r in range(1, len(containers) + 1):
        combinations = itertools.combinations(containers, r)
        for combination in combinations:
            if sum(combination) == target:
                count += 1
    return count

def main():
    with open('input.txt', 'r') as file:
        lines = file.readlines()
        target = int(lines[0])
        containers = [int(line) for line in lines[1:]]
        count = count_combinations(containers, target)
        print(count)

if __name__ == '__main__':
    main()",0.0
33,2015,17,2,part1_failed,,17,,,
34,2015,18,1,wrong_output,"2
",814,,"
def animate_lights(grid, steps):
    for _ in range(steps):
        new_grid = """"
        for i in range(len(grid)):
            count = 0
            for j in range(max(0, i-11), min(len(grid), i+10)):
                if grid[j] == ""#"":
                    count += 1
            if grid[i] == ""#"" and (count == 2 or count == 3):
                new_grid += ""#""
            elif grid[i] == ""."" and count == 3:
                new_grid += ""#""
            else:
                new_grid += "".""
        grid = new_grid
    return grid.count(""#"")

# Read input from file
with open('input.txt', 'r') as f:
    input_grid = f.read().strip()

# Animate the grid for 100 steps and print the number of lights on
print(animate_lights(input_grid, 100))
",0.0
35,2015,18,2,part1_failed,,924,,,
36,2015,19,1,no_error,"518
",518,,"from typing import List

def count_distinct_molecules(replacement_rules: List[str], medicine_molecule: str) -> int:
    molecules = set()
    for rule in replacement_rules:
        a, b = rule.split(' => ')
        i = 0
        while i < len(medicine_molecule):
            if medicine_molecule[i:i+len(a)] == a:
                new_molecule = medicine_molecule[:i] + b + medicine_molecule[i+len(a):]
                molecules.add(new_molecule)
                i += len(a)
            else:
                i += 1
    return len(molecules)

# Read input from file
with open('input.txt', 'r') as f:
    input_lines = f.readlines()

replacement_rules = []
i = 0
while i < len(input_lines) and input_lines[i] != '\n':
    replacement_rules.append(input_lines[i].strip())
    i += 1

medicine_molecule = input_lines[i+1].strip()

# Call the function and print the result
result = count_distinct_molecules(replacement_rules, medicine_molecule)
print(result)",0.0
37,2015,19,2,wrong_output,"-1
",200,,"from typing import List

def count_steps_to_transform(replacement_rules: List[str], target_molecule: str) -> int:
    reverse_rules = {}
    for rule in replacement_rules:
        a, b = rule.split(' => ')
        if b not in reverse_rules:
            reverse_rules[b] = []
        reverse_rules[b].append(a)
    
    queue = [(target_molecule, 0)]
    visited = set([target_molecule])
    
    while queue:
        molecule, steps = queue.pop(0)
        
        if molecule == 'e':
            return steps
        
        for i in range(len(molecule)):
            if molecule[i:] in reverse_rules:
                for rule in reverse_rules[molecule[i:]]:
                    new_molecule = molecule[:i] + rule + molecule[i+len(molecule[i:]):]
                    if new_molecule not in visited:
                        queue.append((new_molecule, steps + 1))
                        visited.add(new_molecule)
    
    return -1

# Read input from file
with open('input.txt', 'r') as f:
    input_lines = f.readlines()

replacement_rules = []
i = 0
while i < len(input_lines) and input_lines[i] != '\n':
    replacement_rules.append(input_lines[i].strip())
    i += 1

target_molecule = input_lines[i+1].strip()

# Call the function and print the result
result = count_steps_to_transform(replacement_rules, target_molecule)
print(result)",0.0
38,2015,20,1,timeout_error,,776160,TIMEOUT,"target_number = int(input())

house_number = 1
while True:
    total_presents = 0
    for elf in range(1, house_number + 1):
        if house_number % elf == 0:
            total_presents += elf * 10
    
    if total_presents >= target_number:
        print(house_number)
        break
    
    house_number += 1",0.0
39,2015,20,2,part1_failed,,786240,,,
40,2015,21,1,runtime_error,,78,"Traceback (most recent call last):
  File ""/tmp/tmpal272y9s/tmp.py"", line 70, in <module>
    least_gold_cost = find_least_gold_cost(boss_hp, boss_damage, boss_armor)
  File ""/tmp/tmpal272y9s/tmp.py"", line 58, in find_least_gold_cost
    gold_cost, damage, armor = calculate_gold_cost(*combination)
TypeError: calculate_gold_cost() takes 3 positional arguments but 4 were given
","import itertools

def calculate_damage(attacker_damage, defender_armor):
    damage = attacker_damage - defender_armor
    return max(damage, 1)

def simulate_battle(player_hp, player_damage, player_armor, boss_hp, boss_damage, boss_armor):
    while player_hp > 0 and boss_hp > 0:
        boss_hp -= calculate_damage(player_damage, boss_armor)
        if boss_hp <= 0:
            return True
        player_hp -= calculate_damage(boss_damage, player_armor)
    return False

def calculate_gold_cost(weapon, armor, rings):
    weapon_cost, weapon_damage, _ = weapon
    armor_cost, _, armor_armor = armor
    ring1_cost, ring1_damage, ring1_armor = rings[0]
    ring2_cost, ring2_damage, ring2_armor = rings[1]
    total_cost = weapon_cost + armor_cost + ring1_cost + ring2_cost
    total_damage = weapon_damage + ring1_damage + ring2_damage
    total_armor = armor_armor + ring1_armor + ring2_armor
    return total_cost, total_damage, total_armor

def find_least_gold_cost(boss_hp, boss_damage, boss_armor):
    weapons = [
        (8, 4, 0),  # Dagger
        (10, 5, 0),  # Shortsword
        (25, 6, 0),  # Warhammer
        (40, 7, 0),  # Longsword
        (74, 8, 0)  # Greataxe
    ]

    armors = [
        (0, 0, 0),  # No armor
        (13, 0, 1),  # Leather
        (31, 0, 2),  # Chainmail
        (53, 0, 3),  # Splintmail
        (75, 0, 4),  # Bandedmail
        (102, 0, 5),  # Platemail
    ]

    rings = [
        (0, 0, 0),  # No ring
        (0, 0, 0),  # No ring
        (25, 1, 0),  # Damage +1
        (50, 2, 0),  # Damage +2
        (100, 3, 0),  # Damage +3
        (20, 0, 1),  # Defense +1
        (40, 0, 2),  # Defense +2
        (80, 0, 3)  # Defense +3
    ]

    combinations = list(itertools.product(weapons, armors, rings, rings))
    least_gold_cost = float('inf')

    for combination in combinations:
        gold_cost, damage, armor = calculate_gold_cost(*combination)
        if gold_cost < least_gold_cost and simulate_battle(100, damage, armor, boss_hp, boss_damage, boss_armor):
            least_gold_cost = gold_cost

    return least_gold_cost

# Read input from file
with open('input.txt', 'r') as file:
    boss_hp = int(file.readline().split()[2])
    boss_damage = int(file.readline().split()[1])
    boss_armor = int(file.readline().split()[1])

least_gold_cost = find_least_gold_cost(boss_hp, boss_damage, boss_armor)
print(least_gold_cost)",0.0
41,2015,21,2,part1_failed,,148,,,
42,2015,22,1,runtime_error,,953,"Traceback (most recent call last):
  File ""/tmp/tmpb7d22tlp/tmp.py"", line 45, in <module>
    boss_hp = int(file.readline())
ValueError: invalid literal for int() with base 10: 'Hit Points: 55\n'
","import sys

def play_game(boss_hp, boss_damage):
    player_hp = 50
    player_mana = 500
    min_mana = sys.maxsize

    def cast_spell(spell, boss_hp, player_hp, player_mana, boss_damage, mana_spent):
        if mana_spent >= min_mana:
            return

        # Player's turn
        player_hp -= 1

        if player_hp <= 0:
            return

        # Apply spell effects
        # TODO: Apply spell effects

        # Check if the boss is defeated
        if boss_hp <= 0:
            min_mana = mana_spent
            return

        # Boss's turn
        player_hp -= boss_damage

        if player_hp <= 0:
            return

        # Check if the boss is defeated
        if boss_hp <= 0:
            min_mana = mana_spent
            return

        # TODO: Recursively call cast_spell for each possible spell

    # TODO: Call cast_spell for each possible spell

    return min_mana

# Read input from file
with open('input.txt', 'r') as file:
    boss_hp = int(file.readline())
    boss_damage = int(file.readline())

# Play the game and print the result
result = play_game(boss_hp, boss_damage)
print(result)",0.0
43,2015,22,2,part1_failed,,1289,,,
44,2015,23,1,no_error,"307
",307,,"
# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Remove newline characters from the instructions
instructions = [instruction.strip() for instruction in instructions]

# Initialize the registers
a = 0
b = 0

# Initialize the program counter
pc = 0

# Execute the instructions
while pc < len(instructions):
    instruction = instructions[pc].split()

    if instruction[0] == 'hlf':
        if instruction[1] == 'a':
            a //= 2
        elif instruction[1] == 'b':
            b //= 2
        pc += 1

    elif instruction[0] == 'tpl':
        if instruction[1] == 'a':
            a *= 3
        elif instruction[1] == 'b':
            b *= 3
        pc += 1

    elif instruction[0] == 'inc':
        if instruction[1] == 'a':
            a += 1
        elif instruction[1] == 'b':
            b += 1
        pc += 1

    elif instruction[0] == 'jmp':
        offset = int(instruction[1])
        pc += offset

    elif instruction[0] == 'jie':
        register = instruction[1][0]
        offset = int(instruction[2])
        if (register == 'a' and a % 2 == 0) or (register == 'b' and b % 2 == 0):
            pc += offset
        else:
            pc += 1

    elif instruction[0] == 'jio':
        register = instruction[1][0]
        offset = int(instruction[2])
        if (register == 'a' and a == 1) or (register == 'b' and b == 1):
            pc += offset
        else:
            pc += 1

# Print the value in register b
print(b)
",0.0
45,2015,23,2,no_error,"160
",160,,"
# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Remove newline characters from the instructions
instructions = [instruction.strip() for instruction in instructions]

# Initialize the registers
a = 1
b = 0

# Initialize the program counter
pc = 0

# Execute the instructions
while pc < len(instructions):
    instruction = instructions[pc].split()

    if instruction[0] == 'hlf':
        if instruction[1] == 'a':
            a //= 2
        elif instruction[1] == 'b':
            b //= 2
        pc += 1

    elif instruction[0] == 'tpl':
        if instruction[1] == 'a':
            a *= 3
        elif instruction[1] == 'b':
            b *= 3
        pc += 1

    elif instruction[0] == 'inc':
        if instruction[1] == 'a':
            a += 1
        elif instruction[1] == 'b':
            b += 1
        pc += 1

    elif instruction[0] == 'jmp':
        offset = int(instruction[1])
        pc += offset

    elif instruction[0] == 'jie':
        register = instruction[1][0]
        offset = int(instruction[2])
        if (register == 'a' and a % 2 == 0) or (register == 'b' and b % 2 == 0):
            pc += offset
        else:
            pc += 1

    elif instruction[0] == 'jio':
        register = instruction[1][0]
        offset = int(instruction[2])
        if (register == 'a' and a == 1) or (register == 'b' and b == 1):
            pc += offset
        else:
            pc += 1

# Print the value in register b
print(b)
",0.0
46,2015,24,1,runtime_error,,10439961859,"Traceback (most recent call last):
  File ""/tmp/tmp6po62yj3/tmp.py"", line 13, in <module>
    smallest_group = find_smallest_group(weights)
  File ""/tmp/tmp6po62yj3/tmp.py"", line 9, in find_smallest_group
    for combination in combinations(weights, group_size):
NameError: name 'combinations' is not defined
","with open('input.txt', 'r') as file:
    weights = [int(line.strip()) for line in file]

def find_smallest_group(weights):
    total_weight = sum(weights)
    target_weight = total_weight // 3
    
    for group_size in range(1, len(weights)):
        for combination in combinations(weights, group_size):
            if sum(combination) == target_weight:
                return combination

smallest_group = find_smallest_group(weights)
quantum_entanglement = 1
for weight in smallest_group:
    quantum_entanglement *= weight

print(""Smallest Group:"", smallest_group)
print(""Quantum Entanglement:"", quantum_entanglement)",0.0
47,2015,24,2,part1_failed,,72050269,,,
48,2015,25,1,wrong_output,"None
",9132360,,"file = open(""input.txt"", ""r"")
inputs = file.read().split("","")
row = int(inputs[0])
column = int(inputs[1])

def find_code(row, column):
    code = 20151125
    for i in range(1, row+column-1):
        for j in range(1, i+1):
            code = (code * 252533) % 33554393
            if j == column and i-j+1 == row:
                return code

result = find_code(row, column)
print(result)",0.0
49,2015,25,2,part1_failed,,,,,
50,2016,1,1,no_error,"287
",287,,"
def shortest_path(instructions):
    # Initialize current position and direction
    x = 0
    y = 0
    direction = 0  # 0: North, 1: East, 2: South, 3: West

    # Parse the instructions
    instructions = instructions.split("", "")
    for instruction in instructions:
        # Get the turn direction and distance
        turn = instruction[0]
        distance = int(instruction[1:])

        # Update the direction based on the turn
        if turn == ""R"":
            direction = (direction + 1) % 4
        else:
            direction = (direction - 1) % 4

        # Update the position based on the direction and distance
        if direction == 0:  # North
            y += distance
        elif direction == 1:  # East
            x += distance
        elif direction == 2:  # South
            y -= distance
        elif direction == 3:  # West
            x -= distance

    # Calculate the shortest path distance
    distance = abs(x) + abs(y)
    return distance

# Read the input from input.txt
with open('input.txt', 'r') as file:
    instructions = file.read().strip()

# Call the function with the instructions and print the result
print(shortest_path(instructions))
",0.0
51,2016,1,2,no_error,"133
",133,,"
def first_location_visited_twice(instructions):
    # Initialize current position and direction
    x = 0
    y = 0
    direction = 0  # 0: North, 1: East, 2: South, 3: West

    # Initialize the set of visited locations
    visited = set()

    # Parse the instructions
    instructions = instructions.split("", "")
    for instruction in instructions:
        # Get the turn direction and distance
        turn = instruction[0]
        distance = int(instruction[1:])

        # Update the direction based on the turn
        if turn == ""R"":
            direction = (direction + 1) % 4
        else:
            direction = (direction - 1) % 4

        # Walk forward one block at a time
        for _ in range(distance):
            # Update the position based on the direction
            if direction == 0:  # North
                y += 1
            elif direction == 1:  # East
                x += 1
            elif direction == 2:  # South
                y -= 1
            elif direction == 3:  # West
                x -= 1

            # Check if the current location has been visited before
            if (x, y) in visited:
                # Calculate the distance to the first visited location
                distance = abs(x) + abs(y)
                return distance

            # Add the current location to the set of visited locations
            visited.add((x, y))

    # If no location is visited twice, return -1
    return -1

# Read the input from input.txt
with open('input.txt', 'r') as file:
    instructions = file.read().strip()

# Call the function with the instructions and print the result
print(first_location_visited_twice(instructions))
",0.0
52,2016,2,1,runtime_error,,12578,"Traceback (most recent call last):
  File ""/tmp/tmp6zuuy6h7/tmp.py"", line 18, in <module>
    current_button = keypad[current_button // 3][current_button % 3 + 1]
IndexError: list index out of range
","with open('input.txt', 'r') as f:
    instructions = f.readlines()

keypad = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
code = []

current_button = 5

for line in instructions:
    for move in line.strip():
        if move == 'U':
            current_button = keypad[current_button // 3 - 1][current_button % 3]
        elif move == 'D':
            current_button = keypad[current_button // 3 + 1][current_button % 3]
        elif move == 'L':
            current_button = keypad[current_button // 3][current_button % 3 - 1]
        elif move == 'R':
            current_button = keypad[current_button // 3][current_button % 3 + 1]
    code.append(current_button)

print('Bathroom code:', ''.join(map(str, code)))",0.0
53,2016,2,2,part1_failed,,516DD,,,
54,2016,3,1,no_error,"993
",993,,"filename = 'input.txt'

def is_triangle(a, b, c):
    return (a + b > c) and (a + c > b) and (b + c > a)

def count_valid_triangles(filename):
    count = 0
    with open(filename, 'r') as file:
        for line in file:
            a, b, c = map(int, line.strip().split())
            if is_triangle(a, b, c):
                count += 1
    return count

print(count_valid_triangles(filename))",0.0
55,2016,3,2,no_error,"1849
",1849,,"filename = 'input.txt'

def is_triangle(a, b, c):
    return (a + b > c) and (a + c > b) and (b + c > a)

def count_valid_triangles(filename):
    count = 0
    with open(filename, 'r') as file:
        lines = file.readlines()
        for i in range(0, len(lines), 3):
            a1, a2, a3 = map(int, lines[i].strip().split())
            b1, b2, b3 = map(int, lines[i+1].strip().split())
            c1, c2, c3 = map(int, lines[i+2].strip().split())
            if is_triangle(a1, b1, c1):
                count += 1
            if is_triangle(a2, b2, c2):
                count += 1
            if is_triangle(a3, b3, c3):
                count += 1
    return count

print(count_valid_triangles(filename))",0.0
56,2016,4,1,no_error,"245102
",245102,,"# Reading input from file
with open(""input.txt"", ""r"") as file:
    encrypted_rooms = file.readlines()

# Function to calculate the checksum of a room name
def calculate_checksum(room_name):
    # Remove the dash, sector ID, and square brackets
    name = room_name.split(""-"")[:-1]
    sector_id = room_name.split(""-"")[-1].split(""["")[0]
    checksum = room_name.split(""-"")[-1].split(""["")[1][:-2]

    # Count the frequency of each letter in the room name
    frequency = {}
    for letter in """".join(name):
        if letter.isalpha():
            frequency[letter] = frequency.get(letter, 0) + 1

    # Sort the letters by frequency and alphabetically
    sorted_letters = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))

    # Generate the checksum by taking the first 5 letters
    generated_checksum = """".join(sorted_letters[:5])

    # Check if the generated checksum matches the given checksum
    if generated_checksum == checksum:
        return int(sector_id)
    else:
        return 0

# Calculate the sum of the sector IDs of the real rooms
sum_sector_ids = sum(calculate_checksum(room) for room in encrypted_rooms)

print(sum_sector_ids)",0.0
57,2016,4,2,wrong_output,"None
",324,,"# Reading input from file
with open(""input.txt"", ""r"") as file:
    encrypted_rooms = file.readlines()

# Function to calculate the checksum of a room name
def calculate_checksum(room_name):
    # Remove the dash, sector ID, and square brackets
    name = room_name.split(""-"")[:-1]
    sector_id = room_name.split(""-"")[-1].split(""["")[0]
    checksum = room_name.split(""-"")[-1].split(""["")[1][:-2]

    # Count the frequency of each letter in the room name
    frequency = {}
    for letter in """".join(name):
        if letter.isalpha():
            frequency[letter] = frequency.get(letter, 0) + 1

    # Sort the letters by frequency and alphabetically
    sorted_letters = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))

    # Generate the checksum by taking the first 5 letters
    generated_checksum = """".join(sorted_letters[:5])

    # Check if the generated checksum matches the given checksum
    if generated_checksum == checksum:
        return int(sector_id)
    else:
        return 0

# Calculate the sector ID of the room where North Pole objects are stored
def find_sector_id_of_north_pole_room(encrypted_rooms):
    for room in encrypted_rooms:
        sector_id = calculate_checksum(room)
        decrypted_name = """"
        for letter in room:
            if letter.isalpha():
                decrypted_letter = chr((ord(letter) - 97 + sector_id) % 26 + 97)
                decrypted_name += decrypted_letter
            elif letter == ""-"":
                decrypted_name += "" ""
        if decrypted_name == ""northpole object storage"":
            return sector_id
    return None

sector_id_of_north_pole_room = find_sector_id_of_north_pole_room(encrypted_rooms)

print(sector_id_of_north_pole_room)",0.0
58,2016,5,1,no_error,"1a3099aa
",1a3099aa,,"import hashlib

def find_password(door_id):
    password = """"
    index = 0
    while len(password) < 8:
        hash_input = door_id + str(index)
        hash_output = hashlib.md5(hash_input.encode()).hexdigest()
        if hash_output.startswith(""00000""):
            password += hash_output[5]
        index += 1
    return password

with open('input.txt', 'r') as file:
    door_id = file.readline().strip()

password = find_password(door_id)
print(password)",0.0
59,2016,5,2,no_error,"694190cd
",694190cd,,"import hashlib

def find_password(door_id):
    password = [""_""] * 8
    index = 0
    while ""_"" in password:
        hash_input = door_id + str(index)
        hash_output = hashlib.md5(hash_input.encode()).hexdigest()
        if hash_output.startswith(""00000""):
            position = int(hash_output[5], 16)
            if position < 8 and password[position] == ""_"":
                password[position] = hash_output[6]
        index += 1
    return """".join(password)

with open('input.txt', 'r') as file:
    door_id = file.readline().strip()

password = find_password(door_id)
print(password)",0.0
60,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"with open('input.txt', 'r') as file:
    matrix = [list(line.strip()) for line in file]

columns = zip(*matrix)
error_corrected_message = ''.join(max(column, key=column.count) for column in columns)

print(error_corrected_message)",0.0
61,2016,6,2,no_error,"pdesmnoz
",pdesmnoz,,"with open('input.txt', 'r') as file:
    matrix = [list(line.strip()) for line in file]

columns = zip(*matrix)
reconstructed_message = ''.join(min(column, key=column.count) for column in columns)

print(reconstructed_message)",0.0
62,2016,7,1,runtime_error,,115,"Traceback (most recent call last):
  File ""/tmp/tmpjsqr32lx/tmp.py"", line 42, in <module>
    if supports_tls(ip_address):
  File ""/tmp/tmpjsqr32lx/tmp.py"", line 23, in supports_tls
    non_hypernet_sequences[-1] += ip_address[i]
IndexError: list index out of range
","# Read the input file
with open('input.txt', 'r') as file:
    ip_addresses = file.read().splitlines()

# Function to check if an IP address supports TLS
def supports_tls(ip_address):
    hypernet_sequences = []
    non_hypernet_sequences = []
    in_hypernet_sequence = False

    # Separate the IP address into hypernet and non-hypernet sequences
    for i in range(len(ip_address)):
        if ip_address[i] == '[':
            in_hypernet_sequence = True
            non_hypernet_sequences.append('')
        elif ip_address[i] == ']':
            in_hypernet_sequence = False
            hypernet_sequences.append('')
        else:
            if in_hypernet_sequence:
                hypernet_sequences[-1] += ip_address[i]
            else:
                non_hypernet_sequences[-1] += ip_address[i]

    # Check if any non-hypernet sequence contains an ABBA
    for sequence in non_hypernet_sequences:
        for i in range(len(sequence) - 3):
            if sequence[i] != sequence[i+1] and sequence[i:i+2] == sequence[i+3:i+1:-1]:
                return True

    # Check if any hypernet sequence contains an ABBA
    for sequence in hypernet_sequences:
        for i in range(len(sequence) - 3):
            if sequence[i] != sequence[i+1] and sequence[i:i+2] == sequence[i+3:i+1:-1]:
                return False

    return False

# Count the number of IPs that support TLS
count = 0
for ip_address in ip_addresses:
    if supports_tls(ip_address):
        count += 1

print(count)",0.0
63,2016,7,2,part1_failed,,231,,,
64,2016,8,1,no_error,"115
",115,,"
def turn_on_pixels(instructions):
    screen = [['.' for _ in range(50)] for _ in range(6)]
    for instruction in instructions:
        if instruction.startswith('rect'):
            a, b = map(int, instruction.split()[1].split('x'))
            for i in range(b):
                for j in range(a):
                    screen[i][j] = '#'
        elif instruction.startswith('rotate row'):
            a, b = map(int, instruction.split('=')[1].split(' by '))
            screen[a] = screen[a][-b:] + screen[a][:-b]
        elif instruction.startswith('rotate column'):
            a, b = map(int, instruction.split('=')[1].split(' by '))
            column = [screen[i][a] for i in range(6)]
            column = column[-b:] + column[:-b]
            for i in range(6):
                screen[i][a] = column[i]
    return sum(row.count('#') for row in screen)

with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()
    result = turn_on_pixels(instructions)
    print(result)
",0.0
65,2016,8,2,wrong_output,"####.#....###..#....#....####.
####.#....###..#....#....#....
####.#....###..#....#....####.
#...##...#.#.#...#....#....#..
#..#.#.#..##...#.#..#.#..#..#.
####.#....###..#....#....#....
###..#..#.#..#.###..#.#..#..#.
####.#....###..#....#....#....
.###...#....#....#....#...###.
..##....#....#....#.#..#..##..
","####.####.####.#...##..#.####.###..####..###...##.
#....#....#....#...##.#..#....#..#.#......#.....#.
###..###..###...#.#.##...###..#..#.###....#.....#.
#....#....#......#..#.#..#....###..#......#.....#.
#....#....#......#..#.#..#....#.#..#......#..#..#.
####.#....####...#..#..#.#....#..#.#.....###..##..",,"
def extract_code_block(instructions):
    screen = [['.' for _ in range(50)] for _ in range(6)]
    for instruction in instructions:
        if instruction.startswith('rect'):
            a, b = map(int, instruction.split()[1].split('x'))
            for i in range(b):
                for j in range(a):
                    screen[i][j] = '#'
        elif instruction.startswith('rotate row'):
            a, b = map(int, instruction.split('=')[1].split(' by '))
            screen[a] = screen[a][-b:] + screen[a][:-b]
        elif instruction.startswith('rotate column'):
            a, b = map(int, instruction.split('=')[1].split(' by '))
            column = [screen[i][a] for i in range(6)]
            column = column[-b:] + column[:-b]
            for i in range(6):
                screen[i][a] = column[i]
    
    code_block = []
    for i in range(0, 50, 5):
        code = ''
        for j in range(6):
            code += ''.join(screen[j][i:i+5])
        code_block.append(code)
    
    return code_block

with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()
    code_block = extract_code_block(instructions)
    for code in code_block:
        print(code)
",0.0
66,2016,9,1,wrong_output,,102239,,"with open('input.txt', 'r') as f:
    compressed_file = f.read().strip()

def decompressed_length(compressed_file):
    length = 0
    i = 0
    while i < len(compressed_file):
        if compressed_file[i] == '(':
            marker_end = compressed_file.index(')', i)
            marker = compressed_file[i+1:marker_end]
            x, y = marker.split('x')
            x = int(x)
            y = int(y)
            length += x * y
            i = marker_end + 1 + x
        else:
            length += 1
            i += 1
    return length

decompressed_length(compressed_file)",0.0
67,2016,9,2,part1_failed,,10780403063,,,
68,2016,10,1,runtime_error,,118,"Traceback (most recent call last):
  File ""/tmp/tmpj3fb3c5z/tmp.py"", line 80, in <module>
    result = process_instructions(instructions)
  File ""/tmp/tmpj3fb3c5z/tmp.py"", line 71, in process_instructions
    parse_instruction(instruction)
  File ""/tmp/tmpj3fb3c5z/tmp.py"", line 62, in parse_instruction
    instructions.setdefault(bot_number, []).append((low_dest_type, low_dest_number))
AttributeError: 'list' object has no attribute 'setdefault'
","
class Bot:
    def __init__(self, number):
        self.number = number
        self.chips = []

    def add_chip(self, chip):
        self.chips.append(chip)

    def has_two_chips(self):
        return len(self.chips) == 2

    def get_low_chip(self):
        return min(self.chips)

    def get_high_chip(self):
        return max(self.chips)


def process_instructions(instructions):
    bots = {}
    outputs = {}

    def get_bot(number):
        if number not in bots:
            bots[number] = Bot(number)
        return bots[number]

    def give_chip(value, bot):
        bot.add_chip(value)
        if bot.has_two_chips():
            low_chip = bot.get_low_chip()
            high_chip = bot.get_high_chip()

            if low_chip == 17 and high_chip == 61:
                return bot.number

            low_dest_type, low_dest_number = instructions[bot.number][0]
            high_dest_type, high_dest_number = instructions[bot.number][1]

            low_dest = get_bot(low_dest_number) if low_dest_type == 'bot' else outputs.setdefault(low_dest_number, [])
            high_dest = get_bot(high_dest_number) if high_dest_type == 'bot' else outputs.setdefault(high_dest_number, [])

            low_dest.append(low_chip)
            high_dest.append(high_chip)

            bot.chips = []

    def parse_instruction(instruction):
        parts = instruction.split(' ')
        if parts[0] == 'value':
            value = int(parts[1])
            bot_number = int(parts[5])
            bot = get_bot(bot_number)
            give_chip(value, bot)
        else:
            bot_number = int(parts[1])
            low_dest_type = parts[5]
            low_dest_number = int(parts[6])
            high_dest_type = parts[10]
            high_dest_number = int(parts[11])
            instructions.setdefault(bot_number, []).append((low_dest_type, low_dest_number))
            instructions.setdefault(bot_number, []).append((high_dest_type, high_dest_number))

            bot = get_bot(bot_number)
            if bot.has_two_chips():
                give_chip(bot.get_low_chip(), bot)
                give_chip(bot.get_high_chip(), bot)

    for instruction in instructions:
        parse_instruction(instruction)

    return None

instructions = []
with open('input.txt', 'r') as file:
    for line in file:
        instructions.append(line.strip())

result = process_instructions(instructions)
print(result)
",0.0
69,2016,10,2,part1_failed,,143153,,,
70,2016,11,1,wrong_output,,37,,"# Helper functions

def parse_input(input_str):
    floors = input_str.strip().split('\n')
    containment_area = []
    for floor in floors:
        objects = floor.strip().split(',')
        containment_area.append(objects)
    return containment_area

def is_valid_floor(floor):
    generators = [obj for obj in floor if 'G' in obj]
    chips = [obj for obj in floor if 'M' in obj]
    for chip in chips:
        if 'G' not in chip and len(generators) > 0:
            return False
    return True

def is_valid_state(area):
    for floor in area:
        if not is_valid_floor(floor):
            return False
    return True

def is_goal_state(area):
    return all(not floor for floor in area[:-1])

def get_valid_moves(area):
    elevator_floor = -1
    for i, floor in enumerate(area):
        if 'E' in floor:
            elevator_floor = i
            break
    if elevator_floor == 0:
        return [('up', area[0], area[1])]
    elif elevator_floor == len(area) - 1:
        return [('down', area[-1], area[-2])]
    else:
        moves = []
        moves.append(('up', area[elevator_floor], area[elevator_floor + 1]))
        moves.append(('down', area[elevator_floor], area[elevator_floor - 1]))
        return moves

def apply_move(area, move):
    direction, current_floor, next_floor = move
    new_area = [floor[:] for floor in area]
    current_floor.remove('E')
    next_floor.append('E')
    return new_area

def is_valid_move(area, move):
    direction, current_floor, next_floor = move
    if direction == 'up':
        if 'E' in current_floor and len(current_floor) >= 3:
            return False
        return is_valid_floor(current_floor + ['E']) and is_valid_floor(next_floor + ['E'])
    elif direction == 'down':
        if 'E' in current_floor and len(current_floor) <= 1:
            return False
        return is_valid_floor(current_floor + ['E']) and is_valid_floor(next_floor + ['E'])

def get_heuristic(area):
    floors = len(area)
    objects = 0
    for floor in area:
        objects += len(floor)
    return floors - objects

# Breadth-first search algorithm

def breadth_first_search(area):
    queue = [(area, 0)]
    visited = set()
    
    while queue:
        current_area, steps = queue.pop(0)
        
        if is_goal_state(current_area):
            return steps
        
        if tuple(map(tuple, current_area)) in visited:
            continue
        
        visited.add(tuple(map(tuple, current_area)))
        
        for move in get_valid_moves(current_area):
            if is_valid_move(current_area, move):
                new_area = apply_move(current_area, move)
                if is_valid_state(new_area):
                    queue.append((new_area, steps + 1))
    
    return -1

# Main function

def minimum_steps_to_assembly(input_str):
    area = parse_input(input_str)
    return breadth_first_search(area)",0.0
71,2016,11,2,part1_failed,,61,,,
72,2016,12,1,no_error,"318083
",318083,,"# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Initialize the registers
registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}

# Function to parse and execute the instructions
def execute_instructions(instructions):
    # Iterate over each instruction
    i = 0
    while i < len(instructions):
        parts = instructions[i].split()

        # Copy instruction
        if parts[0] == 'cpy':
            value = parts[1]
            register = parts[2]
            if value in registers:
                value = registers[value]
            else:
                value = int(value)
            registers[register] = value

        # Increment instruction
        elif parts[0] == 'inc':
            register = parts[1]
            registers[register] += 1

        # Decrement instruction
        elif parts[0] == 'dec':
            register = parts[1]
            registers[register] -= 1

        # Jump instruction
        elif parts[0] == 'jnz':
            value = parts[1]
            jump = parts[2]
            if value in registers:
                value = registers[value]
            else:
                value = int(value)
            if value != 0:
                i += int(jump)
                continue

        i += 1

# Execute the instructions
execute_instructions(instructions)

# Print the final value in register a
print(registers['a'])",0.0
73,2016,12,2,no_error,"9227737
",9227737,,"# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Initialize the registers
registers = {'a': 0, 'b': 0, 'c': 1, 'd': 0}

# Function to parse and execute the instructions
def execute_instructions(instructions):
    # Iterate over each instruction
    i = 0
    while i < len(instructions):
        parts = instructions[i].split()

        # Copy instruction
        if parts[0] == 'cpy':
            value = parts[1]
            register = parts[2]
            if value in registers:
                value = registers[value]
            else:
                value = int(value)
            registers[register] = value

        # Increment instruction
        elif parts[0] == 'inc':
            register = parts[1]
            registers[register] += 1

        # Decrement instruction
        elif parts[0] == 'dec':
            register = parts[1]
            registers[register] -= 1

        # Jump instruction
        elif parts[0] == 'jnz':
            value = parts[1]
            jump = parts[2]
            if value in registers:
                value = registers[value]
            else:
                value = int(value)
            if value != 0:
                i += int(jump)
                continue

        i += 1

# Execute the instructions
execute_instructions(instructions)

# Print the final value in register a
print(registers['a'])",0.0
74,2016,13,1,no_error,"92
",92,,"def is_open_space(x, y, favorite_number):
    value = x*x + 3*x + 2*x*y + y + y*y + favorite_number
    binary_value = bin(value)[2:]
    count_ones = binary_value.count('1')
    return count_ones % 2 == 0

def shortest_path(favorite_number):
    queue = [(1, 1, 0)]
    visited = set()
    
    while queue:
        x, y, steps = queue.pop(0)
        
        if (x, y) == (31, 39):
            return steps
        
        if (x, y) not in visited:
            visited.add((x, y))
            
            if is_open_space(x, y, favorite_number):
                if x > 0:
                    queue.append((x-1, y, steps+1))
                if y > 0:
                    queue.append((x, y-1, steps+1))
                queue.append((x+1, y, steps+1))
                queue.append((x, y+1, steps+1))
                
    return -1

# Read input from file
with open('input.txt', 'r') as file:
    favorite_number = int(file.readline())

# Find the shortest path
result = shortest_path(favorite_number)

# Print the result
print(result)",0.0
75,2016,13,2,wrong_output,"268
",124,,"def is_open_space(x, y, favorite_number):
    value = x*x + 3*x + 2*x*y + y + y*y + favorite_number
    binary_value = bin(value)[2:]
    count_ones = binary_value.count('1')
    return count_ones % 2 == 0

def count_reachable_locations(favorite_number):
    queue = [(1, 1, 0)]
    visited = set()
    
    while queue:
        x, y, steps = queue.pop(0)
        
        if steps > 50:
            break
        
        if (x, y) not in visited:
            visited.add((x, y))
            
            if is_open_space(x, y, favorite_number):
                if x > 0:
                    queue.append((x-1, y, steps+1))
                if y > 0:
                    queue.append((x, y-1, steps+1))
                queue.append((x+1, y, steps+1))
                queue.append((x, y+1, steps+1))
                
    return len(visited)

# Read input from file
with open('input.txt', 'r') as file:
    favorite_number = int(file.readline())

# Count the number of reachable locations
result = count_reachable_locations(favorite_number)

# Print the result
print(result)",0.0
76,2016,14,1,wrong_output,"11385
",23890,,"import hashlib

# Read the salt from input file
with open('input.txt', 'r') as file:
    salt = file.read().strip()

def stretch_hash(hash_str):
    # Stretch the hash by finding the MD5 hash of the previous hash for 2016 times
    for _ in range(2016):
        hash_str = hashlib.md5(hash_str.encode()).hexdigest()
    return hash_str

def find_key_index(salt):
    keys_found = 0
    index = 0
    hashes = []
    while keys_found < 64:
        if len(hashes) <= index:
            # Generate new hash
            hash_str = salt + str(index)
            hash_str = stretch_hash(hash_str)
            hashes.append(hash_str)

        # Check if the hash contains a sequence of three identical characters
        if any(hashes[index][i] == hashes[index][i+1] == hashes[index][i+2] for i in range(len(hashes[index])-2)):
            # Check the next 1000 hashes for a sequence of five identical characters
            for i in range(index+1, index+1001):
                if len(hashes) <= i:
                    # Generate new hash
                    hash_str = salt + str(i)
                    hash_str = stretch_hash(hash_str)
                    hashes.append(hash_str)

                if any(hashes[i][j] == hashes[i][j+1] == hashes[i][j+2] == hashes[i][j+3] == hashes[i][j+4] for j in range(len(hashes[i])-4)):
                    keys_found += 1
                    break

        index += 1

    return index-1

key_index = find_key_index(salt)
print(key_index)",0.0
77,2016,14,2,part1_failed,,22696,,,
78,2016,15,1,runtime_error,,400589,"Traceback (most recent call last):
  File ""/tmp/tmp4v5ep012/tmp.py"", line 7, in <module>
    disc_number = int(line[1])
ValueError: invalid literal for int() with base 10: '#1'
","with open('input.txt', 'r') as file:
    input_data = file.readlines()

discs = []
for line in input_data:
    line = line.strip().split(' ')
    disc_number = int(line[1])
    positions = int(line[3])
    initial_position = int(line[11][:-1])
    discs.append((disc_number, positions, initial_position))

def find_button_press_time(discs):
    time = 0
    while True:
        success = True
        for i, disc in enumerate(discs):
            disc_number, positions, initial_position = disc
            current_position = (initial_position + time + i + 1) % positions
            if current_position != 0:
                success = False
                break
        if success:
            return time
        time += 1

button_press_time = find_button_press_time(discs)
print(button_press_time)",0.0
79,2016,15,2,part1_failed,,3045959,,,
80,2016,16,1,wrong_output,,10100011010101011,,"with open('input.txt', 'r') as file:
    initial_state = file.readline().strip()",0.0
81,2016,16,2,part1_failed,,01010001101011001,,,
82,2016,17,1,wrong_output,"Shortest path: RDDRULDDRR
",RDDRULDDRR,,"
import hashlib
from collections import deque

def shortest_path(passcode):
    directions = {'U': (0, -1), 'D': (0, 1), 'L': (-1, 0), 'R': (1, 0)}
    target = (3, 3)
    queue = deque([(0, 0, """")])

    while queue:
        x, y, path = queue.popleft()
        if (x, y) == target:
            return path
        hash_string = hashlib.md5((passcode + path).encode()).hexdigest()
        for i, direction in enumerate('UDLR'):
            dx, dy = directions[direction]
            if hash_string[i] in 'bcdef' and 0 <= x + dx < 4 and 0 <= y + dy < 4:
                queue.append((x + dx, y + dy, path + direction))

    return None

# Read input from file
with open('input.txt', 'r') as file:
    passcode = file.read().strip()

# Find the shortest path
path = shortest_path(passcode)
print(""Shortest path:"", path)
",0.0
83,2016,17,2,part1_failed,,766,,,
84,2016,18,1,no_error,"1913
",1913,,"
def count_safe_tiles(pattern):
    rows = [pattern]
    
    while len(rows) < 40:
        current_row = rows[-1]
        new_row = """"
        
        for i in range(len(current_row)):
            left_tile = current_row[i-1] if i > 0 else '.'
            center_tile = current_row[i]
            right_tile = current_row[i+1] if i < len(current_row)-1 else '.'
            
            if (left_tile == '^' and center_tile == '^' and right_tile == '.') or \
               (left_tile == '.' and center_tile == '^' and right_tile == '^') or \
               (left_tile == '^' and center_tile == '.' and right_tile == '.') or \
               (left_tile == '.' and center_tile == '.' and right_tile == '^'):
                new_row += '^'
            else:
                new_row += '.'
        
        rows.append(new_row)
    
    safe_tiles = sum(row.count('.') for row in rows)
    return safe_tiles

# Read input from file
with open('input.txt', 'r') as file:
    pattern = file.read().strip()

# Calculate the number of safe tiles
result = count_safe_tiles(pattern)
print(result)
",0.0
85,2016,18,2,no_error,"19993564
",19993564,,"
def count_safe_tiles(pattern):
    rows = [pattern]
    
    while len(rows) < 400000:
        current_row = rows[-1]
        new_row = """"
        
        for i in range(len(current_row)):
            left_tile = current_row[i-1] if i > 0 else '.'
            center_tile = current_row[i]
            right_tile = current_row[i+1] if i < len(current_row)-1 else '.'
            
            if (left_tile == '^' and center_tile == '^' and right_tile == '.') or \
               (left_tile == '.' and center_tile == '^' and right_tile == '^') or \
               (left_tile == '^' and center_tile == '.' and right_tile == '.') or \
               (left_tile == '.' and center_tile == '.' and right_tile == '^'):
                new_row += '^'
            else:
                new_row += '.'
        
        rows.append(new_row)
    
    safe_tiles = sum(row.count('.') for row in rows)
    return safe_tiles

# Read input from file
with open('input.txt', 'r') as file:
    pattern = file.read().strip()

# Calculate the number of safe tiles
result = count_safe_tiles(pattern)
print(result)
",0.0
86,2016,19,1,timeout_error,,1808357,TIMEOUT,"with open('input.txt', 'r') as f:
    num_people = int(f.readline().strip())

def find_winner(num_people):
    # Create a list to represent the circle of people
    circle = list(range(1, num_people + 1))

    # Start from the first person
    current_person = 0

    while len(circle) > 1:
        # Determine the person to the left
        left_person = (current_person - 1) % len(circle)

        # Steal all presents from the person to the left
        circle[current_person] += circle[left_person]

        # Remove the person to the left from the circle
        circle.pop(left_person)

        # Move to the next person in the circle
        current_person = (current_person + 1) % len(circle)

    # Return the remaining person who has all the presents
    return circle[0]

winner = find_winner(num_people)
print(winner)",0.0
87,2016,19,2,part1_failed,,1407007,,,
88,2016,20,1,no_error,32259706,32259706,,"# Read the input file
with open('input.txt', 'r') as file:
    input_lines = file.readlines()

# Parse the input lines
blocked_ranges = []
for line in input_lines:
    start, end = map(int, line.strip().split('-'))
    blocked_ranges.append((start, end))

# Sort the blocked ranges by start value
blocked_ranges.sort()

# Find the lowest-valued IP that is not blocked
lowest_ip = 0
for start, end in blocked_ranges:
    if lowest_ip < start:
        break
    lowest_ip = max(lowest_ip, end + 1)

# Print the result
print(""Lowest-valued IP that is not blocked:"", lowest_ip)",0.0
89,2016,20,2,no_error,113,113,,"# Read the input file
with open('input.txt', 'r') as file:
    input_lines = file.readlines()

# Parse the input lines
blocked_ranges = []
for line in input_lines:
    start, end = map(int, line.strip().split('-'))
    blocked_ranges.append((start, end))

# Sort the blocked ranges by start value
blocked_ranges.sort()

# Initialize variables
allowed_ips = 0
current_ip = 0

# Iterate through the blocked ranges
for start, end in blocked_ranges:
    # Check if there is a gap between the current IP and the start of the range
    if current_ip < start:
        allowed_ips += start - current_ip

    # Update the current IP to the end of the range
    current_ip = max(current_ip, end + 1)

# Check if there is a gap between the last blocked IP and the maximum IP value
if current_ip < 4294967295:
    allowed_ips += 4294967295 - current_ip + 1

# Print the result
print(""Number of allowed IPs:"", allowed_ips)",0.0
90,2016,21,1,runtime_error,,gbhafcde,"Traceback (most recent call last):
  File ""/tmp/tmpjr8ssrtw/tmp.py"", line 58, in <module>
    scrambled_password = apply_operations(password, operations)
  File ""/tmp/tmpjr8ssrtw/tmp.py"", line 22, in apply_operations
    steps = int(operation_parts[2])
ValueError: invalid literal for int() with base 10: 'on'
","
def apply_operations(password, operations):
    password = list(password)
    
    for operation in operations:
        operation_parts = operation.split()
        
        if operation_parts[0] == 'swap':
            if operation_parts[1] == 'position':
                x = int(operation_parts[2])
                y = int(operation_parts[5])
                password[x], password[y] = password[y], password[x]
            elif operation_parts[1] == 'letter':
                x = operation_parts[2]
                y = operation_parts[5]
                x_index = password.index(x)
                y_index = password.index(y)
                password[x_index], password[y_index] = password[y_index], password[x_index]
        
        elif operation_parts[0] == 'rotate':
            direction = operation_parts[1]
            steps = int(operation_parts[2])
            
            if direction == 'left':
                password = password[steps:] + password[:steps]
            elif direction == 'right':
                password = password[-steps:] + password[:-steps]
            elif direction == 'based':
                x = operation_parts[6]
                x_index = password.index(x)
                steps = 1 + x_index
                
                if x_index >= 4:
                    steps += 1
                
                password = password[-steps:] + password[:-steps]
        
        elif operation_parts[0] == 'reverse':
            x = int(operation_parts[2])
            y = int(operation_parts[4])
            password[x:y+1] = password[x:y+1][::-1]
        
        elif operation_parts[0] == 'move':
            x = int(operation_parts[2])
            y = int(operation_parts[5])
            letter = password.pop(x)
            password.insert(y, letter)
    
    return ''.join(password)


# Read the input
with open('input.txt', 'r') as file:
    password = file.readline().strip()
    operations = [line.strip() for line in file]

# Apply the operations and print the result
scrambled_password = apply_operations(password, operations)
print(scrambled_password)
",0.0
91,2016,21,2,part1_failed,,bcfaegdh,,,
92,2016,22,1,wrong_output,,901,,# Directly executable python code,0.0
93,2016,22,2,part1_failed,,238,,,
94,2016,23,1,timeout_error,,12516,TIMEOUT,"
def execute_code(code):
    registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}

    def get_value(x):
        if x.isalpha():
            return registers[x]
        else:
            return int(x)

    def toggle_instruction(pos, code):
        if pos < 0 or pos >= len(code):
            return
        instruction, args = code[pos]
        if instruction == 'inc':
            code[pos] = ('dec', args)
        elif instruction == 'dec' or instruction == 'tgl':
            code[pos] = ('inc', args)
        elif instruction == 'jnz':
            code[pos] = ('cpy', args)
        elif instruction == 'cpy':
            code[pos] = ('jnz', args)

    pos = 0
    while pos < len(code):
        instruction, args = code[pos]
        if instruction == 'cpy':
            x, y = args
            if y.isalpha():
                registers[y] = get_value(x)
        elif instruction == 'inc':
            x = args[0]
            if x.isalpha():
                registers[x] += 1
        elif instruction == 'dec':
            x = args[0]
            if x.isalpha():
                registers[x] -= 1
        elif instruction == 'jnz':
            x, y = args
            if get_value(x) != 0:
                pos += get_value(y) - 1
        elif instruction == 'tgl':
            x = args[0]
            toggle_pos = pos + get_value(x)
            toggle_instruction(toggle_pos, code)

        pos += 1

    return registers['a']

# Read input from file
with open('input.txt', 'r') as f:
    lines = f.read().splitlines()

# Parse the instructions and arguments
code = []
for line in lines:
    parts = line.split()
    instruction = parts[0]
    args = tuple(parts[1:])
    code.append((instruction, args))

# Execute the code
result = execute_code(code)

print(result)
",0.0
95,2016,23,2,part1_failed,,479009076,,,
96,2016,24,1,wrong_output,"315
",498,,"from typing import List, Tuple

def find_shortest_path(map_str: str) -> int:
    # Parse the map string into a 2D grid
    map_grid = [list(row) for row in map_str.split('\n')]

    # Find the starting point
    start_row, start_col = find_start_point(map_grid)

    # Find the number of locations
    num_locations = count_locations(map_grid)

    # Perform breadth-first search to find the shortest path
    queue = [(start_row, start_col, 0, set())]  # (row, col, steps, visited)
    visited = set()
    while queue:
        row, col, steps, visited_locations = queue.pop(0)

        # Check if all locations have been visited
        if len(visited_locations) == num_locations:
            return steps

        # Check if the current location is a number
        if map_grid[row][col].isdigit():
            visited_locations.add(map_grid[row][col])

        # Add adjacent cells to the queue
        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            new_row = row + dr
            new_col = col + dc
            if is_valid_move(map_grid, new_row, new_col) and (new_row, new_col) not in visited:
                queue.append((new_row, new_col, steps + 1, visited_locations))
                visited.add((new_row, new_col))

    # If no path is found, return -1
    return -1


def find_start_point(map_grid: List[List[str]]) -> Tuple[int, int]:
    for row in range(len(map_grid)):
        for col in range(len(map_grid[0])):
            if map_grid[row][col] == '0':
                return row, col
    raise ValueError(""No start point found"")


def count_locations(map_grid: List[List[str]]) -> int:
    count = 0
    for row in range(len(map_grid)):
        for col in range(len(map_grid[0])):
            if map_grid[row][col].isdigit():
                count += 1
    return count


def is_valid_move(map_grid: List[List[str]], row: int, col: int) -> bool:
    if row < 0 or row >= len(map_grid) or col < 0 or col >= len(map_grid[0]):
        return False
    if map_grid[row][col] == '#':
        return False
    return True


# Read the input from file
with open('input.txt', 'r') as file:
    map_str = file.read()

# Find the shortest path
shortest_path = find_shortest_path(map_str)

# Print the result
print(shortest_path)",0.0
97,2016,24,2,part1_failed,,804,,,
98,2016,25,1,timeout_error,,196,TIMEOUT,"import itertools

def generate_clock_signal(instructions):
    for a in itertools.count(start=1):
        clock_signal = []
        for instruction in instructions:
            if instruction == 'JMP':
                clock_signal.append(a % 2)
            elif instruction == 'INC':
                a += 1
        if clock_signal == [0, 1, 0, 1]:
            return a

# Read input from file
with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

# Generate clock signal
result = generate_clock_signal(instructions)
print(result)",0.0
99,2016,25,2,part1_failed,,,,,
100,2017,1,1,no_error,"1177
",1177,,"# Reading input from file
with open('input.txt', 'r') as f:
    sequence = f.readline().strip()

# Calculating sum of matching digits
total_sum = 0
for i in range(len(sequence)):
    if sequence[i] == sequence[(i+1) % len(sequence)]:
        total_sum += int(sequence[i])

# Printing the result
print(total_sum)",0.0
101,2017,1,2,no_error,"1060
",1060,,"# Reading input from file
with open('input.txt', 'r') as f:
    sequence = f.readline().strip()

# Calculating sum of matching digits
total_sum = 0
halfway = len(sequence) // 2
for i in range(len(sequence)):
    if sequence[i] == sequence[(i+halfway) % len(sequence)]:
        total_sum += int(sequence[i])

# Printing the result
print(total_sum)",0.0
102,2017,2,1,syntax_error,,45158,"  File ""/tmp/tmpsnn27p39/tmp.py"", line 2
    We can solve this problem by following these steps:
       ^
SyntaxError: invalid syntax
","# Approach:
We can solve this problem by following these steps:
1. Read the input spreadsheet from the file.
2. For each row in the spreadsheet, find the difference between the largest and smallest value.
3. Sum all the differences found in step 2 to get the checksum.
4. Print the checksum.

# Implementation:
Here's the implementation of the above approach:",0.0
103,2017,2,2,part1_failed,,294,,,
104,2017,3,1,no_error,"438
",438,,"def find_shortest_path(identifier):
    # find the coordinates of the given square
    x, y = 0, 0
    layer = 1
    while layer * layer < identifier:
        layer += 2
    side_length = layer - 1
    max_identifier = layer * layer
    x = (side_length // 2) - (max_identifier - identifier) % side_length
    y = (side_length // 2) - (max_identifier - identifier) // side_length
    
    # calculate the Manhattan distance
    distance = abs(x) + abs(y)
    return distance

# Read input from file
with open('input.txt', 'r') as file:
    identifier = int(file.readline())

# Call the function and print the result
shortest_path = find_shortest_path(identifier)
print(shortest_path)",0.0
105,2017,3,2,timeout_error,,266330,TIMEOUT,"def find_first_larger_value(puzzle_input):
    # Initialize the grid and set square 1 with value 1
    grid = {(0, 0): 1}
    x, y = 0, 0
    layer = 1
    direction = 0
    side_length = 1

    # Define the move directions (right, up, left, down)
    dx = [1, 0, -1, 0]
    dy = [0, 1, 0, -1]

    while True:
        # Calculate the value for the current square
        value = 0
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            value += grid.get((nx, ny), 0)

        # Check if the value is larger than the puzzle input
        if value > puzzle_input:
            return value

        # Update the grid and move to the next square
        grid[(x, y)] = value
        x += dx[direction]
        y += dy[direction]

        # Check if we need to change direction or increase layer
        if abs(x) == layer and abs(y) == layer:
            direction = (direction + 1) % 4
            if direction == 0:
                layer += 1
        elif abs(x) > layer or abs(y) > layer:
            direction = (direction + 1) % 4

# Read input from file
with open('input.txt', 'r') as file:
    puzzle_input = int(file.readline())

# Call the function and print the result
first_larger_value = find_first_larger_value(puzzle_input)
print(first_larger_value)",0.0
106,2017,4,1,no_error,"383
",383,,"# Read the input file
with open('input.txt', 'r') as file:
    passphrases = file.read().splitlines()

# Count the number of valid passphrases
valid_count = 0
for passphrase in passphrases:
    words = passphrase.split()
    if len(set(words)) == len(words):
        valid_count += 1

# Print the result
print(valid_count)",0.0
107,2017,4,2,no_error,"265
",265,,"# Read the input file
with open('input.txt', 'r') as file:
    passphrases = file.read().splitlines()

# Function to check if two words are anagrams
def is_anagram(word1, word2):
    return sorted(word1) == sorted(word2)

# Count the number of valid passphrases
valid_count = 0
for passphrase in passphrases:
    words = passphrase.split()
    if len(set(words)) == len(words):
        is_valid = True
        for i in range(len(words)):
            for j in range(i+1, len(words)):
                if is_anagram(words[i], words[j]):
                    is_valid = False
                    break
            if not is_valid:
                break
        if is_valid:
            valid_count += 1

# Print the result
print(valid_count)",0.0
108,2017,5,1,no_error,"391540
",391540,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    jumps = [int(line.strip()) for line in file.readlines()]

# Initialize variables
steps = 0
index = 0

# Loop until we reach outside the list
while index >= 0 and index < len(jumps):
    offset = jumps[index]
    jumps[index] += 1  # Increase the offset of the current instruction
    index += offset
    steps += 1

# Print the number of steps taken to reach the exit
print(steps)",0.0
109,2017,5,2,no_error,"30513679
",30513679,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    jumps = [int(line.strip()) for line in file.readlines()]

# Initialize variables
steps = 0
index = 0

# Loop until we reach outside the list
while index >= 0 and index < len(jumps):
    offset = jumps[index]
    if offset >= 3:
        jumps[index] -= 1
    else:
        jumps[index] += 1
    index += offset
    steps += 1

# Print the number of steps taken to reach the exit
print(steps)",0.0
110,2017,6,1,wrong_output,"2392
",6681,,"# Read input from file
with open('input.txt', 'r') as file:
    memory_banks = list(map(int, file.read().split('\t')))

# Initialize variables
num_banks = len(memory_banks)
cycles = 0
seen_configurations = {}

# Loop until a configuration is repeated
while tuple(memory_banks) not in seen_configurations:
    # Add current configuration to seen configurations
    seen_configurations[tuple(memory_banks)] = cycles
    
    # Find bank with maximum blocks
    max_blocks = max(memory_banks)
    max_bank = memory_banks.index(max_blocks)
    
    # Redistribute blocks
    memory_banks[max_bank] = 0
    for i in range(max_blocks):
        memory_banks[(max_bank + i + 1) % num_banks] += 1
    
    # Increment cycles
    cycles += 1

# Calculate the number of cycles required to reach repeated configuration
num_cycles = cycles - seen_configurations[tuple(memory_banks)]

# Print the result
print(num_cycles)",0.0
111,2017,6,2,part1_failed,,2392,,,
112,2017,7,1,wrong_output,"myfhxk
",cyrupz,,"def find_bottom_program(input_list):
    programs = set()
    holding_programs = set()

    # Get all the programs and holding programs from the input
    for line in input_list:
        program_info = line.split()
        program = program_info[0]
        programs.add(program)

        if len(program_info) > 3:
            holding_programs.update(program_info[3:])

    # The bottom program is the one that is in the programs set but not in the holding_programs set
    bottom_program = programs.difference(holding_programs).pop()

    return bottom_program


# Read input from file
with open('input.txt', 'r') as file:
    input_list = file.readlines()

bottom_program = find_bottom_program(input_list)
print(bottom_program)",0.0
113,2017,7,2,part1_failed,,193,,,
114,2017,8,1,wrong_output,"4365
",4448,,"# Read input from file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Initialize variables
registers = {}
max_value = 0

# Process instructions
for instruction in instructions:
    # Split instruction into parts
    parts = instruction.split()
    register = parts[0]
    operation = parts[1]
    amount = int(parts[2])
    condition_register = parts[4]
    condition_operator = parts[5]
    condition_value = int(parts[6])

    # Check condition
    if registers.get(condition_register, 0) > condition_value:
        # Perform operation
        if operation == 'inc':
            registers[register] = registers.get(register, 0) + amount
        elif operation == 'dec':
            registers[register] = registers.get(register, 0) - amount

        # Update max value
        if registers[register] > max_value:
            max_value = registers[register]

# Print maximum value
print(max_value)",0.0
115,2017,8,2,part1_failed,,6582,,,
116,2017,9,1,no_error,"7640
",7640,,"# Reading input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Function to calculate the total score
def calculate_total_score(input_string):
    # Initializing variables
    score = 0
    group_level = 0
    garbage = False
    ignore_next = False

    # Iterating through each character in the input string
    for char in input_string:
        if ignore_next:
            ignore_next = False
            continue

        if char == '!':
            ignore_next = True
            continue

        if garbage:
            if char == '>':
                garbage = False
            continue

        if char == '{':
            group_level += 1
            score += group_level
        elif char == '}':
            group_level -= 1
        elif char == '<':
            garbage = True

    return score

# Calculating the total score
total_score = calculate_total_score(input_string)
print(total_score)",0.0
117,2017,9,2,wrong_output,"7535
",4368,,"# Reading input from file
with open('input.txt', 'r') as file:
    input_string = file.read()

# Function to count non-canceled characters within garbage
def count_non_canceled_characters(input_string):
    # Initializing variables
    count = 0
    garbage = False
    ignore_next = False

    # Iterating through each character in the input string
    for char in input_string:
        if ignore_next:
            ignore_next = False
            continue

        if char == '!':
            ignore_next = True
            continue

        if garbage:
            if char != '>':
                count += 1
            continue

        if char == '<':
            garbage = True

    return count

# Counting non-canceled characters within garbage
non_canceled_count = count_non_canceled_characters(input_string)
print(non_canceled_count)",0.0
118,2017,10,1,wrong_output,"5852
",46600,,"def reverse_list(lengths):
    numbers = list(range(256))
    current_position = 0
    skip_size = 0
    for length in lengths:
        sublist = []
        for _ in range(length):
            sublist.append(numbers[current_position])
            current_position = (current_position + 1) % len(numbers)
        sublist.reverse()
        for i in range(length):
            numbers[(current_position + i) % len(numbers)] = sublist[i]
        current_position = (current_position + length + skip_size) % len(numbers)
        skip_size += 1
    result = numbers[0] * numbers[1]
    return result

def main():
    with open('input.txt', 'r') as file:
        input_data = file.read().strip()
    lengths = list(map(int, input_data.split(',')))
    result = reverse_list(lengths)
    print(result)

if __name__ == '__main__':
    main()",0.0
119,2017,10,2,part1_failed,,23234babdc6afa036749cfa9b597de1b,,,
120,2017,11,1,syntax_error,,696,"  File ""/tmp/tmp_j_tjfut/tmp.py"", line 2
    - Initialize the current position as (0, 0)
                 ^
SyntaxError: invalid syntax
","# Plan
- Initialize the current position as (0, 0)
- For each direction in the input list, update the current position accordingly
- The fewest number of steps required to reach the destination hexagon is the maximum of the absolute values of the x and y coordinates of the current position",0.0
121,2017,11,2,part1_failed,,1461,,,
122,2017,12,1,no_error,"288
",288,,"# Read the input from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Create a dictionary to store the connections
connections = {}
for line in lines:
    program, connected_programs = line.strip().split("" <-> "")
    connections[program] = set(connected_programs.split("", ""))

# Function to find all programs in a group
def find_group(program, group):
    # Add the program to the group
    group.add(program)
    # Iterate through the connections of the program
    for connected_program in connections[program]:
        # If the connected program is not already in the group, recursively call the function
        if connected_program not in group:
            find_group(connected_program, group)

# Function to count the number of programs in a group
def count_programs_in_group(program):
    group = set()
    find_group(program, group)
    return len(group)

# Test the count_programs_in_group function with a specific program ID
program_id = ""0""
result = count_programs_in_group(program_id)
print(result)",0.0
123,2017,12,2,runtime_error,,211,"Traceback (most recent call last):
  File ""/tmp/tmp63dv7wxr/tmp.py"", line 41, in <module>
    result = count_groups()
  File ""/tmp/tmp63dv7wxr/tmp.py"", line 37, in count_groups
    visited.update(group)
NameError: name 'group' is not defined
","# Read the input from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Create a dictionary to store the connections
connections = {}
for line in lines:
    program, connected_programs = line.strip().split("" <-> "")
    connections[program] = set(connected_programs.split("", ""))

# Function to find all programs in a group
def find_group(program, group):
    # Add the program to the group
    group.add(program)
    # Iterate through the connections of the program
    for connected_program in connections[program]:
        # If the connected program is not already in the group, recursively call the function
        if connected_program not in group:
            find_group(connected_program, group)

# Function to count the number of programs in a group
def count_programs_in_group(program):
    group = set()
    find_group(program, group)
    return len(group)

# Function to count the number of groups
def count_groups():
    groups = 0
    # Create a set to store visited programs
    visited = set()
    for program in connections.keys():
        # If the program has not been visited, count the programs in its group and increment the groups count
        if program not in visited:
            count_programs_in_group(program)
            groups += 1
            visited.update(group)
    return groups

# Test the count_groups function
result = count_groups()
print(result)",0.0
124,2017,13,1,no_error,"1624
",1624,,"# Read input from file
with open('input.txt', 'r') as file:
    firewall = [line.strip() for line in file.readlines()]

# Parse the input to get depth and range for each layer
layers = []
for layer in firewall:
    depth, range = map(int, layer.split(': '))
    layers.append((depth, range))

# Function to calculate severity of the trip through the firewall
def calculate_severity(layers):
    severity = 0
    for layer in layers:
        depth, range = layer
        if depth % ((range - 1) * 2) == 0:
            severity += depth * range
    return severity

# Calculate severity
severity = calculate_severity(layers)
print(severity)",0.0
125,2017,13,2,no_error,"3923436
",3923436,,"# Read input from file
with open('input.txt', 'r') as file:
    firewall = [line.strip() for line in file.readlines()]

# Parse the input to get depth and range for each layer
layers = []
for layer in firewall:
    depth, range = map(int, layer.split(': '))
    layers.append((depth, range))

def is_caught(layers, delay):
    for layer in layers:
        depth, range = layer
        if (depth + delay) % ((range - 1) * 2) == 0:
            return True
    return False

def find_minimum_delay(layers):
    delay = 0
    while True:
        if not is_caught(layers, delay):
            return delay
        delay += 1

# Find minimum delay
minimum_delay = find_minimum_delay(layers)
print(minimum_delay)",0.0
126,2017,14,1,runtime_error,,8148,"  File ""/tmp/tmpzjhhtp9z/tmp.py"", line 10
    hashes = []
    ^
IndentationError: expected an indented block
","# Read the input key from 'input.txt'
with open('input.txt', 'r') as f:
    key = f.readline().strip()

# Function to calculate the knot hash
def knot_hash(lengths):
    # Implementation of knot hash algorithm

# Generate the 128 knot hashes using the key
hashes = []
for i in range(128):
    lengths = [ord(c) for c in key + '-' + str(i)]
    lengths += [17, 31, 73, 47, 23]  # Additional lengths
    sparse_hash = knot_hash(lengths)
    dense_hash = []
    for j in range(16):
        dense_hash.append(sparse_hash[j*16:(j+1)*16])
    hash_string = ''.join(['{:08b}'.format(x) for x in dense_hash])
    hashes.append(hash_string)

# Count the number of used squares in the grid
used_squares = 0
for hash_string in hashes:
    used_squares += hash_string.count('1')

print(used_squares)",0.0
127,2017,14,2,part1_failed,,1180,,,
128,2017,15,1,timeout_error,,650,TIMEOUT,"a_start = int(input())
b_start = int(input())

a_factor = 16807
b_factor = 48271
divisor = 2147483647

matches = 0
count = 0

for _ in range(40000000):
    a_start = (a_start * a_factor) % divisor
    b_start = (b_start * b_factor) % divisor

    if a_start & 0xFFFF == b_start & 0xFFFF:
        matches += 1

print(matches)",0.0
129,2017,15,2,part1_failed,,336,,,
130,2017,16,1,syntax_error,,nlciboghjmfdapek,"  File ""/tmp/tmp6k84p8f2/tmp.py"", line 2
    1. First, we need to initialize the line of programs as a list of letters from 'a' to 'p' in order.
       ^
SyntaxError: invalid syntax
","# Approach:
1. First, we need to initialize the line of programs as a list of letters from 'a' to 'p' in order.
2. Then, we need to iterate through each dance move in the input string.
3. For each move, we can use if-elif statements to determine the type of move and perform the necessary actions on the line of programs.
4. After performing all the dance moves, we can print the final order of the programs.

# Let's write the code now.",0.0
131,2017,16,2,part1_failed,,nlciboghmkedpfja,,,
132,2017,17,1,no_error,"640
",640,,"# Reading input from file
with open('input.txt', 'r') as f:
    steps = int(f.readline())

# Initializing variables
current_position = 0
circular_buffer = [0]

# Performing spinlock algorithm
for i in range(1, 2018):
    current_position = (current_position + steps) % len(circular_buffer) + 1
    circular_buffer.insert(current_position, i)

# Finding the value immediately after 2017
index_of_2017 = circular_buffer.index(2017)
value_after_2017 = circular_buffer[(index_of_2017 + 1) % len(circular_buffer)]

# Printing the result
print(value_after_2017)",0.0
133,2017,17,2,no_error,"47949463
",47949463,,"# Reading input from file
with open('input.txt', 'r') as f:
    steps = int(f.readline())

# Initializing variables
current_position = 0
value_after_zero = None
buffer_size = 1

# Performing spinlock algorithm
for i in range(1, 50000001):
    current_position = (current_position + steps) % buffer_size + 1
    if current_position == 1:
        value_after_zero = i
    buffer_size += 1

# Printing the result
print(value_after_zero)",0.0
134,2017,18,1,runtime_error,,4601,"Traceback (most recent call last):
  File ""/tmp/tmp27w3f3yq/tmp.py"", line 43, in <module>
    result = execute_program(instructions)
  File ""/tmp/tmp27w3f3yq/tmp.py"", line 14, in execute_program
    operation, x, y = instructions[i].split()
ValueError: not enough values to unpack (expected 3, got 2)
","
def execute_program(instructions):
    registers = {}
    last_sound = None
    i = 0

    def get_value(x):
        if x.isalpha():
            return registers.get(x, 0)
        else:
            return int(x)

    while i < len(instructions):
        operation, x, y = instructions[i].split()

        if operation == ""set"":
            registers[x] = get_value(y)
        elif operation == ""add"":
            registers[x] = get_value(x) + get_value(y)
        elif operation == ""mul"":
            registers[x] = get_value(x) * get_value(y)
        elif operation == ""mod"":
            registers[x] = get_value(x) % get_value(y)
        elif operation == ""snd"":
            last_sound = get_value(x)
        elif operation == ""rcv"":
            if get_value(x) != 0:
                return last_sound
        elif operation == ""jgz"":
            if get_value(x) > 0:
                i += get_value(y)
                continue

        i += 1

    return None

# Read input from file
with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

# Execute the program
result = execute_program(instructions)
print(result)
",0.0
135,2017,18,2,part1_failed,,6858,,,
136,2017,19,1,wrong_output,"
",GSXDIPWTU,,"file = open('input.txt', 'r')
lines = file.readlines()
file.close()

diagram = [line.strip() for line in lines]

# Find the starting point
start = (0, diagram[0].index('|'))

# Determine the direction of the packet
direction = 'down'

# Initialize the current position to the starting point
current = start

# Initialize the encountered letters list
encountered_letters = []

# Start traversing the diagram
while True:
    # Get the current character
    current_char = diagram[current[0]][current[1]]

    # If the current character is a letter, add it to the encountered letters list
    if current_char.isalpha():
        encountered_letters.append(current_char)

    # Determine the next position based on the current direction
    if direction == 'down':
        next_position = (current[0] + 1, current[1])
    elif direction == 'up':
        next_position = (current[0] - 1, current[1])
    elif direction == 'right':
        next_position = (current[0], current[1] + 1)
    elif direction == 'left':
        next_position = (current[0], current[1] - 1)

    # Check if the next position is out of bounds or if the current character is the end of path
    if (
        next_position[0] < 0
        or next_position[0] >= len(diagram)
        or next_position[1] < 0
        or next_position[1] >= len(diagram[next_position[0]])
        or current_char == ' '
    ):
        break

    # Update the current position to the next position
    current = next_position

    # Update the direction based on the current character
    if current_char == '|':
        direction = 'down' if direction != 'up' else 'up'
    elif current_char == '-':
        direction = 'right' if direction != 'left' else 'left'
    elif current_char == '+':
        # Determine the next direction based on the neighbors
        if direction == 'down' or direction == 'up':
            if current[1] > 0 and diagram[current[0]][current[1] - 1] != ' ':
                direction = 'left'
            elif current[1] < len(diagram[current[0]]) - 1 and diagram[current[0]][current[1] + 1] != ' ':
                direction = 'right'
        elif direction == 'right' or direction == 'left':
            if current[0] > 0 and diagram[current[0] - 1][current[1]] != ' ':
                direction = 'up'
            elif current[0] < len(diagram) - 1 and diagram[current[0] + 1][current[1]] != ' ':
                direction = 'down'

print(''.join(encountered_letters))",0.0
137,2017,19,2,part1_failed,,16100,,,
138,2017,20,1,wrong_output,"Closest particle: 55
",344,,"import re

def calculate_manhattan_distance(x, y, z):
    return abs(x) + abs(y) + abs(z)

def find_closest_particle(particles):
    closest_particle = None
    closest_distance = float('inf')
    
    for i, particle in enumerate(particles):
        match = re.match(r""p=<(-?\d+),(-?\d+),(-?\d+)>, v=<(-?\d+),(-?\d+),(-?\d+)>, a=<(-?\d+),(-?\d+),(-?\d+)>"", particle)
        if match:
            p_x, p_y, p_z, v_x, v_y, v_z, a_x, a_y, a_z = map(int, match.groups())
            
            distance = calculate_manhattan_distance(p_x, p_y, p_z)
            if distance < closest_distance:
                closest_distance = distance
                closest_particle = i
    
    return closest_particle

# Read input from file
particles = []
with open('input.txt', 'r') as file:
    for line in file:
        particles.append(line.strip())

closest_particle_index = find_closest_particle(particles)
print(""Closest particle:"", closest_particle_index)",0.0
139,2017,20,2,part1_failed,,404,,,
140,2017,21,1,wrong_output,"0
",179,,"
def enhance_pattern(pattern, rules):
    size = len(pattern)
    if size % 2 == 0:
        new_size = size // 2 * 3
    elif size % 3 == 0:
        new_size = size // 3 * 4
    else:
        return pattern

    new_pattern = [['' for _ in range(new_size)] for _ in range(new_size)]

    for i in range(0, size, new_size):
        for j in range(0, size, new_size):
            square = [row[j:j+new_size] for row in pattern[i:i+new_size]]
            for rule in rules:
                input_pattern, output_pattern = rule.split('=>')
                input_pattern = [row.split('/') for row in input_pattern.split(',')]
                if input_pattern == square:
                    output_pattern = [row.split('/') for row in output_pattern.split(',')]
                    for k in range(new_size):
                        for l in range(new_size):
                            new_pattern[i+k][j+l] = output_pattern[k][l]
                    break

    return new_pattern

def count_pixels(pattern):
    count = 0
    for row in pattern:
        for pixel in row:
            if pixel == '#':
                count += 1
    return count

with open('input.txt', 'r') as file:
    input_lines = file.readlines()

rules = [line.strip() for line in input_lines]

pattern = [['.#.'], ['..#'], ['###']]
iterations = 5

for _ in range(iterations):
    pattern = enhance_pattern(pattern, rules)

result = count_pixels(pattern)
print(result)
",0.0
141,2017,21,2,part1_failed,,2766750,,,
142,2017,22,1,runtime_error,,5280,"Traceback (most recent call last):
  File ""/tmp/tmpnqiemyg9/tmp.py"", line 44, in <module>
    num_infected_bursts = count_infected_bursts(grid, num_bursts)
  File ""/tmp/tmpnqiemyg9/tmp.py"", line 15, in count_infected_bursts
    if grid[cur_row][cur_col] == '#':
IndexError: list index out of range
","with open('input.txt', 'r') as f:
    grid = [list(line.strip()) for line in f]

def count_infected_bursts(grid, num_bursts):
    num_rows = len(grid)
    num_cols = len(grid[0])
    num_infected = 0
    num_bursts_infected = 0
    cur_row = num_rows // 2
    cur_col = num_cols // 2
    cur_dir = 'up'
    directions = ['up', 'right', 'down', 'left']

    for _ in range(num_bursts):
        if grid[cur_row][cur_col] == '#':
            cur_dir = directions[(directions.index(cur_dir) + 1) % 4]
            grid[cur_row][cur_col] = '.'
        else:
            cur_dir = directions[(directions.index(cur_dir) - 1) % 4]
            grid[cur_row][cur_col] = '#'
            num_infected += 1
            num_bursts_infected += 1

        if cur_dir == 'up':
            cur_row -= 1
        elif cur_dir == 'right':
            cur_col += 1
        elif cur_dir == 'down':
            cur_row += 1
        elif cur_dir == 'left':
            cur_col -= 1

        if cur_row < 0 or cur_row >= num_rows or cur_col < 0 or cur_col >= num_cols:
            # Expand the grid if the carrier moves to a node outside the current grid
            grid = [['.' for _ in range(num_cols)]] + grid + [['.' for _ in range(num_cols)]]
            num_rows += 2
            num_cols = len(grid[0])
            cur_row += 1
            cur_col += 1

    return num_bursts_infected

num_bursts = 10000
num_infected_bursts = count_infected_bursts(grid, num_bursts)
print(num_infected_bursts)",0.0
143,2017,22,2,part1_failed,,2512261,,,
144,2017,23,1,runtime_error,,6724,"Traceback (most recent call last):
  File ""/tmp/tmpfsrjmcur/tmp.py"", line 19, in <module>
    registers[operands[0]] = int(operands[1])
ValueError: invalid literal for int() with base 10: 'b'
","# Read the input file
with open('input.txt', 'r') as file:
    instructions = file.readlines()

# Initialize the program counter, register dictionary, and mul count
pc = 0
registers = {}
mul_count = 0

# Execute the instructions until the program counter is out of range
while 0 <= pc < len(instructions):
    # Split the instruction into operation and operands
    instruction = instructions[pc].strip().split()
    operation = instruction[0]
    operands = instruction[1:]

    # Perform the corresponding operation
    if operation == 'set':
        registers[operands[0]] = int(operands[1])
    elif operation == 'sub':
        registers[operands[0]] -= int(operands[1])
    elif operation == 'mul':
        registers[operands[0]] *= int(operands[1])
        mul_count += 1
    elif operation == 'jnz':
        if registers.get(operands[0], int(operands[0])) != 0:
            pc += int(operands[1])
            continue

    # Increment the program counter
    pc += 1

# Print the number of times the mul instruction is invoked
print(mul_count)",0.0
145,2017,23,2,part1_failed,,903,,,
146,2017,24,1,no_error,"2006
",2006,,"# Read the input from the file
with open('input.txt', 'r') as file:
    input_data = file.read().splitlines()

# Parse the input to get the list of components
components = []
for line in input_data:
    pins = line.split('/')
    component = (int(pins[0]), int(pins[1]))
    components.append(component)

# Function to find the strength of the strongest bridge
def find_strongest_bridge(components, current_port, current_strength):
    # Find all the components that can be connected to the current port
    compatible_components = [component for component in components if current_port in component]

    # If there are no compatible components, return the current strength
    if len(compatible_components) == 0:
        return current_strength

    # Initialize the maximum strength with the current strength
    max_strength = current_strength

    # Iterate over all the compatible components
    for component in compatible_components:
        # Find the other port of the component
        other_port = component[0] if current_port == component[1] else component[1]

        # Remove the current component from the list of components
        remaining_components = components.copy()
        remaining_components.remove(component)

        # Recursively find the strength of the bridge with the remaining components
        bridge_strength = find_strongest_bridge(remaining_components, other_port, current_strength + sum(component))

        # Update the maximum strength if the current bridge strength is greater
        if bridge_strength > max_strength:
            max_strength = bridge_strength

    return max_strength

# Find the strength of the strongest bridge starting with a port of type 0
strongest_bridge_strength = find_strongest_bridge(components, 0, 0)

# Print the strength of the strongest bridge
print(strongest_bridge_strength)",0.0
147,2017,24,2,no_error,"1994
",1994,,"# Read the input from the file
with open('input.txt', 'r') as file:
    input_data = file.read().splitlines()

# Parse the input to get the list of components
components = []
for line in input_data:
    pins = line.split('/')
    component = (int(pins[0]), int(pins[1]))
    components.append(component)

# Function to find the longest bridge and its strength
def find_longest_bridge(components, current_port, current_length, current_strength):
    # Find all the components that can be connected to the current port
    compatible_components = [component for component in components if current_port in component]

    # If there are no compatible components, return the current length and strength
    if len(compatible_components) == 0:
        return current_length, current_strength

    # Initialize the maximum length and strength with the current values
    max_length = current_length
    max_strength = current_strength

    # Iterate over all the compatible components
    for component in compatible_components:
        # Find the other port of the component
        other_port = component[0] if current_port == component[1] else component[1]

        # Remove the current component from the list of components
        remaining_components = components.copy()
        remaining_components.remove(component)

        # Recursively find the length and strength of the bridge with the remaining components
        bridge_length, bridge_strength = find_longest_bridge(remaining_components, other_port, current_length + 1, current_strength + sum(component))

        # Update the maximum length and strength if the current bridge length is greater or if the lengths are equal but the strength is greater
        if bridge_length > max_length or (bridge_length == max_length and bridge_strength > max_strength):
            max_length = bridge_length
            max_strength = bridge_strength

    return max_length, max_strength

# Find the longest bridge and its strength starting with a port of type 0
longest_bridge_length, longest_bridge_strength = find_longest_bridge(components, 0, 0, 0)

# Print the strength of the longest bridge
print(longest_bridge_strength)",0.0
148,2017,25,1,runtime_error,,2846,"Traceback (most recent call last):
  File ""/tmp/tmp7eexv9iu/tmp.py"", line 5, in <module>
    num_steps = int(lines[1].strip())
ValueError: invalid literal for int() with base 10: 'Perform a diagnostic checksum after 12994925 steps.'
","with open('input.txt', 'r') as file:
    lines = file.readlines()

initial_state = lines[0].strip()
num_steps = int(lines[1].strip())

states = {}
i = 2
while i < len(lines):
    state = lines[i].strip()
    zero_value = int(lines[i+2].strip().split()[-1])
    zero_direction = 1 if lines[i+3].strip().split()[-1] == 'right' else -1
    zero_next_state = lines[i+4].strip().split()[-1]
    one_value = int(lines[i+6].strip().split()[-1])
    one_direction = 1 if lines[i+7].strip().split()[-1] == 'right' else -1
    one_next_state = lines[i+8].strip().split()[-1]
    states[state] = {
        0: {'value': zero_value, 'direction': zero_direction, 'next_state': zero_next_state},
        1: {'value': one_value, 'direction': one_direction, 'next_state': one_next_state}
    }
    i += 9

# Turing machine simulation
tape = [0] * 1000000  # Initialize tape with infinite zeros
cursor = len(tape) // 2  # Place cursor at the middle of the tape
current_state = initial_state

for _ in range(num_steps):
    current_value = tape[cursor]
    action = states[current_state][current_value]
    tape[cursor] = action['value']
    cursor += action['direction']
    current_state = action['next_state']

checksum = sum(tape)

print(""Diagnostic Checksum:"", checksum)",0.0
149,2017,25,2,part1_failed,,,,,
150,2018,1,1,no_error,"490
",490,,"with open('input.txt', 'r') as f:
    frequency_changes = [int(line.strip()) for line in f.readlines()]

resulting_frequency = sum(frequency_changes)
print(resulting_frequency)",0.0
151,2018,1,2,no_error,"70357
",70357,,"with open('input.txt', 'r') as f:
    frequency_changes = [int(line.strip()) for line in f.readlines()]

current_frequency = 0
frequency_set = set()
found = False

while not found:
    for change in frequency_changes:
        current_frequency += change
        if current_frequency in frequency_set:
            found = True
            break
        frequency_set.add(current_frequency)

print(current_frequency)",0.0
152,2018,2,1,no_error,"7163
",7163,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    box_ids = file.read().splitlines()

def calculate_checksum(box_ids):
    count_two = 0
    count_three = 0

    for box_id in box_ids:
        letter_counts = {}
        for letter in box_id:
            if letter in letter_counts:
                letter_counts[letter] += 1
            else:
                letter_counts[letter] = 1

        if 2 in letter_counts.values():
            count_two += 1
        if 3 in letter_counts.values():
            count_three += 1

    checksum = count_two * count_three
    return checksum

# Call the function with the provided input
result = calculate_checksum(box_ids)
print(result)",0.0
153,2018,2,2,no_error,"ighfbyijnoumxjlxevacpwqtr
",ighfbyijnoumxjlxevacpwqtr,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    box_ids = file.read().splitlines()

def find_common_letters(box_ids):
    for i in range(len(box_ids)):
        for j in range(i+1, len(box_ids)):
            differing_chars = 0
            differing_index = -1
            for k in range(len(box_ids[i])):
                if box_ids[i][k] != box_ids[j][k]:
                    differing_chars += 1
                    differing_index = k
                    if differing_chars > 1:
                        break
            if differing_chars == 1:
                common_letters = box_ids[i][:differing_index] + box_ids[i][differing_index+1:]
                return common_letters

# Call the function with the provided input
result = find_common_letters(box_ids)
print(result)",0.0
154,2018,3,1,no_error,109716,109716,,"def find_overlapping_area(claims):
    # Initialize a 2D grid to keep track of the fabric
    fabric = [[0 for _ in range(1000)] for _ in range(1000)]
    overlapping_area = 0

    # Iterate through each claim
    for claim in claims:
        # Parse the claim string to get the coordinates and dimensions
        claim_parts = claim.split()
        claim_id = int(claim_parts[0][1:])
        left_offset, top_offset = map(int, claim_parts[2][:-1].split(','))
        width, height = map(int, claim_parts[3].split('x'))

        # Mark the area of the claim on the fabric grid
        for i in range(left_offset, left_offset + width):
            for j in range(top_offset, top_offset + height):
                if fabric[i][j] == 0:
                    # If the fabric is unmarked, mark it with the claim ID
                    fabric[i][j] = claim_id
                elif fabric[i][j] != -1:
                    # If the fabric is already marked with a claim ID, mark it as overlapping
                    fabric[i][j] = -1
                    overlapping_area += 1

    return overlapping_area


# Read the input from the file
with open('input.txt', 'r') as file:
    claims = file.read().splitlines()

# Calculate the overlapping area
overlapping_area = find_overlapping_area(claims)
print(""Number of square inches of fabric within two or more claims:"", overlapping_area)",0.0
155,2018,3,2,no_error,124,124,,"def find_non_overlapping_claim(claims):
    # Initialize a 2D grid to keep track of the fabric
    fabric = [[0 for _ in range(1000)] for _ in range(1000)]
    claims_dict = {}

    # Iterate through each claim
    for claim in claims:
        # Parse the claim string to get the coordinates and dimensions
        claim_parts = claim.split()
        claim_id = int(claim_parts[0][1:])
        left_offset, top_offset = map(int, claim_parts[2][:-1].split(','))
        width, height = map(int, claim_parts[3].split('x'))

        # Mark the area of the claim on the fabric grid and store the claim ID
        claims_dict[claim_id] = True
        for i in range(left_offset, left_offset + width):
            for j in range(top_offset, top_offset + height):
                if fabric[i][j] == 0:
                    # If the fabric is unmarked, mark it with the claim ID
                    fabric[i][j] = claim_id
                else:
                    # If the fabric is already marked with a claim ID, mark both claims as overlapping
                    claims_dict[claim_id] = False
                    claims_dict[fabric[i][j]] = False

    # Find the claim ID that doesn't overlap with any other claim
    for claim_id, non_overlapping in claims_dict.items():
        if non_overlapping:
            return claim_id

    return None


# Read the input from the file
with open('input.txt', 'r') as file:
    claims = file.read().splitlines()

# Find the ID of the non-overlapping claim
non_overlapping_claim_id = find_non_overlapping_claim(claims)
print(""ID of the non-overlapping claim:"", non_overlapping_claim_id)",0.0
156,2018,4,1,runtime_error,,73646,"Traceback (most recent call last):
  File ""/tmp/tmpye2048d8/tmp.py"", line 67, in <module>
    output = find_sleepiest_guard(records)
  File ""/tmp/tmpye2048d8/tmp.py"", line 16, in find_sleepiest_guard
    sleep_start = int(record.split("":"")[1].split()[0])
ValueError: invalid literal for int() with base 10: '08]'
","
def find_sleepiest_guard(records):
    guard_sleep = {}
    guard_id = None
    sleep_start = None
    
    # Sort the records by timestamp
    sorted_records = sorted(records)
    
    for record in sorted_records:
        if ""begins shift"" in record:
            # Get the guard ID from the record
            guard_id = int(record.split(""#"")[1].split()[0])
        elif ""falls asleep"" in record:
            # Get the minute the guard falls asleep
            sleep_start = int(record.split("":"")[1].split()[0])
        elif ""wakes up"" in record:
            # Get the minute the guard wakes up
            sleep_end = int(record.split("":"")[1].split()[0])
            
            # Calculate the duration the guard was asleep
            sleep_duration = sleep_end - sleep_start
            
            # Update the sleep duration for the guard
            if guard_id in guard_sleep:
                guard_sleep[guard_id] += sleep_duration
            else:
                guard_sleep[guard_id] = sleep_duration
    
    # Find the guard with the maximum sleep duration
    sleepiest_guard = max(guard_sleep, key=guard_sleep.get)
    
    # Find the minute the sleepiest guard is asleep the most
    minute_sleep = {}
    for record in sorted_records:
        if ""begins shift"" in record and int(record.split(""#"")[1].split()[0]) == sleepiest_guard:
            sleep_start = None
        elif ""falls asleep"" in record and int(record.split(""#"")[1].split()[0]) == sleepiest_guard:
            sleep_start = int(record.split("":"")[1].split()[0])
        elif ""wakes up"" in record and int(record.split(""#"")[1].split()[0]) == sleepiest_guard:
            sleep_end = int(record.split("":"")[1].split()[0])
            
            # Update the minute sleep count
            for minute in range(sleep_start, sleep_end):
                if minute in minute_sleep:
                    minute_sleep[minute] += 1
                else:
                    minute_sleep[minute] = 1
    
    # Find the minute the sleepiest guard is asleep the most
    sleepiest_minute = max(minute_sleep, key=minute_sleep.get)
    
    # Calculate the final result
    result = sleepiest_guard * sleepiest_minute
    
    return result


# Read the input from 'input.txt' file
with open('input.txt', 'r') as file:
    records = file.readlines()

# Remove newlines and whitespace
records = [record.strip() for record in records]

# Call the function with the records
output = find_sleepiest_guard(records)

print(output)
",0.0
157,2018,4,2,part1_failed,,4727,,,
158,2018,5,1,no_error,"9686
",9686,,"# Read the input polymer from the file
with open('input.txt', 'r') as file:
    polymer = file.read().strip()

def react_polymer(polymer):
    stack = []  # Use a stack to track the remaining units

    for unit in polymer:
        if stack and unit == stack[-1].swapcase():
            # If the current unit reacts with the top unit in the stack, remove both units
            stack.pop()
        else:
            # Otherwise, add the current unit to the stack
            stack.append(unit)

    return len(stack)  # Return the length of the remaining polymer

# Call the function with the input polymer and print the result
result = react_polymer(polymer)
print(result)",0.0
159,2018,5,2,no_error,"5524
",5524,,"# Read the input polymer from the file
with open('input.txt', 'r') as file:
    polymer = file.read().strip()

def react_polymer(polymer):
    stack = []  # Use a stack to track the remaining units

    for unit in polymer:
        if stack and unit == stack[-1].swapcase():
            # If the current unit reacts with the top unit in the stack, remove both units
            stack.pop()
        else:
            # Otherwise, add the current unit to the stack
            stack.append(unit)

    return len(stack)  # Return the length of the remaining polymer

def find_shortest_polymer(polymer):
    shortest_length = float('inf')

    # Iterate through each unit type and remove all instances of that type
    for unit_type in set(polymer.lower()):
        modified_polymer = polymer.replace(unit_type, '').replace(unit_type.upper(), '')
        length = react_polymer(modified_polymer)
        
        # Update the shortest length if necessary
        if length < shortest_length:
            shortest_length = length

    return shortest_length

# Call the function with the input polymer and print the result
result = find_shortest_polymer(polymer)
print(result)",0.0
160,2018,6,1,wrong_output,"4338
",3909,,"import math

def manhattan_distance(x1, y1, x2, y2):
    return abs(x1 - x2) + abs(y1 - y2)

def find_closest_coordinate(x, y, coordinates):
    closest_coordinate = None
    min_distance = math.inf

    for coordinate in coordinates:
        distance = manhattan_distance(x, y, coordinate[0], coordinate[1])
        if distance < min_distance:
            closest_coordinate = coordinate
            min_distance = distance
        elif distance == min_distance:
            closest_coordinate = None

    return closest_coordinate

def calculate_largest_area(coordinates):
    grid_size = 400 # assuming a 20x20 grid
    grid = [[None] * grid_size for _ in range(grid_size)]
    areas = {}

    for x in range(grid_size):
        for y in range(grid_size):
            closest_coordinate = find_closest_coordinate(x, y, coordinates)
            if closest_coordinate:
                if x == 0 or y == 0 or x == grid_size - 1 or y == grid_size - 1:
                    areas.pop(closest_coordinate, None)
                else:
                    areas[closest_coordinate] = areas.get(closest_coordinate, 0) + 1
                grid[x][y] = closest_coordinate

    return max(areas.values())

def read_coordinates():
    coordinates = []
    with open('input.txt', 'r') as file:
        for line in file:
            x, y = map(int, line.strip().split(','))
            coordinates.append((x, y))
    return coordinates

def main():
    coordinates = read_coordinates()
    largest_area = calculate_largest_area(coordinates)
    print(largest_area)

if __name__ == '__main__':
    main()",0.0
161,2018,6,2,part1_failed,,36238,,,
162,2018,7,1,wrong_output,,GKRVWBESYAMZDPTIUCFXQJLHNO,,"def get_step_order(instructions):
    # Step 1: Parse the instructions
    steps = set()
    dependencies = {}
    for instruction in instructions:
        parts = instruction.split()
        step = parts[1]
        dependency = parts[7]
        steps.add(step)
        steps.add(dependency)
        if dependency not in dependencies:
            dependencies[dependency] = set()
        dependencies[dependency].add(step)

    # Step 2: Determine the order of steps
    order = []
    while len(order) < len(steps):
        ready_steps = [step for step in steps if step not in order and all(dependency in order for dependency in dependencies.get(step, []))]
        next_step = min(ready_steps)
        order.append(next_step)

    return ''.join(order)",0.0
163,2018,7,2,part1_failed,,903,,,
164,2018,8,1,no_error,"47244
",47244,,"with open('input.txt', 'r') as file:
    input_list = list(map(int, file.readline().strip().split()))

def calculate_metadata_sum(tree):
    # Base case: if tree has no nodes, return 0
    if len(tree) == 0:
        return 0
    
    # Extract header information
    num_child_nodes = tree[0]
    num_metadata_entries = tree[1]
    
    # Remove header from tree
    tree = tree[2:]
    
    metadata_sum = 0
    
    # Recursively process child nodes
    for _ in range(num_child_nodes):
        child_metadata_sum, tree = calculate_metadata_sum(tree)
        metadata_sum += child_metadata_sum
    
    # Sum metadata entries
    metadata_sum += sum(tree[:num_metadata_entries])
    
    # Remove processed metadata entries
    tree = tree[num_metadata_entries:]
    
    return metadata_sum, tree

metadata_sum, _ = calculate_metadata_sum(input_list)
print(metadata_sum)",0.0
165,2018,8,2,no_error,"17267
",17267,,"with open('input.txt', 'r') as file:
    input_list = list(map(int, file.readline().strip().split()))

def calculate_node_value(tree):
    # Base case: if tree has no nodes, return 0
    if len(tree) == 0:
        return 0
    
    # Extract header information
    num_child_nodes = tree[0]
    num_metadata_entries = tree[1]
    
    # Remove header from tree
    tree = tree[2:]
    
    node_value = 0
    child_values = []
    
    # Recursively process child nodes
    for _ in range(num_child_nodes):
        child_value, tree = calculate_node_value(tree)
        child_values.append(child_value)
    
    # Calculate node value based on child nodes and metadata entries
    if num_child_nodes == 0:
        node_value = sum(tree[:num_metadata_entries])
    else:
        for metadata_entry in tree[:num_metadata_entries]:
            if metadata_entry > 0 and metadata_entry <= num_child_nodes:
                node_value += child_values[metadata_entry - 1]
    
    # Remove processed metadata entries
    tree = tree[num_metadata_entries:]
    
    return node_value, tree

node_value, _ = calculate_node_value(input_list)
print(node_value)",0.0
166,2018,9,1,no_error,"384288
",384288,,"with open('input.txt', 'r') as f:
    input_string = f.read()

# Parsing the input string to extract the number of players and the value of the last marble
num_players = int(input_string.split()[0])
last_marble_value = int(input_string.split()[-2])

# Initialize the game state
circle = [0]  # The circle of marbles
current_marble_index = 0  # Index of the current marble in the circle
players_scores = [0] * num_players  # Scores of each player
current_player = 0  # Index of the current player

# Play the game
for marble in range(1, last_marble_value + 1):
    if marble % 23 != 0:
        # Insert the marble between the marbles that are 1 and 2 positions clockwise from the current marble
        insert_index = (current_marble_index + 2) % len(circle)
        circle.insert(insert_index, marble)
        current_marble_index = insert_index
    else:
        # The marble is a multiple of 23
        players_scores[current_player] += marble
        remove_index = (current_marble_index - 7) % len(circle)
        removed_marble = circle.pop(remove_index)
        players_scores[current_player] += removed_marble
        current_marble_index = remove_index

    # Move to the next player
    current_player = (current_player + 1) % num_players

# Find the player with the highest score
highest_score = max(players_scores)

print(highest_score)",0.0
167,2018,9,2,timeout_error,,3189426841,TIMEOUT,"with open('input.txt', 'r') as f:
    input_string = f.read()

# Parsing the input string to extract the number of players and the value of the last marble
num_players = int(input_string.split()[0])
last_marble_value = int(input_string.split()[-2]) * 100

# Initialize the game state
circle = [0]  # The circle of marbles
current_marble_index = 0  # Index of the current marble in the circle
players_scores = [0] * num_players  # Scores of each player
current_player = 0  # Index of the current player

# Play the game
for marble in range(1, last_marble_value + 1):
    if marble % 23 != 0:
        # Insert the marble between the marbles that are 1 and 2 positions clockwise from the current marble
        insert_index = (current_marble_index + 2) % len(circle)
        circle.insert(insert_index, marble)
        current_marble_index = insert_index
    else:
        # The marble is a multiple of 23
        players_scores[current_player] += marble
        remove_index = (current_marble_index - 7) % len(circle)
        removed_marble = circle.pop(remove_index)
        players_scores[current_player] += removed_marble
        current_marble_index = remove_index

    # Move to the next player
    current_player = (current_player + 1) % num_players

# Find the player with the highest score
highest_score = max(players_scores)

print(highest_score)",0.0
168,2018,10,1,wrong_output,,GFNKCGGH,,"# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input to get the positions and velocities
points = []
for line in lines:
    position_start = line.find('<') + 1
    position_end = line.find('>')
    velocity_start = line.find('<', position_end) + 1
    velocity_end = line.find('>', velocity_start)
    position = tuple(map(int, line[position_start:position_end].split(',')))
    velocity = tuple(map(int, line[velocity_start:velocity_end].split(',')))
    points.append((position, velocity))

# Calculate the time when the points align
time = 0
while True:
    aligned = True
    min_x = min_y = float('inf')
    max_x = max_y = float('-inf')
    for position, velocity in points:
        x, y = position
        min_x = min(min_x, x)
        max_x = max(max_x, x)
        min_y = min(min_y, y)
        max_y = max(max_y, y)
    width = max_x - min_x + 1
    height = max_y - min_y + 1
    if width <= 100 and height <= 100:
        aligned = False
    if aligned:
        break
    for i, (position, velocity) in enumerate(points):
        x, y = position
        dx, dy = velocity
        points[i] = ((x + dx, y + dy), velocity)
    time += 1

# Generate the sky with the message
sky = [['.'] * width for _ in range(height)]
for position, _ in points:
    x, y = position
    x -= min_x
    y -= min_y
    sky[y][x] = '#'

# Print the message
for row in sky:
    print(''.join(row))",0.0
169,2018,10,2,part1_failed,,10274,,,
170,2018,11,1,runtime_error,,"235,63","Traceback (most recent call last):
  File ""/tmp/tmpdcglruts/tmp.py"", line 1, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","import numpy as np

def calculate_power_level(x, y, serial_number):
    rack_id = x + 10
    power_level = rack_id * y
    power_level += serial_number
    power_level *= rack_id
    power_level = (power_level // 100) % 10
    power_level -= 5
    return power_level

def find_largest_power_square(serial_number):
    grid = np.zeros((300, 300))
    for x in range(300):
        for y in range(300):
            grid[x, y] = calculate_power_level(x+1, y+1, serial_number)

    max_power = float('-inf')
    max_power_coords = None
    for x in range(298):
        for y in range(298):
            square_power = np.sum(grid[x:x+3, y:y+3])
            if square_power > max_power:
                max_power = square_power
                max_power_coords = (x+1, y+1)

    return max_power_coords

# Read the input
with open('input.txt', 'r') as file:
    serial_number = int(file.read().strip())

# Find the largest power square
largest_power_square = find_largest_power_square(serial_number)

print(largest_power_square)",0.0
171,2018,11,2,part1_failed,,"229,251,16",,,
172,2018,12,1,runtime_error,,4110,"Traceback (most recent call last):
  File ""/tmp/tmpq5wqkts6/tmp.py"", line 37, in <module>
    print(sum_of_plants('input.txt'))
  File ""/tmp/tmpq5wqkts6/tmp.py"", line 9, in sum_of_plants
    pattern, result = line.strip().split(' => ')
ValueError: not enough values to unpack (expected 2, got 1)
","
def sum_of_plants(input_file):
    with open(input_file, 'r') as file:
        lines = file.readlines()

    initial_state = lines[0].split(':')[1].strip()
    rules = {}
    for line in lines[1:]:
        pattern, result = line.strip().split(' => ')
        rules[pattern] = result

    generations = 20
    start_index = 0
    state = initial_state

    for _ in range(generations):
        next_state = ''
        state = '....' + state + '....'
        start_index -= 2
        for i in range(2, len(state) - 2):
            pattern = state[i-2:i+3]
            if pattern in rules:
                next_state += rules[pattern]
            else:
                next_state += '.'

        state = next_state
        start_index += 2

    total = 0
    for i in range(len(state)):
        if state[i] == '#':
            total += i + start_index

    return total

print(sum_of_plants('input.txt'))
",0.0
173,2018,12,2,part1_failed,,2650000000466,,,
174,2018,13,1,wrong_output,,"79,128",,"def find_first_crash(input):
    tracks = []
    carts = []

    lines = input.strip().split('\n')
    for y, line in enumerate(lines):
        for x, char in enumerate(line):
            if char in '|-':
                tracks.append((x, y, char))
            elif char in '^v<>':
                carts.append((x, y, char, 0))

    while True:
        carts.sort(key=lambda cart: (cart[1], cart[0]))

        for i, cart in enumerate(carts):
            x, y, direction, intersection_count = cart

            if direction == '^':
                y -= 1
            elif direction == 'v':
                y += 1
            elif direction == '<':
                x -= 1
            elif direction == '>':
                x += 1

            for other_cart in carts:
                if other_cart != cart and (x, y) == (other_cart[0], other_cart[1]):
                    return (x, y)

            if (x, y, direction) in tracks:
                if direction == '^' or direction == 'v':
                    if tracks.count((x, y, '|')) != 0:
                        intersection_count += 1
                        if intersection_count % 3 == 1:
                            direction = '<'
                        elif intersection_count % 3 == 2:
                            direction = direction
                        elif intersection_count % 3 == 0:
                            direction = '>'
                elif direction == '<' or direction == '>':
                    if tracks.count((x, y, '-')) != 0:
                        intersection_count += 1
                        if intersection_count % 3 == 1:
                            direction = '^'
                        elif intersection_count % 3 == 2:
                            direction = direction
                        elif intersection_count % 3 == 0:
                            direction = 'v'

            carts[i] = (x, y, direction, intersection_count)",0.0
175,2018,13,2,part1_failed,,"3,42",,,
176,2018,14,1,wrong_output,"[9, 4, 1, 1, 1, 3, 7, 1, 3, 3]
",9411137133,,"# Read the input from the file
with open('input.txt', 'r') as file:
    num_recipes = int(file.readline().strip())

# Initialize the scores of the two recipes
scores = [3, 7]
elf1_index = 0
elf2_index = 1

# Loop until we have enough recipes
while len(scores) < num_recipes + 10:
    # Calculate the sum of the current recipes
    total = scores[elf1_index] + scores[elf2_index]

    # Append the digits of the sum to the scoreboard
    scores.extend([int(digit) for digit in str(total)])

    # Move the elves forward
    elf1_index = (elf1_index + 1 + scores[elf1_index]) % len(scores)
    elf2_index = (elf2_index + 1 + scores[elf2_index]) % len(scores)

# Get the scores of the ten recipes immediately after the given number of recipes
result = scores[num_recipes:num_recipes + 10]

# Print the result
print(result)",0.0
177,2018,14,2,part1_failed,,20317612,,,
178,2018,15,1,timeout_error,,201638,TIMEOUT,"def parse_input(input_file):
    map = []
    goblins = []
    elves = []
    with open(input_file, 'r') as file:
        for line in file:
            row = []
            for char in line.strip():
                if char == 'G':
                    goblins.append((len(map), len(row)))
                elif char == 'E':
                    elves.append((len(map), len(row)))
                row.append(char)
            map.append(row)
    return map, goblins, elves

def get_adjacent_positions(position):
    x, y = position
    return [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]

def get_open_adjacent_positions(position, map):
    adj_positions = get_adjacent_positions(position)
    open_positions = []
    for adj_pos in adj_positions:
        x, y = adj_pos
        if 0 <= x < len(map) and 0 <= y < len(map[0]) and map[x][y] == '.':
            open_positions.append(adj_pos)
    return open_positions

def get_distance(position1, position2):
    x1, y1 = position1
    x2, y2 = position2
    return abs(x1 - x2) + abs(y1 - y2)

def move_unit(position, targets, map):
    queue = [(position, 0)] # (position, distance)
    visited = set()
    min_distance = float('inf')
    min_positions = []
    while queue:
        curr_pos, curr_dist = queue.pop(0)
        if curr_dist > min_distance:
            break
        visited.add(curr_pos)
        adj_positions = get_open_adjacent_positions(curr_pos, map)
        for adj_pos in adj_positions:
            if adj_pos in visited:
                continue
            if adj_pos in targets:
                min_distance = curr_dist + 1
                min_positions.append(adj_pos)
            else:
                queue.append((adj_pos, curr_dist + 1))
    if min_positions:
        return min(sorted(min_positions))
    else:
        return None

def attack_unit(position, targets, map, attack_power):
    adjacent_positions = get_adjacent_positions(position)
    min_hp = float('inf')
    min_positions = []
    for adj_pos in adjacent_positions:
        x, y = adj_pos
        if 0 <= x < len(map) and 0 <= y < len(map[0]) and map[x][y] in targets:
            target_hp = targets[map[x][y]]
            if target_hp < min_hp:
                min_hp = target_hp
                min_positions = [adj_pos]
            elif target_hp == min_hp:
                min_positions.append(adj_pos)
    if min_positions:
        return min(sorted(min_positions))
    else:
        return None

def perform_combat(map, goblins, elves, attack_power):
    rounds = 0
    while goblins and elves:
        units = sorted(goblins + elves)
        for unit in units:
            if unit in goblins:
                targets = { 'E': 200 for elf in elves }
                target_symbol = 'E'
            else:
                targets = { 'G': 200 for goblin in goblins }
                target_symbol = 'G'
            adjacent_positions = get_adjacent_positions(unit)
            in_range = False
            for adj_pos in adjacent_positions:
                x, y = adj_pos
                if 0 <= x < len(map) and 0 <= y < len(map[0]) and map[x][y] == target_symbol:
                    in_range = True
                    break
            if not in_range:
                new_unit = move_unit(unit, targets, map)
                if new_unit:
                    del map[unit[0]][unit[1]]
                    map[new_unit[0]][new_unit[1]] = target_symbol
                    unit = new_unit
            attack_pos = attack_unit(unit, targets, map, attack_power)
            if attack_pos:
                x, y = attack_pos
                targets[map[x][y]] -= attack_power
                if targets[map[x][y]] <= 0:
                    if map[x][y] == 'E':
                        elves.remove((x, y))
                    else:
                        goblins.remove((x, y))
                    del map[x][y]
        rounds += 1
    remaining_units = goblins + elves
    total_hp = sum([targets[map[x][y]] for x, y in remaining_units])
    return rounds * total_hp

map, goblins, elves = parse_input('input.txt')
result = perform_combat(map, goblins, elves, 3)
print(result)",0.0
179,2018,15,2,part1_failed,,95764,,,
180,2018,16,1,runtime_error,,642,"Traceback (most recent call last):
  File ""/tmp/tmpaftg4cst/tmp.py"", line 99, in <module>
    main()
  File ""/tmp/tmpaftg4cst/tmp.py"", line 95, in main
    count = count_samples_with_three_or_more_opcodes(samples)
  File ""/tmp/tmpaftg4cst/tmp.py"", line 88, in count_samples_with_three_or_more_opcodes
    if behaves_like_three_or_more_opcodes(sample):
  File ""/tmp/tmpaftg4cst/tmp.py"", line 74, in behaves_like_three_or_more_opcodes
    before, instruction, after = parse_sample(sample)
  File ""/tmp/tmpaftg4cst/tmp.py"", line 67, in parse_sample
    before, instruction, after = sample.strip().split('\n')
ValueError: not enough values to unpack (expected 3, got 1)
","
def addr(registers, A, B, C):
    registers[C] = registers[A] + registers[B]
    return registers

def addi(registers, A, B, C):
    registers[C] = registers[A] + B
    return registers

def mulr(registers, A, B, C):
    registers[C] = registers[A] * registers[B]
    return registers

def muli(registers, A, B, C):
    registers[C] = registers[A] * B
    return registers

def banr(registers, A, B, C):
    registers[C] = registers[A] & registers[B]
    return registers

def bani(registers, A, B, C):
    registers[C] = registers[A] & B
    return registers

def borr(registers, A, B, C):
    registers[C] = registers[A] | registers[B]
    return registers

def bori(registers, A, B, C):
    registers[C] = registers[A] | B
    return registers

def setr(registers, A, B, C):
    registers[C] = registers[A]
    return registers

def seti(registers, A, B, C):
    registers[C] = A
    return registers

def gtir(registers, A, B, C):
    registers[C] = 1 if A > registers[B] else 0
    return registers

def gtri(registers, A, B, C):
    registers[C] = 1 if registers[A] > B else 0
    return registers

def gtrr(registers, A, B, C):
    registers[C] = 1 if registers[A] > registers[B] else 0
    return registers

def eqir(registers, A, B, C):
    registers[C] = 1 if A == registers[B] else 0
    return registers

def eqri(registers, A, B, C):
    registers[C] = 1 if registers[A] == B else 0
    return registers

def eqrr(registers, A, B, C):
    registers[C] = 1 if registers[A] == registers[B] else 0
    return registers

def parse_sample(sample):
    before, instruction, after = sample.strip().split('\n')
    before = eval(before.replace('Before: ', ''))
    instruction = list(map(int, instruction.split()))
    after = eval(after.replace('After:  ', ''))
    return before, instruction, after

def behaves_like_three_or_more_opcodes(sample):
    before, instruction, after = parse_sample(sample)
    opcode, A, B, C = instruction
    opcodes = [addr, addi, mulr, muli, banr, bani, borr, bori, setr, seti, gtir, gtri, gtrr, eqir, eqri, eqrr]
    count = 0
    for opcode_func in opcodes:
        registers = before.copy()
        result = opcode_func(registers, A, B, C)
        if result == after:
            count += 1
    return count >= 3

def count_samples_with_three_or_more_opcodes(samples):
    count = 0
    for sample in samples:
        if behaves_like_three_or_more_opcodes(sample):
            count += 1
    return count

def main():
    with open('input.txt', 'r') as file:
        samples = file.read().strip().split('\n\n')
    count = count_samples_with_three_or_more_opcodes(samples)
    print(count)

if __name__ == '__main__':
    main()
",0.0
181,2018,16,2,part1_failed,,481,,,
182,2018,17,1,syntax_error,,31788,"  File ""/tmp/tmp3hh7bzd1/tmp.py"", line 3
    To solve this problem, we can simulate the flow of water and count the number of tiles that can be reached by the water.
       ^
SyntaxError: invalid syntax
","# Approach

To solve this problem, we can simulate the flow of water and count the number of tiles that can be reached by the water.

1. Parse the input to extract the coordinates of the clay veins.
2. Determine the minimum and maximum y coordinates of the clay veins.
3. Create a grid to represent the terrain, with sand represented as '.' and clay represented as '#'.
4. Set the spring of water at (500, 0) and mark it as '+'. All other squares should be initialized as sand.
5. Simulate the flow of water:
   - Start from the spring position and move downwards until reaching the bottom of the terrain or hitting clay.
   - Once a square of clay or settled water is reached, move horizontally to the left and right to fill any open space until hitting clay or settled water.
   - If no open space is found, backtrack to the previous position and continue moving.
   - If an open space is found, continue moving downwards from the new position.
   - If water flows off the bottom of the terrain, stop the simulation.
6. Count the number of tiles that can be reached by the water. This includes both settled water ('~') and sand that the water can flow through ('|').

# Plan

1. Read the input from the file.
2. Parse the input to extract the coordinates of the clay veins.
3. Determine the minimum and maximum y coordinates of the clay veins.
4. Create a grid to represent the terrain.
5. Simulate the flow of water.
6. Count the number of tiles that can be reached by the water.
7. Print the result.",0.0
183,2018,17,2,part1_failed,,25800,,,
184,2018,18,1,no_error,"653184
",653184,,"def get_adjacent_acres(row, col, grid):
    adjacent_acres = []
    for i in range(row-1, row+2):
        for j in range(col-1, col+2):
            if i >= 0 and i < 50 and j >= 0 and j < 50 and (i != row or j != col):
                adjacent_acres.append(grid[i][j])
    return adjacent_acres

def update_grid(grid):
    new_grid = [['.' for _ in range(50)] for _ in range(50)]
    for row in range(50):
        for col in range(50):
            acre = grid[row][col]
            adjacent_acres = get_adjacent_acres(row, col, grid)
            tree_count = adjacent_acres.count('|')
            lumberyard_count = adjacent_acres.count('#')
            if acre == '.' and tree_count >= 3:
                new_grid[row][col] = '|'
            elif acre == '|' and lumberyard_count >= 3:
                new_grid[row][col] = '#'
            elif acre == '#':
                if '|' not in adjacent_acres or '#' not in adjacent_acres:
                    new_grid[row][col] = '.'
                else:
                    new_grid[row][col] = '#'
            else:
                new_grid[row][col] = acre
    return new_grid

def calculate_resource_value(grid):
    wooded_acres = 0
    lumberyards = 0
    for row in range(50):
        for col in range(50):
            if grid[row][col] == '|':
                wooded_acres += 1
            elif grid[row][col] == '#':
                lumberyards += 1
    return wooded_acres * lumberyards

# Read input from file
with open('input.txt', 'r') as f:
    grid = [list(line.strip()) for line in f.readlines()]

# Simulate for 10 minutes
for _ in range(10):
    grid = update_grid(grid)

resource_value = calculate_resource_value(grid)
print(resource_value)",0.0
185,2018,18,2,wrong_output,"100541
",169106,,"def get_adjacent_acres(row, col, grid):
    adjacent_acres = []
    for i in range(row-1, row+2):
        for j in range(col-1, col+2):
            if i >= 0 and i < 50 and j >= 0 and j < 50 and (i != row or j != col):
                adjacent_acres.append(grid[i][j])
    return adjacent_acres

def update_grid(grid):
    new_grid = [['.' for _ in range(50)] for _ in range(50)]
    for row in range(50):
        for col in range(50):
            acre = grid[row][col]
            adjacent_acres = get_adjacent_acres(row, col, grid)
            tree_count = adjacent_acres.count('|')
            lumberyard_count = adjacent_acres.count('#')
            if acre == '.' and tree_count >= 3:
                new_grid[row][col] = '|'
            elif acre == '|' and lumberyard_count >= 3:
                new_grid[row][col] = '#'
            elif acre == '#':
                if '|' not in adjacent_acres or '#' not in adjacent_acres:
                    new_grid[row][col] = '.'
                else:
                    new_grid[row][col] = '#'
            else:
                new_grid[row][col] = acre
    return new_grid

def calculate_resource_value(grid):
    wooded_acres = 0
    lumberyards = 0
    for row in range(50):
        for col in range(50):
            if grid[row][col] == '|':
                wooded_acres += 1
            elif grid[row][col] == '#':
                lumberyards += 1
    return wooded_acres * lumberyards

# Read input from file
with open('input.txt', 'r') as f:
    grid = [list(line.strip()) for line in f.readlines()]

# Simulate until a cycle is detected
resource_values = []
cycle_start = None
for minute in range(1000000000):
    grid = update_grid(grid)
    resource_value = calculate_resource_value(grid)
    if resource_value in resource_values:
        cycle_start = resource_values.index(resource_value)
        break
    resource_values.append(resource_value)

# Calculate the final resource value using the cycle
cycle_length = len(resource_values) - cycle_start
remaining_minutes = 1000000000 - cycle_start
final_resource_value = resource_values[cycle_start + (remaining_minutes % cycle_length)]
print(final_resource_value)",0.0
186,2018,19,1,no_error,"2520
",2520,,"# Code

def addr(registers, a, b, c):
    registers[c] = registers[a] + registers[b]

def addi(registers, a, b, c):
    registers[c] = registers[a] + b

def mulr(registers, a, b, c):
    registers[c] = registers[a] * registers[b]

def muli(registers, a, b, c):
    registers[c] = registers[a] * b

def banr(registers, a, b, c):
    registers[c] = registers[a] & registers[b]

def bani(registers, a, b, c):
    registers[c] = registers[a] & b

def borr(registers, a, b, c):
    registers[c] = registers[a] | registers[b]

def bori(registers, a, b, c):
    registers[c] = registers[a] | b

def setr(registers, a, b, c):
    registers[c] = registers[a]

def seti(registers, a, b, c):
    registers[c] = a

def gtir(registers, a, b, c):
    registers[c] = 1 if a > registers[b] else 0

def gtri(registers, a, b, c):
    registers[c] = 1 if registers[a] > b else 0

def gtrr(registers, a, b, c):
    registers[c] = 1 if registers[a] > registers[b] else 0

def eqir(registers, a, b, c):
    registers[c] = 1 if a == registers[b] else 0

def eqri(registers, a, b, c):
    registers[c] = 1 if registers[a] == b else 0

def eqrr(registers, a, b, c):
    registers[c] = 1 if registers[a] == registers[b] else 0

def execute_program(program):
    ip_register = int(program[0].split()[1])
    instructions = program[1:]
    registers = [0] * 6

    while 0 <= registers[ip_register] < len(instructions):
        instruction = instructions[registers[ip_register]]
        opcode, a, b, c = instruction.split()
        a, b, c = int(a), int(b), int(c)

        if opcode == ""addr"":
            addr(registers, a, b, c)
        elif opcode == ""addi"":
            addi(registers, a, b, c)
        elif opcode == ""mulr"":
            mulr(registers, a, b, c)
        elif opcode == ""muli"":
            muli(registers, a, b, c)
        elif opcode == ""banr"":
            banr(registers, a, b, c)
        elif opcode == ""bani"":
            bani(registers, a, b, c)
        elif opcode == ""borr"":
            borr(registers, a, b, c)
        elif opcode == ""bori"":
            bori(registers, a, b, c)
        elif opcode == ""setr"":
            setr(registers, a, b, c)
        elif opcode == ""seti"":
            seti(registers, a, b, c)
        elif opcode == ""gtir"":
            gtir(registers, a, b, c)
        elif opcode == ""gtri"":
            gtri(registers, a, b, c)
        elif opcode == ""gtrr"":
            gtrr(registers, a, b, c)
        elif opcode == ""eqir"":
            eqir(registers, a, b, c)
        elif opcode == ""eqri"":
            eqri(registers, a, b, c)
        elif opcode == ""eqrr"":
            eqrr(registers, a, b, c)

        registers[ip_register] += 1

    return registers[0]

with open('input.txt', 'r') as file:
    program = file.read().splitlines()

result = execute_program(program)
print(result)",0.0
187,2018,19,2,timeout_error,,27941760,TIMEOUT,"# Code

def addr(registers, a, b, c):
    registers[c] = registers[a] + registers[b]

def addi(registers, a, b, c):
    registers[c] = registers[a] + b

def mulr(registers, a, b, c):
    registers[c] = registers[a] * registers[b]

def muli(registers, a, b, c):
    registers[c] = registers[a] * b

def banr(registers, a, b, c):
    registers[c] = registers[a] & registers[b]

def bani(registers, a, b, c):
    registers[c] = registers[a] & b

def borr(registers, a, b, c):
    registers[c] = registers[a] | registers[b]

def bori(registers, a, b, c):
    registers[c] = registers[a] | b

def setr(registers, a, b, c):
    registers[c] = registers[a]

def seti(registers, a, b, c):
    registers[c] = a

def gtir(registers, a, b, c):
    registers[c] = 1 if a > registers[b] else 0

def gtri(registers, a, b, c):
    registers[c] = 1 if registers[a] > b else 0

def gtrr(registers, a, b, c):
    registers[c] = 1 if registers[a] > registers[b] else 0

def eqir(registers, a, b, c):
    registers[c] = 1 if a == registers[b] else 0

def eqri(registers, a, b, c):
    registers[c] = 1 if registers[a] == b else 0

def eqrr(registers, a, b, c):
    registers[c] = 1 if registers[a] == registers[b] else 0

def execute_program(program):
    ip_register = int(program[0].split()[1])
    instructions = program[1:]
    registers = [0] * 6
    registers[0] = 1

    while 0 <= registers[ip_register] < len(instructions):
        instruction = instructions[registers[ip_register]]
        opcode, a, b, c = instruction.split()
        a, b, c = int(a), int(b), int(c)

        if opcode == ""addr"":
            addr(registers, a, b, c)
        elif opcode == ""addi"":
            addi(registers, a, b, c)
        elif opcode == ""mulr"":
            mulr(registers, a, b, c)
        elif opcode == ""muli"":
            muli(registers, a, b, c)
        elif opcode == ""banr"":
            banr(registers, a, b, c)
        elif opcode == ""bani"":
            bani(registers, a, b, c)
        elif opcode == ""borr"":
            borr(registers, a, b, c)
        elif opcode == ""bori"":
            bori(registers, a, b, c)
        elif opcode == ""setr"":
            setr(registers, a, b, c)
        elif opcode == ""seti"":
            seti(registers, a, b, c)
        elif opcode == ""gtir"":
            gtir(registers, a, b, c)
        elif opcode == ""gtri"":
            gtri(registers, a, b, c)
        elif opcode == ""gtrr"":
            gtrr(registers, a, b, c)
        elif opcode == ""eqir"":
            eqir(registers, a, b, c)
        elif opcode == ""eqri"":
            eqri(registers, a, b, c)
        elif opcode == ""eqrr"":
            eqrr(registers, a, b, c)

        registers[ip_register] += 1

    return registers[0]

with open('input.txt', 'r') as file:
    program = file.read().splitlines()

result = execute_program(program)
print(result)",0.0
188,2018,20,1,wrong_output,"Furthest room distance: 687
Furthest rooms: [(12, -7)]
",4432,,"# Read the input regex string
with open('input.txt', 'r') as file:
    regex = file.readline().strip()

# Function to compute the distance of the furthest room
def compute_furthest_room(regex):
    stack = [(0, 0)]  # Stack to keep track of the current position
    distances = {(0, 0): 0}  # Dictionary to store the distances from the starting position

    for char in regex:
        if char == 'N':
            x, y = stack[-1]
            stack.append((x, y+1))
            nx, ny = stack[-1]
            if (nx, ny) not in distances:
                distances[(nx, ny)] = distances[(x, y)] + 1
        elif char == 'S':
            x, y = stack[-1]
            stack.append((x, y-1))
            nx, ny = stack[-1]
            if (nx, ny) not in distances:
                distances[(nx, ny)] = distances[(x, y)] + 1
        elif char == 'E':
            x, y = stack[-1]
            stack.append((x+1, y))
            nx, ny = stack[-1]
            if (nx, ny) not in distances:
                distances[(nx, ny)] = distances[(x, y)] + 1
        elif char == 'W':
            x, y = stack[-1]
            stack.append((x-1, y))
            nx, ny = stack[-1]
            if (nx, ny) not in distances:
                distances[(nx, ny)] = distances[(x, y)] + 1
        elif char == '|':
            stack.pop()

    max_distance = max(distances.values())  # Find the maximum distance from the starting position
    furthest_rooms = [room for room, distance in distances.items() if distance == max_distance]
    return max_distance, furthest_rooms

# Compute the furthest room distance and the corresponding rooms
max_distance, furthest_rooms = compute_furthest_room(regex)

# Print the result
print(""Furthest room distance:"", max_distance)
print(""Furthest rooms:"", furthest_rooms)",0.0
189,2018,20,2,part1_failed,,8681,,,
190,2018,21,1,timeout_error,,2159153,TIMEOUT,"# Here is a possible approach to solve this problem:

# Read the input from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input
ip_register = int(lines[0].split()[1])
instructions = [line.strip().split() for line in lines[1:]]

# Define the operations
def addr(registers, a, b, c):
    registers[c] = registers[a] + registers[b]

def addi(registers, a, b, c):
    registers[c] = registers[a] + b

def mulr(registers, a, b, c):
    registers[c] = registers[a] * registers[b]

def muli(registers, a, b, c):
    registers[c] = registers[a] * b

def banr(registers, a, b, c):
    registers[c] = registers[a] & registers[b]

def bani(registers, a, b, c):
    registers[c] = registers[a] & b

def borr(registers, a, b, c):
    registers[c] = registers[a] | registers[b]

def bori(registers, a, b, c):
    registers[c] = registers[a] | b

def setr(registers, a, b, c):
    registers[c] = registers[a]

def seti(registers, a, b, c):
    registers[c] = a

def gtir(registers, a, b, c):
    registers[c] = int(a > registers[b])

def gtri(registers, a, b, c):
    registers[c] = int(registers[a] > b)

def gtrr(registers, a, b, c):
    registers[c] = int(registers[a] > registers[b])

def eqir(registers, a, b, c):
    registers[c] = int(a == registers[b])

def eqri(registers, a, b, c):
    registers[c] = int(registers[a] == b)

def eqrr(registers, a, b, c):
    registers[c] = int(registers[a] == registers[b])

# Initialize the registers
registers = [0] * 6
registers[0] = 0

# Execute the program
while True:
    instruction_pointer = registers[ip_register]
    if instruction_pointer < 0 or instruction_pointer >= len(instructions):
        break
    
    instruction = instructions[instruction_pointer]
    operation = globals()[instruction[0]]
    operation(registers, int(instruction[1]), int(instruction[2]), int(instruction[3]))
    
    registers[ip_register] += 1

# Print the value of register 0
print(registers[0])",0.0
191,2018,21,2,part1_failed,,7494885,,,
192,2018,22,1,runtime_error,,11972,"Traceback (most recent call last):
  File ""/tmp/tmpjk09j3kg/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np

def calculate_risk_level(depth, target_coordinates):
    # Parse the depth and target coordinates
    depth = int(depth)
    target_x, target_y = map(int, target_coordinates.split(','))

    # Calculate the size of the cave system based on the target coordinates
    cave_width = target_x + 1
    cave_height = target_y + 1

    # Initialize the cave system with zeros
    cave_system = np.zeros((cave_height, cave_width), dtype=int)

    # Calculate the geologic index and erosion level for each region
    for y in range(cave_height):
        for x in range(cave_width):
            if x == 0 and y == 0:
                geologic_index = 0
            elif x == target_x and y == target_y:
                geologic_index = 0
            elif y == 0:
                geologic_index = x * 16807
            elif x == 0:
                geologic_index = y * 48271
            else:
                geologic_index = cave_system[y-1, x] * cave_system[y, x-1]

            erosion_level = (geologic_index + depth) % 20183
            cave_system[y, x] = erosion_level

    # Calculate the risk level for each region
    risk_level = np.sum(cave_system % 3)

    return risk_level

# Read the input from the file
with open('input.txt', 'r') as file:
    depth = file.readline().strip()
    target_coordinates = file.readline().strip()

# Calculate the risk level
risk_level = calculate_risk_level(depth, target_coordinates)
print(risk_level)
",0.0
193,2018,22,2,part1_failed,,1092,,,
194,2018,23,1,wrong_output,"202
",270,,"def find_largest_radius(nanobots):
    largest_radius = 0
    largest_radius_bot = None
    in_range_count = 0

    for bot in nanobots:
        x, y, z, r = parse_nanobot(bot)

        if r > largest_radius:
            largest_radius = r
            largest_radius_bot = (x, y, z)

        if is_in_range(bot, largest_radius_bot):
            in_range_count += 1

    return in_range_count

def parse_nanobot(bot):
    pos_start = bot.index(""<"") + 1
    pos_end = bot.index("">"")
    pos_values = bot[pos_start:pos_end].split("","")
    x = int(pos_values[0])
    y = int(pos_values[1])
    z = int(pos_values[2])

    r_start = bot.index(""r="") + 2
    r = int(bot[r_start:])

    return x, y, z, r

def is_in_range(bot, largest_bot):
    x, y, z, r = parse_nanobot(bot)
    largest_x, largest_y, largest_z = largest_bot

    distance = abs(x - largest_x) + abs(y - largest_y) + abs(z - largest_z)

    return distance <= r

def read_input_file(file_name):
    with open(file_name, 'r') as file:
        return file.readlines()

def main():
    input_file = 'input.txt'
    nanobots = read_input_file(input_file)
    in_range_count = find_largest_radius(nanobots)
    print(in_range_count)

if __name__ == '__main__':
    main()",0.0
195,2018,23,2,part1_failed,,106323091,,,
196,2018,24,1,timeout_error,,14377,TIMEOUT,"
import re

class Group:
    def __init__(self, units, hp, attack_damage, attack_type, initiative, weaknesses, immunities):
        self.units = units
        self.hp = hp
        self.attack_damage = attack_damage
        self.attack_type = attack_type
        self.initiative = initiative
        self.weaknesses = weaknesses
        self.immunities = immunities
    
    def effective_power(self):
        return self.units * self.attack_damage
    
    def select_target(self, targets):
        potential_targets = []
        for target in targets:
            if target not in self.immunities:
                if self.attack_type in target.weaknesses:
                    potential_targets.append((target, target.effective_power() * 2))
                else:
                    potential_targets.append((target, target.effective_power()))
        if potential_targets:
            potential_targets.sort(key=lambda x: (x[1], x[0].initiative), reverse=True)
            return potential_targets[0][0]
        return None
    
    def take_damage(self, damage):
        units_lost = damage // self.hp
        self.units = max(0, self.units - units_lost)
    
    def is_alive(self):
        return self.units > 0

def parse_input(input_string):
    immune_system = []
    infection = []
    sections = input_string.strip().split(""\n\n"")
    immune_system_section = sections[0].split(""\n"")[1:]
    infection_section = sections[1].split(""\n"")[1:]
    
    for line in immune_system_section:
        match = re.match(r""(\d+) units each with (\d+) hit points (\([^)]+\) )?with an attack that does (\d+) (\w+) damage at initiative (\d+)"", line)
        units = int(match.group(1))
        hp = int(match.group(2))
        attack_damage = int(match.group(4))
        attack_type = match.group(5)
        initiative = int(match.group(6))
        weaknesses = []
        immunities = []
        if match.group(3):
            modifier_text = match.group(3).strip(""() "")
            for modifier in modifier_text.split(""; ""):
                if modifier.startswith(""weak to""):
                    weaknesses = modifier[8:].split("", "")
                elif modifier.startswith(""immune to""):
                    immunities = modifier[10:].split("", "")
        
        immune_system.append(Group(units, hp, attack_damage, attack_type, initiative, weaknesses, immunities))
    
    for line in infection_section:
        match = re.match(r""(\d+) units each with (\d+) hit points (\([^)]+\) )?with an attack that does (\d+) (\w+) damage at initiative (\d+)"", line)
        units = int(match.group(1))
        hp = int(match.group(2))
        attack_damage = int(match.group(4))
        attack_type = match.group(5)
        initiative = int(match.group(6))
        weaknesses = []
        immunities = []
        if match.group(3):
            modifier_text = match.group(3).strip(""() "")
            for modifier in modifier_text.split(""; ""):
                if modifier.startswith(""weak to""):
                    weaknesses = modifier[8:].split("", "")
                elif modifier.startswith(""immune to""):
                    immunities = modifier[10:].split("", "")
        
        infection.append(Group(units, hp, attack_damage, attack_type, initiative, weaknesses, immunities))
    
    return immune_system, infection

def simulate_combat(immune_system, infection):
    while immune_system and infection:
        all_groups = immune_system + infection
        all_groups.sort(key=lambda x: (x.effective_power(), x.initiative), reverse=True)
        targets = {}
        
        for group in all_groups:
            if group.is_alive():
                target = group.select_target(all_groups)
                if target:
                    targets[group] = target
        
        all_groups.sort(key=lambda x: x.initiative, reverse=True)
        
        for group in all_groups:
            if group.is_alive():
                if group in targets:
                    target = targets[group]
                    damage = group.effective_power()
                    if group.attack_type in target.weaknesses:
                        damage *= 2
                    target.take_damage(damage)
                    if not target.is_alive():
                        all_groups.remove(target)
                        if target in immune_system:
                            immune_system.remove(target)
                        else:
                            infection.remove(target)
        
    if immune_system:
        return sum(group.units for group in immune_system)
    else:
        return sum(group.units for group in infection)

def main():
    with open('input.txt', 'r') as file:
        input_string = file.read()
    
    immune_system, infection = parse_input(input_string)
    result = simulate_combat(immune_system, infection)
    print(f""The winning army has {result} units."")

if __name__ == '__main__':
    main()
",0.0
197,2018,24,2,part1_failed,,6947,,,
198,2018,25,1,no_error,"363
",363,,"from collections import deque

def manhattan_distance(p1, p2):
    return sum(abs(x - y) for x, y in zip(p1, p2))

def find_constellations(coordinates):
    constellations = []
    visited = set()

    def bfs(coord):
        queue = deque([coord])
        constellation = set()
        while queue:
            curr = queue.popleft()
            constellation.add(curr)
            for neighbor in coordinates:
                if neighbor not in constellation and neighbor not in visited and manhattan_distance(curr, neighbor) <= 3:
                    queue.append(neighbor)
                    visited.add(neighbor)
        return constellation

    for coord in coordinates:
        if coord not in visited:
            constellation = bfs(coord)
            constellations.append(constellation)
            visited.update(constellation)

    return len(constellations)


if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        coordinates = [tuple(map(int, line.strip().split("",""))) for line in file.readlines()]
        num_constellations = find_constellations(coordinates)
        print(num_constellations)",0.0
199,2019,1,1,no_error,"3336439
",3336439,,"masses = []

# Read the input from the file
with open('input.txt', 'r') as f:
    for line in f:
        masses.append(int(line.strip()))

total_fuel = 0

# Calculate the fuel requirement for each module
for mass in masses:
    fuel = (mass // 3) - 2
    total_fuel += fuel

print(total_fuel)",0.0
200,2019,1,2,no_error,"5001791
",5001791,,"masses = []

# Read the input from the file
with open('input.txt', 'r') as f:
    for line in f:
        masses.append(int(line.strip()))

def calculate_fuel(mass):
    fuel = (mass // 3) - 2
    if fuel <= 0:
        return 0
    return fuel + calculate_fuel(fuel)

total_fuel = 0

# Calculate the fuel requirement for each module and its fuel
for mass in masses:
    fuel = calculate_fuel(mass)
    total_fuel += fuel

print(total_fuel)",0.0
201,2019,2,1,no_error,"4138658
",4138658,,"# Read the input from the file
with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))

# Replace positions 1 and 2 with the given values
program[1] = 12
program[2] = 2

# Execute the Intcode program
instruction_pointer = 0
while True:
    opcode = program[instruction_pointer]
    if opcode == 99:
        break
    elif opcode == 1:
        operand1 = program[program[instruction_pointer + 1]]
        operand2 = program[program[instruction_pointer + 2]]
        program[program[instruction_pointer + 3]] = operand1 + operand2
    elif opcode == 2:
        operand1 = program[program[instruction_pointer + 1]]
        operand2 = program[program[instruction_pointer + 2]]
        program[program[instruction_pointer + 3]] = operand1 * operand2
    instruction_pointer += 4

# Print the value at position 0
print(program[0])",0.0
202,2019,2,2,no_error,"7264
",7264,,"# Read the input from the file
with open('input.txt', 'r') as file:
    program = list(map(int, file.read().split(',')))

# Function to execute the Intcode program
def execute_program(program):
    instruction_pointer = 0
    while True:
        opcode = program[instruction_pointer]
        if opcode == 99:
            break
        elif opcode == 1:
            operand1 = program[program[instruction_pointer + 1]]
            operand2 = program[program[instruction_pointer + 2]]
            program[program[instruction_pointer + 3]] = operand1 + operand2
        elif opcode == 2:
            operand1 = program[program[instruction_pointer + 1]]
            operand2 = program[program[instruction_pointer + 2]]
            program[program[instruction_pointer + 3]] = operand1 * operand2
        instruction_pointer += 4
    return program[0]

# Try all possible combinations of noun and verb
for noun in range(100):
    for verb in range(100):
        # Reset the computer's memory
        memory = program.copy()
        # Set the noun and verb values
        memory[1] = noun
        memory[2] = verb
        # Execute the program
        result = execute_program(memory)
        # Check if the output matches the desired value
        if result == 19690720:
            # Calculate the final result
            final_result = 100 * noun + verb
            # Print the result
            print(final_result)
            # Exit the loop
            break
    else:
        continue
    break",0.0
203,2019,3,1,no_error,248,248,,"# Read the input from 'input.txt' file
with open('input.txt', 'r') as file:
    wire1_path = file.readline().strip()
    wire2_path = file.readline().strip()

# Convert the wire paths into lists of instructions
wire1_instructions = wire1_path.split(',')
wire2_instructions = wire2_path.split(',')

# Function to calculate the Manhattan distance between two points
def manhattan_distance(point1, point2):
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

# Function to get the coordinates of all points visited by a wire
def get_wire_coordinates(wire_instructions):
    coordinates = []
    current_point = [0, 0]
    
    for instruction in wire_instructions:
        direction = instruction[0]
        distance = int(instruction[1:])
        
        if direction == 'R':
            for i in range(1, distance + 1):
                coordinates.append([current_point[0] + i, current_point[1]])
            current_point[0] += distance
        elif direction == 'L':
            for i in range(1, distance + 1):
                coordinates.append([current_point[0] - i, current_point[1]])
            current_point[0] -= distance
        elif direction == 'U':
            for i in range(1, distance + 1):
                coordinates.append([current_point[0], current_point[1] + i])
            current_point[1] += distance
        elif direction == 'D':
            for i in range(1, distance + 1):
                coordinates.append([current_point[0], current_point[1] - i])
            current_point[1] -= distance
    
    return coordinates

# Get the coordinates visited by both wires
wire1_coordinates = get_wire_coordinates(wire1_instructions)
wire2_coordinates = get_wire_coordinates(wire2_instructions)

# Find the intersection points between both wires
intersection_points = set(map(tuple, wire1_coordinates)).intersection(map(tuple, wire2_coordinates))

# Find the intersection point closest to the central port
closest_intersection_point = min(intersection_points, key=lambda point: manhattan_distance([0, 0], point))

# Calculate the Manhattan distance of the closest intersection point
closest_intersection_distance = manhattan_distance([0, 0], closest_intersection_point)

# Print the result
print(f""The closest intersection point is {closest_intersection_point} with a Manhattan distance of {closest_intersection_distance}."")",0.0
204,2019,3,2,no_error,28580,28580,,"# Read the input from 'input.txt' file
with open('input.txt', 'r') as file:
    wire1_path = file.readline().strip()
    wire2_path = file.readline().strip()

# Convert the wire paths into lists of instructions
wire1_instructions = wire1_path.split(',')
wire2_instructions = wire2_path.split(',')

# Function to calculate the Manhattan distance between two points
def manhattan_distance(point1, point2):
    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])

# Function to get the coordinates and steps of all points visited by a wire
def get_wire_coordinates_and_steps(wire_instructions):
    coordinates = []
    steps = 0
    current_point = [0, 0]
    step_counts = {}
    
    for instruction in wire_instructions:
        direction = instruction[0]
        distance = int(instruction[1:])
        
        if direction == 'R':
            for i in range(1, distance + 1):
                step_counts[tuple([current_point[0] + i, current_point[1]])] = steps + i
                coordinates.append([current_point[0] + i, current_point[1]])
            current_point[0] += distance
        elif direction == 'L':
            for i in range(1, distance + 1):
                step_counts[tuple([current_point[0] - i, current_point[1]])] = steps + i
                coordinates.append([current_point[0] - i, current_point[1]])
            current_point[0] -= distance
        elif direction == 'U':
            for i in range(1, distance + 1):
                step_counts[tuple([current_point[0], current_point[1] + i])] = steps + i
                coordinates.append([current_point[0], current_point[1] + i])
            current_point[1] += distance
        elif direction == 'D':
            for i in range(1, distance + 1):
                step_counts[tuple([current_point[0], current_point[1] - i])] = steps + i
                coordinates.append([current_point[0], current_point[1] - i])
            current_point[1] -= distance
        
        steps += distance
    
    return coordinates, step_counts

# Get the coordinates and steps visited by both wires
wire1_coordinates, wire1_step_counts = get_wire_coordinates_and_steps(wire1_instructions)
wire2_coordinates, wire2_step_counts = get_wire_coordinates_and_steps(wire2_instructions)

# Find the intersection points between both wires
intersection_points = list(set(map(tuple, wire1_coordinates)).intersection(map(tuple, wire2_coordinates)))

# Calculate the total number of steps for each intersection point
total_steps = [wire1_step_counts[point] + wire2_step_counts[point] for point in intersection_points]

# Find the intersection point with the fewest combined steps
fewest_steps_intersection_point = intersection_points[total_steps.index(min(total_steps))]

# Print the result
print(f""The intersection point with the fewest combined steps is {fewest_steps_intersection_point} with a total of {min(total_steps)} steps."")",0.0
205,2019,4,1,no_error,"454
",454,,"
def count_passwords(range_str):
    range_start, range_end = map(int, range_str.split('-'))
    count = 0
    for num in range(range_start, range_end + 1):
        digits = list(str(num))
        if len(set(digits)) < len(digits) and digits == sorted(digits):
            count += 1
    return count

with open('input.txt', 'r') as file:
    input_range = file.read().strip()

num_passwords = count_passwords(input_range)
print(num_passwords)
",0.0
206,2019,4,2,no_error,"288
",288,,"
def count_passwords(range_str):
    range_start, range_end = map(int, range_str.split('-'))
    count = 0
    for num in range(range_start, range_end + 1):
        digits = list(str(num))
        if has_adjacent_digits(digits) and digits == sorted(digits):
            count += 1
    return count

def has_adjacent_digits(digits):
    for i in range(len(digits) - 1):
        if digits[i] == digits[i+1]:
            if i == 0 or digits[i] != digits[i-1]:
                if i == len(digits) - 2 or digits[i+1] != digits[i+2]:
                    return True
    return False

with open('input.txt', 'r') as file:
    input_range = file.read().strip()

num_passwords = count_passwords(input_range)
print(num_passwords)
",0.0
207,2019,5,1,no_error,6069343,6069343,,"
def run_diagnostic(program):
    def get_value(mode, value):
        if mode == 0:
            return program[value]
        else:
            return value

    def set_value(mode, index, value):
        if mode == 0:
            program[index] = value
        else:
            raise ValueError(""Invalid parameter mode for write operation"")

    def add(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])
        result = p1 + p2
        set_value(p3_mode, program[pointer + 3], result)

        return pointer + 4

    def multiply(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])
        result = p1 * p2
        set_value(p3_mode, program[pointer + 3], result)

        return pointer + 4

    def input_value(parameter_modes, pointer, input_val):
        p1_mode = parameter_modes[0]

        set_value(p1_mode, program[pointer + 1], input_val)

        return pointer + 2

    def output_value(parameter_modes, pointer):
        p1_mode = parameter_modes[0]

        output_val = get_value(p1_mode, program[pointer + 1])

        return pointer + 2, output_val

    def jump_if_true(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 != 0:
            return p2
        else:
            return pointer + 3

    def jump_if_false(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 == 0:
            return p2
        else:
            return pointer + 3

    def less_than(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 < p2:
            set_value(p3_mode, program[pointer + 3], 1)
        else:
            set_value(p3_mode, program[pointer + 3], 0)

        return pointer + 4

    def equals(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 == p2:
            set_value(p3_mode, program[pointer + 3], 1)
        else:
            set_value(p3_mode, program[pointer + 3], 0)

        return pointer + 4

    pointer = 0
    while True:
        instruction = str(program[pointer]).rjust(5, '0')
        opcode = int(instruction[-2:])
        parameter_modes = [int(mode) for mode in instruction[:-2]][::-1]

        if opcode == 1:
            pointer = add(parameter_modes, pointer)
        elif opcode == 2:
            pointer = multiply(parameter_modes, pointer)
        elif opcode == 3:
            pointer = input_value(parameter_modes, pointer, 1)
        elif opcode == 4:
            pointer, output_val = output_value(parameter_modes, pointer)
            print(output_val)
        elif opcode == 5:
            pointer = jump_if_true(parameter_modes, pointer)
        elif opcode == 6:
            pointer = jump_if_false(parameter_modes, pointer)
        elif opcode == 7:
            pointer = less_than(parameter_modes, pointer)
        elif opcode == 8:
            pointer = equals(parameter_modes, pointer)
        elif opcode == 99:
            break
        else:
            raise ValueError(f""Invalid opcode: {opcode}"")

    return program[0]


with open('input.txt', 'r') as file:
    program = [int(x) for x in file.read().split(',')]

run_diagnostic(program)
",0.0
208,2019,5,2,no_error,"3188550
",3188550,,"
def run_diagnostic(program):
    def get_value(mode, value):
        if mode == 0:
            return program[value]
        else:
            return value

    def set_value(mode, index, value):
        if mode == 0:
            program[index] = value
        else:
            raise ValueError(""Invalid parameter mode for write operation"")

    def add(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])
        result = p1 + p2
        set_value(p3_mode, program[pointer + 3], result)

        return pointer + 4

    def multiply(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])
        result = p1 * p2
        set_value(p3_mode, program[pointer + 3], result)

        return pointer + 4

    def input_value(parameter_modes, pointer, input_val):
        p1_mode = parameter_modes[0]

        set_value(p1_mode, program[pointer + 1], input_val)

        return pointer + 2

    def output_value(parameter_modes, pointer):
        p1_mode = parameter_modes[0]

        output_val = get_value(p1_mode, program[pointer + 1])

        return pointer + 2, output_val

    def jump_if_true(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 != 0:
            return p2
        else:
            return pointer + 3

    def jump_if_false(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 == 0:
            return p2
        else:
            return pointer + 3

    def less_than(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 < p2:
            set_value(p3_mode, program[pointer + 3], 1)
        else:
            set_value(p3_mode, program[pointer + 3], 0)

        return pointer + 4

    def equals(parameter_modes, pointer):
        p1_mode = parameter_modes[0]
        p2_mode = parameter_modes[1]
        p3_mode = parameter_modes[2]

        p1 = get_value(p1_mode, program[pointer + 1])
        p2 = get_value(p2_mode, program[pointer + 2])

        if p1 == p2:
            set_value(p3_mode, program[pointer + 3], 1)
        else:
            set_value(p3_mode, program[pointer + 3], 0)

        return pointer + 4

    pointer = 0
    while True:
        instruction = str(program[pointer]).rjust(5, '0')
        opcode = int(instruction[-2:])
        parameter_modes = [int(mode) for mode in instruction[:-2]][::-1]

        if opcode == 1:
            pointer = add(parameter_modes, pointer)
        elif opcode == 2:
            pointer = multiply(parameter_modes, pointer)
        elif opcode == 3:
            pointer = input_value(parameter_modes, pointer, 5)
        elif opcode == 4:
            pointer, output_val = output_value(parameter_modes, pointer)
            print(output_val)
        elif opcode == 5:
            pointer = jump_if_true(parameter_modes, pointer)
        elif opcode == 6:
            pointer = jump_if_false(parameter_modes, pointer)
        elif opcode == 7:
            pointer = less_than(parameter_modes, pointer)
        elif opcode == 8:
            pointer = equals(parameter_modes, pointer)
        elif opcode == 99:
            break
        else:
            raise ValueError(f""Invalid opcode: {opcode}"")

    return program[0]


with open('input.txt', 'r') as file:
    program = [int(x) for x in file.read().split(',')]

run_diagnostic(program)
",0.0
209,2019,6,1,no_error,"142497
",142497,,"with open('input.txt', 'r') as file:
    relationships = [line.strip() for line in file]

orbit_map = {}
for relationship in relationships:
    center, orbit = relationship.split(')')
    orbit_map[orbit] = center

total_orbits = 0
for orbit in orbit_map:
    current_object = orbit
    while current_object in orbit_map:
        current_object = orbit_map[current_object]
        total_orbits += 1

print(total_orbits)",0.0
210,2019,6,2,no_error,"301
",301,,"with open('input.txt', 'r') as file:
    relationships = [line.strip() for line in file]

orbit_map = {}
for relationship in relationships:
    center, orbit = relationship.split(')')
    orbit_map[orbit] = center

def get_path_to_com(object):
    path = []
    current_object = object
    while current_object in orbit_map:
        current_object = orbit_map[current_object]
        path.append(current_object)
    return path

you_path = get_path_to_com('YOU')
san_path = get_path_to_com('SAN')

common_objects = set(you_path).intersection(set(san_path))

min_transfers = float('inf')
for object in common_objects:
    transfers = you_path.index(object) + san_path.index(object)
    min_transfers = min(min_transfers, transfers)

print(min_transfers)",0.0
211,2019,7,1,runtime_error,,77500,"Traceback (most recent call last):
  File ""/tmp/tmpceda_lfe/tmp.py"", line 143, in <module>
    max_output_signal = run_amplifiers(program)
  File ""/tmp/tmpceda_lfe/tmp.py"", line 133, in run_amplifiers
    input_signal = run_amplifier(program.copy(), phase, input_signal)
  File ""/tmp/tmpceda_lfe/tmp.py"", line 121, in run_amplifier
    execute_program()
  File ""/tmp/tmpceda_lfe/tmp.py"", line 50, in execute_program
    program[parameter] = phase_setting if phase_setting_used else input_signal
UnboundLocalError: local variable 'phase_setting_used' referenced before assignment
","def run_amplifiers(program):
    from itertools import permutations

    def run_amplifier(program, phase_setting, input_signal):
        def parse_instruction(instruction):
            opcode = int(instruction[-2:])
            modes = [int(mode) for mode in instruction[:-2][::-1]]
            return opcode, modes

        def get_parameter_value(parameter, mode):
            if mode == 0:
                return program[parameter]
            elif mode == 1:
                return parameter
            else:
                raise ValueError(f""Invalid parameter mode: {mode}"")

        def execute_program():
            nonlocal instruction_pointer, input_signal, output_signal

            while True:
                opcode, modes = parse_instruction(str(program[instruction_pointer]))
                if opcode == 1:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]
                    parameter3 = program[instruction_pointer + 3]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    program[parameter3] = value1 + value2

                    instruction_pointer += 4

                elif opcode == 2:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]
                    parameter3 = program[instruction_pointer + 3]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    program[parameter3] = value1 * value2

                    instruction_pointer += 4

                elif opcode == 3:
                    parameter = program[instruction_pointer + 1]

                    program[parameter] = phase_setting if phase_setting_used else input_signal
                    phase_setting_used = True

                    instruction_pointer += 2

                elif opcode == 4:
                    parameter = program[instruction_pointer + 1]

                    output_signal = get_parameter_value(parameter, modes[0])

                    instruction_pointer += 2
                    return output_signal

                elif opcode == 5:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    if value1 != 0:
                        instruction_pointer = value2
                    else:
                        instruction_pointer += 3

                elif opcode == 6:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    if value1 == 0:
                        instruction_pointer = value2
                    else:
                        instruction_pointer += 3

                elif opcode == 7:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]
                    parameter3 = program[instruction_pointer + 3]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    program[parameter3] = 1 if value1 < value2 else 0

                    instruction_pointer += 4

                elif opcode == 8:
                    parameter1 = program[instruction_pointer + 1]
                    parameter2 = program[instruction_pointer + 2]
                    parameter3 = program[instruction_pointer + 3]

                    value1 = get_parameter_value(parameter1, modes[0])
                    value2 = get_parameter_value(parameter2, modes[1])

                    program[parameter3] = 1 if value1 == value2 else 0

                    instruction_pointer += 4

                elif opcode == 99:
                    break

                else:
                    raise ValueError(f""Invalid opcode: {opcode}"")

        instruction_pointer = 0
        output_signal = None
        phase_setting_used = False

        execute_program()

        return output_signal

    program = [int(x) for x in program.split("","")]
    phase_settings = permutations(range(5))

    max_output_signal = float(""-inf"")

    for phase_setting in phase_settings:
        input_signal = 0
        for phase in phase_setting:
            input_signal = run_amplifier(program.copy(), phase, input_signal)

        max_output_signal = max(max_output_signal, input_signal)

    return max_output_signal


with open(""input.txt"", ""r"") as file:
    program = file.read()

max_output_signal = run_amplifiers(program)
print(max_output_signal)",0.0
212,2019,7,2,part1_failed,,22476942,,,
213,2019,8,1,no_error,"1742
",1742,,"
def find_fewest_zeros(input_str):
    width = 25
    height = 6
    layer_size = width * height
    num_layers = len(input_str) // layer_size

    min_zeros = float('inf')
    result = 0

    for i in range(num_layers):
        layer = input_str[i * layer_size: (i + 1) * layer_size]
        zeros = layer.count('0')
        if zeros < min_zeros:
            min_zeros = zeros
            ones = layer.count('1')
            twos = layer.count('2')
            result = ones * twos

    return result


if __name__ == ""__main__"":
    with open('input.txt', 'r') as file:
        input_str = file.read().strip()

    output = find_fewest_zeros(input_str)
    print(output)
",0.0
214,2019,8,2,wrong_output,"0110000110100011111001100
1001000010100011000010010
1000000010010101110010010
1011000010001001000011110
1001010010001001000010010
0111001100001001111010010
",GJYEA,,"
def decode_image(input_str):
    width = 25
    height = 6
    layer_size = width * height
    num_layers = len(input_str) // layer_size

    final_image = ['2'] * layer_size

    for i in range(num_layers):
        layer = input_str[i * layer_size: (i + 1) * layer_size]
        for j in range(layer_size):
            if final_image[j] == '2':
                final_image[j] = layer[j]

    return final_image


if __name__ == ""__main__"":
    with open('input.txt', 'r') as file:
        input_str = file.read().strip()

    decoded_image = decode_image(input_str)
    width = 25
    height = 6
    for i in range(height):
        row = decoded_image[i * width: (i + 1) * width]
        print(''.join(row))
",0.0
215,2019,9,1,runtime_error,,3780860499,"Traceback (most recent call last):
  File ""/tmp/tmpvesyhczq/tmp.py"", line 148, in <module>
    main()
  File ""/tmp/tmpvesyhczq/tmp.py"", line 143, in main
    boost_keycode = run_intcode_program(program)
  File ""/tmp/tmpvesyhczq/tmp.py"", line 35, in run_intcode_program
    set_value(mode3, parameter3, value1 + value2)
  File ""/tmp/tmpvesyhczq/tmp.py"", line 16, in set_value
    memory[parameter] = value
IndexError: list assignment index out of range
","def run_intcode_program(program):
    memory = program.copy()
    relative_base = 0
    position = 0

    def get_value(mode, parameter):
        if mode == 0:  # position mode
            return memory[parameter]
        elif mode == 1:  # immediate mode
            return parameter
        elif mode == 2:  # relative mode
            return memory[relative_base + parameter]

    def set_value(mode, parameter, value):
        if mode == 0:  # position mode
            memory[parameter] = value
        elif mode == 2:  # relative mode
            memory[relative_base + parameter] = value

    while True:
        instruction = str(memory[position]).rjust(5, '0')
        opcode = int(instruction[-2:])
        mode1 = int(instruction[2])
        mode2 = int(instruction[1])
        mode3 = int(instruction[0])

        if opcode == 1:  # addition
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]
            parameter3 = memory[position + 3]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            set_value(mode3, parameter3, value1 + value2)

            position += 4

        elif opcode == 2:  # multiplication
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]
            parameter3 = memory[position + 3]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            set_value(mode3, parameter3, value1 * value2)

            position += 4

        elif opcode == 3:  # input
            parameter1 = memory[position + 1]

            value = int(input(""Enter input: ""))
            set_value(mode1, parameter1, value)

            position += 2

        elif opcode == 4:  # output
            parameter1 = memory[position + 1]

            value = get_value(mode1, parameter1)
            print(""Output:"", value)

            position += 2

        elif opcode == 5:  # jump-if-true
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            if value1 != 0:
                position = value2
            else:
                position += 3

        elif opcode == 6:  # jump-if-false
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            if value1 == 0:
                position = value2
            else:
                position += 3

        elif opcode == 7:  # less than
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]
            parameter3 = memory[position + 3]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            if value1 < value2:
                set_value(mode3, parameter3, 1)
            else:
                set_value(mode3, parameter3, 0)

            position += 4

        elif opcode == 8:  # equals
            parameter1 = memory[position + 1]
            parameter2 = memory[position + 2]
            parameter3 = memory[position + 3]

            value1 = get_value(mode1, parameter1)
            value2 = get_value(mode2, parameter2)

            if value1 == value2:
                set_value(mode3, parameter3, 1)
            else:
                set_value(mode3, parameter3, 0)

            position += 4

        elif opcode == 9:  # adjust relative base
            parameter1 = memory[position + 1]

            value1 = get_value(mode1, parameter1)

            relative_base += value1

            position += 2

        elif opcode == 99:  # halt
            break

        else:
            raise ValueError(""Invalid opcode"")

    return memory[0]


def main():
    with open('input.txt', 'r') as file:
        program = list(map(int, file.readline().strip().split(',')))

    boost_keycode = run_intcode_program(program)
    print(""BOOST Keycode:"", boost_keycode)


if __name__ == '__main__':
    main()",0.0
216,2019,9,2,part1_failed,,33343,,,
217,2019,10,1,runtime_error,,309,"Traceback (most recent call last):
  File ""/tmp/tmpnxvpyor2/tmp.py"", line 54, in <module>
    print(findBestAsteroid(input_str))
  File ""/tmp/tmpnxvpyor2/tmp.py"", line 10, in findBestAsteroid
    num_asteroids = count_visible_asteroids(i, j, asteroid_map)
  File ""/tmp/tmpnxvpyor2/tmp.py"", line 25, in count_visible_asteroids
    if not is_obstructed(x, y, i, j, asteroid_map):
  File ""/tmp/tmpnxvpyor2/tmp.py"", line 34, in is_obstructed
    gcd = math.gcd(abs(dx), abs(dy))
NameError: name 'math' is not defined
","def findBestAsteroid(input):
    asteroid_map = [list(row) for row in input.split('\n')]

    max_asteroids = 0
    best_asteroid = None

    for i in range(len(asteroid_map)):
        for j in range(len(asteroid_map[0])):
            if asteroid_map[i][j] == '#':
                num_asteroids = count_visible_asteroids(i, j, asteroid_map)
                if num_asteroids > max_asteroids:
                    max_asteroids = num_asteroids
                    best_asteroid = (i, j)

    return max_asteroids

def count_visible_asteroids(x, y, asteroid_map):
    visible_asteroids = 0

    for i in range(len(asteroid_map)):
        for j in range(len(asteroid_map[0])):
            if asteroid_map[i][j] == '#':
                if i == x and j == y:
                    continue
                if not is_obstructed(x, y, i, j, asteroid_map):
                    visible_asteroids += 1

    return visible_asteroids

def is_obstructed(x1, y1, x2, y2, asteroid_map):
    dx = x2 - x1
    dy = y2 - y1

    gcd = math.gcd(abs(dx), abs(dy))
    dx //= gcd
    dy //= gcd

    x = x1 + dx
    y = y1 + dy

    while x != x2 or y != y2:
        if asteroid_map[x][y] == '#':
            return True
        x += dx
        y += dy

    return False

# Read input from file
with open('input.txt', 'r') as f:
    input_str = f.read()

# Call the function and print the result
print(findBestAsteroid(input_str))",0.0
218,2019,10,2,part1_failed,,416,,,
219,2019,11,1,runtime_error,,2336,"Traceback (most recent call last):
  File ""/tmp/tmp2kmt52cr/tmp.py"", line 107, in <module>
    painted_panels_count = run_intcode_program(program)
  File ""/tmp/tmp2kmt52cr/tmp.py"", line 31, in run_intcode_program
    parameters = get_parameters(2, modes)
  File ""/tmp/tmp2kmt52cr/tmp.py"", line 20, in get_parameters
    parameters.append(get_value(int(modes[-i]), program[pc + i]))
  File ""/tmp/tmp2kmt52cr/tmp.py"", line 4, in get_value
    return program[parameter]
IndexError: list index out of range
","def run_intcode_program(program):
    def get_value(mode, parameter):
        if mode == 0:
            return program[parameter]
        elif mode == 1:
            return parameter

    def set_value(mode, parameter, value):
        if mode == 0:
            program[parameter] = value

    def add_instruction(instruction):
        opcode = instruction % 100
        modes = str(instruction // 100).zfill(3)
        return opcode, modes

    def get_parameters(num_parameters, modes):
        parameters = []
        for i in range(1, num_parameters + 1):
            parameters.append(get_value(int(modes[-i]), program[pc + i]))
        return parameters

    pc = 0
    painted_panels = {}
    position = (0, 0)
    direction = (0, 1)

    while program[pc] != 99:
        opcode, modes = add_instruction(program[pc])
        if opcode == 1:
            parameters = get_parameters(2, modes)
            set_value(int(modes[-3]), program[pc + 3], parameters[0] + parameters[1])
            pc += 4
        elif opcode == 2:
            parameters = get_parameters(2, modes)
            set_value(int(modes[-3]), program[pc + 3], parameters[0] * parameters[1])
            pc += 4
        elif opcode == 3:
            color = painted_panels.get(position, 0)
            set_value(int(modes[-1]), program[pc + 1], color)
            pc += 2
        elif opcode == 4:
            parameters = get_parameters(1, modes)
            painted_panels[position] = parameters[0]
            pc += 2
        elif opcode == 5:
            parameters = get_parameters(2, modes)
            if parameters[0] != 0:
                pc = parameters[1]
            else:
                pc += 3
        elif opcode == 6:
            parameters = get_parameters(2, modes)
            if parameters[0] == 0:
                pc = parameters[1]
            else:
                pc += 3
        elif opcode == 7:
            parameters = get_parameters(2, modes)
            if parameters[0] < parameters[1]:
                set_value(int(modes[-3]), program[pc + 3], 1)
            else:
                set_value(int(modes[-3]), program[pc + 3], 0)
            pc += 4
        elif opcode == 8:
            parameters = get_parameters(2, modes)
            if parameters[0] == parameters[1]:
                set_value(int(modes[-3]), program[pc + 3], 1)
            else:
                set_value(int(modes[-3]), program[pc + 3], 0)
            pc += 4
        elif opcode == 9:
            parameters = get_parameters(1, modes)
            position, direction = move_robot(position, direction, parameters[0])
            pc += 2

    return len(painted_panels)


def move_robot(position, direction, turn):
    if turn == 0:  # Turn left
        if direction == (0, 1):
            direction = (-1, 0)
        elif direction == (-1, 0):
            direction = (0, -1)
        elif direction == (0, -1):
            direction = (1, 0)
        elif direction == (1, 0):
            direction = (0, 1)
    elif turn == 1:  # Turn right
        if direction == (0, 1):
            direction = (1, 0)
        elif direction == (1, 0):
            direction = (0, -1)
        elif direction == (0, -1):
            direction = (-1, 0)
        elif direction == (-1, 0):
            direction = (0, 1)

    new_position = (position[0] + direction[0], position[1] + direction[1])
    return new_position, direction


with open('input.txt', 'r') as file:
    program = list(map(int, file.read().strip().split(',')))

painted_panels_count = run_intcode_program(program)
print(painted_panels_count)",0.0
220,2019,11,2,part1_failed,,UZAEKBLP,,,
221,2019,12,1,runtime_error,,6220,"Traceback (most recent call last):
  File ""/tmp/tmppr1hdgr4/tmp.py"", line 48, in <module>
    positions = [tuple(map(int, line.strip()[1:-1].split(', '))) for line in file.readlines()]
  File ""/tmp/tmppr1hdgr4/tmp.py"", line 48, in <listcomp>
    positions = [tuple(map(int, line.strip()[1:-1].split(', '))) for line in file.readlines()]
ValueError: invalid literal for int() with base 10: 'x=-4'
","from typing import List, Tuple

def simulateMotion(moons: List[Tuple[int, int, int]], steps: int) -> int:
    # Initialize velocities
    velocities = [(0, 0, 0) for _ in range(len(moons))]

    for _ in range(steps):
        # Apply gravity
        for i in range(len(moons)):
            for j in range(i+1, len(moons)):
                moon1 = moons[i]
                moon2 = moons[j]
                velocity1 = velocities[i]
                velocity2 = velocities[j]

                # Update velocities based on gravity
                for k in range(3):
                    if moon1[k] < moon2[k]:
                        velocity1 = (velocity1[0] + 1, velocity1[1], velocity1[2])
                        velocity2 = (velocity2[0] - 1, velocity2[1], velocity2[2])
                    elif moon1[k] > moon2[k]:
                        velocity1 = (velocity1[0] - 1, velocity1[1], velocity1[2])
                        velocity2 = (velocity2[0] + 1, velocity2[1], velocity2[2])

                velocities[i] = velocity1
                velocities[j] = velocity2

        # Apply velocity
        for i in range(len(moons)):
            moon = moons[i]
            velocity = velocities[i]
            moon = (moon[0] + velocity[0], moon[1] + velocity[1], moon[2] + velocity[2])
            moons[i] = moon

    # Calculate total energy
    total_energy = 0
    for i in range(len(moons)):
        moon = moons[i]
        velocity = velocities[i]
        potential_energy = sum(abs(coord) for coord in moon)
        kinetic_energy = sum(abs(coord) for coord in velocity)
        total_energy += potential_energy * kinetic_energy

    return total_energy

# Read input from file
with open('input.txt', 'r') as file:
    positions = [tuple(map(int, line.strip()[1:-1].split(', '))) for line in file.readlines()]

# Simulate motion for 1000 steps
result = simulateMotion(positions, 1000)
print(result)",0.0
222,2019,12,2,part1_failed,,548525804273976,,,
223,2019,13,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmpis7cm5bi/tmp.py"", line 104, in <module>
    print(run_program(input_program))
  File ""/tmp/tmpis7cm5bi/tmp.py"", line 35, in run_program
    set_value(program[pc + 3], mode3, param1 + param2)
  File ""/tmp/tmpis7cm5bi/tmp.py"", line 24, in set_value
    program[relative_base + param] = value
IndexError: list assignment index out of range
","import sys

def run_program(program):
    program = list(map(int, program.split(',')))
    program[0] = 2  # Set the memory address
    pc = 0  # Program counter
    relative_base = 0
    outputs = []
    grid = {}
    score = 0

    def get_value(param, mode):
        if mode == 0:  # Position mode
            return program[param]
        elif mode == 1:  # Immediate mode
            return param
        elif mode == 2:  # Relative mode
            return program[relative_base + param]

    def set_value(param, mode, value):
        if mode == 0:  # Position mode
            program[param] = value
        elif mode == 2:  # Relative mode
            program[relative_base + param] = value

    while True:
        opcode = program[pc] % 100
        mode1 = (program[pc] // 100) % 10
        mode2 = (program[pc] // 1000) % 10
        mode3 = (program[pc] // 10000) % 10

        if opcode == 1:  # Addition
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            set_value(program[pc + 3], mode3, param1 + param2)
            pc += 4
        elif opcode == 2:  # Multiplication
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            set_value(program[pc + 3], mode3, param1 * param2)
            pc += 4
        elif opcode == 3:  # Input
            joystick = 0
            for tile in grid:
                if grid[tile] == 3:  # Find the paddle tile
                    paddle_x = tile[0]
                elif grid[tile] == 4:  # Find the ball tile
                    ball_x = tile[0]
            if paddle_x < ball_x:
                joystick = 1  # Move paddle right
            elif paddle_x > ball_x:
                joystick = -1  # Move paddle left
            set_value(program[pc + 1], mode1, joystick)
            pc += 2
        elif opcode == 4:  # Output
            output = get_value(program[pc + 1], mode1)
            outputs.append(output)
            if len(outputs) == 3:
                x, y, tile_id = outputs
                if x == -1 and y == 0:  # Update score
                    score = tile_id
                else:
                    grid[(x, y)] = tile_id
                outputs = []
            pc += 2
        elif opcode == 5:  # Jump if true
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            if param1 != 0:
                pc = param2
            else:
                pc += 3
        elif opcode == 6:  # Jump if false
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            if param1 == 0:
                pc = param2
            else:
                pc += 3
        elif opcode == 7:  # Less than
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            set_value(program[pc + 3], mode3, int(param1 < param2))
            pc += 4
        elif opcode == 8:  # Equals
            param1 = get_value(program[pc + 1], mode1)
            param2 = get_value(program[pc + 2], mode2)
            set_value(program[pc + 3], mode3, int(param1 == param2))
            pc += 4
        elif opcode == 9:  # Adjust relative base
            param1 = get_value(program[pc + 1], mode1)
            relative_base += param1
            pc += 2
        elif opcode == 99:  # Halt
            break

    return len([tile for tile in grid.values() if tile == 2])

# Read the input from file
with open('input.txt', 'r') as file:
    input_program = file.readline().strip()

# Run the program and print the number of block tiles
print(run_program(input_program))",0.0
224,2019,13,2,part1_failed,,12535,,,
225,2019,14,1,no_error,"532506
",532506,,"from collections import defaultdict

def parse_input(filename):
    reactions = {}
    with open(filename, 'r') as file:
        for line in file:
            inputs, output = line.strip().split(' => ')
            input_chemicals = []
            for input in inputs.split(', '):
                quantity, chemical = input.split(' ')
                input_chemicals.append((int(quantity), chemical))
            output_quantity, output_chemical = output.split(' ')
            reactions[output_chemical] = (int(output_quantity), input_chemicals)
    return reactions

def calculate_ore_required(reactions):
    def calculate_ore_needed(chemical, quantity, surplus):
        if chemical == 'ORE':
            return quantity

        if surplus[chemical] >= quantity:
            surplus[chemical] -= quantity
            return 0

        quantity -= surplus[chemical]
        surplus[chemical] = 0

        reaction_quantity, input_chemicals = reactions[chemical]
        reaction_count = (quantity + reaction_quantity - 1) // reaction_quantity
        ore_needed = 0

        for input_quantity, input_chemical in input_chemicals:
            ore_needed += calculate_ore_needed(input_chemical, input_quantity * reaction_count, surplus)

        surplus[chemical] += reaction_count * reaction_quantity - quantity

        return ore_needed

    surplus = defaultdict(int)
    return calculate_ore_needed('FUEL', 1, surplus)

reactions = parse_input('input.txt')
ore_required = calculate_ore_required(reactions)
print(ore_required)",0.0
226,2019,14,2,no_error,"2595245
",2595245,,"from collections import defaultdict

def parse_input(filename):
    reactions = {}
    with open(filename, 'r') as file:
        for line in file:
            inputs, output = line.strip().split(' => ')
            input_chemicals = []
            for input in inputs.split(', '):
                quantity, chemical = input.split(' ')
                input_chemicals.append((int(quantity), chemical))
            output_quantity, output_chemical = output.split(' ')
            reactions[output_chemical] = (int(output_quantity), input_chemicals)
    return reactions

def calculate_fuel_produced(reactions, ore_available):
    def calculate_fuel_possible(ore, surplus):
        low, high = 1, ore
        while low < high:
            mid = (low + high + 1) // 2
            surplus.clear()
            if calculate_ore_needed('FUEL', mid, surplus) <= ore:
                low = mid
            else:
                high = mid - 1
        return low

    def calculate_ore_needed(chemical, quantity, surplus):
        if chemical == 'ORE':
            return quantity

        if surplus[chemical] >= quantity:
            surplus[chemical] -= quantity
            return 0

        quantity -= surplus[chemical]
        surplus[chemical] = 0

        reaction_quantity, input_chemicals = reactions[chemical]
        reaction_count = (quantity + reaction_quantity - 1) // reaction_quantity
        ore_needed = 0

        for input_quantity, input_chemical in input_chemicals:
            ore_needed += calculate_ore_needed(input_chemical, input_quantity * reaction_count, surplus)

        surplus[chemical] += reaction_count * reaction_quantity - quantity

        return ore_needed

    surplus = defaultdict(int)
    return calculate_fuel_possible(ore_available, surplus)

reactions = parse_input('input.txt')
ore_available = 1000000000000
fuel_produced = calculate_fuel_produced(reactions, ore_available)
print(fuel_produced)",0.0
227,2019,15,1,runtime_error,,300,"Traceback (most recent call last):
  File ""/tmp/tmpgtgvfwy4/tmp.py"", line 140, in <module>
    result = explore(program)
  File ""/tmp/tmpgtgvfwy4/tmp.py"", line 133, in explore
    steps, oxygen_system_position = bfs(position)
ValueError: too many values to unpack (expected 2)
","import itertools

def run_intcode_program(program):
    memory = program[:]
    pc = 0
    relative_base = 0

    def get_value(param, mode):
        if mode == 0:
            return memory[param]
        elif mode == 1:
            return param
        elif mode == 2:
            return memory[relative_base + param]
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    def get_address(param, mode):
        if mode == 0:
            return param
        elif mode == 2:
            return relative_base + param
        else:
            raise ValueError(f""Invalid parameter mode: {mode}"")

    while True:
        opcode = memory[pc] % 100
        modes = str(memory[pc])[:-2].zfill(3)[::-1]

        if opcode == 1:  # add
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            address = get_address(memory[pc + 3], int(modes[2]))
            memory[address] = param1 + param2
            pc += 4

        elif opcode == 2:  # multiply
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            address = get_address(memory[pc + 3], int(modes[2]))
            memory[address] = param1 * param2
            pc += 4

        elif opcode == 3:  # input
            address = get_address(memory[pc + 1], int(modes[0]))
            memory[address] = yield
            pc += 2

        elif opcode == 4:  # output
            param = get_value(memory[pc + 1], int(modes[0]))
            yield param
            pc += 2

        elif opcode == 5:  # jump-if-true
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            if param1 != 0:
                pc = param2
            else:
                pc += 3

        elif opcode == 6:  # jump-if-false
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            if param1 == 0:
                pc = param2
            else:
                pc += 3

        elif opcode == 7:  # less than
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            address = get_address(memory[pc + 3], int(modes[2]))
            memory[address] = int(param1 < param2)
            pc += 4

        elif opcode == 8:  # equals
            param1 = get_value(memory[pc + 1], int(modes[0]))
            param2 = get_value(memory[pc + 2], int(modes[1]))
            address = get_address(memory[pc + 3], int(modes[2]))
            memory[address] = int(param1 == param2)
            pc += 4

        elif opcode == 9:  # adjust relative base
            param = get_value(memory[pc + 1], int(modes[0]))
            relative_base += param
            pc += 2

        elif opcode == 99:  # halt
            return

        else:
            raise ValueError(f""Invalid opcode: {opcode}"")

def explore(program):
    directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]
    reverse_directions = [1, 0, 3, 2]

    def move(position, direction):
        return (position[0] + directions[direction][0], position[1] + directions[direction][1])

    def opposite_direction(direction):
        return reverse_directions[direction]

    def get_neighbours(position):
        return [(move(position, direction), direction) for direction in range(4)]

    def bfs(start):
        queue = [(start, 0)]
        visited = set()
        oxygen_system_position = None

        while queue:
            position, steps = queue.pop(0)
            visited.add(position)

            for neighbour, direction in get_neighbours(position):
                if neighbour not in visited:
                    output = yield direction
                    if output == 0:
                        continue
                    elif output == 2:
                        oxygen_system_position = neighbour
                    queue.append((neighbour, steps + 1))

        return steps, oxygen_system_position

    program = program[:]
    computer = run_intcode_program(program)
    next(computer)

    position = (0, 0)
    steps, oxygen_system_position = bfs(position)

    return steps

with open('input.txt', 'r') as f:
    program = list(map(int, f.read().strip().split(',')))

result = explore(program)
print(result)",0.0
228,2019,15,2,part1_failed,,312,,,
229,2019,16,1,no_error,68317988,68317988,,"# Implementation of Flawed Frequency Transmission algorithm (FFT)

def fft_algorithm(signal, phases):
    pattern = [0, 1, 0, -1]
    
    for _ in range(phases):
        output = []
        
        for i in range(len(signal)):
            sum_val = 0
            
            for j in range(len(signal)):
                pattern_index = ((j + 1) // (i + 1)) % len(pattern)
                sum_val += signal[j] * pattern[pattern_index]
            
            output.append(abs(sum_val) % 10)
        
        signal = output
    
    return signal

# Read input from file
with open('input.txt', 'r') as file:
    input_signal = file.read().strip()

# Convert input string to list of integers
signal = [int(digit) for digit in input_signal]

# Run FFT algorithm for 100 phases
result = fft_algorithm(signal, 100)

# Print the first eight digits of the final output list
print(""First eight digits of the final output list:"", ''.join(map(str, result[:8])))",0.0
230,2019,16,2,timeout_error,,53850800,TIMEOUT,"# Implementation of Flawed Frequency Transmission algorithm (FFT)

def fft_algorithm(signal, phases):
    pattern = [0, 1, 0, -1]
    
    for _ in range(phases):
        output = []
        
        for i in range(len(signal)):
            sum_val = 0
            
            for j in range(len(signal)):
                pattern_index = ((j + 1) // (i + 1)) % len(pattern)
                sum_val += signal[j] * pattern[pattern_index]
            
            output.append(abs(sum_val) % 10)
        
        signal = output
    
    return signal

# Read input from file
with open('input.txt', 'r') as file:
    input_signal = file.read().strip()

# Convert input string to list of integers
signal = [int(digit) for digit in input_signal]

# Determine the message offset from the first seven digits of the initial input signal
offset = int(''.join(map(str, signal[:7])))

# Repeat the signal 10000 times
signal = signal * 10000

# Extract the relevant portion of the signal based on the message offset
relevant_signal = signal[offset:]

# Run FFT algorithm for 100 phases on the relevant portion of the signal
result = fft_algorithm(relevant_signal, 100)

# Extract the eight-digit message from the final output list
message = ''.join(map(str, result[:8]))

# Print the eight-digit message
print(""Eight-digit message embedded in the final output list:"", message)",0.0
231,2019,17,1,wrong_output,"0
",9876,,"def find_intersections(view):
    scaffold = []
    robot = None
    width = len(view[0])
    height = len(view)

    for y in range(height):
        row = []
        for x in range(width):
            char = view[y][x]
            if char == '#':
                row.append((x, y))
            elif char in ['^', 'v', '<', '>']:
                robot = (x, y, char)
        scaffold.append(row)

    intersections = []
    for y in range(1, height - 1):
        for x in range(1, width - 1):
            if (x, y) in scaffold[y] and (x, y) in scaffold[y - 1] and (x, y) in scaffold[y + 1] and (x, y) in scaffold[y][x - 1] and (x, y) in scaffold[y][x + 1]:
                intersections.append((x, y))

    alignment_parameters = sum([x * y for x, y in intersections])

    return alignment_parameters

def main():
    with open('input.txt', 'r') as f:
        view = [list(line.strip()) for line in f]

    alignment_parameters = find_intersections(view)
    print(alignment_parameters)

if __name__ == '__main__':
    main()",0.0
232,2019,17,2,part1_failed,,1234055,,,
233,2019,18,1,runtime_error,,6316,"Traceback (most recent call last):
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 70, in <module>
    shortest_path = find_shortest_path(vault_map)
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 61, in find_shortest_path
    shortest_path = dfs(entrance_pos, set())
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 56, in dfs
    distance = 1 + dfs(new_pos, new_keys_collected)
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 56, in dfs
    distance = 1 + dfs(new_pos, new_keys_collected)
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 56, in dfs
    distance = 1 + dfs(new_pos, new_keys_collected)
  [Previous line repeated 993 more times]
  File ""/tmp/tmp7e6r5c7c/tmp.py"", line 48, in dfs
    if neighbor in doors and neighbor.lower() not in keys_collected:
RecursionError: maximum recursion depth exceeded in comparison
","def find_shortest_path(vault_map):
    # Find the position of the entrance
    for i in range(len(vault_map)):
        for j in range(len(vault_map[i])):
            if vault_map[i][j] == '@':
                entrance_pos = (i, j)
                break
    
    # Find the keys in the map
    keys = []
    for i in range(len(vault_map)):
        for j in range(len(vault_map[i])):
            if vault_map[i][j].islower():
                keys.append((i, j))
    
    # Find the doors in the map
    doors = []
    for i in range(len(vault_map)):
        for j in range(len(vault_map[i])):
            if vault_map[i][j].isupper():
                doors.append((i, j))
    
    # Create a graph representation of the vault
    graph = {}
    for i in range(len(vault_map)):
        for j in range(len(vault_map[i])):
            if vault_map[i][j] != '#':
                neighbors = []
                if i > 0 and vault_map[i-1][j] != '#':
                    neighbors.append((i-1, j))
                if i < len(vault_map)-1 and vault_map[i+1][j] != '#':
                    neighbors.append((i+1, j))
                if j > 0 and vault_map[i][j-1] != '#':
                    neighbors.append((i, j-1))
                if j < len(vault_map[i])-1 and vault_map[i][j+1] != '#':
                    neighbors.append((i, j+1))
                graph[(i, j)] = neighbors
    
    # Find the shortest path to collect all the keys
    def dfs(current_pos, keys_collected):
        if len(keys_collected) == len(keys):
            return 0
        
        min_distance = float('inf')
        for neighbor in graph[current_pos]:
            if neighbor in keys_collected:
                continue
            if neighbor in doors and neighbor.lower() not in keys_collected:
                continue
            
            new_pos = neighbor
            new_keys_collected = keys_collected.copy()
            if neighbor in keys:
                new_keys_collected.add(neighbor)
            
            distance = 1 + dfs(new_pos, new_keys_collected)
            min_distance = min(min_distance, distance)
        
        return min_distance
    
    shortest_path = dfs(entrance_pos, set())
    
    return shortest_path

# Read the input from the file
with open('input.txt', 'r') as file:
    vault_map = [list(line.strip()) for line in file]

# Find the shortest path
shortest_path = find_shortest_path(vault_map)

# Print the result
print(shortest_path)",0.0
234,2019,18,2,part1_failed,,1648,,,
235,2019,19,1,runtime_error,,150,"Traceback (most recent call last):
  File ""/tmp/tmpygy5127c/tmp.py"", line 2, in <module>
    from intcode import IntcodeComputer
ModuleNotFoundError: No module named 'intcode'
","import itertools
from intcode import IntcodeComputer

def is_affected(program, x, y):
    computer = IntcodeComputer(program)
    computer.input_queue.extend([x, y])
    computer.run()
    return computer.output_queue.pop()

def count_affected_points(program, min_x, max_x, min_y, max_y):
    count = 0
    for x, y in itertools.product(range(min_x, max_x + 1), range(min_y, max_y + 1)):
        if is_affected(program, x, y):
            count += 1
    return count

def parse_input(input_string):
    return [int(x) for x in input_string.strip().split(',')]

def main():
    with open('input.txt', 'r') as f:
        input_string = f.read().strip()
    program = parse_input(input_string)
    min_x = 0
    max_x = 49
    min_y = 0
    max_y = 49
    count = count_affected_points(program, min_x, max_x, min_y, max_y)
    print(count)

if __name__ == '__main__':
    main()",0.0
236,2019,19,2,part1_failed,,12201460,,,
237,2019,20,1,wrong_output,"0
",608,,"from collections import deque

def find_shortest_path(maze):
    # Find the start and end positions
    start_pos = None
    end_pos = None
    for i in range(len(maze)):
        for j in range(len(maze[0])):
            if maze[i][j] == 'AA':
                start_pos = (i, j)
            elif maze[i][j] == 'ZZ':
                end_pos = (i, j)
    
    # Create a queue for BFS and a visited set
    queue = deque([(start_pos, 0)])
    visited = set([start_pos])
    
    # Define the four possible directions
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    
    # BFS to find the shortest path
    while queue:
        current_pos, steps = queue.popleft()
        
        # Check if we reached the end position
        if current_pos == end_pos:
            return steps
        
        # Get the current row and column
        current_row, current_col = current_pos
        
        # Check the four possible directions
        for direction in directions:
            new_row = current_row + direction[0]
            new_col = current_col + direction[1]
            
            # Check if the new position is within the maze
            if 0 <= new_row < len(maze) and 0 <= new_col < len(maze[0]):
                # Check if the new position is a valid move
                if maze[new_row][new_col] != '#':
                    # Check if the new position is a portal
                    if maze[new_row][new_col].isupper():
                        # Find the other portal with the same label
                        for i in range(len(maze)):
                            for j in range(len(maze[0])):
                                if maze[i][j] == maze[new_row][new_col] and (i, j) != (new_row, new_col):
                                    new_pos = (i, j)
                                    break
                        # Check if the other portal has been visited
                        if new_pos not in visited:
                            queue.append((new_pos, steps + 1))
                            visited.add(new_pos)
                    else:
                        new_pos = (new_row, new_col)
                        # Check if the new position has been visited
                        if new_pos not in visited:
                            queue.append((new_pos, steps + 1))
                            visited.add(new_pos)
    
    # If there is no path from start to end, return -1
    return -1

# Read the input maze from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()
    maze = [list(line.strip()) for line in lines]

# Find the shortest path from start to end
shortest_path = find_shortest_path(maze)

# Print the result
print(shortest_path)",0.0
238,2019,20,2,part1_failed,,6706,,,
239,2019,21,1,timeout_error,,19358688,TIMEOUT,"
def parse_input():
    with open('input.txt', 'r') as f:
        return [int(x) for x in f.read().split(',')]

def run_intcode_program(program):
    memory = program.copy()
    ip = 0
    relative_base = 0
    
    def read_memory(address):
        if address >= len(memory):
            memory.extend([0] * (address - len(memory) + 1))
        return memory[address]
    
    def write_memory(address, value):
        if address >= len(memory):
            memory.extend([0] * (address - len(memory) + 1))
        memory[address] = value
    
    def parse_opcode(opcode):
        opcode_str = str(opcode).rjust(5, '0')
        return (int(opcode_str[-2:]), int(opcode_str[-3]), int(opcode_str[-4]), int(opcode_str[-5]))
    
    def get_parameter_value(parameter, mode):
        if mode == 0:
            return read_memory(parameter)
        elif mode == 1:
            return parameter
        elif mode == 2:
            return read_memory(relative_base + parameter)
    
    def get_address(parameter, mode):
        if mode == 0:
            return parameter
        elif mode == 2:
            return relative_base + parameter
    
    while True:
        opcode, mode1, mode2, mode3 = parse_opcode(read_memory(ip))
        
        if opcode == 1:  # Add
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            param3 = read_memory(ip + 3)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            address = get_address(param3, mode3)
            
            write_memory(address, value1 + value2)
            ip += 4
        
        elif opcode == 2:  # Multiply
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            param3 = read_memory(ip + 3)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            address = get_address(param3, mode3)
            
            write_memory(address, value1 * value2)
            ip += 4
        
        elif opcode == 3:  # Input
            param1 = read_memory(ip + 1)
            
            value = int(input())
            address = get_address(param1, mode1)
            
            write_memory(address, value)
            ip += 2
        
        elif opcode == 4:  # Output
            param1 = read_memory(ip + 1)
            
            value = get_parameter_value(param1, mode1)
            print(value)
            ip += 2
        
        elif opcode == 5:  # Jump if True
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            
            if value1 != 0:
                ip = value2
            else:
                ip += 3
        
        elif opcode == 6:  # Jump if False
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            
            if value1 == 0:
                ip = value2
            else:
                ip += 3
        
        elif opcode == 7:  # Less Than
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            param3 = read_memory(ip + 3)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            address = get_address(param3, mode3)
            
            write_memory(address, 1 if value1 < value2 else 0)
            ip += 4
        
        elif opcode == 8:  # Equals
            param1 = read_memory(ip + 1)
            param2 = read_memory(ip + 2)
            param3 = read_memory(ip + 3)
            
            value1 = get_parameter_value(param1, mode1)
            value2 = get_parameter_value(param2, mode2)
            address = get_address(param3, mode3)
            
            write_memory(address, 1 if value1 == value2 else 0)
            ip += 4
        
        elif opcode == 9:  # Adjust Relative Base
            param1 = read_memory(ip + 1)
            
            value = get_parameter_value(param1, mode1)
            relative_base += value
            ip += 2
        
        elif opcode == 99:  # Halt
            break
    return memory

program = parse_input()
run_intcode_program(program)
",0.0
240,2019,21,2,part1_failed,,1141236756,,,
241,2019,22,1,no_error,"1252
",1252,,"# Read input from file
with open('input.txt', 'r') as f:
    techniques = f.read().splitlines()

# Variables to keep track of deck size and card position
deck_size = 10007
card_position = 2019

# Perform shuffling techniques
for technique in techniques:
    if technique == ""deal into new stack"":
        card_position = deck_size - card_position - 1
    elif technique.startswith(""cut""):
        n = int(technique.split()[1])
        card_position = (card_position - n) % deck_size
    elif technique.startswith(""deal with increment""):
        n = int(technique.split()[3])
        card_position = (card_position * n) % deck_size

# Print the final position of card 2019
print(card_position)",0.0
242,2019,22,2,wrong_output,"115553830488133
",46116012647793,,"# Read input from file
with open('input.txt', 'r') as f:
    techniques = f.read().splitlines()

# Function to perform modular exponentiation
def modular_exponentiation(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent = exponent // 2
    return result

# Variables to keep track of deck size and card position
deck_size = 119315717514047
card_position = 2020

# Perform the complete shuffle process
for technique in techniques:
    if technique == ""deal into new stack"":
        card_position = deck_size - card_position - 1
    elif technique.startswith(""cut""):
        n = int(technique.split()[1])
        card_position = (card_position + n) % deck_size
    elif technique.startswith(""deal with increment""):
        n = int(technique.split()[3])
        card_position = (card_position * modular_exponentiation(n, deck_size-2, deck_size)) % deck_size

# Perform the shuffle process 101741582076661 times
a = (modular_exponentiation(card_position, 101741582076661, deck_size) * (1 - modular_exponentiation(modular_exponentiation(n, deck_size-2, deck_size), 101741582076661, deck_size))) % deck_size
b = (1 - modular_exponentiation(modular_exponentiation(n, deck_size-2, deck_size), 101741582076661, deck_size)) % deck_size

# Calculate the number on the card that ends up in position 2020
result = (a * modular_exponentiation(b, deck_size-2, deck_size)) % deck_size

# Print the result
print(result)",0.0
243,2019,23,1,timeout_error,,24922,TIMEOUT,"
import queue

def run_computer(program):
    input_queue = queue.Queue()
    output_queue = queue.Queue()
    prog_pointer = 0
    relative_base = 0
    program += [0] * 10000  # Extend memory

    def get_value(param, mode):
        if mode == 0:  # Position mode
            return program[param]
        elif mode == 1:  # Immediate mode
            return param
        elif mode == 2:  # Relative mode
            return program[param + relative_base]

    def set_value(param, mode, value):
        if mode == 0:  # Position mode
            program[param] = value
        elif mode == 2:  # Relative mode
            program[param + relative_base] = value

    while True:
        instruction = str(program[prog_pointer]).zfill(5)
        opcode = int(instruction[-2:])
        param_modes = [int(mode) for mode in instruction[:-2]][::-1]

        if opcode == 1:  # Add
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            param3 = program[prog_pointer + 3]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            set_value(param3, param_modes[2], value1 + value2)
            prog_pointer += 4
        elif opcode == 2:  # Multiply
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            param3 = program[prog_pointer + 3]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            set_value(param3, param_modes[2], value1 * value2)
            prog_pointer += 4
        elif opcode == 3:  # Input
            param1 = program[prog_pointer + 1]
            input_value = input_queue.get()
            set_value(param1, param_modes[0], input_value)
            prog_pointer += 2
        elif opcode == 4:  # Output
            param1 = program[prog_pointer + 1]
            output_value = get_value(param1, param_modes[0])
            output_queue.put(output_value)
            prog_pointer += 2
        elif opcode == 5:  # Jump if true
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            if value1 != 0:
                prog_pointer = value2
            else:
                prog_pointer += 3
        elif opcode == 6:  # Jump if false
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            if value1 == 0:
                prog_pointer = value2
            else:
                prog_pointer += 3
        elif opcode == 7:  # Less than
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            param3 = program[prog_pointer + 3]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            if value1 < value2:
                set_value(param3, param_modes[2], 1)
            else:
                set_value(param3, param_modes[2], 0)
            prog_pointer += 4
        elif opcode == 8:  # Equals
            param1 = program[prog_pointer + 1]
            param2 = program[prog_pointer + 2]
            param3 = program[prog_pointer + 3]
            value1 = get_value(param1, param_modes[0])
            value2 = get_value(param2, param_modes[1])
            if value1 == value2:
                set_value(param3, param_modes[2], 1)
            else:
                set_value(param3, param_modes[2], 0)
            prog_pointer += 4
        elif opcode == 9:  # Adjust relative base
            param1 = program[prog_pointer + 1]
            value1 = get_value(param1, param_modes[0])
            relative_base += value1
            prog_pointer += 2
        elif opcode == 99:  # Halt
            break

    return output_queue

# Read input from file
with open('input.txt', 'r') as f:
    input_str = f.read().strip()

# Parse input
program = list(map(int, input_str.split(',')))

# Initialize computers
computers = []
for _ in range(50):
    computers.append(run_computer(program.copy()))

# Send initial network addresses
for i, computer in enumerate(computers):
    computer.put(i)

# Run the network
nat_packet = None
last_nat_y = None
waiting_for_input = [False] * 50
while True:
    for i, computer in enumerate(computers):
        if computer.empty():
            computer.put(-1)  # Send -1 if no packet is available
            waiting_for_input[i] = True
        else:
            waiting_for_input[i] = False
            dest_address = computer.get()
            x_value = computer.get()
            y_value = computer.get()
            if dest_address == 255:
                nat_packet = (x_value, y_value)
            else:
                computers[dest_address].put(x_value)
                computers[dest_address].put(y_value)

    if all(waiting_for_input) and nat_packet:
        computers[0].put(nat_packet[0])
        computers[0].put(nat_packet[1])
        if nat_packet[1] == last_nat_y:
            print(nat_packet[1])
            break
        last_nat_y = nat_packet[1]
",0.0
244,2019,23,2,part1_failed,,19478,,,
245,2019,24,1,wrong_output,"2736374
",1151290,,"
# Step 1: Read the input grid
with open('input.txt', 'r') as file:
    grid = [list(line.strip()) for line in file]

# Step 2: Initialize an empty set to store the layouts
layouts = set()

# Step 3: Initialize the biodiversity rating
biodiversity_rating = 0

# Step 4: Simulate the minutes until a layout appears twice
minute = 0
while True:
    # Step 4a: Check if the current layout is already in the set
    current_layout = tuple(''.join(row) for row in grid)  # Convert grid to a tuple of strings for hashability
    if current_layout in layouts:
        break
    
    # Step 4b: Add the current layout to the set
    layouts.add(current_layout)
    
    # Step 4c: Update the grid based on the rules
    new_grid = [['.' for _ in range(5)] for _ in range(5)]
    for i in range(5):
        for j in range(5):
            bug_count = 0
            if i > 0 and grid[i - 1][j] == '#':  # Check top cell
                bug_count += 1
            if i < 4 and grid[i + 1][j] == '#':  # Check bottom cell
                bug_count += 1
            if j > 0 and grid[i][j - 1] == '#':  # Check left cell
                bug_count += 1
            if j < 4 and grid[i][j + 1] == '#':  # Check right cell
                bug_count += 1
            
            if grid[i][j] == '#' and bug_count != 1:
                new_grid[i][j] = '.'  # Mark bug as empty space
            elif grid[i][j] == '.' and bug_count in (1, 2):
                new_grid[i][j] = '#'  # Mark empty space as bug
    
    grid = new_grid
    minute += 1

# Step 5: Calculate the biodiversity rating for the first layout that appears twice
for i in range(5):
    for j in range(5):
        if grid[i][j] == '#':
            biodiversity_rating += 2 ** (i * 5 + j)

# Step 6: Print the biodiversity rating
print(biodiversity_rating)
",0.0
246,2019,24,2,part1_failed,,1953,,,
247,2019,25,1,runtime_error,,25166400,"Traceback (most recent call last):
  File ""/tmp/tmpjrvh_eru/tmp.py"", line 95, in <module>
    computer.run([])
  File ""/tmp/tmpjrvh_eru/tmp.py"", line 44, in run
    self.set_parameter(mode3, 3, param1 * param2)
  File ""/tmp/tmpjrvh_eru/tmp.py"", line 25, in set_parameter
    self.program[self.relative_base + self.program[self.pointer + offset]] = value
IndexError: list assignment index out of range
","# Read the input from the file
with open('input.txt', 'r') as f:
    program = list(map(int, f.read().strip().split(',')))

# Define the Intcode computer class
class IntcodeComputer:
    def __init__(self, program):
        self.program = program
        self.pointer = 0
        self.relative_base = 0
        self.outputs = []

    def get_parameter(self, mode, offset):
        if mode == 0:  # Position mode
            return self.program[self.program[self.pointer + offset]]
        elif mode == 1:  # Immediate mode
            return self.program[self.pointer + offset]
        elif mode == 2:  # Relative mode
            return self.program[self.relative_base + self.program[self.pointer + offset]]

    def set_parameter(self, mode, offset, value):
        if mode == 0:  # Position mode
            self.program[self.program[self.pointer + offset]] = value
        elif mode == 2:  # Relative mode
            self.program[self.relative_base + self.program[self.pointer + offset]] = value

    def run(self, inputs):
        self.outputs = []

        while True:
            opcode = self.program[self.pointer] % 100
            mode1 = (self.program[self.pointer] // 100) % 10
            mode2 = (self.program[self.pointer] // 1000) % 10
            mode3 = (self.program[self.pointer] // 10000) % 10

            if opcode == 1:  # Add
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                self.set_parameter(mode3, 3, param1 + param2)
                self.pointer += 4
            elif opcode == 2:  # Multiply
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                self.set_parameter(mode3, 3, param1 * param2)
                self.pointer += 4
            elif opcode == 3:  # Input
                if len(inputs) == 0:
                    return
                self.set_parameter(mode1, 1, inputs.pop(0))
                self.pointer += 2
            elif opcode == 4:  # Output
                self.outputs.append(self.get_parameter(mode1, 1))
                self.pointer += 2
            elif opcode == 5:  # Jump if true
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 != 0:
                    self.pointer = param2
                else:
                    self.pointer += 3
            elif opcode == 6:  # Jump if false
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 == 0:
                    self.pointer = param2
                else:
                    self.pointer += 3
            elif opcode == 7:  # Less than
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 < param2:
                    self.set_parameter(mode3, 3, 1)
                else:
                    self.set_parameter(mode3, 3, 0)
                self.pointer += 4
            elif opcode == 8:  # Equals
                param1 = self.get_parameter(mode1, 1)
                param2 = self.get_parameter(mode2, 2)
                if param1 == param2:
                    self.set_parameter(mode3, 3, 1)
                else:
                    self.set_parameter(mode3, 3, 0)
                self.pointer += 4
            elif opcode == 9:  # Adjust relative base
                param1 = self.get_parameter(mode1, 1)
                self.relative_base += param1
                self.pointer += 2
            elif opcode == 99:  # Halt
                return

# Create an instance of the Intcode computer
computer = IntcodeComputer(program)

# Run the program with empty inputs
computer.run([])

# Print the outputs
print(computer.outputs)",0.0
248,2019,25,2,part1_failed,,,,,
249,2020,1,1,no_error,"928896
",928896,,"
def find_product_of_sum(numbers):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if numbers[i] + numbers[j] == 2020:
                return numbers[i] * numbers[j]

# Read input from file
with open('input.txt', 'r') as file:
    numbers = [int(line.strip()) for line in file.readlines()]

# Find product of two numbers that sum to 2020
product = find_product_of_sum(numbers)

print(product)
",0.0
250,2020,1,2,no_error,"295668576
",295668576,,"
def find_product_of_sum(numbers):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            for k in range(j+1, len(numbers)):
                if numbers[i] + numbers[j] + numbers[k] == 2020:
                    return numbers[i] * numbers[j] * numbers[k]

# Read input from file
with open('input.txt', 'r') as file:
    numbers = [int(line.strip()) for line in file.readlines()]

# Find product of three numbers that sum to 2020
product = find_product_of_sum(numbers)

print(product)
",0.0
251,2020,2,1,no_error,"434
",434,,"
def count_valid_passwords(passwords):
    count = 0
    for password in passwords:
        policy, password = password.split(': ')
        occurrences_range, letter = policy.split(' ')
        min_occurrences, max_occurrences = map(int, occurrences_range.split('-'))
        occurrences = password.count(letter)
        if min_occurrences <= occurrences <= max_occurrences:
            count += 1
    return count


# Read input from file
with open('input.txt', 'r') as file:
    passwords = [line.strip() for line in file.readlines()]

# Count valid passwords
valid_passwords = count_valid_passwords(passwords)
print(valid_passwords)
",0.0
252,2020,2,2,no_error,"509
",509,,"
def count_valid_passwords(passwords):
    count = 0
    for password in passwords:
        policy, password = password.split(': ')
        positions, letter = policy.split(' ')
        position1, position2 = map(int, positions.split('-'))
        if (password[position1 - 1] == letter) != (password[position2 - 1] == letter):
            count += 1
    return count


# Read input from file
with open('input.txt', 'r') as file:
    passwords = [line.strip() for line in file.readlines()]

# Count valid passwords
valid_passwords = count_valid_passwords(passwords)
print(valid_passwords)
",0.0
253,2020,3,1,no_error,"292
",292,,"
def count_trees(grid):
    num_trees = 0
    width = len(grid[0])
    x, y = 0, 0

    while y < len(grid):
        if grid[y][x] == '#':
            num_trees += 1
        x = (x + 3) % width
        y += 1

    return num_trees


if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        grid = [line.strip() for line in file.readlines()]
    result = count_trees(grid)
    print(result)
",0.0
254,2020,3,2,no_error,"9354744432
",9354744432,,"
def count_trees(grid, slope):
    num_trees = 0
    width = len(grid[0])
    x, y = 0, 0
    right, down = slope

    while y < len(grid):
        if grid[y][x] == '#':
            num_trees += 1
        x = (x + right) % width
        y += down

    return num_trees


if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        grid = [line.strip() for line in file.readlines()]

    slopes = [
        (1, 1),
        (3, 1),
        (5, 1),
        (7, 1),
        (1, 2)
    ]

    num_trees_product = 1
    for slope in slopes:
        num_trees = count_trees(grid, slope)
        num_trees_product *= num_trees

    print(num_trees_product)
",0.0
255,2020,4,1,no_error,"233
",233,,"
def is_valid_passport(passport):
    required_fields = {'byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid'}
    fields = passport.split()
    for field in fields:
        key, value = field.split(':')
        if key in required_fields:
            required_fields.remove(key)
    return len(required_fields) == 0 or (len(required_fields) == 1 and 'cid' in required_fields)

def count_valid_passports(batch_file):
    passports = batch_file.strip().split('\n\n')
    count = 0
    for passport in passports:
        if is_valid_passport(passport):
            count += 1
    return count

with open('input.txt') as file:
    batch_file = file.read()
    valid_passport_count = count_valid_passports(batch_file)
    print(valid_passport_count)
",0.0
256,2020,4,2,no_error,"111
",111,,"
import re

def is_valid_passport(passport):
    required_fields = {'byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid'}
    fields = passport.split()
    for field in fields:
        key, value = field.split(':')
        if key in required_fields:
            required_fields.remove(key)
            if not is_field_valid(key, value):
                return False
    return len(required_fields) == 0 or (len(required_fields) == 1 and 'cid' in required_fields)

def is_field_valid(key, value):
    if key == 'byr':
        return re.match(r'^\d{4}$', value) and 1920 <= int(value) <= 2002
    elif key == 'iyr':
        return re.match(r'^\d{4}$', value) and 2010 <= int(value) <= 2020
    elif key == 'eyr':
        return re.match(r'^\d{4}$', value) and 2020 <= int(value) <= 2030
    elif key == 'hgt':
        return re.match(r'^(\d+)(cm|in)$', value) and is_height_valid(value)
    elif key == 'hcl':
        return re.match(r'^#[0-9a-f]{6}$', value)
    elif key == 'ecl':
        return value in {'amb', 'blu', 'brn', 'gry', 'grn', 'hzl', 'oth'}
    elif key == 'pid':
        return re.match(r'^\d{9}$', value)
    elif key == 'cid':
        return True
    return False

def is_height_valid(value):
    match = re.match(r'^(\d+)(cm|in)$', value)
    if match:
        height, unit = match.groups()
        if unit == 'cm':
            return 150 <= int(height) <= 193
        elif unit == 'in':
            return 59 <= int(height) <= 76
    return False

def count_valid_passports(batch_file):
    passports = batch_file.strip().split('\n\n')
    count = 0
    for passport in passports:
        if is_valid_passport(passport):
            count += 1
    return count

with open('input.txt') as file:
    batch_file = file.read()
    valid_passport_count = count_valid_passports(batch_file)
    print(valid_passport_count)
",0.0
257,2020,5,1,no_error,"987
",987,,"
def find_highest_seat_id(boarding_passes):
    highest_seat_id = 0

    for boarding_pass in boarding_passes:
        row = _find_row(boarding_pass[:7])
        column = _find_column(boarding_pass[7:])
        seat_id = row * 8 + column
        highest_seat_id = max(highest_seat_id, seat_id)

    return highest_seat_id


def _find_row(row_string):
    lower = 0
    upper = 127

    for char in row_string:
        mid = (lower + upper) // 2

        if char == 'F':
            upper = mid
        elif char == 'B':
            lower = mid + 1

    return lower


def _find_column(column_string):
    lower = 0
    upper = 7

    for char in column_string:
        mid = (lower + upper) // 2

        if char == 'L':
            upper = mid
        elif char == 'R':
            lower = mid + 1

    return lower


# Read input from file
with open('input.txt', 'r') as file:
    boarding_passes = file.read().splitlines()

highest_seat_id = find_highest_seat_id(boarding_passes)
print(highest_seat_id)
",0.0
258,2020,5,2,no_error,"603
",603,,"
def find_missing_seat_id(boarding_passes):
    seat_ids = []

    for boarding_pass in boarding_passes:
        row = _find_row(boarding_pass[:7])
        column = _find_column(boarding_pass[7:])
        seat_id = row * 8 + column
        seat_ids.append(seat_id)

    seat_ids.sort()

    for i in range(1, len(seat_ids)):
        if seat_ids[i] - seat_ids[i-1] > 1:
            return seat_ids[i] - 1


def _find_row(row_string):
    lower = 0
    upper = 127

    for char in row_string:
        mid = (lower + upper) // 2

        if char == 'F':
            upper = mid
        elif char == 'B':
            lower = mid + 1

    return lower


def _find_column(column_string):
    lower = 0
    upper = 7

    for char in column_string:
        mid = (lower + upper) // 2

        if char == 'L':
            upper = mid
        elif char == 'R':
            lower = mid + 1

    return lower


# Read input from file
with open('input.txt', 'r') as file:
    boarding_passes = file.read().splitlines()

missing_seat_id = find_missing_seat_id(boarding_passes)
print(missing_seat_id)
",0.0
259,2020,6,1,no_error,"6775
",6775,,"def count_questions(input):
    groups = input.split(""\n\n"")

    total_count = 0

    for group in groups:
        group_answers = group.split('\n')
        group_set = set()

        for person_answers in group_answers:
            group_set.update(set(person_answers))

        total_count += len(group_set)

    return total_count

with open('input.txt', 'r') as file:
    input = file.read()

result = count_questions(input)
print(result)",0.0
260,2020,6,2,no_error,"3356
",3356,,"def count_questions(input):
    groups = input.split(""\n\n"")

    total_count = 0

    for group in groups:
        group_answers = group.split('\n')
        group_set = set(group_answers[0])

        for person_answers in group_answers[1:]:
            group_set.intersection_update(set(person_answers))

        total_count += len(group_set)

    return total_count

with open('input.txt', 'r') as file:
    input = file.read()

result = count_questions(input)
print(result)",0.0
261,2020,7,1,syntax_error,,226,"  File ""/tmp/tmp42uecsh6/tmp.py"", line 3
    1. Read the input file and parse the rules into a dictionary.
       ^
SyntaxError: invalid syntax
","# Plan

1. Read the input file and parse the rules into a dictionary.
2. Iterate over the rules and check if a bag can eventually contain a `shiny gold` bag.
3. Use recursion to explore the bags contained within each bag.
4. Keep track of bags that can contain a `shiny gold` bag and return the count.

Let's start by reading the input file and parsing the rules.",0.0
262,2020,7,2,part1_failed,,9569,,,
263,2020,8,1,no_error,"1384
",1384,,"
with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

accumulator = 0
current_index = 0
visited = set()

while True:
    if current_index >= len(instructions):
        break

    if current_index in visited:
        break

    visited.add(current_index)
    operation, argument = instructions[current_index].split()
    argument = int(argument)

    if operation == 'acc':
        accumulator += argument
        current_index += 1
    elif operation == 'jmp':
        current_index += argument
    elif operation == 'nop':
        current_index += 1

print(accumulator)
",0.0
264,2020,8,2,no_error,761,761,,"
def run_program(instructions):
    accumulator = 0
    current_index = 0
    visited = set()

    while True:
        if current_index >= len(instructions):
            return accumulator

        if current_index in visited:
            return None

        visited.add(current_index)
        operation, argument = instructions[current_index].split()
        argument = int(argument)

        if operation == 'acc':
            accumulator += argument
            current_index += 1
        elif operation == 'jmp':
            current_index += argument
        elif operation == 'nop':
            current_index += 1


with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

for i in range(len(instructions)):
    modified_instructions = instructions.copy()

    if modified_instructions[i].startswith('jmp'):
        modified_instructions[i] = modified_instructions[i].replace('jmp', 'nop')
    elif modified_instructions[i].startswith('nop'):
        modified_instructions[i] = modified_instructions[i].replace('nop', 'jmp')

    result = run_program(modified_instructions)

    if result is not None:
        print(result)
        break

print(""Error: No fix found for the program."")
",0.0
265,2020,9,1,wrong_output,,258585477,,"'''
def find_first_non_sum(numbers):
    for i in range(25, len(numbers)):
        found = False
        for j in range(i-25, i):
            for k in range(j+1, i):
                if numbers[j] + numbers[k] == numbers[i]:
                    found = True
                    break
            if found:
                break
        if not found:
            return numbers[i]
    return -1

# Read input from file
with open('input.txt', 'r') as file:
    numbers = [int(line.strip()) for line in file]

# Call function and print result
result = find_first_non_sum(numbers)
print(result)
'''",0.0
266,2020,9,2,part1_failed,,36981213,,,
267,2020,10,1,wrong_output,"1-jolt differences: 73
2-jolt differences: 0
3-jolt differences: 31
",2263,,"# Read the input file
with open('input.txt', 'r') as file:
    adapters = [int(line.strip()) for line in file.readlines()]

# Sort the adapters in ascending order
adapters.sort()

# Add the charging outlet rating (0) at the beginning
adapters.insert(0, 0)

# Add the built-in adapter rating at the end
adapters.append(adapters[-1] + 3)

# Initialize counters for 1-jolt, 2-jolt, and 3-jolt differences
diff_1 = 0
diff_2 = 0
diff_3 = 0

# Iterate over the adapters and calculate the differences
for i in range(1, len(adapters)):
    diff = adapters[i] - adapters[i-1]
    if diff == 1:
        diff_1 += 1
    elif diff == 2:
        diff_2 += 1
    elif diff == 3:
        diff_3 += 1

# Print the distribution of joltage differences
print(f""1-jolt differences: {diff_1}"")
print(f""2-jolt differences: {diff_2}"")
print(f""3-jolt differences: {diff_3}"")",0.0
268,2020,10,2,part1_failed,,396857386627072,,,
269,2020,11,1,no_error,"2368
",2368,,"with open('input.txt', 'r') as file:
    seating_area = [list(line.strip()) for line in file.readlines()]

def count_occupied_seats(seating_area):
    def count_adjacent_occupied_seats(seating_area, i, j):
        count = 0
        for x in range(max(0, i-1), min(i+2, len(seating_area))):
            for y in range(max(0, j-1), min(j+2, len(seating_area[0]))):
                if (x, y) != (i, j) and seating_area[x][y] == '#':
                    count += 1
        return count

    def apply_rules(seating_area):
        new_seating_area = [row[:] for row in seating_area]
        for i in range(len(seating_area)):
            for j in range(len(seating_area[0])):
                if seating_area[i][j] == 'L' and count_adjacent_occupied_seats(seating_area, i, j) == 0:
                    new_seating_area[i][j] = '#'
                elif seating_area[i][j] == '#' and count_adjacent_occupied_seats(seating_area, i, j) >= 4:
                    new_seating_area[i][j] = 'L'
        return new_seating_area

    while True:
        new_seating_area = apply_rules(seating_area)
        if seating_area == new_seating_area:
            break
        seating_area = new_seating_area

    count = 0
    for row in seating_area:
        for seat in row:
            if seat == '#':
                count += 1
    return count

occupied_seats = count_occupied_seats(seating_area)
print(occupied_seats)",0.0
270,2020,11,2,no_error,"2124
",2124,,"with open('input.txt', 'r') as file:
    seating_area = [list(line.strip()) for line in file.readlines()]

def count_occupied_seats(seating_area):
    def count_visible_occupied_seats(seating_area, i, j):
        count = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (-1, 1), (-1, -1), (1, 1), (1, -1)]
        for dx, dy in directions:
            x, y = i + dx, j + dy
            while 0 <= x < len(seating_area) and 0 <= y < len(seating_area[0]):
                if seating_area[x][y] == '#':
                    count += 1
                    break
                elif seating_area[x][y] == 'L':
                    break
                x += dx
                y += dy
        return count

    def apply_rules(seating_area):
        new_seating_area = [row[:] for row in seating_area]
        for i in range(len(seating_area)):
            for j in range(len(seating_area[0])):
                if seating_area[i][j] == 'L' and count_visible_occupied_seats(seating_area, i, j) == 0:
                    new_seating_area[i][j] = '#'
                elif seating_area[i][j] == '#' and count_visible_occupied_seats(seating_area, i, j) >= 5:
                    new_seating_area[i][j] = 'L'
        return new_seating_area

    while True:
        new_seating_area = apply_rules(seating_area)
        if seating_area == new_seating_area:
            break
        seating_area = new_seating_area

    count = 0
    for row in seating_area:
        for seat in row:
            if seat == '#':
                count += 1
    return count

occupied_seats = count_occupied_seats(seating_area)
print(occupied_seats)",0.0
271,2020,12,1,syntax_error,,962,"  File ""/tmp/tmp2p_n1gng/tmp.py"", line 3
    1. Initialize the ship's position as `(0, 0)` and the direction it is facing as `east`.
       ^
SyntaxError: invalid syntax
","# Approach:

1. Initialize the ship's position as `(0, 0)` and the direction it is facing as `east`.
2. Read the input instructions line by line.
3. For each instruction:
   - If the action is `N`, update the ship's position by moving `value` units north.
   - If the action is `S`, update the ship's position by moving `value` units south.
   - If the action is `E`, update the ship's position by moving `value` units east.
   - If the action is `W`, update the ship's position by moving `value` units west.
   - If the action is `L`, update the direction the ship is facing by turning `value` degrees left.
   - If the action is `R`, update the direction the ship is facing by turning `value` degrees right.
   - If the action is `F`, move the ship `value` units forward in the current direction it is facing.
4. Calculate the Manhattan distance between the final position of the ship and its starting position by taking the absolute difference of the east/west positions and the north/south positions.
5. Output the Manhattan distance.

# To Do:
- Read the input instructions from the 'input.txt' file.
- Implement the above approach in code.
- Print the Manhattan distance as the output.",0.0
272,2020,12,2,part1_failed,,56135,,,
273,2020,13,1,runtime_error,,2095,"Traceback (most recent call last):
  File ""/tmp/tmpgp54zp4v/tmp.py"", line 9, in <module>
    bus_ids = [int(bus_id) for bus_id in lines[1].strip().split(',')]
  File ""/tmp/tmpgp54zp4v/tmp.py"", line 9, in <listcomp>
    bus_ids = [int(bus_id) for bus_id in lines[1].strip().split(',')]
ValueError: invalid literal for int() with base 10: 'x'
","# Read the input from the file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Extract the estimated earliest timestamp
estimated_timestamp = int(lines[0].strip())

# Extract the list of bus IDs
bus_ids = [int(bus_id) for bus_id in lines[1].strip().split(',')]

# Filter out the out-of-service bus IDs
active_bus_ids = [bus_id for bus_id in bus_ids if bus_id != 'x']

# Find the earliest bus ID
earliest_bus_id = min(active_bus_ids, key=lambda x: (estimated_timestamp // x + 1) * x)

# Calculate the number of minutes to wait for the earliest bus
minutes_to_wait = ((estimated_timestamp // earliest_bus_id + 1) * earliest_bus_id) - estimated_timestamp

# Print the result
print(f""The earliest bus you can take is {earliest_bus_id} and you'll need to wait for {minutes_to_wait} minutes."")",0.0
274,2020,13,2,part1_failed,,598411311431841,,,
275,2020,14,1,runtime_error,,14553106347726,"Traceback (most recent call last):
  File ""/tmp/tmpbq18bp0w/tmp.py"", line 27, in <module>
    memory_sum = calculate_memory_sum(input)
  File ""/tmp/tmpbq18bp0w/tmp.py"", line 17, in calculate_memory_sum
    address, value = map(int, line[line.index('[')+1:line.index(']')].split())
ValueError: not enough values to unpack (expected 2, got 1)
","
def apply_bitmask(mask, value):
    binary_value = bin(value)[2:].zfill(36)
    result = ''
    for i in range(len(mask)):
        if mask[i] == 'X':
            result += binary_value[i]
        else:
            result += mask[i]
    return int(result, 2)

def calculate_memory_sum(input):
    lines = input.strip().split('\n')
    mask = lines[0][7:]
    memory = {}
    for line in lines[1:]:
        address, value = map(int, line[line.index('[')+1:line.index(']')].split())
        value = apply_bitmask(mask, value)
        memory[address] = value
    return sum(memory.values())

# Read input from file
with open('input.txt', 'r') as file:
    input = file.read()

# Calculate memory sum
memory_sum = calculate_memory_sum(input)
print(memory_sum)
",0.0
276,2020,14,2,part1_failed,,2737766154126,,,
277,2020,15,1,wrong_output,"0
",468,,"def find_number(starting_numbers):
    # Create a dictionary to store the last turn each number was spoken
    last_turns = {}

    # Initialize the turn and the last spoken number
    turn = 1
    last_spoken = None

    # Process the starting numbers
    for number in starting_numbers:
        # If the number was spoken before, update the last turn
        if number in last_turns:
            last_spoken = number
            last_turns[number] = turn
        # If the number is new, set the last spoken number to 0
        else:
            last_spoken = 0
            last_turns[number] = turn
        # Increment the turn
        turn += 1

    # Continue the game until the 2020th turn
    while turn <= 2020:
        # If the last spoken number was spoken before, calculate the difference in turns
        if last_spoken in last_turns:
            difference = turn - last_turns[last_spoken]
            last_turns[last_spoken] = turn
            last_spoken = difference
        # If the last spoken number is new, set the last spoken number to 0
        else:
            last_turns[last_spoken] = turn
            last_spoken = 0
        # Increment the turn
        turn += 1

    return last_spoken

# Read the input
with open('input.txt', 'r') as file:
    input_data = file.read().strip().split(',')

# Convert the input to a list of integers
starting_numbers = [int(number) for number in input_data]

# Find the number spoken on the 2020th turn
result = find_number(starting_numbers)
print(result)",0.0
278,2020,15,2,part1_failed,,1801753,,,
279,2020,16,1,wrong_output,,26026,,"# Parsing the Input

# Read the input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the rules for ticket fields
rules = {}
i = 0
while lines[i] != '\n':
    field, ranges = lines[i].strip().split(': ')
    ranges = ranges.split(' or ')
    rules[field] = []
    for range_str in ranges:
        start, end = map(int, range_str.split('-'))
        rules[field].append((start, end))
    i += 1

# Parse your ticket
your_ticket = list(map(int, lines[i+2].strip().split(',')))

# Parse nearby tickets
nearby_tickets = []
for j in range(i+5, len(lines)):
    nearby_tickets.append(list(map(int, lines[j].strip().split(','))))

# Implement the ticket scanning error rate calculation",0.0
280,2020,16,2,part1_failed,,1305243193339,,,
281,2020,17,1,wrong_output,"18
",263,,"# Read the input file
with open('input.txt', 'r') as f:
    lines = f.read().splitlines()
    
# Initialize the grid
grid = {}
for y, line in enumerate(lines):
    for x, cube in enumerate(line):
        grid[(x, y, 0)] = cube == '#'

# Define the function to count active cubes
def count_active_cubes(grid):
    return sum(grid.values())

# Define the function to get the neighboring coordinates
def get_neighbors(x, y, z):
    neighbors = []
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            for dz in range(-1, 2):
                if dx == 0 and dy == 0 and dz == 0:
                    continue
                neighbors.append((x + dx, y + dy, z + dz))
    return neighbors

# Simulate six cycles
for _ in range(6):
    new_grid = {}
    for (x, y, z), cube in grid.items():
        active_neighbors = 0
        for neighbor in get_neighbors(x, y, z):
            if grid.get(neighbor):
                active_neighbors += 1
        
        if cube and active_neighbors in [2, 3]:
            new_grid[(x, y, z)] = True
        elif not cube and active_neighbors == 3:
            new_grid[(x, y, z)] = True
        else:
            new_grid[(x, y, z)] = False
    
    grid = new_grid

# Count the number of active cubes after the sixth cycle
active_cubes = count_active_cubes(grid)
print(active_cubes)",0.0
282,2020,17,2,part1_failed,,1680,,,
283,2020,18,1,runtime_error,,31142189909908,"Traceback (most recent call last):
  File ""/tmp/tmpc5uixo8z/tmp.py"", line 50, in <module>
    value = evaluate(expression)
  File ""/tmp/tmpc5uixo8z/tmp.py"", line 37, in evaluate
    number = int(expression[i])
ValueError: invalid literal for int() with base 10: ' '
","# Read the input from 'input.txt'
with open('input.txt', 'r') as f:
    expressions = f.read().splitlines()

# Define a function to evaluate a mathematical expression
def evaluate(expression):
    result = 0
    operator = '+'
    i = 0
    while i < len(expression):
        if expression[i] == '(':
            # Find the closing parenthesis
            j = i
            count = 1
            while count > 0:
                j += 1
                if expression[j] == '(':
                    count += 1
                elif expression[j] == ')':
                    count -= 1
            # Evaluate the subexpression within the parentheses
            subexpression = expression[i+1:j]
            subresult = evaluate(subexpression)
            # Apply the operator to the result
            if operator == '+':
                result += subresult
            elif operator == '*':
                result *= subresult
            # Move the index to the closing parenthesis
            i = j
        elif expression[i] == '+':
            operator = '+'
        elif expression[i] == '*':
            operator = '*'
        else:
            # Convert the number string to an integer
            number = int(expression[i])
            # Apply the operator to the result
            if operator == '+':
                result += number
            elif operator == '*':
                result *= number
        i += 1

    return result

# Evaluate each expression and find the sum of the resulting values
sum_of_values = 0
for expression in expressions:
    value = evaluate(expression)
    sum_of_values += value

# Print the sum of the resulting values
print(sum_of_values)",0.0
284,2020,18,2,part1_failed,,323912478287549,,,
285,2020,19,1,wrong_output,,173,,"
def generate_valid_messages_count(rules, messages):
    def match_rule(message, rule):
        if not message:
            return False
        if rule.isdigit():
            return match_rule(message, rules[rule])
        elif rule.startswith('""') and rule.endswith('""'):
            return message[0] == rule[1:-1]
        else:
            for option in rule.split('|'):
                sub_rules = option.split()
                i = 0
                for sub_rule in sub_rules:
                    if not match_rule(message[i:], sub_rule):
                        break
                    i += len(message[i:])
                else:
                    return True
            return False

    rule_dict = {}
    for rule in rules:
        rule_number, rule_definition = rule.split(':')
        rule_dict[rule_number] = rule_definition.strip()

    count = 0
    for message in messages:
        if match_rule(message, rule_dict['0']) and len(message) == 0:
            count += 1

    return count
",0.0
286,2020,19,2,part1_failed,,367,,,
287,2020,20,1,wrong_output,"26745670061589237258053844095258621980732481490592666419170397353508970396968382419973568907102062940376120825746737921614423348010224186537537287307998089740452134139247937570993217284239830045232455109547
",15003787688423,,"
import re

def parse_input(input_string):
    tiles = []
    for tile_string in input_string.strip().split('\n\n'):
        tile_id_match = re.match(r'Tile (\d+):', tile_string)
        tile_id = int(tile_id_match.group(1))
        tile_data = tile_string[tile_id_match.end() + 1:].strip().split('\n')
        tiles.append((tile_id, tile_data))
    return tiles

def rotate(tile):
    return [''.join(row) for row in zip(*reversed(tile))]

def flip(tile):
    return [row[::-1] for row in tile]

def get_borders(tile):
    top = tile[0]
    bottom = tile[-1]
    left = ''.join(row[0] for row in tile)
    right = ''.join(row[-1] for row in tile)
    return [top, right, bottom, left]

def get_possible_orientations(tile):
    orientations = []
    for _ in range(4):
        orientations.append(tile)
        orientations.append(flip(tile))
        tile = rotate(tile)
    return orientations

def find_corner_tiles(tiles):
    corner_tiles = []
    for i, (tile_id, tile_data) in enumerate(tiles):
        tile_borders = get_borders(tile_data)
        matching_borders = 0
        for j, (other_tile_id, other_tile_data) in enumerate(tiles):
            if i != j:
                other_tile_borders = get_borders(other_tile_data)
                if any(border in tile_borders for border in other_tile_borders):
                    matching_borders += 1
        if matching_borders == 2:
            corner_tiles.append(tile_id)
    return corner_tiles

def find_product_of_corner_tiles(input_string):
    tiles = parse_input(input_string)
    corner_tiles = find_corner_tiles(tiles)
    product = 1
    for tile_id in corner_tiles:
        product *= tile_id
    return product

with open('input.txt', 'r') as file:
    input_string = file.read()

product = find_product_of_corner_tiles(input_string)
print(product)
",0.0
288,2020,20,2,part1_failed,,1705,,,
289,2020,21,1,no_error,"2542
",2542,,"import re

def find_safe_ingredients(input_list):
    # Create a dictionary to store the allergens and their possible ingredients
    allergen_dict = {}
    
    # Create a dictionary to store the count of each ingredient
    ingredient_count = {}
    
    for food in input_list:
        # Split the food into ingredients list and allergens
        ingredients_list, allergens = re.match(r""(.*) \(contains (.*)\)"", food).groups()
        ingredients = ingredients_list.split("" "")
        allergens = allergens.split("", "")
        
        # Update the count of each ingredient
        for ingredient in ingredients:
            if ingredient in ingredient_count:
                ingredient_count[ingredient] += 1
            else:
                ingredient_count[ingredient] = 1
        
        # Update the possible ingredients for each allergen
        for allergen in allergens:
            if allergen in allergen_dict:
                allergen_dict[allergen] = allergen_dict[allergen].intersection(set(ingredients))
            else:
                allergen_dict[allergen] = set(ingredients)
    
    # Find the safe ingredients that cannot contain any allergen
    safe_ingredients = set(ingredient_count.keys())
    for allergen_ingredients in allergen_dict.values():
        safe_ingredients = safe_ingredients.difference(allergen_ingredients)
    
    # Count the number of times the safe ingredients appear in any ingredients list
    safe_ingredients_count = 0
    for ingredient in safe_ingredients:
        safe_ingredients_count += ingredient_count[ingredient]
    
    return safe_ingredients_count

# Read the input from file
with open('input.txt', 'r') as f:
    input_list = f.read().splitlines()

# Find the count of safe ingredients
safe_ingredients_count = find_safe_ingredients(input_list)
print(safe_ingredients_count)",0.0
290,2020,21,2,wrong_output,"bd,mqvk,bfrq,bfrq,mqvk,mqvk,bd,mqvk
","hkflr,ctmcqjf,bfrq,srxphcm,snmxl,zvx,bd,mqvk",,"import re

def find_dangerous_ingredients(input_list):
    # Create a dictionary to store the allergens and their possible ingredients
    allergen_dict = {}
    
    for food in input_list:
        # Split the food into ingredients list and allergens
        ingredients_list, allergens = re.match(r""(.*) \(contains (.*)\)"", food).groups()
        ingredients = ingredients_list.split("" "")
        allergens = allergens.split("", "")
        
        # Update the possible ingredients for each allergen
        for allergen in allergens:
            if allergen in allergen_dict:
                allergen_dict[allergen] = allergen_dict[allergen].intersection(set(ingredients))
            else:
                allergen_dict[allergen] = set(ingredients)
    
    # Sort the allergens alphabetically
    sorted_allergens = sorted(allergen_dict.keys())
    
    # Create the canonical dangerous ingredient list
    canonical_dangerous_list = []
    for allergen in sorted_allergens:
        ingredient = allergen_dict[allergen].pop()
        canonical_dangerous_list.append(ingredient)
    
    return "","".join(canonical_dangerous_list)

# Read the input from file
with open('input.txt', 'r') as f:
    input_list = f.read().splitlines()

# Find the canonical dangerous ingredient list
canonical_dangerous_list = find_dangerous_ingredients(input_list)
print(canonical_dangerous_list)",0.0
291,2020,22,1,syntax_error,,34255,"  File ""/tmp/tmp6w6zab32/tmp.py"", line 3
    1. Read the input decks from the file.
       ^
SyntaxError: invalid syntax
","# Approach

1. Read the input decks from the file.
2. Split the input into two decks.
3. Convert the string representation of the decks into arrays of integers.
4. Initialize scores for both players to 0.
5. Initialize a variable to keep track of the round number.
6. While both decks are not empty, repeat steps 7-11.
7. Get the top cards from each deck.
8. Compare the values of the top cards.
9. If the value of player 1's card is higher, add the product of the card value and the round number to player 1's score. Otherwise, add it to player 2's score.
10. Move the top cards to the bottom of the respective decks.
11. Increment the round number.
12. Print the score of the winning player.",0.0
292,2020,22,2,part1_failed,,33369,,,
293,2020,23,1,no_error,"49576328
",49576328,,"# Read input from file
with open('input.txt', 'r') as file:
    cups = file.readline().strip()

# Create a dictionary to store the next cup for each cup
next_cup = {}
for i in range(len(cups)-1):
    next_cup[cups[i]] = cups[i+1]
next_cup[cups[-1]] = cups[0]

# Perform 100 moves
current_cup = cups[0]
for _ in range(100):
    picked_up = [next_cup[current_cup]]
    for _ in range(2):
        picked_up.append(next_cup[picked_up[-1]])
    destination_cup = str(int(current_cup) - 1)
    while destination_cup not in next_cup or destination_cup in picked_up:
        destination_cup = str(int(destination_cup) - 1)
        if int(destination_cup) <= 0:
            destination_cup = max(cups)
    next_cup[current_cup] = next_cup[picked_up[-1]]
    next_cup[picked_up[-1]] = next_cup[destination_cup]
    next_cup[destination_cup] = picked_up[0]
    current_cup = next_cup[current_cup]

# Determine the order of the cups starting after the cup labeled 1
result = ''
cup = next_cup['1']
while cup != '1':
    result += cup
    cup = next_cup[cup]

# Print the result
print(result)",0.0
294,2020,23,2,timeout_error,,511780369955,TIMEOUT,"# Read input from file
with open('input.txt', 'r') as file:
    cups = file.readline().strip()

# Extend the cups with the remaining labeled cups
max_label = max(cups)
for i in range(int(max_label) + 1, 1000001):
    cups += str(i)

# Create a dictionary to store the next cup for each cup
next_cup = {}
for i in range(len(cups) - 1):
    next_cup[cups[i]] = cups[i + 1]
next_cup[cups[-1]] = cups[0]

# Perform 10 million moves
current_cup = cups[0]
for _ in range(10000000):
    picked_up = [next_cup[current_cup]]
    for _ in range(2):
        picked_up.append(next_cup[picked_up[-1]])
    destination_cup = str(int(current_cup) - 1)
    while destination_cup not in next_cup or destination_cup in picked_up:
        destination_cup = str(int(destination_cup) - 1)
        if int(destination_cup) <= 0:
            destination_cup = max(cups)
    next_cup[current_cup] = next_cup[picked_up[-1]]
    next_cup[picked_up[-1]] = next_cup[destination_cup]
    next_cup[destination_cup] = picked_up[0]
    current_cup = next_cup[current_cup]

# Determine the labels on the two cups immediately clockwise of cup 1
cup_1_next_1 = next_cup['1']
cup_1_next_2 = next_cup[cup_1_next_1]

# Calculate the product
result = int(cup_1_next_1) * int(cup_1_next_2)

# Print the result
print(result)",0.0
295,2020,24,1,wrong_output,"40
",356,,"
def flip_tiles(instructions):
    # Initialize a dictionary to store the color of each tile
    tiles = {}

    for instruction in instructions:
        # Initialize the current tile as the reference tile
        current_tile = (0, 0)

        # Iterate through each step in the instruction
        i = 0
        while i < len(instruction):
            step = instruction[i]

            # Determine the direction of the step
            if step == 'e':
                x, y = 1, 0
            elif step == 'se':
                x, y = 0, -1
            elif step == 'sw':
                x, y = -1, -1
            elif step == 'w':
                x, y = -1, 0
            elif step == 'nw':
                x, y = 0, 1
            elif step == 'ne':
                x, y = 1, 1

            # Update the current tile coordinates
            current_tile = (current_tile[0] + x, current_tile[1] + y)

            i += 1

        # Flip the color of the current tile
        if current_tile in tiles:
            tiles[current_tile] = not tiles[current_tile]
        else:
            tiles[current_tile] = True

    # Count the number of tiles with the black side up
    black_tiles = sum(tiles.values())

    return black_tiles


# Read the input from the file
with open('input.txt', 'r') as file:
    instructions = file.read().splitlines()

# Call the function with the given instructions and print the result
print(flip_tiles(instructions))
",0.0
296,2020,24,2,part1_failed,,3887,,,
297,2020,25,1,no_error,711945,711945,,"# Read the input file
with open('input.txt', 'r') as f:
    public_key1, public_key2 = map(int, f.readlines())

# Find the secret loop size for public_key1
subject_number = 7
value = 1
loop_size1 = 0
while value != public_key1:
    value = (value * subject_number) % 20201227
    loop_size1 += 1

# Find the secret loop size for public_key2
subject_number = 7
value = 1
loop_size2 = 0
while value != public_key2:
    value = (value * subject_number) % 20201227
    loop_size2 += 1

# Calculate the encryption key
encryption_key = pow(public_key1, loop_size2, 20201227)

print(f""The encryption key is: {encryption_key}"")",0.0
298,2021,1,1,no_error,"1532
",1532,,"# Read input from file
with open('input.txt', 'r') as f:
    measurements = [int(x) for x in f.read().split('\n') if x != '']

# Initialize counter
count = 0

# Iterate through the measurements and count the increases
for i in range(1, len(measurements)):
    if measurements[i] > measurements[i-1]:
        count += 1

# Print the result
print(count)",0.0
299,2021,1,2,no_error,"1571
",1571,,"# Read input from file
with open('input.txt', 'r') as f:
    measurements = [int(x) for x in f.read().split('\n') if x != '']

# Initialize counter
count = 0

# Initialize previous sum
prev_sum = None

# Iterate through the measurements with a sliding window size of 3
for i in range(2, len(measurements)):
    curr_sum = sum(measurements[i-2:i+1])
    if prev_sum is not None and curr_sum > prev_sum:
        count += 1
    prev_sum = curr_sum

# Print the result
print(count)",0.0
300,2021,2,1,no_error,"1990000
",1990000,,"with open('input.txt', 'r') as file:
    commands = file.readlines()

horizontal_position = 0
depth = 0

for command in commands:
    command = command.strip().split()
    if command[0] == 'forward':
        horizontal_position += int(command[1])
    elif command[0] == 'down':
        depth += int(command[1])
    elif command[0] == 'up':
        depth -= int(command[1])

result = horizontal_position * depth
print(result)",0.0
301,2021,2,2,no_error,"1975421260
",1975421260,,"with open('input.txt', 'r') as file:
    commands = file.readlines()

horizontal_position = 0
depth = 0
aim = 0

for command in commands:
    command = command.strip().split()
    if command[0] == 'forward':
        x = int(command[1])
        horizontal_position += x
        depth += aim * x
    elif command[0] == 'down':
        aim += int(command[1])
    elif command[0] == 'up':
        aim -= int(command[1])

result = horizontal_position * depth
print(result)",0.0
302,2021,3,1,wrong_output,,3549854,,"# Reading the input from the file
with open('input.txt', 'r') as file:
    binary_numbers = file.read().splitlines()

# Calculating the gamma rate
gamma_rate = ''
for i in range(len(binary_numbers[0])):
    count_0 = 0
    count_1 = 0
    for binary_number in binary_numbers:
        if binary_number[i] == '0':
            count_0 += 1
        else:
            count_1 += 1
    if count_0 > count_1:
        gamma_rate += '0'
    else:
        gamma_rate += '1'

# Calculating the epsilon rate
epsilon_rate = ''
for i in range(len(binary_numbers[0])):
    count_0 = 0
    count_1 = 0
    for binary_number in binary_numbers:
        if binary_number[i] == '0':
            count_0 += 1
        else:
            count_1 += 1
    if count_0 < count_1:
        epsilon_rate += '0'
    else:
        epsilon_rate += '1'

# Calculating the power consumption
power_consumption = int(gamma_rate, 2) * int(epsilon_rate, 2)

# Returning the decimal representation of the power consumption
power_consumption",0.0
303,2021,3,2,part1_failed,,3765399,,,
304,2021,4,1,runtime_error,,49860,"Traceback (most recent call last):
  File ""/tmp/tmp72fm5ys3/tmp.py"", line 9, in <module>
    board = list(map(int, data[i].strip().split(',')))
ValueError: invalid literal for int() with base 10: ''
","# Read the input from the file
with open('input.txt', 'r') as file:
    data = file.readlines()

# Parse the input
numbers_drawn = list(map(int, data[0].strip().split(',')))
boards = []
for i in range(1, len(data)):
    board = list(map(int, data[i].strip().split(',')))
    boards.append(board)

# Function to check if a board wins
def check_win(board):
    for i in range(5):
        if all(board[i][j] == 'X' for j in range(5)):
            return True
        if all(board[j][i] == 'X' for j in range(5)):
            return True
    if all(board[i][i] == 'X' for i in range(5)):
        return True
    if all(board[i][4-i] == 'X' for i in range(5)):
        return True
    return False

# Iterate through the numbers drawn
for number in numbers_drawn:
    # Mark the number on each board
    for board in boards:
        for i in range(5):
            for j in range(5):
                if board[i][j] == number:
                    board[i][j] = 'X'
    # Check if any board wins
    for board in boards:
        if check_win(board):
            # Calculate the score
            score = sum(sum(row) for row in board)
            # Print the winning board and score
            print(board)
            print(score)
            break",0.0
305,2021,4,2,part1_failed,,24628,,,
306,2021,5,1,wrong_output,"6894
",6710,,"import re

def count_overlapping_points(segments):
    points = set()
    overlapping_points = 0

    for segment in segments:
        x1, y1, x2, y2 = map(int, re.findall(r'\d+', segment))

        if x1 == x2:
            for y in range(min(y1, y2), max(y1, y2)):
                point = (x1, y)
                if point in points:
                    overlapping_points += 1
                points.add(point)

        if y1 == y2:
            for x in range(min(x1, x2), max(x1, x2)):
                point = (x, y1)
                if point in points:
                    overlapping_points += 1
                points.add(point)

    return overlapping_points


with open('input.txt', 'r') as file:
    segments = file.readlines()

overlapping_points = count_overlapping_points(segments)
print(overlapping_points)",0.0
307,2021,5,2,part1_failed,,20121,,,
308,2021,6,1,timeout_error,,380243,TIMEOUT,"with open('input.txt', 'r') as f:
    input_list = f.read().strip().split(',')

num_days = int(input(""Enter the number of days: ""))

lanternfish_list = [int(timer) for timer in input_list]

for day in range(num_days):
    new_lanternfish = len([timer for timer in lanternfish_list if timer == 0])
    lanternfish_list = [timer-1 for timer in lanternfish_list if timer != 0]
    lanternfish_list.extend([8]*new_lanternfish)
    lanternfish_list = [(timer+6)%7 if timer != 0 else timer for timer in lanternfish_list]

total_lanternfish = len(lanternfish_list)
print(""Total number of lanternfish after"", num_days, ""days:"", total_lanternfish)",0.0
309,2021,6,2,part1_failed,,1708791884591,,,
310,2021,7,1,wrong_output,"The horizontal position that requires the least amount of fuel is 313.
The total fuel required to align all the crab submarines to that position is 344297.
",344297,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    positions = list(map(int, file.readline().strip().split(',')))

# Sort the positions in ascending order
positions.sort()

# Calculate the total fuel required to align all the crab submarines to each position
total_fuel = []
for i in range(len(positions)):
    fuel = 0
    for j in range(len(positions)):
        fuel += abs(positions[j] - positions[i])
    total_fuel.append(fuel)

# Find the position that requires the least amount of fuel
min_position = positions[total_fuel.index(min(total_fuel))]

# Calculate the total fuel required to align all the crab submarines to the min position
min_total_fuel = min(total_fuel)

# Print the result
print(f""The horizontal position that requires the least amount of fuel is {min_position}."")
print(f""The total fuel required to align all the crab submarines to that position is {min_total_fuel}."")",0.0
311,2021,7,2,part1_failed,,97164301,,,
312,2021,8,1,runtime_error,,440,"Traceback (most recent call last):
  File ""/tmp/tmp47t9haax/tmp.py"", line 24, in <module>
    result = count_digits(entries)
  File ""/tmp/tmp47t9haax/tmp.py"", line 4, in count_digits
    signals, output = entry.split("" | "")
AttributeError: 'list' object has no attribute 'split'
","def count_digits(entries):
    count = 0
    for entry in entries:
        signals, output = entry.split("" | "")
        digits = [int(signal) for signal in signals.split("" "")]
        for digit in digits:
            if digit in [1, 4, 7, 8]:
                count += 1
    return count

# Read input from file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Remove newline characters
lines = [line.strip() for line in lines]

# Parse entries
entries = []
for line in lines:
    entries.append(line.split("" | ""))

# Call count_digits function
result = count_digits(entries)

# Print result
print(result)",0.0
313,2021,8,2,part1_failed,,1046281,,,
314,2021,9,1,wrong_output,"165628800126933960277171784152566405056235434915427441892227555405118553378397607148299196947133448259
",462,,"
def find_low_points(heightmap):
    # Convert the heightmap string to a list of integers
    heightmap = list(map(int, heightmap.split()))

    # Define the dimensions of the heightmap
    rows = len(heightmap) // 10
    cols = 10

    # Calculate the sum of the risk levels
    sum_of_risk_levels = 0

    # Iterate over each location in the heightmap
    for i in range(rows):
        for j in range(cols):
            current_height = heightmap[i * cols + j]
            is_low_point = True

            # Check the adjacent locations
            if i > 0 and current_height <= heightmap[(i - 1) * cols + j]:
                is_low_point = False
            elif i < rows - 1 and current_height <= heightmap[(i + 1) * cols + j]:
                is_low_point = False
            elif j > 0 and current_height <= heightmap[i * cols + (j - 1)]:
                is_low_point = False
            elif j < cols - 1 and current_height <= heightmap[i * cols + (j + 1)]:
                is_low_point = False

            # Calculate the risk level and add it to the sum
            if is_low_point:
                risk_level = 1 + current_height
                sum_of_risk_levels += risk_level

    return sum_of_risk_levels


# Read the input from the file
with open('input.txt', 'r') as file:
    heightmap = file.read()

# Find the low points and calculate the sum of the risk levels
sum_of_risk_levels = find_low_points(heightmap)

print(sum_of_risk_levels)
",0.0
315,2021,9,2,part1_failed,,1397760,,,
316,2021,10,1,wrong_output,"0
",299793,,"
def calculate_syntax_error_score(closing_character):
    score_table = {
        ')': 1,
        ']': 2,
        '}': 3,
        '>': 4
    }
    return score_table.get(closing_character, 0)

def is_valid_line(line):
    stack = []
    opening_chars = ['(', '[', '{', '<']
    closing_chars = [')', ']', '}', '>']

    for chunk in line.split():
        for char in chunk:
            if char in opening_chars:
                stack.append(char)
            elif char in closing_chars:
                if not stack or stack[-1] != opening_chars[closing_chars.index(char)]:
                    return False
                stack.pop()

    return len(stack) == 0

def calculate_total_syntax_error_score(input_file):
    total_score = 0

    with open(input_file, 'r') as file:
        for line in file:
            line = line.strip()
            if not is_valid_line(line):
                total_score += calculate_syntax_error_score(line[line.index(line) + 1])

    return total_score

input_file = 'input.txt'
total_score = calculate_total_syntax_error_score(input_file)
print(total_score)
",0.0
317,2021,10,2,part1_failed,,3654963618,,,
318,2021,11,1,wrong_output,"1067
",1793,,"with open('input.txt', 'r') as file:
    grid = [list(map(int, line.strip())) for line in file.readlines()]

flashes = 0

for _ in range(100):
    new_grid = [[0] * 10 for _ in range(10)]
    for i in range(10):
        for j in range(10):
            if grid[i][j] > 9:
                flashes += 1
                new_grid[i][j] = 0
                if i > 0:
                    new_grid[i-1][j] += 1
                if i < 9:
                    new_grid[i+1][j] += 1
                if j > 0:
                    new_grid[i][j-1] += 1
                if j < 9:
                    new_grid[i][j+1] += 1
            else:
                new_grid[i][j] = grid[i][j] + 1
    grid = new_grid

print(flashes)",0.0
319,2021,11,2,part1_failed,,247,,,
320,2021,12,1,wrong_output,"0
",3887,,"# Reading the input
with open('input.txt', 'r') as file:
    cave_connections = file.read().splitlines()

# Creating a dictionary to store the connections
connections = {}
for connection in cave_connections:
    cave1, cave2 = connection.split('-')
    if cave1 in connections:
        connections[cave1].append(cave2)
    else:
        connections[cave1] = [cave2]

# Function to find the number of distinct paths
def find_distinct_paths(start, end, visited):
    if start == end:
        return 1
    
    visited[start] = True
    count = 0
    
    if start in connections:
        for cave in connections[start]:
            if not visited.get(cave, False):
                count += find_distinct_paths(cave, end, visited)
    
    visited[start] = False
    return count

# Calling the function and printing the result
start = 'start'
end = 'end'
visited = {}
distinct_paths = find_distinct_paths(start, end, visited)
print(distinct_paths)",0.0
321,2021,12,2,part1_failed,,104834,,,
322,2021,13,1,wrong_output,"853
",712,,"
def count_visible_dots(coordinates, fold_instructions):
    # Create a set to store the visible dots
    visible_dots = set(coordinates)
    
    for instruction in fold_instructions:
        # Split the instruction into fold direction and line position
        fold_direction, line_position = instruction.split(' along ')
        line_position = int(line_position.split('=')[1])
        
        # Fold the paper
        if fold_direction == 'x':
            visible_dots = set((x, line_position - y) for x, y in visible_dots)
        else:
            visible_dots = set((line_position - x, y) for x, y in visible_dots)
    
    # Count the number of visible dots
    return len(visible_dots)


# Read input from file
with open('input.txt', 'r') as file:
    # Read the coordinates
    coordinates = []
    while True:
        line = file.readline().strip()
        if not line:
            break
        x, y = map(int, line.split(','))
        coordinates.append((x, y))
    
    # Read the fold instructions
    fold_instructions = []
    while True:
        line = file.readline().strip()
        if not line:
            break
        fold_instructions.append(line)
    
    # Calculate and print the number of visible dots
    print(count_visible_dots(coordinates, fold_instructions))
",0.0
323,2021,13,2,part1_failed,,BLHFJPJF,,,
324,2021,14,1,wrong_output,"Most common element: E
Least common element: E
Difference: 0
",2233,,"polymer_template = ""ABCD""
pair_insertion_rules = [""AB -> E"", ""BC -> F"", ""CD -> G""]

# Function to perform pair insertion on the polymer template
def perform_pair_insertion(polymer_template, pair_insertion_rules):
    for rule in pair_insertion_rules:
        rule_parts = rule.split("" -> "")
        pair = rule_parts[0]
        insert = rule_parts[1]
        polymer_template = polymer_template.replace(pair, insert)
    return polymer_template

# Perform pair insertion on the polymer template
polymer_result = perform_pair_insertion(polymer_template, pair_insertion_rules)

# Calculate the occurrence count of each element in the polymer result
element_count = {}
for element in polymer_result:
    if element in element_count:
        element_count[element] += 1
    else:
        element_count[element] = 1

# Find the most and least common elements in the polymer result
most_common_element = max(element_count, key=element_count.get)
least_common_element = min(element_count, key=element_count.get)

# Calculate the difference between the quantities of the most and least common elements
difference = element_count[most_common_element] - element_count[least_common_element]

# Print the result
print(""Most common element:"", most_common_element)
print(""Least common element:"", least_common_element)
print(""Difference:"", difference)",0.0
325,2021,14,2,part1_failed,,2884513602164,,,
326,2021,15,1,wrong_output,"496779937659483554723609678920206665295854873326261015454714036189706633091867047446297165379834432107
",423,,"# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse the input into a 2D matrix
matrix = []
for line in lines:
    row = list(map(int, line.strip().split()))
    matrix.append(row)

# Function to find the lowest total risk path
def find_lowest_risk_path(matrix):
    # Get the dimensions of the matrix
    n = len(matrix)
    m = len(matrix[0])

    # Create a 2D matrix to store the minimum risks
    dp = [[0] * m for _ in range(n)]

    # Initialize the first row and column
    dp[0][0] = matrix[0][0]
    for i in range(1, n):
        dp[i][0] = dp[i-1][0] + matrix[i][0]
    for j in range(1, m):
        dp[0][j] = dp[0][j-1] + matrix[0][j]

    # Calculate the minimum risks for each position
    for i in range(1, n):
        for j in range(1, m):
            dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])

    # Return the minimum risk at the bottom right position
    return dp[n-1][m-1]

# Find the lowest total risk path
lowest_risk = find_lowest_risk_path(matrix)

# Print the result
print(lowest_risk)",0.0
327,2021,15,2,part1_failed,,2778,,,
328,2021,16,1,runtime_error,,947,"Traceback (most recent call last):
  File ""/tmp/tmp0zha1p4a/tmp.py"", line 38, in <module>
    parse_hexadecimal(input_string)
  File ""/tmp/tmp0zha1p4a/tmp.py"", line 26, in parse_hexadecimal
    for version in parse_packet(packet):
  File ""/tmp/tmp0zha1p4a/tmp.py"", line 18, in parse_packet
    sub_packet = binary_string[:sub_packet_length]
UnboundLocalError: local variable 'binary_string' referenced before assignment
","
def parse_hexadecimal(input_string):
    # Step 2: Convert hexadecimal string to binary
    binary_string = bin(int(input_string, 16))[2:]

    def parse_packet(packet):
        packet_type = packet[:4]
        packet_version = packet[4:8]

        if packet_type == '0000':
            # Step 4: Literal value packet
            literal_value = packet_version.zfill(16)
            for i in range(0, 16, 4):
                yield int(literal_value[i:i+4], 2)
        else:
            # Step 5: Operator packet
            sub_packet_length = int(packet_version, 2)
            sub_packet = binary_string[:sub_packet_length]
            binary_string = binary_string[sub_packet_length:]
            yield from parse_packet(sub_packet)

    # Step 3: Iterate through binary string and parse packets
    version_sum = 0
    for i in range(0, len(binary_string), 8):
        packet = binary_string[i:i+8]
        for version in parse_packet(packet):
            # Step 6: Calculate sum of all version numbers
            version_sum += version

    # Step 7: Print the sum
    print(version_sum)

# Step 1: Read input hexadecimal string from file
with open('input.txt', 'r') as file:
    input_string = file.read().strip()

# Call the parsing function
parse_hexadecimal(input_string)
",0.0
329,2021,16,2,part1_failed,,660797830937,,,
330,2021,17,1,wrong_output,"Initial Velocity: 60
Maximum Y-Position: 1830
",8646,,"
def find_initial_velocity(target_area):
    # Parsing the input string to extract the x and y coordinate ranges
    x_range, y_range = target_area.split("": "")[1].split("", "")
    x_start, x_end = map(int, x_range.split(""="")[1].split(""..""))
    y_start, y_end = map(int, y_range.split(""="")[1].split(""..""))
    
    # Finding the initial velocity that causes the probe to be within the target area after any step
    initial_x_velocity = x_end - x_start
    initial_y_velocity = y_end - y_start

    # Finding the maximum y-position the probe reaches on this trajectory
    max_y_position = initial_y_velocity * (initial_y_velocity + 1) // 2
    
    return initial_x_velocity, max_y_position

# Reading the input from the file
with open('input.txt', 'r') as file:
    target_area = file.read().strip()

# Calling the function to find the initial velocity and maximum y-position
initial_velocity, max_y_position = find_initial_velocity(target_area)

# Printing the results
print(""Initial Velocity:"", initial_velocity)
print(""Maximum Y-Position:"", max_y_position)
",0.0
331,2021,17,2,part1_failed,,5945,,,
332,2021,18,1,runtime_error,,4184,"Traceback (most recent call last):
  File ""/tmp/tmpr4b5g472/tmp.py"", line 53, in <module>
    result = calculate_sum_of_snailfish_numbers(snailfish_list)
  File ""/tmp/tmpr4b5g472/tmp.py"", line 40, in calculate_sum_of_snailfish_numbers
    reduced_number = reduce_snailfish(snailfish_number)
  File ""/tmp/tmpr4b5g472/tmp.py"", line 21, in reduce_snailfish
    number = [number[0][0] + number[1][0], number[0][1] + number[1][1]]
TypeError: unsupported operand type(s) for +: 'int' and 'list'
","# Reading the input from the file
with open('input.txt', 'r') as file:
    input_data = file.readlines()

# Function to check if a number is a regular number or a snailfish number
def is_regular_number(number):
    return isinstance(number, int) and number < 10

# Function to explode a snailfish number
def explode(number):
    return number[0] + number[1]

# Function to split a regular number
def split(number):
    return [number // 10, number % 10]

# Function to reduce a snailfish number
def reduce_snailfish(number):
    while isinstance(number, list):
        if not is_regular_number(number[0]) or not is_regular_number(number[1]):
            number = [number[0][0] + number[1][0], number[0][1] + number[1][1]]
        else:
            break
    return number

# Function to reduce a regular number
def reduce_regular(number):
    while is_regular_number(number):
        if number >= 10:
            number = split(number)
        else:
            break
    return number

# Function to calculate the sum of all snailfish numbers in the list
def calculate_sum_of_snailfish_numbers(snailfish_list):
    sum_of_snailfish_numbers = 0
    for snailfish_number in snailfish_list:
        while True:
            reduced_number = reduce_snailfish(snailfish_number)
            if reduced_number == snailfish_number:
                break
            snailfish_number = reduced_number
        sum_of_snailfish_numbers += reduced_number
    return sum_of_snailfish_numbers

# Converting the input data into a list of snailfish numbers
snailfish_list = []
for line in input_data:
    snailfish_list.append(eval(line.strip()))

# Calculating the sum of all snailfish numbers and finding the reduced result
result = calculate_sum_of_snailfish_numbers(snailfish_list)

# Printing the reduced result
print(result)",0.0
333,2021,18,2,part1_failed,,4731,,,
334,2021,19,1,runtime_error,,405,"Traceback (most recent call last):
  File ""/tmp/tmp5xsfmqin/tmp.py"", line 43, in <module>
    result = find_num_beacons(scanner_reports)
  File ""/tmp/tmp5xsfmqin/tmp.py"", line 17, in find_num_beacons
    x, y, z = map(int, beacon_coords[i:i+3])
ValueError: not enough values to unpack (expected 3, got 1)
","
import re

def find_num_beacons(scanner_reports):
    # Create a dictionary to store the coordinates of each beacon
    beacons = {}

    # Iterate through each scanner report
    for report in scanner_reports:
        # Extract the scanner number and beacon coordinates from the report
        scanner_num = int(re.findall(r'\d+', report)[0])
        beacon_coords = re.findall(r'-?\d+', report)

        # If it's the first scanner, add all the beacons to the dictionary
        if scanner_num == 0:
            for i in range(0, len(beacon_coords), 3):
                x, y, z = map(int, beacon_coords[i:i+3])
                beacons[(x, y, z)] = True
        else:
            # Create a temporary dictionary to store the overlapping beacons
            temp_beacons = {}

            # Check each beacon in the report
            for i in range(0, len(beacon_coords), 3):
                x, y, z = map(int, beacon_coords[i:i+3])
                beacon = (x, y, z)

                # If the beacon exists in the main dictionary, add it to the temporary dictionary
                if beacon in beacons:
                    temp_beacons[beacon] = True

            # Update the main dictionary with the overlapping beacons
            beacons = temp_beacons

    # Return the number of beacons in the map
    return len(beacons)

# Read the input from the file
with open('input.txt', 'r') as file:
    scanner_reports = file.read().splitlines()

# Call the function and print the result
result = find_num_beacons(scanner_reports)
print(result)
",0.0
335,2021,19,2,part1_failed,,12306,,,
336,2021,20,1,runtime_error,,5682,"Traceback (most recent call last):
  File ""/tmp/tmp7kb9i7on/tmp.py"", line 47, in <module>
    result = count_light_pixels(input_image)
  File ""/tmp/tmp7kb9i7on/tmp.py"", line 35, in count_light_pixels
    output_pixel = apply_pixel(row, col)
  File ""/tmp/tmp7kb9i7on/tmp.py"", line 26, in apply_pixel
    top_left, top_center, top_right, left, center, right, bottom_left, bottom_center, bottom_right = get_surrounding_pixels(row, col)
  File ""/tmp/tmp7kb9i7on/tmp.py"", line 21, in get_surrounding_pixels
    bottom_center = input_image[row+1][col] if row+1 < len(input_image) else None
IndexError: list index out of range
","
def count_light_pixels(input_image):
    def apply_algorithm(input_pixel, algorithm):
        binary = bin(ord(input_pixel))[2:].zfill(8)
        index = int(binary, 2)
        return algorithm[index]

    def get_surrounding_pixels(row, col):
        if row < 0 or col < 0:
            return None, None, None, None, None, None, None, None, None
        elif row >= len(input_image) or col >= len(input_image[0]):
            return None, None, None, None, None, None, None, None, None
        else:
            top_left = input_image[row-1][col-1] if row-1 >= 0 and col-1 >= 0 else None
            top_center = input_image[row-1][col] if row-1 >= 0 else None
            top_right = input_image[row-1][col+1] if row-1 >= 0 and col+1 < len(input_image[0]) else None
            left = input_image[row][col-1] if col-1 >= 0 else None
            center = input_image[row][col]
            right = input_image[row][col+1] if col+1 < len(input_image[0]) else None
            bottom_left = input_image[row+1][col-1] if row+1 < len(input_image) and col-1 >= 0 else None
            bottom_center = input_image[row+1][col] if row+1 < len(input_image) else None
            bottom_right = input_image[row+1][col+1] if row+1 < len(input_image) and col+1 < len(input_image[0]) else None
            return top_left, top_center, top_right, left, center, right, bottom_left, bottom_center, bottom_right

    def apply_pixel(row, col):
        top_left, top_center, top_right, left, center, right, bottom_left, bottom_center, bottom_right = get_surrounding_pixels(row, col)
        algorithm_output = apply_algorithm(center, algorithm)
        return algorithm_output

    algorithm = ""your_image_enhancement_algorithm_here""
    output_image = []
    for row in range(len(input_image)):
        output_row = []
        for col in range(len(input_image[row])):
            output_pixel = apply_pixel(row, col)
            output_row.append(output_pixel)
        output_image.append(output_row)

    count = sum([row.count(""#"") for row in output_image])
    return count

# Read input from file
with open(""input.txt"", ""r"") as file:
    input_image = [list(line.strip()) for line in file]

# Call the function and print the result
result = count_light_pixels(input_image)
print(result)
",0.0
337,2021,20,2,part1_failed,,17628,,,
338,2021,21,1,runtime_error,,504972,"Traceback (most recent call last):
  File ""/tmp/tmp3s2twi0_/tmp.py"", line 17, in <module>
    die_roll = random.randint(1, 100)
NameError: name 'random' is not defined
","# Parsing the input
with open('input.txt', 'r') as file:
    lines = file.readlines()

player_1_starting_position = int(lines[0].split(':')[1].strip())
player_2_starting_position = int(lines[1].split(':')[1].strip())

# Initializing variables
player_1_score = 0
player_2_score = 0
die_rolls = 0

# Game loop
while player_1_score < 1000 and player_2_score < 1000:
    # Rolling the die 3 times
    for _ in range(3):
        die_roll = random.randint(1, 100)
        die_rolls += 1
        
        # Moving player 1
        player_1_starting_position = (player_1_starting_position + die_roll) % 10
        player_1_score += player_1_starting_position
        
        # Moving player 2
        player_2_starting_position = (player_2_starting_position + die_roll) % 10
        player_2_score += player_2_starting_position

# Determining the losing player
if player_1_score >= 1000 and player_2_score >= 1000:
    losing_player_score = min(player_1_score, player_2_score)
elif player_1_score >= 1000:
    losing_player_score = player_2_score
else:
    losing_player_score = player_1_score

# Calculating the final result
final_result = losing_player_score * die_rolls

# Printing the final result
print(final_result)",0.0
339,2021,21,2,part1_failed,,446968027750017,,,
340,2021,22,1,runtime_error,,600458,"Traceback (most recent call last):
  File ""/tmp/tmp8os1aj00/tmp.py"", line 30, in <module>
    result = calculate_cubes_on(reboot_steps)
  File ""/tmp/tmp8os1aj00/tmp.py"", line 9, in calculate_cubes_on
    start, end = map(int, ranges.split('..'))
ValueError: invalid literal for int() with base 10: 'x=-17'
","from typing import List

def calculate_cubes_on(reboot_steps: List[str]) -> int:
    grid = [[[False for _ in range(101)] for _ in range(101)] for _ in range(101)]
    count = 0
    
    for step in reboot_steps:
        command, ranges = step.split(' ')
        start, end = map(int, ranges.split('..'))
        
        for x in range(start, end+1):
            for y in range(start, end+1):
                for z in range(start, end+1):
                    if command == 'on':
                        if not grid[x+50][y+50][z+50]:
                            grid[x+50][y+50][z+50] = True
                            count += 1
                    elif command == 'off':
                        if grid[x+50][y+50][z+50]:
                            grid[x+50][y+50][z+50] = False
                            count -= 1
    
    return count

# Read input from file
with open('input.txt', 'r') as file:
    reboot_steps = [line.strip() for line in file.readlines()]

# Calculate number of cubes turned on
result = calculate_cubes_on(reboot_steps)

# Print the result
print(result)",0.0
341,2021,22,2,part1_failed,,1334275219162622,,,
342,2021,23,1,runtime_error,,19019,"Traceback (most recent call last):
  File ""/tmp/tmpmb5p8tcy/tmp.py"", line 51, in <module>
    min_energy = min_energy_required(burrow)
  File ""/tmp/tmpmb5p8tcy/tmp.py"", line 10, in min_energy_required
    if burrow[i][j] in ['A', 'B', 'C', 'D']:
IndexError: list index out of range
","def min_energy_required(burrow):
    num_rows = len(burrow)
    num_cols = len(burrow[0])
    energy_cost = {'A': 1, 'B': 10, 'C': 100, 'D': 1000}
    
    # Find the starting positions of each type of amphipod
    start_positions = {'A': None, 'B': None, 'C': None, 'D': None}
    for i in range(num_rows):
        for j in range(num_cols):
            if burrow[i][j] in ['A', 'B', 'C', 'D']:
                start_positions[burrow[i][j]] = (i, j)
    
    # Initialize the total energy cost
    total_energy = 0
    
    # Move each amphipod to its corresponding side room
    for amphipod in ['A', 'B', 'C', 'D']:
        start_pos = start_positions[amphipod]
        target_col = ['A', 'B', 'C', 'D'].index(amphipod)
        
        # Perform a breadth-first search to find the shortest path to the target column
        queue = [(start_pos[0], start_pos[1], 0)]
        visited = set()
        while queue:
            row, col, energy = queue.pop(0)
            
            # Check if the current position is the target column
            if col == target_col:
                total_energy += energy
                break
            
            # Check if the current position is valid and unvisited
            if 0 <= row < num_rows and 0 <= col < num_cols and (row, col) not in visited:
                visited.add((row, col))
                
                # Check if the current position is an open space
                if burrow[row][col] == '.':
                    # Add the neighboring positions to the queue
                    queue.append((row-1, col, energy+energy_cost[amphipod]))  # Move up
                    queue.append((row+1, col, energy+energy_cost[amphipod]))  # Move down
                    queue.append((row, col-1, energy+energy_cost[amphipod]))  # Move left
                    queue.append((row, col+1, energy+energy_cost[amphipod]))  # Move right
    
    return total_energy

# Read the input from 'input.txt'
with open('input.txt', 'r') as file:
    burrow = [list(line.strip()) for line in file.readlines()]

# Find the minimum total energy required to organize the amphipods
min_energy = min_energy_required(burrow)

# Print the result
print(min_energy)",0.0
343,2021,23,2,part1_failed,,47533,,,
344,2021,24,1,runtime_error,,49917929934999,"Traceback (most recent call last):
  File ""/tmp/tmpf6wmzumk/tmp.py"", line 37, in <module>
    largest_valid_model_number = find_largest_valid_model_number(program)
  File ""/tmp/tmpf6wmzumk/tmp.py"", line 27, in find_largest_valid_model_number
    if is_valid_model_number(program, model_number):
TypeError: is_valid_model_number() takes 1 positional argument but 2 were given
","def is_valid_model_number(model_number):
    z = 0
    for instruction in model_number:
        op, a, b = instruction.split()
        if op == 'inp':
            # do nothing
            pass
        elif op == 'add':
            z = int(a) + int(b)
        elif op == 'mul':
            z = int(a) * int(b)
        elif op == 'div':
            z = int(a) // int(b)
        elif op == 'mod':
            z = int(a) % int(b)
        elif op == 'eql':
            if int(a) != int(b):
                z = 1
        else:
            return False
    return z == 0

def find_largest_valid_model_number(program):
    largest_valid_model_number = None
    for i in range(99999999999999, 0, -1):
        model_number = str(i).zfill(14)
        if is_valid_model_number(program, model_number):
            largest_valid_model_number = model_number
            break
    return largest_valid_model_number

program = []
with open('input.txt', 'r') as file:
    for line in file:
        program.append(line.strip())

largest_valid_model_number = find_largest_valid_model_number(program)
print(largest_valid_model_number)",0.0
345,2021,24,2,part1_failed,,11911316711816,,,
346,2021,25,1,syntax_error,,489,"  File ""/tmp/tmpc7mtct5t/tmp.py"", line 1
    ```python
    ^
SyntaxError: invalid syntax
","```python
def find_last_step(grid):
    rows = len(grid)
    cols = len(grid[0])
    step = 0

    while True:
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == "">"":
                    next_col = (col + 1) % cols
                    if grid[row][next_col] == ""."":
                        grid[row] = grid[row][:col] + ""."" + grid[row][col + 1:]
                        grid[row] = grid[row][:next_col] + "">"" + grid[row][next_col + 1:]
                elif grid[row][col] == ""v"":
                    next_row = (row + 1) % rows
                    if grid[next_row][col] == ""."":
                        grid[row] = grid[row][:col] + ""."" + grid[row][col + 1:]
                        grid[next_row] = grid[next_row][:col] + ""v"" + grid[next_row][col + 1:]
        
        if all(""."" in row for row in grid):
            return step
        
        step += 1",0.0
347,2021,25,2,part1_failed,,,,,
348,2022,1,1,no_error,70116,70116,,"with open('input.txt', 'r') as file:
    data = file.read().split('\n\n')

calories = []
for elf in data:
    calories.append(sum(map(int, elf.split())))

max_calories = max(calories)
print(f""The elf carrying the most calories is carrying {max_calories} calories."")",0.0
349,2022,1,2,no_error,206582,206582,,"with open('input.txt', 'r') as file:
    data = file.read().split('\n\n')

calories = []
for elf in data:
    calories.append(sum(map(int, elf.split())))

top_elves = sorted(calories, reverse=True)[:3]
total_calories_top_elves = sum(top_elves)
print(f""The top three elves are carrying a total of {total_calories_top_elves} calories."")",0.0
350,2022,2,1,wrong_output,"3846
",12276,,"# Read the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Initialize the total score
total_score = 0

# Iterate over each line in the input
for line in lines:
    # Extract the opponent's move and your recommended move
    opponent_move, recommended_move = line.split()

    # Determine the score for the round based on the moves
    if opponent_move == 'A' and recommended_move == 'X':
        score = 2
    elif opponent_move == 'B' and recommended_move == 'Y':
        score = 2
    elif opponent_move == 'C' and recommended_move == 'Z':
        score = 2
    elif opponent_move == 'A' and recommended_move == 'Z':
        score = 1
    elif opponent_move == 'B' and recommended_move == 'X':
        score = 1
    elif opponent_move == 'C' and recommended_move == 'Y':
        score = 1
    else:
        score = 0

    # Add the score to the total score
    total_score += score

# Print the total score
print(total_score)",0.0
351,2022,2,2,part1_failed,,9975,,,
352,2022,3,1,wrong_output,"3762
",8053,,"
def find_misplaced_items(rucksacks):
    priorities = {
        'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13,
        'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25,
        'z': 26, 'A': 27, 'B': 28, 'C': 29, 'D': 30, 'E': 31, 'F': 32, 'G': 33, 'H': 34, 'I': 35, 'J': 36, 'K': 37,
        'L': 38, 'M': 39, 'N': 40, 'O': 41, 'P': 42, 'Q': 43, 'R': 44, 'S': 45, 'T': 46, 'U': 47, 'V': 48, 'W': 49,
        'X': 50, 'Y': 51, 'Z': 52
    }
    misplaced_items = []
    for rucksack in rucksacks:
        compartment1 = rucksack[0]
        compartment2 = rucksack[1]
        misplaced_item = """"
        for item in compartment1:
            if item in compartment2:
                misplaced_item = item
                break
        misplaced_items.append(misplaced_item)
    priority_sum = sum(priorities[item] for item in misplaced_items)
    return priority_sum

# Read input from file
with open('input.txt', 'r') as file:
    rucksacks = []
    lines = file.readlines()
    for i in range(0, len(lines), 2):
        compartment1 = lines[i].strip()
        compartment2 = lines[i+1].strip()
        rucksack = (compartment1, compartment2)
        rucksacks.append(rucksack)

# Call the function and print the result
result = find_misplaced_items(rucksacks)
print(result)
",0.0
353,2022,3,2,part1_failed,,2425,,,
354,2022,4,1,no_error,"441
",441,,"with open(""input.txt"", ""r"") as f:
    input_data = f.read()

assignment_pairs = input_data.split('\n')
assignment_pairs = [pair.split(',') for pair in assignment_pairs]

def count_contained_pairs(assignment_pairs):
    count = 0
    for pair in assignment_pairs:
        range1, range2 = pair[0].split('-'), pair[1].split('-')
        start1, end1 = int(range1[0]), int(range1[1])
        start2, end2 = int(range2[0]), int(range2[1])
        
        if (start1 >= start2 and end1 <= end2) or (start2 >= start1 and end2 <= end1):
            count += 1
    
    return count

result = count_contained_pairs(assignment_pairs)
print(result)",0.0
355,2022,4,2,no_error,"861
",861,,"with open(""input.txt"", ""r"") as f:
    input_data = f.read()

assignment_pairs = input_data.split('\n')
assignment_pairs = [pair.split(',') for pair in assignment_pairs]

def count_overlapping_pairs(assignment_pairs):
    count = 0
    for pair in assignment_pairs:
        range1, range2 = pair[0].split('-'), pair[1].split('-')
        start1, end1 = int(range1[0]), int(range1[1])
        start2, end2 = int(range2[0]), int(range2[1])
        
        if start1 <= end2 and start2 <= end1:
            count += 1
    
    return count

result = count_overlapping_pairs(assignment_pairs)
print(result)",0.0
356,2022,5,1,syntax_error,,FCVRLMVQP,"  File ""/tmp/tmpttvhf9dv/tmp.py"", line 2
    1. Read the input file to get the initial configuration of the stacks and the rearrangement steps.
       ^
SyntaxError: invalid syntax
","## Plan
1. Read the input file to get the initial configuration of the stacks and the rearrangement steps.
2. Create a dictionary to represent the stacks, where the keys are the stack numbers and the values are lists representing the crates in each stack.
3. Iterate over the rearrangement steps and update the stacks dictionary accordingly.
4. After all the rearrangement steps are applied, get the top crate from each stack.
5. Combine the top crates into a single string and return it.

Let's implement this plan in the code.",0.0
357,2022,5,2,part1_failed,,RWLWGJGFD,,,
358,2022,6,1,no_error,"1109
",1109,,"f = open(""input.txt"", ""r"")
buffer = f.read()

def find_start_of_packet(buffer):
    for i in range(len(buffer) - 3):
        if buffer[i] != buffer[i+1] and buffer[i] != buffer[i+2] and buffer[i] != buffer[i+3] and buffer[i+1] != buffer[i+2] and buffer[i+1] != buffer[i+3] and buffer[i+2] != buffer[i+3]:
            return i+4
    return -1

position = find_start_of_packet(buffer)
print(position)",0.0
359,2022,6,2,wrong_output,"1109
3965
",3965,,"f = open(""input.txt"", ""r"")
buffer = f.read()

def find_start_of_packet(buffer):
    for i in range(len(buffer) - 3):
        if buffer[i] != buffer[i+1] and buffer[i] != buffer[i+2] and buffer[i] != buffer[i+3] and buffer[i+1] != buffer[i+2] and buffer[i+1] != buffer[i+3] and buffer[i+2] != buffer[i+3]:
            return i+4
    return -1

def find_start_of_message(buffer):
    for i in range(len(buffer) - 13):
        if len(set(buffer[i:i+14])) == 14:
            return i+14
    return -1

start_of_packet_position = find_start_of_packet(buffer)
start_of_message_position = find_start_of_message(buffer)

print(start_of_packet_position)
print(start_of_message_position)",0.0
360,2022,7,1,timeout_error,,1443806,TIMEOUT,"
import sys

class Directory:
    def __init__(self, name):
        self.name = name
        self.subdirectories = []
        self.files = []

    def add_subdirectory(self, directory):
        self.subdirectories.append(directory)

    def add_file(self, file):
        self.files.append(file)

    def get_total_size(self):
        total_size = 0
        for file in self.files:
            total_size += file.size
        for directory in self.subdirectories:
            total_size += directory.get_total_size()
        return total_size

    def find_directories_with_total_size(self, max_size):
        directories = []
        if self.get_total_size() <= max_size:
            directories.append(self)
        for directory in self.subdirectories:
            directories.extend(directory.find_directories_with_total_size(max_size))
        return directories

class File:
    def __init__(self, name, size):
        self.name = name
        self.size = size

def parse_input():
    root_directory = Directory('/')
    current_directory = root_directory

    for line in sys.stdin:
        line = line.strip()
        if line.startswith('$ cd '):
            directory_name = line[5:]
            new_directory = Directory(directory_name)
            current_directory.add_subdirectory(new_directory)
            current_directory = new_directory
        elif line.startswith('$ ls'):
            current_directory.add_file(File(line[4:], 0))
        elif line.isdigit():
            current_directory.files[-1].size = int(line)
        elif line.startswith('dir'):
            current_directory.name = line[4:]

    return root_directory

def main():
    root_directory = parse_input()
    directories = root_directory.find_directories_with_total_size(100000)
    total_size = sum(directory.get_total_size() for directory in directories)
    print(total_size)

if __name__ == '__main__':
    main()
",0.0
361,2022,7,2,part1_failed,,942298,,,
362,2022,8,1,wrong_output,"0
",1807,,"# Function to count the visible trees in the grid
def count_visible_trees(grid):
    # Convert the string grid into a list of lists
    grid = grid.strip().split('\n')
    grid = [list(row) for row in grid]

    # Get the number of rows and columns in the grid
    rows = len(grid)
    cols = len(grid[0])

    # Initialize the count of visible trees to 0
    visible_trees = 0

    # Iterate over each tree in the grid
    for i in range(rows):
        for j in range(cols):
            # Get the current tree height
            current_height = int(grid[i][j])

            # Check if the current tree is visible
            visible = True

            # Check for trees above the current tree
            for k in range(i-1, -1, -1):
                if int(grid[k][j]) >= current_height:
                    visible = False
                    break

            # Check for trees below the current tree
            for k in range(i+1, rows):
                if int(grid[k][j]) >= current_height:
                    visible = False
                    break

            # Check for trees to the left of the current tree
            for k in range(j-1, -1, -1):
                if int(grid[i][k]) >= current_height:
                    visible = False
                    break

            # Check for trees to the right of the current tree
            for k in range(j+1, cols):
                if int(grid[i][k]) >= current_height:
                    visible = False
                    break

            # If the current tree is visible, increment the count
            if visible:
                visible_trees += 1

    # Return the count of visible trees
    return visible_trees

# Read the input from the file
with open('input.txt', 'r') as file:
    grid = file.read()

# Call the function to count the visible trees
result = count_visible_trees(grid)

# Print the result
print(result)",0.0
363,2022,8,2,part1_failed,,480000,,,
364,2022,9,1,wrong_output,"1404
",6087,,"# Read the input from the file
with open('input.txt', 'r') as file:
    motions = file.readlines()

# Initialize the head and tail positions
head = (0, 0)
tail = (0, 0)

# Initialize a set to store the visited positions
visited_positions = set()

# Loop through each motion
for motion in motions:
    direction, steps = motion.strip().split()
    steps = int(steps)

    # Update the head position based on the motion
    if direction == 'U':
        head = (head[0], head[1] + steps)
    elif direction == 'D':
        head = (head[0], head[1] - steps)
    elif direction == 'L':
        head = (head[0] - steps, head[1])
    elif direction == 'R':
        head = (head[0] + steps, head[1])

    # Update the tail position based on the head position
    if head[0] == tail[0]:
        # Head and tail are in the same column
        if head[1] > tail[1]:
            tail = (tail[0], tail[1] + 1)
        elif head[1] < tail[1]:
            tail = (tail[0], tail[1] - 1)
    elif head[1] == tail[1]:
        # Head and tail are in the same row
        if head[0] > tail[0]:
            tail = (tail[0] + 1, tail[1])
        elif head[0] < tail[0]:
            tail = (tail[0] - 1, tail[1])
    else:
        # Head and tail are not in the same row or column
        if head[0] > tail[0]:
            tail = (tail[0] + 1, tail[1] + 1)
        elif head[0] < tail[0]:
            tail = (tail[0] - 1, tail[1] - 1)

    # Add the tail position to the set of visited positions
    visited_positions.add(tail)

# Print the number of distinct positions visited by the tail
print(len(visited_positions))",0.0
365,2022,9,2,part1_failed,,2493,,,
366,2022,10,1,syntax_error,,15360,"  File ""/tmp/tmpbdsnabr_/tmp.py"", line 3
    1. Read the instructions from the input file.
       ^
SyntaxError: invalid syntax
","# Plan

1. Read the instructions from the input file.
2. Initialize the register X to 1.
3. Initialize the cycle number to 1.
4. Iterate through the instructions and perform the corresponding actions.
5. For `addx V` instruction, increment the cycle number by 2 and add V to register X.
6. For `noop` instruction, increment the cycle number by 1.
7. Calculate the signal strength at the specified cycles.
8. Calculate the sum of the signal strengths.
9. Print the sum as the final answer.

# Code",0.0
367,2022,10,2,part1_failed,,PHLHJGZA,,,
368,2022,11,1,runtime_error,,69918,"Traceback (most recent call last):
  File ""/tmp/tmpp169s6wb/tmp.py"", line 17, in <module>
    starting_items = list(map(int, line[1].strip().split(',')))
ValueError: invalid literal for int() with base 10: ''
","# Read input from file
file = open('input.txt', 'r')
lines = file.readlines()

# Initialize dictionary to store monkey attributes
monkeys = {}

# Loop through each line and parse monkey attributes
for i in range(len(lines)):
    # Remove leading/trailing whitespaces and split line by colon
    line = lines[i].strip().split(':')
    
    # Extract monkey index from line
    monkey_index = int(line[0].split()[1])
    
    # Extract starting items from line and convert to list of integers
    starting_items = list(map(int, line[1].strip().split(',')))
    
    # Extract operation from line
    operation = line[2].strip()
    
    # Extract test from line
    test = line[3].strip()
    
    # Extract throw destinations from line and convert to list of integers
    throw_destinations = list(map(int, line[4].strip().split(',')))
    
    # Create dictionary to store monkey attributes
    monkey = {
        'starting_items': starting_items,
        'operation': operation,
        'test': test,
        'throw_destinations': throw_destinations,
        'inspection_count': 0
    }
    
    # Add monkey to dictionary
    monkeys[monkey_index] = monkey

# Close file
file.close()

# Function to calculate worry level after inspection
def calculate_worry_level(old_level, operation):
    if operation.startswith('new = old *'):
        k = int(operation.split('*')[1].strip())
        new_level = old_level * k
    elif operation.startswith('new = old +'):
        k = int(operation.split('+')[1].strip())
        new_level = old_level + k
    return new_level

# Function to check if worry level is divisible by k
def is_divisible(worry_level, k):
    return worry_level % k == 0

# Function to find throw destination based on test result
def find_throw_destination(test_result, throw_destinations):
    if test_result:
        return throw_destinations[0]
    else:
        return throw_destinations[1]

# Function to perform monkey business for 20 rounds
def perform_monkey_business(monkeys):
    # Initialize counts dictionary to store inspection counts for each monkey
    counts = {}
    
    # Loop for 20 rounds
    for round in range(20):
        # Loop through each monkey
        for monkey_index in monkeys:
            # Get monkey attributes
            monkey = monkeys[monkey_index]
            
            # Get starting items
            items = monkey['starting_items']
            
            # Loop through each item
            for item in items:
                # Increment inspection count for monkey
                monkey['inspection_count'] += 1
                
                # Calculate new worry level
                new_level = calculate_worry_level(item, monkey['operation'])
                
                # Divide worry level by 3
                new_level = new_level // 3
                
                # Check if worry level is divisible by test value
                test_result = is_divisible(new_level, int(monkey['test'].split()[2]))
                
                # Find throw destination based on test result
                throw_destination = find_throw_destination(test_result, monkey['throw_destinations'])
                
                # Add item to throw destination's starting items
                monkeys[throw_destination]['starting_items'].append(new_level)
    
    # Loop through each monkey and count inspections
    for monkey_index in monkeys:
        monkey = monkeys[monkey_index]
        counts[monkey_index] = monkey['inspection_count']
    
    # Sort counts in descending order
    sorted_counts = sorted(counts.items(), key=lambda x: x[1], reverse=True)
    
    # Multiply counts of two most active monkeys
    monkey_business = sorted_counts[0][1] * sorted_counts[1][1]
    
    # Return monkey business
    return monkey_business

# Call perform_monkey_business function and print result
result = perform_monkey_business(monkeys)
print(result)",0.0
369,2022,11,2,part1_failed,,19573408701,,,
370,2022,12,1,wrong_output,"-1
",504,,"
def find_best_signal_steps(heightmap):
    rows = len(heightmap)
    cols = len(heightmap[0])

    # Find the starting position and the destination
    start = None
    destination = None
    for i in range(rows):
        for j in range(cols):
            if heightmap[i][j] == 'S':
                start = (i, j)
            elif heightmap[i][j] == 'E':
                destination = (i, j)

    # Use BFS to find the fewest steps required
    queue = [(start, 0)]
    visited = set([start])
    while queue:
        position, steps = queue.pop(0)
        if position == destination:
            return steps
        row, col = position
        elevation = ord(heightmap[row][col]) - ord('a')
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            new_row, new_col = row + dx, col + dy
            if 0 <= new_row < rows and 0 <= new_col < cols:
                new_elevation = ord(heightmap[new_row][new_col]) - ord('a')
                if new_elevation <= elevation + 1 and (new_row, new_col) not in visited:
                    queue.append(((new_row, new_col), steps + 1))
                    visited.add((new_row, new_col))

    return -1  # If no path found

# Read input from file
with open('input.txt', 'r') as file:
    heightmap = [line.strip() for line in file]

# Find the fewest steps required
steps = find_best_signal_steps(heightmap)
print(steps)
",0.0
371,2022,12,2,part1_failed,,500,,,
372,2022,13,1,runtime_error,,5503,"Traceback (most recent call last):
  File ""/tmp/tmpuq7exfbb/tmp.py"", line 37, in <module>
    if compare_packets(packet1, packet2):
  File ""/tmp/tmpuq7exfbb/tmp.py"", line 15, in compare_packets
    return value1 < value2
TypeError: '<' not supported between instances of 'int' and 'list'
","# Reading the input from file
with open('input.txt', 'r') as input_file:
    input_data = input_file.read().split('\n\n')

# Function to compare two packets
def compare_packets(packet1, packet2):
    # If both packets are integers, compare them directly
    if isinstance(packet1, int) and isinstance(packet2, int):
        return packet1 < packet2
    
    # If both packets are lists, compare the values in each list
    elif isinstance(packet1, list) and isinstance(packet2, list):
        for value1, value2 in zip(packet1, packet2):
            if value1 != value2:
                return value1 < value2
        # If all values are equal, compare the lengths of the lists
        return len(packet1) < len(packet2)
    
    # If one packet is an integer and the other is a list, convert the integer to a list and retry the comparison
    elif isinstance(packet1, int):
        return compare_packets([packet1], packet2)
    elif isinstance(packet2, int):
        return compare_packets(packet1, [packet2])
    
    # If the types of the packets are not supported, return False
    else:
        return False

# Count the number of pairs in the right order
count = 0
for pair in input_data:
    packets = pair.split('\n')
    if len(packets) != 2:
        continue
    packet1 = eval(packets[0])
    packet2 = eval(packets[1])
    if compare_packets(packet1, packet2):
        count += 1

# Print the result
print(count)",0.0
373,2022,13,2,part1_failed,,20952,,,
374,2022,14,1,wrong_output,,825,,"def simulate_falling_sand(scan):
    # Initialize the cave with air
    cave = [['.' for _ in range(max([int(coord.split(',')[0]) for coord in line.split(' -> ')]) + 1)] for line in scan]
    
    # Draw the rock structures in the cave
    for i, line in enumerate(scan):
        coords = line.split(' -> ')
        for j in range(len(coords)-1):
            x1, y1 = map(int, coords[j].split(','))
            x2, y2 = map(int, coords[j+1].split(','))
            if x1 == x2:
                for y in range(min(y1, y2), max(y1, y2)+1):
                    cave[i][x1] = '#'
            elif y1 == y2:
                for x in range(min(x1, x2), max(x1, x2)+1):
                    cave[i][x] = '#'
    
    # Simulate the falling sand
    count = 0
    sand = []
    while True:
        new_sand = []
        for x, y in sand:
            # Check if sand can fall down
            if y+1 < len(cave) and cave[y+1][x] == '.':
                cave[y][x] = '.'
                y += 1
                if y == len(cave) - 1:
                    return count
                if cave[y][x] == '.':
                    cave[y][x] = 'o'
                    new_sand.append((x, y))
            # Check if sand can fall down and to the left
            elif y+1 < len(cave) and x-1 >= 0 and cave[y+1][x-1] == '.':
                cave[y][x] = '.'
                x -= 1
                y += 1
                if y == len(cave) - 1:
                    return count
                if cave[y][x] == '.':
                    cave[y][x] = 'o'
                    new_sand.append((x, y))
            # Check if sand can fall down and to the right
            elif y+1 < len(cave) and x+1 < len(cave[y+1]) and cave[y+1][x+1] == '.':
                cave[y][x] = '.'
                x += 1
                y += 1
                if y == len(cave) - 1:
                    return count
                if cave[y][x] == '.':
                    cave[y][x] = 'o'
                    new_sand.append((x, y))
        if not new_sand:
            count += len(sand)
            sand = [(x, 0) for x in range(len(cave[0]))]
        else:
            sand = new_sand",0.0
375,2022,14,2,part1_failed,,26729,,,
376,2022,15,1,timeout_error,,4861076,TIMEOUT,"# Read the input file
with open('input.txt', 'r') as file:
    input_data = file.readlines()

# Initialize a dictionary to store the positions of the closest beacons
beacon_positions = {}

# Iterate through each line of input data
for line in input_data:
    # Extract the coordinates of the sensor and the closest beacon
    sensor_x = int(line.split('x=')[1].split(',')[0])
    sensor_y = int(line.split('y=')[1].split(':')[0])
    beacon_x = int(line.split('x=')[2].split(',')[0])
    beacon_y = int(line.split('y=')[2].split(':')[0])
    
    # Add the position of the closest beacon to the dictionary
    beacon_positions[(beacon_x, beacon_y)] = True

# Initialize a variable to count the number of positions without beacons
positions_without_beacons = 0

# Iterate through each row
for y in range(1, max([pos[1] for pos in beacon_positions.keys()]) + 1):
    # Check each position in the row
    for x in range(1, max([pos[0] for pos in beacon_positions.keys()]) + 1):
        # If the position is not in the dictionary, increment the count
        if (x, y) not in beacon_positions:
            positions_without_beacons += 1

# Print the number of positions without beacons
print(positions_without_beacons)",0.0
377,2022,15,2,part1_failed,,10649103160102,,,
378,2022,16,1,runtime_error,,2080,"Traceback (most recent call last):
  File ""/tmp/tmp58my8ry5/tmp.py"", line 45, in <module>
    main()
  File ""/tmp/tmp58my8ry5/tmp.py"", line 39, in main
    valves, time_frame = parse_input(input_str)
  File ""/tmp/tmp58my8ry5/tmp.py"", line 30, in parse_input
    time_frame = int(valves.pop(0))
ValueError: invalid literal for int() with base 10: 'Valve TB has flow rate=20; tunnel leads to valve DN'
","from collections import defaultdict

def calculate_max_pressure(valves, time_frame):
    max_pressure = 0
    visited = set()
    for valve in valves:
        max_pressure = max(max_pressure, dfs(valve, valves, visited, time_frame))
    return max_pressure

def dfs(valve, valves, visited, time_frame):
    if time_frame <= 0 or valve in visited:
        return 0
    visited.add(valve)
    flow_rate, tunnels = parse_valve(valve)
    max_pressure = flow_rate
    for tunnel in tunnels:
        max_pressure = max(max_pressure, flow_rate + dfs(tunnel, valves, visited, time_frame - 1))
    visited.remove(valve)
    return max_pressure

def parse_valve(valve):
    name, properties = valve.split(' has flow rate=')
    flow_rate, tunnels = properties.split('; tunnels lead to valves ')
    flow_rate = int(flow_rate)
    tunnels = tunnels.split(',')
    return flow_rate, tunnels

def parse_input(input_str):
    valves = input_str.strip().split('\n')
    time_frame = int(valves.pop(0))
    return valves, time_frame

def format_output(output):
    return str(output)

def main():
    with open('input.txt', 'r') as file:
        input_str = file.read()
    valves, time_frame = parse_input(input_str)
    max_pressure = calculate_max_pressure(valves, time_frame)
    output_str = format_output(max_pressure)
    print(output_str)

if __name__ == '__main__':
    main()",0.0
379,2022,16,2,part1_failed,,2752,,,
380,2022,17,1,timeout_error,,3235,TIMEOUT,"
def final_height(jet_pattern, num_rocks):
    tower = [1] * num_rocks
    for i in range(num_rocks):
        if jet_pattern[i] == '<' and i > 0:
            if tower[i-1] == 0:
                tower[i] = 0
            else:
                tower[i] = tower[i-1] - 1
        elif jet_pattern[i] == '>' and i < num_rocks-1:
            if tower[i+1] == 0:
                tower[i] = 0
            else:
                tower[i] = tower[i+1] - 1
    return sum(tower)

jet_pattern = input()
num_rocks = int(input())
print(final_height(jet_pattern, num_rocks))
",0.0
381,2022,17,2,part1_failed,,1591860465110,,,
382,2022,18,1,no_error,"4310
",4310,,"# Read the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Initialize the grid as an empty dictionary
grid = {}

# Iterate over each line of input
for line in lines:
    # Split the line into x, y, and z coordinates
    x, y, z = map(int, line.strip().split(','))

    # Add the cube to the grid dictionary
    grid[(x, y, z)] = True

# Define a helper function to check if a cube has a neighbor in a given direction
def has_neighbor(x, y, z, dx, dy, dz):
    return (x+dx, y+dy, z+dz) in grid

# Initialize the surface area counter
surface_area = 0

# Iterate over each cube in the grid
for x, y, z in grid.keys():
    # Check the number of exposed sides for each cube
    sides = 6
    if has_neighbor(x, y, z, 1, 0, 0):
        sides -= 1
    if has_neighbor(x, y, z, -1, 0, 0):
        sides -= 1
    if has_neighbor(x, y, z, 0, 1, 0):
        sides -= 1
    if has_neighbor(x, y, z, 0, -1, 0):
        sides -= 1
    if has_neighbor(x, y, z, 0, 0, 1):
        sides -= 1
    if has_neighbor(x, y, z, 0, 0, -1):
        sides -= 1

    # Add the number of exposed sides to the surface area
    surface_area += sides

# Print the surface area
print(surface_area)",0.0
383,2022,18,2,wrong_output,"7696
",2466,,"# Read the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Initialize the grid as an empty dictionary
grid = {}

# Iterate over each line of input
for line in lines:
    # Split the line into x, y, and z coordinates
    x, y, z = map(int, line.strip().split(','))

    # Add the cube to the grid dictionary
    grid[(x, y, z)] = True

# Define a helper function to check if a cube has a neighbor in a given direction
def has_neighbor(x, y, z, dx, dy, dz):
    return (x+dx, y+dy, z+dz) in grid

# Initialize the surface area counter
surface_area = 0

# Iterate over each cube in the grid
for x, y, z in grid.keys():
    # Check if the cube is surrounded by other cubes on all six sides
    if (
        has_neighbor(x, y, z, 1, 0, 0) and
        has_neighbor(x, y, z, -1, 0, 0) and
        has_neighbor(x, y, z, 0, 1, 0) and
        has_neighbor(x, y, z, 0, -1, 0) and
        has_neighbor(x, y, z, 0, 0, 1) and
        has_neighbor(x, y, z, 0, 0, -1)
    ):
        # Skip if the cube is surrounded on all sides
        continue

    # Check the number of exposed sides for each cube
    sides = 6
    if not has_neighbor(x, y, z, 1, 0, 0):
        sides -= 1
    if not has_neighbor(x, y, z, -1, 0, 0):
        sides -= 1
    if not has_neighbor(x, y, z, 0, 1, 0):
        sides -= 1
    if not has_neighbor(x, y, z, 0, -1, 0):
        sides -= 1
    if not has_neighbor(x, y, z, 0, 0, 1):
        sides -= 1
    if not has_neighbor(x, y, z, 0, 0, -1):
        sides -= 1

    # Add the number of exposed sides to the surface area
    surface_area += sides

# Print the surface area
print(surface_area)",0.0
384,2022,19,1,runtime_error,,1613,"Traceback (most recent call last):
  File ""/tmp/tmp_5cksjmm/tmp.py"", line 39, in <module>
    result = maximize_geodes(blueprints)
  File ""/tmp/tmp_5cksjmm/tmp.py"", line 7, in maximize_geodes
    ore_cost = int(resources[0])
ValueError: invalid literal for int() with base 10: 'Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.'
","def maximize_geodes(blueprints):
    max_geodes = 0
    max_blueprint = """"

    for blueprint in blueprints:
        resources = blueprint.split("","")
        ore_cost = int(resources[0])
        clay_cost = int(resources[1])
        obsidian_cost = int(resources[2])
        geode_cost = int(resources[3])

        ore_robots = 0
        clay_robots = 0
        obsidian_robots = 0
        geode_robots = 0

        for i in range(24):
            if i % (ore_cost + clay_cost + obsidian_cost + geode_cost) < ore_cost:
                ore_robots += 1
            elif i % (ore_cost + clay_cost + obsidian_cost + geode_cost) < ore_cost + clay_cost:
                clay_robots += 1
            elif i % (ore_cost + clay_cost + obsidian_cost + geode_cost) < ore_cost + clay_cost + obsidian_cost:
                obsidian_robots += 1
            else:
                geode_robots += 1

        geodes = min(ore_robots, clay_robots, obsidian_robots, geode_robots)

        if geodes > max_geodes:
            max_geodes = geodes
            max_blueprint = blueprint

    return max_blueprint

# Read input from file
with open('input.txt', 'r') as file:
    blueprints = [line.strip() for line in file]

result = maximize_geodes(blueprints)
print(result)",0.0
385,2022,19,2,part1_failed,,46816,,,
386,2022,20,1,wrong_output,"-19991
",18257,,"with open('input.txt', 'r') as file:
    numbers = [int(line.strip()) for line in file]

current_index = 0
sum_1000th = 0
sum_2000th = 0
sum_3000th = 0

for i in range(1, 3001):
    current_index = (current_index + numbers[current_index]) % len(numbers)
    if i % 1000 == 0:
        if i == 1000:
            sum_1000th = numbers[current_index]
        elif i == 2000:
            sum_2000th = numbers[current_index]
        else:
            sum_3000th = numbers[current_index]

result = sum_1000th + sum_2000th + sum_3000th
print(result)",0.0
387,2022,20,2,part1_failed,,4148032160983,,,
388,2022,21,1,runtime_error,,118565889858886,"Traceback (most recent call last):
  File ""/tmp/tmpftvccier/tmp.py"", line 36, in <module>
    result = calculate(root, monkeys)
  File ""/tmp/tmpftvccier/tmp.py"", line 24, in calculate
    numbers[monkey] = numbers[num1] / numbers[num2]
ZeroDivisionError: division by zero
","from collections import defaultdict

def calculate(root, monkeys):
    # Create a dictionary to store the numbers yelled by each monkey
    numbers = defaultdict(int)
    
    # Iterate through each monkey in the list
    for monkey, job in monkeys:
        # If the job is a number, store it in the dictionary
        if job.isdigit():
            numbers[monkey] = int(job)
        # If the job is a math operation, perform the operation
        elif '+' in job:
            num1, num2 = job.split('+')
            numbers[monkey] = numbers[num1] + numbers[num2]
        elif '-' in job:
            num1, num2 = job.split('-')
            numbers[monkey] = numbers[num1] - numbers[num2]
        elif '*' in job:
            num1, num2 = job.split('*')
            numbers[monkey] = numbers[num1] * numbers[num2]
        elif '/' in job:
            num1, num2 = job.split('/')
            numbers[monkey] = numbers[num1] / numbers[num2]
        # If the job is a waiting operation, skip it
        
    # Return the number yelled by the root monkey
    return numbers[root]

# Read the input from the file
with open('input.txt', 'r') as file:
    # Extract the root monkey and the list of monkeys and their jobs
    root, *monkeys = [line.strip().split(':') for line in file.readlines()]
    
# Call the calculate function to determine the number yelled by the root monkey
result = calculate(root, monkeys)

# Print the result
print(result)",0.0
389,2022,21,2,part1_failed,,3032671800353,,,
390,2022,22,1,wrong_output,,93226,,"def unfold_map(map_str):
    map_faces = [map_str[i:i + 2500] for i in range(0, len(map_str), 2500)]
    current_face = 0
    row = 0
    col = 0
    facing = ""right""

    for instruction in path:
        if instruction.isdigit():
            steps = int(instruction)
            if facing == ""up"":
                for _ in range(steps):
                    row -= 1
                    if row < 0:
                        row = 49
                        current_face = (current_face + 3) % 6
                    if map_faces[current_face][row * 50 + col] == ""#"":
                        break
            elif facing == ""down"":
                for _ in range(steps):
                    row += 1
                    if row >= 50:
                        row = 0
                        current_face = (current_face + 3) % 6
                    if map_faces[current_face][row * 50 + col] == ""#"":
                        break
            elif facing == ""left"":
                for _ in range(steps):
                    col -= 1
                    if col < 0:
                        col = 49
                        current_face = (current_face + 3) % 6
                    if map_faces[current_face][row * 50 + col] == ""#"":
                        break
            elif facing == ""right"":
                for _ in range(steps):
                    col += 1
                    if col >= 50:
                        col = 0
                        current_face = (current_face + 3) % 6
                    if map_faces[current_face][row * 50 + col] == ""#"":
                        break
        elif instruction == ""R"":
            if facing == ""up"":
                facing = ""right""
            elif facing == ""right"":
                facing = ""down""
            elif facing == ""down"":
                facing = ""left""
            elif facing == ""left"":
                facing = ""up""
        elif instruction == ""L"":
            if facing == ""up"":
                facing = ""left""
            elif facing == ""left"":
                facing = ""down""
            elif facing == ""down"":
                facing = ""right""
            elif facing == ""right"":
                facing = ""up""

    password = 1000 * row + 4 * col + [""up"", ""right"", ""down"", ""left""].index(facing)
    return row, col, facing, password",0.0
391,2022,22,2,part1_failed,,37415,,,
392,2022,23,1,wrong_output,"2696
",4109,,"from copy import deepcopy

def count_empty_ground(grid):
    num_rounds = 10
    num_rows = len(grid)
    num_cols = len(grid[0])

    for _ in range(num_rounds):
        new_grid = deepcopy(grid)
        moves = []

        for i in range(num_rows):
            for j in range(num_cols):
                if grid[i][j] == '#':
                    valid_moves = get_valid_moves(i, j, num_rows, num_cols)
                    move = choose_move(valid_moves, grid)
                    if move:
                        moves.append(move)

        for move in moves:
            i, j, new_i, new_j = move
            if grid[new_i][new_j] != '#':
                new_grid[new_i][new_j] = '#'
                new_grid[i][j] = '.'

        grid = new_grid

    min_row = num_rows
    max_row = 0
    min_col = num_cols
    max_col = 0

    for i in range(num_rows):
        for j in range(num_cols):
            if grid[i][j] == '#':
                min_row = min(min_row, i)
                max_row = max(max_row, i)
                min_col = min(min_col, j)
                max_col = max(max_col, j)

    empty_ground_count = 0

    for i in range(min_row, max_row + 1):
        for j in range(min_col, max_col + 1):
            if grid[i][j] == '.':
                empty_ground_count += 1

    return empty_ground_count

def get_valid_moves(i, j, num_rows, num_cols):
    valid_moves = []

    if i > 0:
        valid_moves.append((i, j, i - 1, j))
    if i < num_rows - 1:
        valid_moves.append((i, j, i + 1, j))
    if j > 0:
        valid_moves.append((i, j, i, j - 1))
    if j < num_cols - 1:
        valid_moves.append((i, j, i, j + 1))

    return valid_moves

def choose_move(valid_moves, grid):
    for move in valid_moves:
        i, j, new_i, new_j = move
        if grid[new_i][new_j] == '#':
            return None

    return valid_moves[0]

# Read input from file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# Parse grid
grid = [list(line.strip()) for line in lines]

# Count empty ground after 10 rounds
empty_ground_count = count_empty_ground(grid)

print(empty_ground_count)",0.0
393,2022,23,2,part1_failed,,1055,,,
394,2022,24,1,wrong_output,"The shortest path exists.
",279,,"
# Read the input from the file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Remove the trailing newline character from each line
lines = [line.strip() for line in lines]

# Get the dimensions of the valley
num_rows = len(lines)
num_columns = len(lines[0])

# Create a 2D matrix to represent the valley
valley = [[0] * num_columns for _ in range(num_rows)]

# Populate the valley matrix based on the input
for i in range(num_rows):
    for j in range(num_columns):
        valley[i][j] = lines[i][j]

# Function to check if a position is out of bounds
def is_out_of_bounds(row, col):
    return row < 0 or row >= num_rows or col < 0 or col >= num_columns

# Function to check if a position is a blizzard
def is_blizzard(row, col):
    return valley[row][col] in ['^', 'v', '<', '>']

# Function to check if a position is safe
def is_safe(row, col):
    if is_out_of_bounds(row, col) or is_blizzard(row, col):
        return False
    return True

# Function to find the shortest path to the bottom row
def shortest_path():
    # Initialize a queue for breadth-first search
    queue = []

    # Initialize a visited matrix to keep track of visited positions
    visited = [[False] * num_columns for _ in range(num_rows)]

    # Add the starting positions to the queue
    for j in range(num_columns):
        if is_safe(0, j):
            queue.append((0, j))
            visited[0][j] = True

    # Perform breadth-first search to find the shortest path
    while queue:
        row, col = queue.pop(0)

        # Check if we have reached the bottom row
        if row == num_rows - 1:
            return True

        # Explore the adjacent positions
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_row = row + dx
            new_col = col + dy

            # Check if the new position is safe and not visited
            if is_safe(new_row, new_col) and not visited[new_row][new_col]:
                queue.append((new_row, new_col))
                visited[new_row][new_col] = True

    # If the queue is empty and no path is found, return False
    return False

# Call the shortest_path function and print the result
result = shortest_path()
if result:
    print(""The shortest path exists."")
else:
    print(""The shortest path does not exist."")
",0.0
395,2022,24,2,part1_failed,,762,,,
396,2022,25,1,wrong_output,"11018697437761339
",2=0=02-0----2-=02-10,,"
def snafu_to_decimal(snafu):
    decimal = 0
    for i in range(len(snafu)):
        if snafu[i] == '1':
            decimal += 1
        elif snafu[i] == '2':
            decimal += 2
        elif snafu[i] == '=':
            decimal *= 10
            decimal += 1
        elif snafu[i] == '-':
            decimal *= 10
            decimal -= 1
        elif snafu[i] == '0':
            decimal *= 10
    return decimal

def calculate_total_fuel(snafu_list):
    total_fuel = 0
    for snafu in snafu_list:
        decimal = snafu_to_decimal(snafu)
        total_fuel += decimal
    return total_fuel

# Read input from file
with open('input.txt', 'r') as file:
    snafu_list = [line.strip() for line in file]

# Calculate total fuel
total_fuel = calculate_total_fuel(snafu_list)

# Print the result
print(total_fuel)
",0.0
397,2022,25,2,part1_failed,,,,,
