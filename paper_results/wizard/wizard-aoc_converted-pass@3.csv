,year,day,part,status,output,expected_output,error,code,kpass
0,2015,1,1,no_error,"74
",74,,"
def count_floor(s):
    floor = 0
    for i in s:
        if i == ""("":
            floor += 1
        else:
            floor -= 1
    return floor

with open(""input.txt"", ""r"") as f:
    input_string = f.readline()
    print(count_floor(input_string))
",1
1,2015,2,1,no_error,"1586300
",1586300,,"
import math

def surface_area_and_slack(l, w, h):
    """"""
    Calculates the total square feet of wrapping paper required for a present with length, width, and height.
    """"""
    dimensions = [l, w, h]
    dimensions.sort()
    surface_area = sum([2 * dimensions[0] * dimensions[1], 2 * dimensions[1] * dimensions[2], 2 * dimensions[2] * dimensions[0]])
    slack = dimensions[0] * dimensions[1]
    return surface_area + slack

# Read input from file
with open('input.txt', 'r') as input_file:
    dimensions = input_file.readlines()

# Calculate total square feet of wrapping paper for each present
total_square_feet = 0
for dimension in dimensions:
    l, w, h = map(int, dimension.split('x'))
    total_square_feet += surface_area_and_slack(l, w, h)

print(total_square_feet)
",0
2,2015,3,1,no_error,"2565
",2565,,"
from collections import defaultdict

def num_houses_with_presents(moves):
    x = y = 0
    visited_houses = defaultdict(int)
    visited_houses[(x, y)] += 1
    
    for move in moves:
        if move == '^':
            y += 1
        elif move == 'v':
            y -= 1
        elif move == '>':
            x += 1
        elif move == '<':
            x -= 1
        visited_houses[(x, y)] += 1
    
    return len(visited_houses)

with open('input.txt', 'r') as f:
    moves = f.read()

print(num_houses_with_presents(moves))
",0
3,2015,4,1,no_error,"117946
",117946,,"
import hashlib
import time

def find_hash_starting_with_zeroes(secret_key, num_zeroes=5):
    i = 1
    while True:
        hash_value = hashlib.md5((secret_key + str(i)).encode()).hexdigest()
        if hash_value[:num_zeroes] == ""0"" * num_zeroes:
            return i
        i += 1

# Reading input from file
with open('input.txt', 'r') as f:
    secret_key = f.read().strip()

# Finding the lowest positive number that produces a hash starting with 5 zeroes
result = find_hash_starting_with_zeroes(secret_key)

print(result)
",1
4,2015,5,1,wrong_output,"594
",236,,"
import sys

def is_nice(s):
    vowels = set('aeiou')
    if sum(1 for c in s if c in vowels) < 3:
        return False
    if any(s[i] == s[i+1] for i in range(len(s)-1)):
        return True
    return all(s[i:i+2] not in ['ab', 'cd', 'pq', 'xy'] for i in range(len(s)-1))

def main():
    with open('input.txt') as f:
        nice_strings = [s.strip() for s in f if is_nice(s)]
    print(len(nice_strings))

if __name__ == '__main__':
    main()
",2
5,2015,6,1,syntax_error,,400410,"  File ""/tmp/tmp5yntd6fn/tmp.py"", line 4
    def turn_lights(command: str, x1: int, y1: int, x2: int, y2: int, grid: List[List[bool]) -> None:
                                                                                           ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def turn_lights(command: str, x1: int, y1: int, x2: int, y2: int, grid: List[List[bool]) -> None:
    for i in range(x1, x2+1):
        for j in range(y1, y2+1):
            if command == ""turn on"":
                grid[i][j] = True
            elif command == ""turn off"":
                grid[i][j] = False
            else:
                grid[i][j] = not grid[i][j]

def count_lights(grid: List[List[bool]) -> int:
    count = 0
    for row in grid:
        for light in row:
            if light:
                count += 1
    return count

def main() -> None:
    grid = [[False for _ in range(1000)] for _ in range(1000)]
    with open(""input.txt"", ""r"") as f:
        for line in f:
            command, start, end = line.split()
            x1, y1 = map(int, start.split("",""))
            x2, y2 = map(int, end.split("",""))
            turn_lights(command, x1, y1, x2, y2, grid)
    print(count_lights(grid))

if __name__ == ""__main__"":
    main()
",2
6,2015,7,1,runtime_error,,46065,"Traceback (most recent call last):
  File ""/tmp/tmp3in9rmw6/tmp.py"", line 59, in <module>
    signals = generate_signal(instructions)
  File ""/tmp/tmp3in9rmw6/tmp.py"", line 25, in generate_signal
    signal, operation, target = line.split(' -> ')
ValueError: not enough values to unpack (expected 3, got 2)
","
import re

def bitwise_and(a, b):
    return a & b

def bitwise_or(a, b):
    return a | b

def left_shift(a, b):
    return a << b

def right_shift(a, b):
    return a >> b

def bitwise_not(a):
    return ~a

def generate_signal(instructions):
    signals = {}
    while instructions:
        for line in instructions:
            if ' -> ' not in line:
                continue
            signal, operation, target = line.split(' -> ')
            if 'AND' in operation:
                wire1, wire2 = re.findall(r'\b\d+\b', signal)
                wire1 = int(wire1) if wire1.isdigit() else signals[wire1]
                wire2 = int(wire2) if wire2.isdigit() else signals[wire2]
                signals[target] = bitwise_and(wire1, wire2)
            elif 'OR' in operation:
                wire1, wire2 = re.findall(r'\b\d+\b', signal)
                wire1 = int(wire1) if wire1.isdigit() else signals[wire1]
                wire2 = int(wire2) if wire2.isdigit() else signals[wire2]
                signals[target] = bitwise_or(wire1, wire2)
            elif 'LSHIFT' in operation:
                wire1, value = re.findall(r'\b\d+\b', signal)
                wire1 = int(wire1) if wire1.isdigit() else signals[wire1]
                value = int(value)
                signals[target] = left_shift(wire1, value)
            elif 'RSHIFT' in operation:
                wire1, value = re.findall(r'\b\d+\b', signal)
                wire1 = int(wire1) if wire1.isdigit() else signals[wire1]
                value = int(value)
                signals[target] = right_shift(wire1, value)
            elif 'NOT' in operation:
                wire1 = re.findall(r'\b\w+\b', signal)[-1]
                wire1 = int(wire1) if wire1.isdigit() else signals[wire1]
                signals[target] = bitwise_not(wire1)
            else:
                value = int(signal)
                signals[target] = value
            instructions.remove(line)
    return signals

with open('input.txt', 'r') as f:
    instructions = f.readlines()

signals = generate_signal(instructions)
print(signals['a'])
",2
7,2015,8,1,wrong_output,"The difference between the total number of characters in code and memory is: 1517
",1371,,"
import os

def calculate_difference(filename):
    file_path = ""input.txt""
    file = open(file_path, ""r"")
    lines = file.readlines()
    total_code_chars = 0
    total_memory_chars = 0
    for line in lines:
        line = line.strip()
        total_code_chars += len(line)
        line = line.replace(""\\"", """").replace('""', '')
        total_memory_chars += len(line)
        while ""\\x"" in line:
            index = line.find('\\x')
            hex_code = line[index+2:index+4]
            character = chr(int(hex_code, 16))
            line = line.replace(""\\x"" + hex_code, character, 1)
            total_memory_chars += 1
    file.close()
    return total_code_chars - total_memory_chars

if __name__ == ""__main__"":
    difference = calculate_difference(""input.txt"")
    print(f""The difference between the total number of characters in code and memory is: {difference}"")
",2
8,2015,9,1,runtime_error,,251,"Traceback (most recent call last):
  File ""/tmp/tmp61yuy6wg/tmp.py"", line 13, in <module>
    loc1, loc2, dist = line.strip().split(' ')
ValueError: too many values to unpack (expected 3)
","
from itertools import permutations

# Read input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Dictionary to store distances
distances = {}

# Parse input and store distances in dictionary
for line in lines:
    loc1, loc2, dist = line.strip().split(' ')
    dist = int(dist)
    if loc1 not in distances:
        distances[loc1] = {}
    if loc2 not in distances:
        distances[loc2] = {}
    distances[loc1][loc2] = dist
    distances[loc2][loc1] = dist

# Get all possible routes
locations = list(distances.keys())
routes = list(permutations(locations, len(locations)))

# Calculate distance for each route
distances_list = []
for route in routes:
    total_distance = 0
    for i in range(len(route) - 1):
        total_distance += distances[route[i]][route[i+1]]
    total_distance += distances[route[-1]][route[0]]
    distances_list.append(total_distance)

# Find the minimum distance
min_distance = min(distances_list)

# Print the answer
print(min_distance)
",2
9,2015,10,1,no_error,"329356
",329356,,"
from collections import Counter

def look_and_say(string):
    result = ''
    count = 1
    curr = string[0]
    for i in range(1, len(string)):
        if string[i] == string[i-1]:
            count += 1
        else:
            result += str(count) + curr
            curr = string[i]
            count = 1
    result += str(count) + curr
    return result

def look_and_say_sequence(string, n):
    for _ in range(n):
        string = look_and_say(string)
    return string

def main():
    with open('input.txt', 'r') as f:
        string = f.read().strip()

    result = look_and_say_sequence(string, 40)
    print(len(result))

if __name__ == '__main__':
    main()


111131222113


4492557961961415746112
",1
10,2015,11,1,wrong_output,,vzbxxyzz,,"
import itertools

def generate_password(current_password):
    if len(current_password) != 8 or not current_password.islower():
        return ""Invalid password""

    for i in range(len(current_password)-2):
        if ord(current_password[i+1]) - ord(current_password[i]) == 1 and ord(current_password[i+2]) - ord(current_password[i+1]) == 1:
            straight = current_password[i:i+3]
            break
    else:
        straight = ""abc""

    pairs = set()
    for i in range(len(current_password)-1):
        if current_password[i] == current_password[i+1]:
            pairs.add(current_password[i:i+2])

    if len(pairs) < 2:
        pairs.add(""aa"")

    if ""i"" in current_password or ""o"" in current_password or ""l"" in current_password:
        current_password = current_password.replace(""i"", ""j"").replace(""o"", ""p"").replace(""l"", ""m"")

    for password in itertools.permutations(current_password, len(current_password)):
        password = """".join(password)
        if password[0] == ""i"":
            continue
        if password[1] == ""i"":
            continue
        if password[0] == ""o"":
            continue
        if password[1] == ""o"":
            continue
        if password[0] == ""l"":
            continue
        if password[1] == ""l"":
            continue
        if ""i"" in password:
            continue
        if ""o"" in password:
            continue
        if ""l"" in password:
            continue
        if all(password[i+1] > password[i] for i in range(len(password)-1)):
            continue
        if any(password[i:i+2] in pairs for i in range(len(password)-1)):
            continue
        if straight in password:
            continue
        return password
",2
11,2015,12,1,no_error,"111754
",111754,,"
import json

def find_sum(json_data):
    if isinstance(json_data, dict):
        return sum(find_sum(value) for value in json_data.values())
    elif isinstance(json_data, list):
        return sum(find_sum(item) for item in json_data)
    elif isinstance(json_data, int):
        return json_data
    else:
        return 0

with open(""input.txt"", ""r"") as f:
    data = json.load(f)

print(find_sum(data))
",0
12,2015,13,1,runtime_error,,733,"Traceback (most recent call last):
  File ""/tmp/tmpjfujfip9/tmp.py"", line 42, in <module>
    attendees = get_attendees(input_file)
  File ""/tmp/tmpjfujfip9/tmp.py"", line 10, in get_attendees
    attendees.add(re.search('[A-Za-z]+$', line).group(0))
AttributeError: 'NoneType' object has no attribute 'group'
","
import re
import itertools

def get_attendees(input_file):
    with open(input_file, 'r') as f:
        attendees = set()
        for line in f.readlines():
            attendees.add(re.search('^[A-Za-z]+', line).group(0))
            attendees.add(re.search('[A-Za-z]+$', line).group(0))
    return list(attendees)

def get_happiness_values(input_file):
    happiness_values = {}
    with open(input_file, 'r') as f:
        for line in f.readlines():
            attendee1 = re.search('^[A-Za-z]+', line).group(0)
            attendee2 = re.search('[A-Za-z]+$', line).group(0)
            happiness_value = int(re.search('\d+', line).group(0))
            if re.search('gain', line):
                happiness_values[(attendee1, attendee2)] = happiness_value
            else:
                happiness_values[(attendee1, attendee2)] = -happiness_value
    return happiness_values

def calculate_total_happiness(attendees, happiness_values):
    total_happiness = 0
    for i in range(len(attendees)):
        total_happiness += happiness_values[(attendees[i], attendees[(i+1)%len(attendees)])] + happiness_values[(attendees[-1], attendees[0])]
        total_happiness += happiness_values[(attendees[i], attendees[i-1])]
    return total_happiness

def max_happiness(attendees, happiness_values):
    max_happiness = float('-inf')
    for seating_arrangement in itertools.permutations(attendees):
        total_happiness = calculate_total_happiness(seating_arrangement, happiness_values)
        if total_happiness > max_happiness:
            max_happiness = total_happiness
    return max_happiness

input_file = 'input.txt'
attendees = get_attendees(input_file)
happiness_values = get_happiness_values(input_file)
print(max_happiness(attendees, happiness_values))
",2
13,2015,14,1,timeout_error,,2655,TIMEOUT,"
import sys
from collections import defaultdict

def calculate_distance(reindeer, seconds):
    distances = defaultdict(int)
    for name, speed, time, rest in reindeer:
        flying_time = time
        resting_time = rest
        distance = speed * time
        total_time = flying_time + resting_time
        total_distance = 0
        while flying_time <= seconds:
            total_distance += speed * flying_time
            seconds -= flying_time
            total_time = resting_time
            if seconds > 0:
                total_distance += speed * min(flying_time, seconds)
                seconds -= flying_time
            else:
                break
            total_time = flying_time
        distances[name] = total_distance
    return distances

def main():
    reindeer = []
    for line in sys.stdin:
        line = line.strip().split()
        name, speed, time, rest = line[0], int(line[3]), int(line[6]), int(line[13])
        reindeer.append((name, speed, time, rest))
    seconds = int(input())
    distances = calculate_distance(reindeer, seconds)
    max_distance = max(distances.values())
    for name, distance in distances.items():
        if distance == max_distance:
            print(name)

if __name__ == ""__main__"":
    main()
",2
14,2015,15,1,no_error,"21367368
",21367368,,"
import itertools
import re

# Read input file
with open('input.txt', 'r') as f:
    data = f.readlines()

# Create a dictionary of ingredients and their properties
ingredients = {}
for line in data:
    name, properties = line.strip().split(':')
    capacity, durability, flavor, texture, calories = map(int, re.findall(r'-?\d+', properties))
    ingredients[name] = {'capacity': capacity, 'durability': durability, 'flavor': flavor, 'texture': texture, 'calories': calories}

# Define all possible combinations of ingredients
combinations = []
for i in range(101):
    for j in range(101-i):
        for k in range(101-i-j):
            l = 100 - i - j - k
            combinations.append((i, j, k, l))

# Calculate the highest score for each combination
highest_score = 0
for a, b, c, d in combinations:
    score = max(0, a*ingredients['Sprinkles']['capacity'] + b*ingredients['Butterscotch']['capacity'] + c*ingredients['Chocolate']['capacity'] + d*ingredients['Candy']['capacity']) \
         * max(0, a*ingredients['Sprinkles']['durability'] + b*ingredients['Butterscotch']['durability'] + c*ingredients['Chocolate']['durability'] + d*ingredients['Candy']['durability']) \
         * max(0, a*ingredients['Sprinkles']['flavor'] + b*ingredients['Butterscotch']['flavor'] + c*ingredients['Chocolate']['flavor'] + d*ingredients['Candy']['flavor']) \
         * max(0, a*ingredients['Sprinkles']['texture'] + b*ingredients['Butterscotch']['texture'] + c*ingredients['Chocolate']['texture'] + d*ingredients['Candy']['texture'])
    if score > highest_score:
        highest_score = score

print(highest_score)
",2
15,2015,16,1,no_error,"40
",40,,"
import re

def find_aunt_sue(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    aunt_sues = {}
    for line in lines:
        aunt, characteristics = line.strip().split(':', 1)
        aunt_num = int(re.findall(r'\d+', aunt)[0])
        characteristics = dict([char.split(': ') for char in characteristics.split(', ')])
        aunt_sues[aunt_num] = characteristics

    gift_sue = {'children': '3', 'cats': '7', 'samoyeds': '2', 'pomeranians': '3', 'akitas': '0', 'vizslas': '0', 'goldfish': '5', 'trees': '3', 'cars': '2', 'perfumes': '1'}

    for num, sue_chars in aunt_sues.items():
        if all(k in sue_chars and (k not in gift_sue or str(v) == gift_sue[k]) for k, v in sue_chars.items()):
            return num

    return None

print(find_aunt_sue('input.txt'))
",1
16,2015,17,1,wrong_output,"19
",1638,,"
import itertools

# Read the input file
with open('input.txt', 'r') as f:
    target_amount = int(f.readline().strip())
    containers = [int(line.strip()) for line in f.readlines()]

# Find all combinations of containers that can fit the target amount
combinations = []
for i in range(1, len(containers) + 1):
    for combo in itertools.combinations(containers, i):
        if sum(combo) == target_amount:
            combinations.append(combo)

# Print the number of combinations
print(len(combinations))
",2
17,2015,18,1,syntax_error,,814,"  File ""/tmp/tmp7kegnws_/tmp.py"", line 4
    def get_adjacent_lights(grid: List[List[str], x: int, y: int) -> List[str]:
                                                                ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List

def get_adjacent_lights(grid: List[List[str], x: int, y: int) -> List[str]:
    adjacent_lights = []
    for i in range(max(0, x - 1), min(x + 2, len(grid)):
        for j in range(max(0, y - 1), min(y + 2, len(grid[0])):
            if not (i == x and j == y):
                adjacent_lights.append(grid[i][j])
    return adjacent_lights

def update_grid(grid: List[List[str]) -> List[List[str]:
    new_grid = [row.copy() for row in grid]
    for i in range(len(grid)):
        for j in range(len(grid[0]):
            adjacent_lights = get_adjacent_lights(grid, i, j)
            if grid[i][j] == '#':
                if sum(1 for light in adjacent_lights if light == '#') in [2, 3]:
                    new_grid[i][j] = '#'
                else:
                    new_grid[i][j] = '.'
            else:
                if sum(1 for light in adjacent_lights if light == '#') == 3:
                    new_grid[i][j] = '#'
                else:
                    new_grid[i][j] = '.'
    return new_grid

def main():
    with open('input.txt', 'r') as file:
        grid = [list(line.strip()) for line in file.readlines()]
    
    for _ in range(100):
        grid = update_grid(grid)
    
    count_on_lights = sum(1 for row in grid for light in row if light == '#')
    print(count_on_lights)

if __name__ == ""__main__"":
    main()
",2
18,2015,19,1,no_error,"518
",518,,"
import re

# Read input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Get the replacement rules and the medicine molecule
replacement_rules = [line.strip().split(' => ') for line in lines if '=>' in line]
medicine_molecule = lines[-1].strip()

# Generate all possible molecules
possible_molecules = set()
for rule in replacement_rules:
    pattern = re.compile(rule[0])
    matches = pattern.findall(medicine_molecule)
    for match in matches:
        index = medicine_molecule.find(match)
        while index != -1:
            new_molecule = medicine_molecule[:index] + rule[1] + medicine_molecule[index+len(rule[0]):]
            possible_molecules.add(new_molecule)
            index = medicine_molecule.find(match, index+1)

# Print the number of distinct molecules
print(len(possible_molecules))
",2
19,2015,20,1,wrong_output,"436
",776160,,"
import math

def presents_delivered(n):
    total_presents = 0
    for i in range(1, n+1):
        total_presents += (i * (n // i)) * i
    return total_presents

def main():
    with open('input.txt', 'r') as f:
        target = int(f.readline().strip())

    house_number = 1
    while True:
        presents = presents_delivered(house_number)
        if presents >= target:
            print(house_number)
            break
        house_number += 1

if __name__ == '__main__':
    main()
",2
20,2015,21,1,runtime_error,,78,"Traceback (most recent call last):
  File ""/tmp/tmpfddg8krw/tmp.py"", line 7, in <module>
    boss_hp, boss_damage, boss_armor = [int(x) for x in f.read().splitlines()]
  File ""/tmp/tmpfddg8krw/tmp.py"", line 7, in <listcomp>
    boss_hp, boss_damage, boss_armor = [int(x) for x in f.read().splitlines()]
ValueError: invalid literal for int() with base 10: 'Hit Points: 104'
","
# Importing necessary libraries
import sys

# Reading input from file
with open('input.txt', 'r') as f:
    boss_hp, boss_damage, boss_armor = [int(x) for x in f.read().splitlines()]

# Defining the items in the item shop
weapons = [
    {'name': 'Dagger', 'cost': 8, 'damage': 4, 'armor': 0},
    {'name': 'Shortsword', 'cost': 10, 'damage': 5, 'armor': 0},
    {'name': 'Warhammer', 'cost': 25, 'damage': 6, 'armor': 0},
    {'name': 'Longsword', 'cost': 40, 'damage': 7, 'armor': 0},
    {'name': 'Greataxe', 'cost': 74, 'damage': 8, 'armor': 0}
]

armors = [
    {'name': 'None', 'cost': 0, 'damage': 0, 'armor': 0},
    {'name': 'Leather', 'cost': 13, 'damage': 0, 'armor': 1},
    {'name': 'Chainmail', 'cost': 31, 'armor': 2},
    {'name': 'Splintmail', 'cost': 53, 'armor': 3},
    {'name': 'Bandedmail', 'cost': 75, 'armor': 4},
    {'name': 'Platemail', 'cost': 102, 'armor': 5}
]

rings = [
    {'name': 'None', 'cost': 0, 'damage': 0, 'armor': 0},
    {'name': 'Damage +1', 'cost': 25, 'damage': 1, 'armor': 0},
    {'name': 'Damage +2', 'cost': 50, 'damage': 2, 'armor': 0},
    {'name': 'Damage +3', 'cost': 100, 'damage': 3, 'armor': 0},
    {'name': 'Defense +1', 'cost': 20, 'damage': 0, 'armor': 1},
    {'name': 'Defense +2', 'cost': 40, 'damage': 0, 'armor': 2},
    {'name': 'Defense +3', 'cost': 80, 'damage': 0, 'armor': 3}
]

# Function to calculate the damage dealt by the player
def player_damage(player_damage_score, boss_armor_score):
    return max(1, player_damage_score - boss_armor_score)

# Function to calculate the damage dealt by the boss
def boss_damage(player_armor_score, boss_damage_score):
    return max(1, boss_damage_score - player_armor_score)

# Initializing variables
player_hp = 100
player_damage_score = 0
player_armor_score = 0
min_gold = sys.maxsize

# Iterating through all possible combinations of items
for weapon in weapons:
    for armor in armors:
        for ring1 in rings:
            for ring2 in rings:
                if ring1 != ring2 or ring1['name'] == 'None':
                    # Calculating the player's stats
                    total_cost = weapon['cost'] + armor['cost'] + ring1['cost'] + ring2['cost']
                    player_damage_score = weapon['damage'] + ring1['damage'] + ring2['damage']
                    player_armor_score = armor['armor'] + ring1['armor'] + ring2['armor']
                    # Simulating the fight
                    player_turn = True
                    boss_hp_temp = boss_hp
                    player_hp_temp = player_hp
                    while boss_hp_temp > 0 and player_hp_temp > 0:
                        if player_turn:
                            boss_hp_temp -= player_damage(player_damage_score, boss_armor)
                        else:
                            player_hp_temp -= boss_damage(player_armor_score, boss_damage)
                        player_turn = not player_turn
                    # Checking if the player won and updating the minimum gold spent
                    if player_hp_temp > 0:
                        min_gold = min(min_gold, total_cost)

# Printing the minimum gold spent
print(min_gold)
",2
21,2015,22,1,runtime_error,,953,"Traceback (most recent call last):
  File ""/tmp/tmp42ryus07/tmp.py"", line 6, in <module>
    boss_hp = int(f.readline().strip())
ValueError: invalid literal for int() with base 10: 'Hit Points: 55'
","
import sys

# read the input
with open('input.txt', 'r') as f:
    boss_hp = int(f.readline().strip())
    boss_damage = int(f.readline().strip())

# initialize player's stats
player_hp = 50
mana_spent = 0
player_mana = 500

# initialize spells
spells = {
    'Magic Missile': {'cost': 53, 'damage': 4, 'heal': 0, 'effect': None},
    'Drain': {'cost': 73, 'damage': 2, 'heal': 2, 'effect': None},
    'Shield': {'cost': 113, 'damage': 0, 'heal': 0, 'effect': 'shield'},
    'Poison': {'cost': 173, 'damage': 0, 'heal': 0, 'effect': 'poison'},
    'Recharge': {'cost': 229, 'damage': 0, 'heal': 0, 'effect': 'recharge'}
}

shield_turns = 0
poison_turns = 0
recharge_turns = 0

# initialize the best mana spent so far
best_mana_spent = sys.maxsize

# function to calculate the damage dealt by the player
def player_damage():
    global poison_turns
    global recharge_turns
    damage = 0
    if poison_turns > 0:
        damage += 3
        poison_turns -= 1
    return damage

# function to calculate the damage dealt by the boss
def boss_damage():
    global player_hp
    return boss_damage

# function to apply the effects of the spells
def apply_effects():
    global player_hp
    global shield_turns
    global poison_turns
    global recharge_turns
    global player_mana
    if shield_turns > 0:
        player_armor = 7
        shield_turns -= 1
    else:
        player_armor = 0
    if poison_turns > 0:
        boss_hp -= 3
        poison_turns -= 1
    if recharge_turns > 0:
        player_mana += 101
        recharge_turns -= 1

# function to play the game
def play_game():
    global player_hp
    global boss_hp
    global mana_spent
    global best_mana_spent
    while player_hp > 0 and boss_hp > 0:
        # apply the effects of the spells
        apply_effects()
        # check if the player can afford to cast a spell
        if player_mana < min(spell['cost'] for spell in spells.values()):
            return
        # choose the best spell to cast
        best_spell = min(spells, key=lambda spell: spells[spell]['cost'])
        if spells[best_spell]['effect'] == 'shield' and shield_turns == 0:
            best_spell = 'Poison' if player_hp < 13 else 'Recharge' if player_mana < 103 else 'Magic Missile'
        elif spells[best_spell]['effect'] == 'poison' and poison_turns == 0:
            best_spell = 'Recharge' if player_mana < 103 else 'Magic Missile'
        elif spells[best_spell]['effect'] == 'recharge' and recharge_turns == 0:
            best_spell = 'Poison' if player_hp < 13 else 'Shield'
        # cast the spell and update the stats
        player_hp += spells[best_spell]['heal']
        boss_hp -= spells[best_spell]['damage']
        player_mana -= spells[best_spell]['cost']
        mana_spent += spells[best_spell]['cost']
        if spells[best_spell]['effect'] == 'shield':
            shield_turns = 6
        elif spells[best_spell]['effect'] == 'poison':
            poison_turns = 6
        elif spells[best_spell]['effect'] == 'recharge':
            recharge_turns = 5
        # check if the boss is dead
        if boss_hp <= 0:
            if mana_spent < best_mana_spent:
                best_mana_spent = mana_spent
            return
        # apply the effects of the spells
        apply_effects()
        # calculate the damage dealt by the boss
        player_hp -= boss_damage()
        if player_hp <= 0:
            return
        # check if the player can afford to cast another spell
        if player_mana < min(spell['cost'] for spell in spells.values()):
            return
        # choose the best spell to cast
        best_spell = min(spells, key=lambda spell: spells[spell]['cost'])
        # cast the spell and update the stats
        player_hp += player_damage()
        boss_hp -= spells[best_spell]['damage']
        player_mana -= spells[best_spell]['cost']
        mana_spent += spells[best_spell]['cost']
        if spells[best_spell]['effect'] == 'shield':
            shield_turns = 6
        elif spells[best_spell]['effect'] == 'poison':
            poison_turns = 6
        elif spells[best_spell]['effect'] == 'recharge':
            recharge_turns = 5
        # check if the boss is dead
        if boss_hp <= 0:
            if mana_spent < best_mana_spent:
                best_mana_spent = mana_spent
            return

# play the game
play_game()
print(best_mana_spent)
",2
22,2015,23,1,timeout_error,,307,TIMEOUT,"
import sys
from io import StringIO

def main():
    file = open(""input.txt"", ""r"")
    instructions = file.readlines()
    file.close()

    a = 0
    b = 0
    pc = 0

    while pc < len(instructions):
        instruction = instructions[pc].strip().split()
        cmd = instruction[0]
        if cmd == ""hlf"":
            if instruction[1] == ""a"":
                a = a // 2
            else:
                b = b // 2
        elif cmd == ""tpl"":
            if instruction[1] == ""a"":
                a = a * 3
            else:
                b = b * 3
        elif cmd == ""inc"":
            if instruction[1] == ""a"":
                a += 1
            else:
                b += 1
        elif cmd == ""jmp"":
            pc += int(instruction[1]) - 1
            continue
        elif cmd == ""jie"":
            if instruction[1] == ""a"":
                if a % 2 == 0:
                    pc += int(instruction[2]) - 1
                    continue
            else:
                if b % 2 == 0:
                    pc += int(instruction[2]) - 1
                    continue
        elif cmd == ""jio"":
            if instruction[1] == ""a"":
                if a == 1:
                    pc += int(instruction[2]) - 1
                    continue
            else:
                if b == 1:
                    pc += int(instruction[2]) - 1
                    continue
        pc += 1

    print(""Value in register b when program finishes executing:"", b)

if __name__ == ""__main__"":
    main()
",2
23,2015,24,1,wrong_output,"The smallest quantum entanglement is inf for groups None
",10439961859,,"
import math

def quantum_entanglement(packages):
    total_weight = sum(packages)
    target_weight = total_weight / 3
    smallest_entanglement = float('inf')
    smallest_packages = None

    for i in range(len(packages)):
        for j in range(i + 1, len(packages)):
            for k in range(j + 1, len(packages)):
                if math.isclose(sum(packages[i:j]), target_weight) and math.isclose(sum(packages[j:k]), target_weight) and math.isclose(sum(packages[k:]), target_weight):
                    entanglement = math.prod(packages[i:j]) * math.prod(packages[j:k]) * math.prod(packages[k:])
                    if entanglement < smallest_entanglement:
                        smallest_entanglement = entanglement
                        smallest_packages = (i, j, k)

    return smallest_packages, smallest_entanglement

if __name__ == ""__main__"":
    with open(""input.txt"") as f:
        packages = list(map(int, f.readlines()))

    groups, entanglement = quantum_entanglement(packages)
    print(f""The smallest quantum entanglement is {entanglement} for groups {groups}"")
",2
24,2015,25,1,timeout_error,,9132360,TIMEOUT,"
import math

def generate_code(previous_code, row, col):
    return (previous_code * 252533) % 3354393

def main():
    row, col = map(int, input().split(','))
    code = 201511211
    for i in range(1, row + col):
        code = generate_code(code, i, 1)
    for j in range(1, col):
        code = generate_code(code, row, j)
    print(code)

if __name__ == '__main__':
    main()
",2
25,2016,1,1,runtime_error,,287,"Traceback (most recent call last):
  File ""/tmp/tmpwyyf5r3p/tmp.py"", line 40, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import sys

def shortest_path(instructions):
    directions = instructions.split(', ')
    position = (0, 0)
    facing = 'N'
    for direction in directions:
        turn = direction[0]
        blocks = int(direction[1:])
        if turn == 'R':
            if facing == 'N':
                facing = 'E'
            elif facing == 'E':
                facing = 'S'
            elif facing == 'S':
                facing = 'W'
            elif facing == 'W':
                facing = 'N'
        else:
            if facing == 'N':
                facing = 'W'
            elif facing == 'E':
                facing = 'N'
            elif facing == 'S':
                facing = 'E'
            elif facing == 'W':
                facing = 'S'
        if facing == 'N':
            position = (position[0], position[1] + blocks)
        elif facing == 'E':
            position = (position[0] + blocks, position[1])
        elif facing == 'S':
            position = (position[0], position[1] - blocks)
        else:
            position = (position[0] - blocks, position[1])
    return abs(position[0]) + abs(position[1])

if __name__ == '__main__':
    input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        instructions = f.readline().strip()
    print(shortest_path(instructions))
",2
26,2016,2,1,wrong_output,"[1, 2, 5, 7, 8]
[1, 2, 5, 7, 8]
",12578,,"
from typing import List

def find_bathroom_code(instructions: List[str]) -> List[int]:
    # create a dictionary to represent the keypad
    keypad = {
        (0, 0): 1, (0, 1): 2, (0, 2): 3,
        (1, 0): 4, (1, 1): 5, (1, 2): 6,
        (2, 0): 7, (2, 1): 8, (2, 2): 9
    }
    # initialize current position as the center of the keypad
    current_position = (1, 1)
    # store the bathroom code in a list
    bathroom_code = []
    # iterate through each line of instructions
    for line in instructions:
        # iterate through each character in the line
        for char in line:
            # move up
            if char == 'U':
                if current_position[0] > 0:
                    current_position = (current_position[0] - 1, current_position[1])
            # move down
            elif char == 'D':
                if current_position[0] < 2:
                    current_position = (current_position[0] + 1, current_position[1])
            # move left
            elif char == 'L':
                if current_position[1] > 0:
                    current_position = (current_position[0], current_position[1] - 1)
            # move right
            elif char == 'R':
                if current_position[1] < 2:
                    current_position = (current_position[0], current_position[1] + 1)
        # add the current button to the bathroom code
        bathroom_code.append(keypad[current_position])
    return bathroom_code

# read the input file and store the lines in a list
with open('input.txt', 'r') as file:
    instructions = [line.strip() for line in file.readlines()]
# find the bathroom code
code = find_bathroom_code(instructions)
# print the bathroom code
print(code)


def find_bathroom_code(instructions):
    keypad = {
        (0, 0): 1, (0, 1): 2, (0, 2): 3,
        (1, 0): 4, (1, 1): 5, (1, 2): 6,
        (2, 0): 7, (2, 1): 8, (2, 2): 9
    }
    current_position = (1, 1)
    bathroom_code = []
    for line in instructions:
        for char in line:
            if char == 'U':
                if current_position[0] > 0:
                    current_position = (current_position[0] - 1, current_position[1])
            elif char == 'D':
                if current_position[0] < 2:
                    current_position = (current_position[0] + 1, current_position[1])
            elif char == 'L':
                if current_position[1] > 0:
                    current_position = (current_position[0], current_position[1] - 1)
            elif char == 'R':
                if current_position[1] < 2:
                    current_position = (current_position[0], current_position[1] + 1)
        bathroom_code.append(keypad[current_position])
    return bathroom_code

with open('input.txt', 'r') as file:
    instructions = [line.strip() for line in file.readlines()]
code = find_bathroom_code(instructions)
print(code)
",2
27,2016,3,1,no_error,"993
",993,,"
def is_valid_triangle(a, b, c):
    return a + b > c and a + c > b and b + c > a

def count_valid_triangles(file_name):
    count = 0
    with open(file_name, 'r') as file:
        for line in file:
            sides = [int(x) for x in line.split()]
            if is_valid_triangle(*sides):
                count += 1
    return count

file_name = 'input.txt'
print(count_valid_triangles(file_name))
",2
28,2016,4,1,runtime_error,,245102,"Traceback (most recent call last):
  File ""/tmp/tmpllmeqte7/tmp.py"", line 28, in <module>
    sum_of_sectors = sum(map(real_room, rooms))
  File ""/tmp/tmpllmeqte7/tmp.py"", line 16, in real_room
    name, sector_id = re.match(r'([a-z]+)-(\d+)', room).groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re
import heapq

def common_letters(name):
    # Function to find the five most common letters in a string
    freq_dict = {}
    for char in name:
        if char.isalpha():
            freq_dict[char] = freq_dict.get(char, 0) + 1
    sorted_freq = heapq.nlargest(5, freq_dict, key=freq_dict.get)
    return ''.join(sorted_freq)

def real_room(room):
    # Function to check if a room is real or not
    name, sector_id = re.match(r'([a-z]+)-(\d+)', room).groups()
    checksum = re.findall(r'\[(.*?)\]', room)[0]
    if common_letters(name) == checksum:
        return int(sector_id)
    else:
        return 0

# Read the input file
with open('input.txt', 'r') as f:
    rooms = f.readlines()

# Calculate the sum of sector IDs of the real rooms
sum_of_sectors = sum(map(real_room, rooms))

print(sum_of_sectors)
",2
29,2016,5,1,timeout_error,,1a3099aa,TIMEOUT,"
import hashlib
import re

def find_password(door_id):
    password = """"
    index = 0
    while len(password) < 8:
        hash_str = door_id + str(index)
        md5_hash = hashlib.md5(hash_str.encode('utf-8')).hexdigest()
        if re.match(r'^000000', md5_hash):
            password += md5_hash[5]
        index += 1
    return password

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        door_id = file.read().strip()
        print(find_password(door_id))
",2
30,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"
import sys
import os

# Reading input from file
with open(os.path.join(sys.path[0], 'input.txt'), 'r') as f:
    matrix = [list(line.rstrip()) for line in f.readlines()]

# Initializing variables
n_rows = len(matrix)
n_cols = len(matrix[0])
message = ''

# Finding most frequent character in each column and appending to message
for col in range(n_cols):
    char_freq = {}
    for row in range(n_rows):
        if matrix[row][col] in char_freq:
            char_freq[matrix[row][col]] += 1
        else:
            char_freq[matrix[row][col]] = 1
    message += max(char_freq, key=char_freq.get)

# Printing the error-corrected message
print(message)
",2
31,2016,7,1,wrong_output,"0
",115,,"
import re

def supports_tls(ip):
    abba_pattern = re.compile(r'(?<![\[\.])\b([a-z])([a-z])\1(?!\1)([a-z])\2\b(?![\.]|[\[\.]\])')
    hypernet_pattern = re.compile(r'\[([a-z]+)\]')
    abba_matches = abba_pattern.findall(ip)
    hypernet_matches = hypernet_pattern.findall(ip)
    for match in hypernet_matches:
        if any(abba_pattern.search(match) for match in abba_matches):
            return False
    return len(abba_matches) > 0

def count_support_tls(filename):
    with open(filename, 'r') as file:
        return sum(1 for line in file if supports_tls(line))

print(count_support_tls('input.txt'))
",2
32,2016,8,1,no_error,"115
",115,,"
import sys

def execute_instruction(screen, instruction):
    if instruction.startswith(""rect""):
        dimensions = instruction.split()[1].split('x')
        width, height = int(dimensions[0]), int(dimensions[1])
        for i in range(height):
            for j in range(width):
                screen[i][j] = 1
    elif instruction.startswith(""rotate""):
        axis, position, shift = instruction.split()[1], int(instruction.split()[2].split('=')[1]), int(instruction.split()[4])
        if axis == ""row"":
            screen[position] = screen[position][-shift:] + screen[position][:-shift]
        elif axis == ""column"":
            column = [row[position] for row in screen]
            column = column[-shift:] + column[:-shift]
            for i in range(len(screen)):
                screen[i][position] = column[i]
    else:
        raise ValueError(""Invalid instruction"")

def count_lights(screen):
    return sum([sum(row) for row in screen])

def main():
    width, height = 50, 6
    screen = [[0 for _ in range(width)] for _ in range(height)]
    with open(""input.txt"", ""r"") as f:
        instructions = f.readlines()
    for instruction in instructions:
        execute_instruction(screen, instruction.strip())
    print(count_lights(screen))

if __name__ == ""__main__"":
    main()
",0
33,2016,9,1,timeout_error,,102239,TIMEOUT,"
import re

def decompress_length(s):
    # This function takes in a string and returns the decompressed length of the file
    decompressed_length = 0
    while '(' in s:
        # Find the first marker in the string
        marker = re.search('\((\d+)x(\d+)\)', s)
        if marker:
            # Extract the marker values
            x, y = int(marker.group(1)), int(marker.group(2))
            # Add the length of the characters before the marker to the decompressed length
            decompressed_length += marker.start()
            # Replace the marker and the characters it compresses with the repeated characters
            s = s[:marker.start()] + s[marker.end():].replace(s[marker.end():marker.end()+x], s[marker.end():marker.end()+x]*y, 1)
        else:
            # If there are no more markers, add the remaining characters to the decompressed length
            decompressed_length += len(s)
            break
    return decompressed_length

# Read in the input file
with open('input.txt', 'r') as file:
    s = file.readline().strip()

# Call the function and print the result
print(decompress_length(s))
",2
34,2016,10,1,runtime_error,,118,"Traceback (most recent call last):
  File ""/tmp/tmpv0u9s1ro/tmp.py"", line 36, in <module>
    result = find_bot(instructions)
  File ""/tmp/tmpv0u9s1ro/tmp.py"", line 17, in find_bot
    low_chip, high_chip = sorted(chip_dict[source_bot])
KeyError: 76
","
import re

def find_bot(instructions):
    chip_dict = {}
    bot_dict = {}

    for line in instructions:
        if line.startswith(""value""):
            value, bot = map(int, re.findall(r'\d+', line))
            if bot in chip_dict:
                chip_dict[bot].append(value)
            else:
                chip_dict[bot] = [value]
        elif line.startswith(""bot""):
            source_bot, low_to, high_to = map(int, re.findall(r'\d+', line))
            low_chip, high_chip = sorted(chip_dict[source_bot])
            bot_dict[source_bot] = (low_chip, high_chip)
            if low_chip == 17 and high_chip == 61:
                return source_bot
            if low_to in chip_dict:
                chip_dict[low_to].append(low_chip)
            else:
                chip_dict[low_to] = [low_chip]
            if high_to in chip_dict:
                chip_dict[high_to].append(high_chip)
            else:
                chip_dict[high_to] = [high_chip]
            del chip_dict[source_bot]

    return None

with open(""input.txt"", ""r"") as f:
    instructions = f.readlines()

result = find_bot(instructions)
print(result)
",2
35,2016,11,1,timeout_error,,37,TIMEOUT,"
import math
import sys

def check_status(floors):
    status = True
    for floor in floors:
        if len(floor) > 0:
            status = False
            break
    return status

def move_objects(elevator, floors, floor_num):
    if len(elevator) == 2:
        return elevator
    if len(floors[floor_num]) == 2:
        return elevator + floors[floor_num]
    elif len(floors[floor_num]) == 1:
        return elevator + [floors[floor_num][0]]
    else:
        return elevator

def main():
    floors = []
    with open(""input.txt"", ""r"") as file:
        for line in file.readlines():
            floors.append(line.strip().split("",""))

    floor_count = len(floors)
    elevator = []
    steps = 0

    while not check_status(floors):
        for i in range(floor_count):
            if len(floors[i]) > 0:
                floors[i] = [x for x in floors[i] if x not in elevator]
                elevator = move_objects(elevator, floors, i)
                steps += 1

        floors[floor_count - 1] = elevator
        elevator = []

    print(""Minimum steps required:"", steps)

if __name__ == ""__main__"":
    main()
",2
36,2016,12,1,runtime_error,,318083,"Traceback (most recent call last):
  File ""/tmp/tmpklm4n_l4/tmp.py"", line 18, in <module>
    x, y = re.findall(r""(\d+|\w)"", instruction)
ValueError: too many values to unpack (expected 2)
","
import re
from collections import defaultdict

input_file = ""input.txt""

registers = defaultdict(int)    # Initialize registers with value 0

# Read instructions from file
with open(input_file, ""r"") as f:
    instructions = [line.strip() for line in f.readlines()]

# Loop through instructions and execute them
i = 0
while i < len(instructions):
    instruction = instructions[i]
    if ""cpy"" in instruction:
        x, y = re.findall(r""(\d+|\w)"", instruction)
        if x.isnumeric():
            registers[y] = int(x)
        else:
            registers[y] = registers[x]
    elif ""inc"" in instruction:
        register = re.findall(r""\w"", instruction)[0]
        registers[register] += 1
    elif ""dec"" in instruction:
        register = re.findall(r""\w"", instruction)[0]
        registers[register] -= 1
    elif ""jnz"" in instruction:
        x, y = re.findall(r""(\d+|\w)"", instruction)
        if x.isnumeric():
            if x != 0:
                i += int(y)
                continue
        elif registers[x] != 0:
            i += int(y)
            continue
    i += 1

print(""The final value in register 'a' is:"", registers[""a""])
",2
37,2016,13,1,timeout_error,,92,TIMEOUT,"
import math

def count_bits(num):
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count

def main():
    favorite_number = int(input())
    visited = set()
    queue = [(1, 1, 0)]
    while queue:
        x, y, steps = queue.pop(0)
        visited.add((x, y))
        if x == 31 and y == 39:
            return steps
        if (x, y) not in visited:
            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):
                new_x, new_y = x + dx, y + dy
                if new_x >= 0 and new_y >= 0 and count_bits(new_x*new_x + 3*new_x + 2*new_x*y + y + y*y + favorite_number) % 2 == 0 and (new_x, new_y) not in visited:
                    queue.append((new_x, new_y, steps+1))
    return None

if __name__ == ""__main__"":
    print(main())
",2
38,2016,14,1,timeout_error,,23890,TIMEOUT,"
import hashlib
import binascii

def generate_md5_hash(salt, stretch_factor, index):
    """"""
    Generates the MD5 hash of a string salt with the given index and key stretching factor.
    """"""
    for i in range(stretch_factor):
        salt = hashlib.md5(salt.encode('utf-8')).hexdigest()
    return salt

def find_key(salt, index):
    """"""
    Finds the index of the 64th key in the generated hashes.
    """"""
    key_count = 0
    i = 0
    while key_count < 64:
        md5_hash = generate_md5_hash(salt + str(i), 0, index)
        if any(char * 3 in md5_hash for char in md5_hash):
            for j in range(1, 1000):
                md5_hash_next = generate_md5_hash(salt + str(i+j), 2016, index)
                if any(char * 5 in md5_hash_next for char in md5_hash_next):
                    key_count += 1
                    break
        i += 1
    return i - 1

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        salt = f.read().strip()
    index = find_key(salt, 0)
    print(f""The index of the 64th key is: {index}"")
",2
39,2016,15,1,timeout_error,,400589,TIMEOUT,"
import math

def drop_capsule(discs):
    # discs is a list of tuples, where each tuple contains (disc_id, num_positions, initial_position)
    time = 0
    while True:
        all_aligned = True
        for disc_id, num_positions, start_pos in discs:
            # Calculate the current position of the disc using the formula: position = start_pos + time % num_positions
            current_pos = (start_pos + time) % num_positions
            # If the current position is not 0, the capsule will bounce off
            if current_pos != 0:
                all_aligned = False
                break
        if all_aligned:
            return time
        time += 1

# Example usage:
discs = [(1, 5, 4), (2, 2, 1), (3, 4, 0)]
print(drop_capsule(discs))
",2
40,2016,16,1,timeout_error,,10100011010101011,TIMEOUT,"
import os

# Reading the input file
with open('input.txt', 'r') as file:
    initial_state = file.readline().strip()

# Disk length
disk_length = int(os.path.getsize('input.txt') * 1024 * 1024 * 1024) # 1 GB

# Dragon curve function
def dragon_curve(state, length):
    while len(state) < length:
        reversed_state = state[::-1]
        reversed_state = reversed_state.replace('0', '2').replace('1', '0').replace('2', '1')
        state += '0' + reversed_state

    return state[:length]

# Checksum function
def checksum(data):
    checksum_str = ''
    for i in range(0, len(data) - 1, 2):
        if data[i] == data[i + 1]:
            checksum_str += '1'
        else:
            checksum_str += '0'
    if len(checksum_str) % 2 == 0:
        return checksum(checksum_str)
    else:
        return checksum_str

# Generating the data
data = dragon_curve(initial_state, disk_length)

# Calculating the checksum
final_checksum = checksum(data)

# Outputting the checksum
print(final_checksum)
",2
41,2016,17,1,wrong_output,"DDRRRD
",RDDRULDDRR,,"
import hashlib
import re

def generate_md5_hash(passcode, path):
    md5_hash = hashlib.md5((passcode + path).encode()).hexdigest()
    return md5_hash

def get_open_doors(md5_hash):
    open_doors = []
    for i in range(4):
        if md5_hash[i] in 'bcdef':
            open_doors.append('U')
        if md5_hash[i+4] in 'bcdef':
            open_doors.append('D')
        if md5_hash[i+8] in 'bcdef':
            open_doors.append('L')
        if md5_hash[i+12] in 'bcdef':
            open_doors.append('R')
    return open_doors

def next_step(position, direction, open_doors):
    if direction == 'U' and position[0] > 0 and 'U' in open_doors:
        return (position[0]-1, position[1])
    elif direction == 'D' and position[0] < 3 and 'D' in open_doors:
        return (position[0]+1, position[1])
    elif direction == 'L' and position[1] > 0 and 'L' in open_doors:
        return (position[0], position[1]-1)
    elif direction == 'R' and position[1] < 3 and 'R' in open_doors:
        return (position[0], position[1]+1)
    else:
        return None

def find_shortest_path(passcode):
    visited = set()
    queue = [((0,0), '','')]
    while queue:
        position, path, _ = queue.pop(0)
        if position == (3,3):
            return path
        if position in visited:
            continue
        visited.add(position)
        md5_hash = generate_md5_hash(passcode, path)
        open_doors = get_open_doors(md5_hash)
        for direction in open_doors:
            next_pos = next_step(position, direction, open_doors)
            if next_pos:
                new_path = path + direction
                queue.append((next_pos, new_path, md5_hash))
    return None

passcode = ''
with open('input.txt', 'r') as file:
    passcode = file.read().strip()

shortest_path = find_shortest_path(passcode)
print(shortest_path)
",2
42,2016,18,1,runtime_error,,1913,"Traceback (most recent call last):
  File ""/tmp/tmp0uqhf7id/tmp.py"", line 41, in <module>
    main()
  File ""/tmp/tmp0uqhf7id/tmp.py"", line 36, in main
    num_rows = int(f.readline())
ValueError: invalid literal for int() with base 10: ''
","
from typing import List

def generate_row(row: str) -> str:
    new_row = ''
    for i in range(len(row)):
        if i == 0:
            if row[i+1] == '^':
                new_row += '^'
            else:
                new_row += '.'
        elif i == len(row) - 1:
            if row[i-1] == '^':
                new_row += '^'
            else:
                new_row += '.'
        else:
            if (row[i-1] == '^' and row[i+1] == '^') and row[i] == '.':
                new_row += '^'
            elif (row[i-1] == '.' and row[i+1] == '^') or (row[i-1] == '^' and row[i+1] == '.'):
                new_row += '.'
            else:
                new_row += '^'
    return new_row

def count_safe_tiles(row: str, num_rows: int) -> int:
    count = row.count('.')
    for _ in range(num_rows - 1):
        row = generate_row(row)
        count += row.count('.')
    return count

def main():
    with open('input.txt', 'r') as f:
        initial_row = f.readline().strip()
        num_rows = int(f.readline())
    safe_tiles = count_safe_tiles(initial_row, num_rows)
    print(f""The number of safe tiles in {num_rows} rows is {safe_tiles}."")

if __name__ == ""__main__"":
    main()
",2
43,2016,19,1,no_error,"1808357
",1808357,,"
import sys
from collections import deque

def gift_exchange(n):
    circle = deque(range(1, n+1))
    
    while len(circle) > 1:
        circle.rotate(-1)
        circle.popleft()

    return circle[0]

if __name__ == '__main__':
    with open('input.txt', 'r') as f:
        n = int(f.read().strip())
    
    result = gift_exchange(n)
    print(result)
",2
44,2016,20,1,timeout_error,,32259706,TIMEOUT,"
import re

def find_lowest_ip(ranges):
    blocked_ips = set()
    for range_str in ranges:
        start, end = range_str.split('-')
        start = int(start)
        end = int(end)
        blocked_ips.update(range(start, end+1))
    lowest_ip = 0
    while lowest_ip in blocked_ips:
        lowest_ip += 1
    return lowest_ip

if __name__ == '__main__':
    with open('input.txt', 'r') as file:
        ranges = file.read().splitlines()
    result = find_lowest_ip(ranges)
    print(result)
",2
45,2016,21,1,runtime_error,,gbhafcde,"Traceback (most recent call last):
  File ""/tmp/tmp385bkq9u/tmp.py"", line 40, in <module>
    result = scramble_password(password, operations)
  File ""/tmp/tmp385bkq9u/tmp.py"", line 17, in scramble_password
    x = int(operation.split()[-1])
ValueError: invalid literal for int() with base 10: 'steps'
","
import re

def scramble_password(password, operations):
    for operation in operations:
        if ""swap position"" in operation:
            x, y = map(int, re.findall(r'\d+', operation))
            password = list(password)
            password[x], password[y] = password[y], password[x]
            password = ''.join(password)
        elif ""letter"" in operation:
            x, y = operation.split()[-1]
            password = password.replace(x, '_')
            password = password.replace(y, x)
            password = password.replace('_', y)
        elif ""rotate"" in operation and ""left"" in operation:
            x = int(operation.split()[-1])
            password = password[x%len(password):] + password[:x%len(password)]
        elif ""rotate"" in operation and ""right"" in operation:
            x = int(operation.split()[-1])
            password = password[-x%len(password):] + password[:-x%len(password)]
        elif ""rotate"" in operation and ""based"" in operation:
            x = password.index(operation.split()[-1])
            password = password[1:x+1] + password[0] + password[x+2:] + password[1]
        elif ""position"" in operation:
            x, y = map(int, re.findall(r'\d+', operation))
            password = list(password)
            password.insert(y, password.pop(x))
            password = ''.join(password)
        else:
            x, y = map(int, re.findall(r'\d+', operation))
            password = list(password)
            password.insert(y, password.pop(x))
            password = ''.join(password)
    return password

with open('input.txt', 'r') as file:
    operations = file.readlines()
    password = 'abcdefgh'
    result = scramble_password(password, operations)
    print(result)
",2
46,2016,22,1,syntax_error,,901,"  File ""/tmp/tmp9jqhlx12/tmp.py"", line 7
    for y in range(len(grid[0]):
                               ^
SyntaxError: invalid syntax
","
def count_viable_pairs(grid):
    count = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            for x in range(len(grid)):
                for y in range(len(grid[0]):
                    if grid[i][j] != 0 and grid[x][y] != 0 and grid[i][j] <= grid[x][y]:
                        count += 1
    return count
",2
47,2016,23,1,syntax_error,,12516,"  File ""/tmp/tmph81jyspb/tmp.py"", line 35
    if (instructions[i][1].isalpha() and instructions[i][1] != ""a"" and int(registers[instructions[i][1]) != 0) or (not instructions[i][1].isalpha() and int(instructions[i][1]) != 0):
                                                                                                       ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys

def tgl(instructions, pos):
    if 0 <= pos < len(instructions):
        inst = instructions[pos][0]
        if len(instructions[pos]) == 1:
            if inst == ""inc"":
                instructions[pos][0] = ""dec""
            else:
                instructions[pos][0] = ""inc""
        elif len(instructions[pos]) == 2:
            if inst == ""jnz"":
                instructions[pos][0] = ""cpy""
            else:
                instructions[pos][0] = ""jnz""

def execute(instructions, a):
    i = 0
    while i < len(instructions):
        inst = instructions[i][0]
        if inst == ""inc"":
            a += int(instructions[i][1])
            i += 1
        elif inst == ""dec"":
            a -= int(instructions[i][1])
            i += 1
        elif inst == ""cpy"":
            if instructions[i][1].isalpha():
                a = instructions[i][1]
            else:
                a = int(instructions[i][1])
            i += 1
        elif inst == ""jnz"":
            if (instructions[i][1].isalpha() and instructions[i][1] != ""a"" and int(registers[instructions[i][1]) != 0) or (not instructions[i][1].isalpha() and int(instructions[i][1]) != 0):
                i += int(instructions[i][2])
            else:
                i += 1
        elif inst == ""tgl"":
            tgl(instructions, i + int(instructions[i][1]))
            i += 1
        else:
            i += 1
    return a

registers = {'a': 0}
with open('input.txt', 'r') as f:
    lines = f.readlines()
    for line in lines:
        instruction = line.strip().split()
        for j in range(len(instruction)):
            if instruction[j].isalpha():
                instruction[j] = registers[instruction[j]]
            else:
                instruction[j] = int(instruction[j])
        instructions.append(instruction)

a = execute(instructions, 0)
print(a)
",2
48,2016,24,1,syntax_error,,498,"  File ""/tmp/tmplprqslf2/tmp.py"", line 5
    def bfs(maze: List[List[str], start: Tuple[int, int]) -> int:
                                                        ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from collections import deque
from typing import List, Tuple

def bfs(maze: List[List[str], start: Tuple[int, int]) -> int:
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    rows, cols = len(maze), len(maze[0])
    visited = set()
    queue = deque([(start, 0)])
    while queue:
        (row, col), steps = queue.popleft()
        if (row, col) in visited:
            continue
        visited.add((row, col))
        if maze[row][col] != '#' and maze[row][col] != '0':
            if maze[row][col] != '.':
                visited.add((row, col))
                if len(visited) == len([x for x in ''.join(maze) if x.isdigit() and x != '0']):
                    return steps
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy
                if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited:
                    queue.append(((new_row, new_col), steps + 1))
    return -1

def main():
    with open('input.txt', 'r') as f:
        maze = [list(line.strip()) for line in f]
    start_row, start_col = next((i, j) for i, row in enumerate(maze) for j, char in enumerate(row) if char == '0')
    result = bfs(maze, (start_row, start_col))
    if result != -1:
        print(result)
    else:
        print(""No path found"")

if __name__ == ""__main__"":
    main()
",2
49,2016,25,1,runtime_error,,196,"  File ""/tmp/tmpyfmcjn83/tmp.py"", line 10
    if __name__ == ""__main__"":
    ^
IndentationError: expected an indented block
","
import re
import sys

def find_lowest_integer(assembly_code):
    # Implement the logic to find the lowest positive integer that can be used to initialize register 'a' in order to produce a clock signal of 0, 1, 0, 1, ...
    # This function will return the lowest positive integer value that can be used to initialize register 'a' to generate the required clock signal


if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        assembly_code = file.read()
        result = find_lowest_integer(assembly_code)
        print(result)
",2
50,2017,1,1,no_error,"1177
",1177,,"
from collections import deque

def sum_matching_digits(nums):
    nums = deque(nums)
    nums.append(nums[0])
    total = 0
    
    for i in range(len(nums) - 1):
        if nums[i] == nums[i + 1]:
            total += int(nums[i])
            
    return total
    
with open('input.txt', 'r') as f:
    nums = f.read().strip()
    
print(sum_matching_digits(nums))
",0
51,2017,2,1,no_error,"45158
",45158,,"
import sys

def checksum(spreadsheet):
    total_diff = 0
    for row in spreadsheet:
        row = list(map(int, row.split()))
        diff = max(row) - min(row)
        total_diff += diff
    return total_diff

# Read the input file
with open(""input.txt"", ""r"") as file:
    spreadsheet = file.readlines()

# Calculate and print the checksum
print(checksum(spreadsheet))
",2
52,2017,3,1,runtime_error,,438,"Traceback (most recent call last):
  File ""/tmp/tmpp5fesufl/tmp.py"", line 58, in <module>
    print(distance_to_access_port(n))
  File ""/tmp/tmpp5fesufl/tmp.py"", line 48, in distance_to_access_port
    x, y = find_position(n, layers)
  File ""/tmp/tmpp5fesufl/tmp.py"", line 26, in find_position
    if n_elements_prev_layer[i] <= n < n_elements_prev_layer[i + 1]:
IndexError: list index out of range
","
import math

def distance_to_access_port(n):
    # Convert the given number to base 2
    def to_binary(n):
        binary_str = bin(n)[2:]
        return [int(i) for i in binary_str]

    # Find the side length of the square containing the given number
    def find_side_length(n):
        return int(math.ceil(math.sqrt(n)))

    # Find the number of layers in the spiral
    def find_layers(n):
        return int(math.ceil(0.5 * (math.sqrt(n) + 1)) // 2)

    # Find the position of the given number within the spiral
    def find_position(n, layers):
        side_length = 2 * layers + 1
        # Calculate the number of elements in each layer of the spiral
        n_elements_layer = [2 * i + 1 for i in range(1, layers + 1)]
        n_elements_prev_layer = [sum(n_elements_layer[:i]) for i in range(1, layers + 1)]
        # Find the layer that the given number belongs to
        for i in range(layers):
            if n_elements_prev_layer[i] <= n < n_elements_prev_layer[i + 1]:
                layer = i
                break
        # Find the position of the given number within the layer
        position = n - n_elements_prev_layer[i]
        # Calculate the position of the center of the layer
        center = (side_length - 1) // 2
        # Calculate the coordinates of the center of the layer
        x_center, y_center = center, -center
        # Calculate the position of the given number relative to the center of the layer
        x_pos, y_pos = position - n_elements_prev_layer[i]
        if i % 2 == 0:
            x_pos, y_pos = y_pos, x_pos
        return x_center + x_pos, y_center + y_pos

    # Calculate the Manhattan distance between two coordinates
    def manhattan_distance(x1, y1, x2, y2):
        return abs(x1 - x2) + abs(y1 - y2)

    # Convert the given number to binary and find the number of layers and position within the spiral
    binary_n = to_binary(n)
    layers = find_layers(n)
    x, y = find_position(n, layers)
    # Calculate the Manhattan distance from the given number to the access port (square 1)
    access_port = (0, 0)
    return manhattan_distance(x, y, access_port[0], access_port[1])

# Read the input file
with open(""input.txt"", ""r"") as f:
    n = int(f.readline().strip())

# Find the shortest path to the access port
print(distance_to_access_port(n))
",2
53,2017,4,1,wrong_output,"Number of valid passphrases: 383
",383,,"
from collections import Counter

def is_valid_passphrase(passphrase):
    words = passphrase.split()
    word_count = Counter(words)
    return len(words) == len(word_count)

def count_valid_passphrases(input_file):
    valid_count = 0
    with open(input_file, 'r') as f:
        for line in f:
            if is_valid_passphrase(line.strip()):
                valid_count += 1
    return valid_count

input_file = 'input.txt'
valid_passphrase_count = count_valid_passphrases(input_file)
print(f""Number of valid passphrases: {valid_passphrase_count}"")
",2
54,2017,5,1,no_error,"391540
",391540,,"
import sys

# Read the input file
with open('input.txt', 'r') as file:
    offsets = [int(line.strip()) for line in file]

steps = 0
current_index = 0

while 0 <= current_index < len(offsets):
    jump = offsets[current_index]
    offsets[current_index] += 1
    current_index += jump
    steps += 1

print(steps)
",0
55,2017,6,1,wrong_output,"Usage: python day6.py input.txt
",6681,,"
import sys

def redistribute(banks):
    count = 0
    seen = set()
    while tuple(banks) not in seen:
        seen.add(tuple(banks))
        count += 1
        max_index = banks.index(max(banks))
        blocks = banks[max_index]
        banks[max_index] = 0
        max_index += 1
        while blocks > 0:
            if max_index < len(banks):
                banks[max_index % len(banks)] += 1
                blocks -= 1
                max_index += 1
            else:
                max_index = 0
        print(banks)
    return count

if __name__ == ""__main__"":
    if len(sys.argv) != 2:
        print(""Usage: python day6.py input.txt"")
        sys.exit(1)

    with open(sys.argv[1], 'r') as f:
        banks = [int(x) for x in f.readline().strip().split('\t')]
        print(redistribute(banks))
",2
56,2017,7,1,runtime_error,,cyrupz,"Traceback (most recent call last):
  File ""/tmp/tmpy9zko8_5/tmp.py"", line 33, in <module>
    bottom_program = find_bottom_program(""input.txt"")
  File ""/tmp/tmpy9zko8_5/tmp.py"", line 17, in find_bottom_program
    program_name, weight, above = re.search(r""(\w+)\s+\((\d+)\)\s*->\s*(.*)"", line).groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re

def find_bottom_program(programs):
    # Reading the input file
    with open(""input.txt"", ""r"") as f:
        lines = f.readlines()

    # Dictionary to store the program names and their weights
    program_weights = {}

    # Dictionary to store the programs above each program
    program_above = {}

    # Reading each line of the input file and extracting the program name and its weight
    for line in lines:
        program_name, weight, above = re.search(r""(\w+)\s+\((\d+)\)\s*->\s*(.*)"", line).groups()
        program_weights[program_name] = int(weight)
        if above.strip():
            above_list = above.split("", "")
            program_above[program_name] = above_list

    # Finding the bottom program by checking which program is not present in the keys of program_above dictionary
    bottom_program = """"
    for program in program_weights.keys():
        if program not in program_above.keys():
            bottom_program = program
            break

    return bottom_program

# Calling the function with input file
bottom_program = find_bottom_program(""input.txt"")
print(""The bottom program is:"", bottom_program)
",2
57,2017,8,1,runtime_error,,4448,"Traceback (most recent call last):
  File ""/tmp/tmp5sb5rynd/tmp.py"", line 25, in <module>
    print(largest_register_value(instructions))
  File ""/tmp/tmp5sb5rynd/tmp.py"", line 7, in largest_register_value
    register, operation, amount, _, condition = instruction.split()
ValueError: too many values to unpack (expected 5)
","
import sys

def largest_register_value(instructions):
    registers = {}
    for instruction in instructions:
        register, operation, amount, _, condition = instruction.split()
        if condition in registers:
            value = int(registers.get(condition, 0))
        else:
            value = int(condition)
        if eval(f""{value} {register} {amount}""):
            if register not in registers:
                registers[register] = 0
            if operation == ""inc"":
                registers[register] += int(amount)
            else:
                registers[register] -= int(amount)

    return max(registers.values())

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as f:
        instructions = f.readlines()
    print(largest_register_value(instructions))
",2
58,2017,9,1,no_error,"7640
",7640,,"
import re

def find_score(s: str) -> int:
    score = 0
    garbage = False
    garbage_count = 0
    depth = 0
    i = 0
    while i < len(s):
        if s[i] == ""<"":
            garbage = True
        elif s[i] == "">"":
            garbage = False
        elif s[i] == ""!"":
            i += 1
        elif s[i] == ""{"" and not garbage:
            depth += 1
        elif s[i] == ""}"" and not garbage:
            score += depth
            depth -= 1
        elif s[i] == "">"" and garbage:
            garbage = False
        elif garbage:
            garbage_count += 1
        i += 1
    return score

with open(""input.txt"", ""r"") as f:
    input_string = f.readline().strip()
    print(find_score(input_string))
",1
59,2017,10,1,wrong_output,"47306
",46600,,"
import sys

def knot_hash(lengths, rounds=1, size=256, start_position=0, skip_size=0):
    string = list(range(size))
    skip_size = 0
    position = 0

    for _ in range(rounds):
        for length in lengths:
            if position + length <= size:
                string[position:position+length] = reversed(string[position:position+length])
            else:
                string = string[position:] + list(reversed(string[:length-position]))
            position = (position + length + skip_size) % size
            skip_size += 1

    return string

def main():
    input_file = open(""input.txt"", ""r"")
    input_string = input_file.readline().strip().split("","")
    lengths = [int(i) for i in input_string]
    hashed_string = knot_hash(lengths)
    print(hashed_string[0] * hashed_string[1])

if __name__ == '__main__':
    main()
",2
60,2017,11,1,wrong_output,"2024
",696,,"
import sys


def main():
    with open('input.txt', 'r') as file:
        input_path = file.readline().strip().split(',')
    origin = (0, 0)
    destination = (0, 0)
    for direction in input_path:
        if direction == ""n"":
            destination = (destination[0], destination[1] + 1)
        elif direction == ""ne"":
            destination = (destination[0] + 1, destination[1] + 1)
        elif direction == ""se"":
            destination = (destination[0] + 1, destination[1])
        elif direction == ""s"":
            destination = (destination[0], destination[1] - 1)
        elif direction == ""sw"":
            destination = (destination[0] - 1, destination[1])
        elif direction == ""nw"":
            destination = (destination[0] - 1, destination[1] + 1)
    steps = abs(destination[0]) + abs(destination[1]) // 2
    print(steps)

if __name__ == ""__main__"":
    main()
",2
61,2017,12,1,runtime_error,,288,"Traceback (most recent call last):
  File ""/tmp/tmpezhjjca4/tmp.py"", line 2, in <module>
    import networkx as nx
ModuleNotFoundError: No module named 'networkx'
","
import networkx as nx

def group_of_program(program_id, input_file):
    # Create an empty graph
    G = nx.Graph()

    # Read the input file and add edges to the graph
    with open(input_file, 'r') as f:
        for line in f:
            nodes = line.strip().split('<->')
            source_node = nodes[0].strip()
            connected_nodes = nodes[1].split(',')
            for node in connected_nodes:
                G.add_edge(source_node, node.strip())

    # Get the set of connected components in the graph
    connected_components = nx.connected_components(G)

    # Find the component that contains the given program ID and return its size
    for component in connected_components:
        if program_id in component:
            return len(component)

    return 0

# Example usage
program_id = '7'
input_file = 'input.txt'
print(group_of_program(program_id, input_file))
",2
62,2017,13,1,wrong_output,"Severity: 316
",1624,,"
import sys

def main():
    # Input
    input_file = open(""input.txt"", ""r"")
    layers = {int(line.strip().split("":"")[0]): int(line.strip().split("":"")[1]) for line in input_file.readlines()}
    input_file.close()

    # Variables
    severity = 0
    current_layer = 0
    current_time = 0

    # Loop through each layer and check if the packet is caught
    for layer in layers:
        if (current_time % (layers[layer] * 2 - 2) == 0):
            severity += layer * layers[layer]

        current_layer += 1
        current_time += 1

    # Output
    print(""Severity: "" + str(severity))

if __name__ == ""__main__"":
    main()
",2
63,2017,14,1,runtime_error,,8148,"Traceback (most recent call last):
  File ""/tmp/tmpnpycvaqo/tmp.py"", line 38, in <module>
    grid = generate_knot_hash(key)
  File ""/tmp/tmpnpycvaqo/tmp.py"", line 29, in generate_knot_hash
    grid.append(knot_hash(key_str))
  File ""/tmp/tmpnpycvaqo/tmp.py"", line 22, in knot_hash
    sparse_hash, cur_pos, skip_size = knot_hash_round(lengths, sparse_hash, cur_pos, skip_size)
  File ""/tmp/tmpnpycvaqo/tmp.py"", line 9, in knot_hash_round
    lst = lst[cur_pos:cur_pos+length][::-1] + lst[cur_pos+length:]
TypeError: unsupported operand type(s) for +: 'range' and 'range'
","
import hashlib
import binascii

def generate_knot_hash(key):
    def knot_hash_round(lengths, lst, cur_pos, skip_size):
        for length in lengths:
            if cur_pos + length <= len(lst):
                lst = lst[cur_pos:cur_pos+length][::-1] + lst[cur_pos+length:]
            else:
                temp = (lst[cur_pos:] + lst[:cur_pos+length-len(lst)])[::-1] + lst[cur_pos+length-len(lst):cur_pos]
                lst = temp[:len(lst)-cur_pos] + lst[cur_pos:cur_pos] + temp[len(lst)-cur_pos:]
            cur_pos = (cur_pos + length + skip_size) % len(lst)
            skip_size += 1
        return lst, cur_pos, skip_size

    def knot_hash(key):
        lengths = [ord(char) for char in key] + [17, 31, 73, 47, 23]
        sparse_hash = range(0, 256)
        cur_pos, skip_size = 0, 0
        for _ in range(64):
            sparse_hash, cur_pos, skip_size = knot_hash_round(lengths, sparse_hash, cur_pos, skip_size)
        dense_hash = [reduce(lambda x, y: x ^ y, sparse_hash[i:i+16]) for i in range(0, 256, 16)]
        return bin(int(binascii.hexlify(bytearray(dense_hash)), 16) ^ (1 << 64) - 1)[2:].zfill(128)

    grid = []
    for i in range(128):
        key_str = key + ""-"" + str(i)
        grid.append(knot_hash(key_str))

    return grid

def count_used_squares(grid):
    return sum(sum(int(bit) for bit in row) for row in grid)

with open('input.txt', 'r') as f:
    key = f.read().strip()
    grid = generate_knot_hash(key)
    print(count_used_squares(grid))
",2
64,2017,15,1,timeout_error,,650,TIMEOUT,"
import random

def generate_numbers(starting_value, factor):
    while True:
        starting_value = (starting_value * factor) % 2147483647
        yield starting_value & 0xFFFF

def count_matching_pairs(a_starting_value, b_starting_value, factor_a, factor_b):
    count = 0
    for i in range(4000000000):
        a_value = generate_numbers(a_starting_value, factor_a)
        b_value = generate_numbers(b_starting_value, factor_b)
        if a_value == b_value:
            count += 1
    return count

# Example input
a_starting_value = 634
b_starting_value = 301
factor_a = random.randint(1, 2147483647)
factor_b = random.randint(1, 2147483647)

print(count_matching_pairs(a_starting_value, b_starting_value, factor_a, factor_b))
",2
65,2017,16,1,no_error,"nlciboghjmfdapek
",nlciboghjmfdapek,,"
import string

# Function to perform spin move
def spin(line, x):
    return line[-x:] + line[:-x]

# Function to perform exchange move
def exchange(line, a, b):
    line = list(line)
    line[a], line[b] = line[b], line[a]
    return ''.join(line)

# Function to perform partner move
def partner(line, a, b):
    index_a = line.index(a)
    index_b = line.index(b)
    return exchange(line, index_a, index_b)

# Read input from file and split into list of moves
with open('input.txt', 'r') as f:
    input_string = f.readline().strip()
moves = input_string.split(',')

# Initialize the line of programs
line = string.ascii_lowercase[:16]

# Iterate through each move and perform the corresponding function
for move in moves:
    if move[0] == 's':
        line = spin(line, int(move[1:]))
    elif move[0] == 'x':
        a, b = move[1:].split('/')
        line = exchange(line, int(a), int(b))
    elif move[0] == 'p':
        a, b = move[1:].split('/')
        line = partner(line, a, b)

print(''.join(line))
",2
66,2017,17,1,timeout_error,,640,TIMEOUT,"
import sys

buffer = [0]
current_position = 0
num_steps = int(input())

for i in range(1, 2018):
    current_position = (current_position + num_steps) % len(buffer) + 1
    buffer.insert(current_position, i)
    current_position = buffer.index(i)

print(buffer[buffer.index(2017) + 1])
",2
67,2017,18,1,runtime_error,,4601,"Traceback (most recent call last):
  File ""/tmp/tmp9dexvliu/tmp.py"", line 47, in <module>
    multiply(arg1, arg2)
  File ""/tmp/tmp9dexvliu/tmp.py"", line 20, in multiply
    registers[x] *= get_value(y)
KeyError: 'p'
","
import re

registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0, 'i': 0, 'j': 0}
last_sound = None

def get_value(item):
    if item in registers:
        return registers[item]
    else:
        return int(item)

def set(x, y):
    registers[x] = get_value(y)

def add(x, y):
    registers[x] += get_value(y)

def multiply(x, y):
    registers[x] *= get_value(y)

def modulo(x, y):
    registers[x] %= get_value(y)

def play(x):
    global last_sound
    last_sound = registers[x]

def recover():
    return last_sound

def jump(x, y):
    return get_value(y) != 0

with open('input.txt') as f:
    instructions = [line.strip() for line in f]

current_instruction = 0
while current_instruction < len(instructions):
    instruction = instructions[current_instruction]
    op, arg1, arg2 = re.findall(r'(\w+) (\w+) (\w+)', instruction)[0]
    if op == 'set':
        set(arg1, arg2)
    elif op == 'add':
        add(arg1, arg2)
    elif op == 'mul':
        multiply(arg1, arg2)
    elif op == 'mod':
        modulo(arg1, arg2)
    elif op == 'play':
        play(arg1)
    elif op == 'recover':
        print(recover())
        break
    elif op == 'jump':
        if jump(arg1, arg2):
            current_instruction = int(arg2) - 1
    else:
        raise ValueError('Invalid instruction')
    current_instruction += 1
",2
68,2017,19,1,syntax_error,,GSXDIPWTU,"  File ""/tmp/tmpflh0ya8m/tmp.py"", line 10
    start_col = next(j for j in range(len(diagram[start_row]) if diagram[start_row][j].isalpha())
                                                                                                ^
SyntaxError: invalid syntax
","
import sys


with open('input.txt', 'r') as f:
    diagram = [line.strip() for line in f.readlines()]


start_row = next(i for i in range(len(diagram)) if any(c.isalpha() for c in diagram[i]))
start_col = next(j for j in range(len(diagram[start_row]) if diagram[start_row][j].isalpha())
end_row = next(i for i in range(len(diagram)-1, -1, -1) if any(c.isalpha() for c in diagram[i]))
end_col = next(j for j in range(len(diagram[end_row])-1, -1, -1) if diagram[end_row][j].isalpha())


direction = 'down'
current_row, current_col = start_row, start_col


letters = []
while (current_row, current_col) != (end_row, end_col):
    if diagram[current_row][current_col].isalpha():
        letters.append(diagram[current_row][current_col])
    
    if direction == 'down':
        if current_row < len(diagram)-1 and diagram[current_row+1][current_col].isalpha():
            current_row += 1
        elif current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1] in ('|', '+'):
            current_col += 1
            direction = 'right'
        elif current_col > 0 and diagram[current_row][current_col-1] in ('|', '+'):
            current_col -= 1
            direction = 'left'
        else:
            current_row -= 1
    elif direction == 'up':
        if current_row > 0 and diagram[current_row-1][current_col].isalpha():
            current_row -= 1
        elif current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1] in ('|', '+'):
            current_col += 1
            direction = 'right'
        elif current_col > 0 and diagram[current_row][current_col-1] in ('|', '+'):
            current_col -= 1
            direction = 'left'
        else:
            current_row += 1
    elif direction == 'right':
        if current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1].isalpha():
            current_col += 1
        elif current_row < len(diagram)-1 and diagram[current_row+1][current_col] in ('-', '+'):
            current_row += 1
            direction = 'down'
        elif current_row > 0 and diagram[current_row-1][current_col] in ('-', '+'):
            current_row -= 1
            direction = 'up'
        else:
            current_col -= 1
    elif direction == 'left':
        if current_col > 0 and diagram[current_row][current_col-1].isalpha():
            current_col -= 1
        elif current_row < len(diagram)-1 and diagram[current_row+1][current_col] in ('-', '+'):
            current_row += 1
            direction = 'down'
        elif current_row > 0 and diagram[current_row-1][current_col] in ('-', '+'):
            current_row -= 1
            direction = 'up'
        else:
            current_col += 1

    current_char = diagram[current_row][current_col]
    if current_char.isalpha():
        letters.append(current_char)

print(''.join(letters))


import sys

with open('input.txt', 'r') as f:
    diagram = [line.strip() for line in f.readlines()]

start_row = next(i for i in range(len(diagram)) if any(c.isalpha() for c in diagram[i]))
start_col = next(j for j in range(len(diagram[start_row]) if diagram[start_row][j].isalpha())
end_row = next(i for i in range(len(diagram)-1, -1, -1) if any(c.isalpha() for c in diagram[i]))
end_col = next(j for j in range(len(diagram[end_row])-1, -1, -1) if diagram[end_row][j].isalpha())

direction = 'down'
current_row, current_col = start_row, start_col
letters = []
while (current_row, current_col) != (end_row, end_col):
    if diagram[current_row][current_col].isalpha():
        letters.append(diagram[current_row][current_col])
    
    if direction == 'down':
        if current_row < len(diagram)-1 and diagram[current_row+1][current_col].isalpha():
            current_row += 1
        elif current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1] in ('|', '+'):
            current_col += 1
            direction = 'right'
        elif current_col > 0 and diagram[current_row][current_col-1] in ('|', '+'):
            current_col -= 1
            direction = 'left'
        else:
            current_row -= 1
    elif direction == 'up':
        if current_row > 0 and diagram[current_row-1][current_col].isalpha():
            current_row -= 1
        elif current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1] in ('|', '+'):
            current_col += 1
            direction = 'right'
        elif current_col > 0 and diagram[current_row][current_col-1] in ('|', '+'):
            current_col -= 1
            direction = 'left'
        else:
            current_row += 1
    elif direction == 'right':
        if current_col < len(diagram[current_row])-1 and diagram[current_row][current_col+1].isalpha():
            current_col += 1
        elif current_row < len(diagram)-1 and diagram[current_row+1][current_col] in ('-', '+'):
            current_row += 1
            direction = 'down'
        elif current_row > 0 and diagram[current_row-1][current_col] in ('-', '+'):
            current_row -= 1
            direction = 'up'
        else:
            current_col -= 1
    elif direction == 'left':
        if current_col > 0 and diagram[current_row][current_col-1].isalpha():
            current_col -= 1
        elif current_row < len(diagram)-1 and diagram[current_row+1][current_col] in ('-', '+'):
            current_row += 1
            direction = 'down'
        elif current_row > 0 and diagram[current_row-1][current_col] in ('-', '+'):
            current_row -= 1
            direction = 'up'
        else:
            current_col += 1

    current_char = diagram[current_row][current_col]
    if current_char.isalpha():
        letters.append(current_char)

print(''.join(letters))
",2
69,2017,20,1,syntax_error,,344,"  File ""/tmp/tmpp913j_m7/tmp.py"", line 10
    p, v, a = particle
            ^
SyntaxError: invalid syntax
","
import re
from itertools import cycle
from typing import List, Tuple

def manhattan_distance(x: int, y: int, z: int) -> int:
    return abs(x) + abs(y) + abs(z)

def update_particle(particle: List[Tuple[int]]) -> List[Tuple[int]:
    p, v, a = particle
    new_v = tuple(map(sum, zip(v, a))
    new_p = tuple(map(sum, zip(p, new_v))
    return new_p, new_v, a

def closest_particle(particles: List[List[Tuple[Tuple[int]]) -> int:
    particles = [update_particle(p) for p in particles]
    distances = [manhattan_distance(*p[0]) for p in particles]
    return distances.index(min(distances))

def main():
    with open(""input.txt"", ""r"") as f:
        lines = f.readlines()
        particles = [list(map(int, re.findall(r'-?\d+', line)) for line in lines]
        particles = [((p, v, a) for p, v, a in zip(particles[::3], particles[1::3], particles[2::3])]
        result = closest_particle(particles)
        print(result)

if __name__ == ""__main__"":
    main()
",2
70,2017,21,1,runtime_error,,179,"Traceback (most recent call last):
  File ""/tmp/tmp9nzg2ibc/tmp.py"", line 33, in <module>
    main()
  File ""/tmp/tmp9nzg2ibc/tmp.py"", line 29, in main
    pattern = enhance_pattern(pattern, enhancement_rules)
  File ""/tmp/tmp9nzg2ibc/tmp.py"", line 16, in enhance_pattern
    current_pattern = ''.join([pattern[i+x][j:j+2] for x in range(2)] + [''.join([pattern[i+x][j+2] for x in range(2)])])
  File ""/tmp/tmp9nzg2ibc/tmp.py"", line 16, in <listcomp>
    current_pattern = ''.join([pattern[i+x][j:j+2] for x in range(2)] + [''.join([pattern[i+x][j+2] for x in range(2)])])
IndexError: string index out of range
","
from collections import defaultdict

def get_enhancement_rules(file_name):
    enhancement_rules = defaultdict(str)
    with open(file_name, 'r') as file:
        for line in file:
            input_pattern, output_pattern = line.strip().split(' => ')
            enhancement_rules[input_pattern] = output_pattern
    return enhancement_rules

def enhance_pattern(pattern, enhancement_rules):
    enhanced_pattern = []
    for i in range(0, len(pattern), 2):
        for j in range(0, len(pattern), 2):
            current_pattern = ''.join([pattern[i+x][j:j+2] for x in range(2)] + [''.join([pattern[i+x][j+2] for x in range(2)])])
            enhanced_pattern.append(enhancement_rules[current_pattern])
    return enhanced_pattern

def count_pixels(pattern):
    return sum(x.count('#') for x in pattern)

def main():
    file_name = 'input.txt'
    enhancement_rules = get_enhancement_rules(file_name)
    pattern = ['.#.', '..#', '###']
    iterations = 2
    for _ in range(iterations):
        pattern = enhance_pattern(pattern, enhancement_rules)
    print(count_pixels(pattern))

if __name__ == '__main__':
    main()
",2
71,2017,22,1,syntax_error,,5280,"  File ""/tmp/tmphlpz66vz/tmp.py"", line 12
    def get_infection_count(grid: List[List[str], bursts: int) -> int:
                                                             ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def get_input(file_name: str) -> List[List[str]]:
    """"""
    Reads the input file and returns a list of lists representing the grid.
    """"""
    with open(file_name, 'r') as file:
        grid = [list(line.strip()) for line in file]
    return grid

def get_infection_count(grid: List[List[str], bursts: int) -> int:
    """"""
    Calculates the number of infected nodes after a given number of bursts.
    """"""
    rows = len(grid)
    cols = len(grid[0])
    direction = 0  # 0: up, 1: right, 2: down, 3: left
    infected_count = 0
    position = (rows // 2, cols // 2)  # Start at the center of the grid
    
    for _ in range(bursts):
        if grid[position[0]][position[1]] == '.':
            grid[position[0]][position[1]] = '#'
            infected_count += 1
            direction = (direction - 1) % 4  # Turn left
        else:
            grid[position[0]][position[1]] = '.'
            direction = (direction + 1) % 4  # Turn right
            
        if direction == 0:
            position = (position[0] - 1, position[1])
        elif direction == 1:
            position = (position[0], position[1] + 1)
        elif direction == 2:
            position = (position[0] + 1, position[1])
        else:
            position = (position[0], position[1] - 1)
        
        # Handle edge cases
        if position[0] < 0:
            grid.insert(0, ['.'] * cols)
            position = (0, position[1])
        elif position[0] >= rows:
            grid.append(['.'] * cols)
            position = (rows, position[1])
        elif position[1] < 0:
            for row in grid:
                row.insert(0, '.')
            position = (position[0], 0)
        elif position[1] >= cols:
            for row in grid:
                row.append('.')
            position = (position[0], cols)
    
    return infected_count

def main():
    bursts = int(input(""Enter the number of bursts: ""))
    grid = get_input('input.txt')
    infection_count = get_infection_count(grid, bursts)
    print(f""The number of infected nodes after {bursts} bursts is {infection_count}"")

if __name__ == '__main__':
    main()
",2
72,2017,23,1,wrong_output,,6724,,"
import re

def count_mul_operations(file_path):
    with open(file_path, 'r') as file:
        instructions = file.readlines()
    mul_count = 0
    for instruction in instructions:
        operation, operands = re.split('[ ]+', instruction.strip())
        if operation == 'mul':
            mul_count += 1
    return mul_count
",2
73,2017,24,1,wrong_output,,2006,,"
from itertools import permutations

def max_strength_bridge(components):
    """"""
    Calculates the strength of the strongest bridge.
    Parameters:
    components (list): A list of components, where each component is represented as a tuple with two integers.
    
    Returns:
    int: The strength of the strongest bridge.
    """"""
    def get_strength(components, port):
        """"""
        Calculates the strength of the bridge starting from the given port.
        Parameters:
        components (list): A list of components, where each component is represented as a tuple with two integers.
        port (int): The port number to start the bridge.
        
        Returns:
        int: The strength of the bridge.
        """"""
        strength = 0
        for component in components:
            if port in component:
                next_port = component[0] if component[1] == port else component[1]
                strength += component[0] + component[1] - port
                components.remove(component)
                strength += get_strength(components, next_port)
                break
        return strength
    
    max_strength = 0
    for p in permutations(components):
        max_strength = max(max_strength, get_strength(list(p), 0))
        
    return max_strength
",2
74,2017,25,1,runtime_error,,2846,"Traceback (most recent call last):
  File ""/tmp/tmpkrdbe5az/tmp.py"", line 44, in <module>
    initial_state, steps = re.findall(r'^Begin in state (\w+)\.\nPerform a diagnostic checksum after (\d+) steps\.', data)
ValueError: not enough values to unpack (expected 2, got 1)
","
import re

def turing_machine(initial_state, steps, states):
    tape = [0]  # Initialize tape with a single 0
    cursor = 0  # Initialize the cursor to the first position
    current_state = initial_state  # Set the initial state
    checksum = 0  # Initialize the checksum

    for _ in range(steps):
        # Get the current value under the cursor
        current_value = tape[cursor]

        # Find the rule that matches the current value and state
        rule = states[current_state].get(current_value)

        # If no rule is found, the machine halts
        if not rule:
            break

        # Write the new value to the current position
        tape[cursor] = rule[0]

        # Move the cursor left or right
        cursor += 1 if rule[1] == 'R' else -1

        # Update the current state
        current_state = rule[2]

        # If the cursor moves beyond the tape, extend the tape with 0s
        if cursor >= len(tape):
            tape.extend([0] * (cursor - len(tape) + 1))

    # Calculate the diagnostic checksum
    checksum = sum(tape)

    return checksum

# Get input from input.txt file
with open('input.txt', 'r') as file:
    data = file.read()

# Extract initial state and number of steps
initial_state, steps = re.findall(r'^Begin in state (\w+)\.\nPerform a diagnostic checksum after (\d+) steps\.', data)
steps = int(steps)

# Extract states
states = {}
for state, rules in re.findall(r'In state (\w+):\n(?:  If the current value is 0:\n    - Write the value (\d+).\n    - Move one slot to the (left|right).\n    - Continue with state (\w+).\n)+', data):
    states[state] = {int(value): (int(write_value), direction, new_state) for value, direction, new_state in rules}

# Calculate the diagnostic checksum
checksum = turing_machine(initial_state, steps, states)

print(checksum) ",2
75,2018,1,1,no_error,"490
",490,,"
import sys

# Read the input file
with open('input.txt', 'r') as f:
    changes = [int(line.strip()) for line in f.readlines()]
    
# Calculate the final frequency
final_frequency = sum(changes)

# Print the final frequency
print(final_frequency)
",2
76,2018,2,1,no_error,"7163
",7163,,"
from collections import Counter

def count_letters(box_id):
    """"""
    Returns a dictionary of the frequency of each letter in the box ID.
    """"""
    letter_count = Counter(box_id)
    return letter_count

def calculate_checksum(box_ids):
    """"""
    Returns the checksum by counting the number of box IDs with exactly two of any letter and the number of box IDs with exactly three of any letter.
    """"""
    two_count = 0
    three_count = 0
    for box_id in box_ids:
        letter_count = count_letters(box_id)
        if any(count == 2 for count in letter_count.values()):
            two_count += 1
        if any(count == 3 for count in letter_count.values()):
            three_count += 1
    return two_count * three_count

with open('input.txt', 'r') as file:
    box_ids = file.readlines()

checksum = calculate_checksum(box_ids)
print(checksum)
",0
77,2018,3,1,runtime_error,,109716,"Traceback (most recent call last):
  File ""/tmp/tmpq_jx167c/tmp.py"", line 20, in <module>
    main()
  File ""/tmp/tmpq_jx167c/tmp.py"", line 16, in main
    overlaps = find_overlap(claims)
  File ""/tmp/tmpq_jx167c/tmp.py"", line 7, in find_overlap
    claim_id, pos_x, pos_y, width, height = map(int, claim.replace(':', '@').split()[1].split(','))
ValueError: invalid literal for int() with base 10: '@'
","
from collections import defaultdict

def find_overlap(claims):
    grid = defaultdict(int)
    for claim in claims:
        claim_id, pos_x, pos_y, width, height = map(int, claim.replace(':', '@').split()[1].split(','))
        for x in range(pos_x, pos_x + width):
            for y in range(pos_y, pos_y + height):
                grid[(x, y)] += 1
    return sum(1 for count in grid.values() if count > 1)

def main():
    with open('input.txt', 'r') as f:
        claims = f.readlines()
    overlaps = find_overlap(claims)
    print(overlaps)

if __name__ == '__main__':
    main()
",2
78,2018,4,1,runtime_error,,73646,"Traceback (most recent call last):
  File ""/tmp/tmp3dlqzs_b/tmp.py"", line 39, in <module>
    main()
  File ""/tmp/tmp3dlqzs_b/tmp.py"", line 32, in main
    records = [parse_record(line.strip()) for line in file]
  File ""/tmp/tmp3dlqzs_b/tmp.py"", line 32, in <listcomp>
    records = [parse_record(line.strip()) for line in file]
  File ""/tmp/tmp3dlqzs_b/tmp.py"", line 6, in parse_record
    date_str, activity = record.split()
ValueError: too many values to unpack (expected 2)
","
import datetime
import collections

def parse_record(record):
    date_str, activity = record.split()
    date = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M')
    guard_id = None
    if activity.startswith('Guard'):
        guard_id = activity.split('#')[1].split()[0]
    return date, activity, guard_id

def process_records(records):
    records.sort()
    guards_sleep_minutes = collections.defaultdict(lambda: [0] * 60)
    current_guard = None
    start_time = None
    end_time = None
    for timestamp, activity, guard_id in records:
        if activity == 'begins':
            current_guard = guard_id
        elif activity == 'falls':
            start_time = timestamp
        else:
            end_time = timestamp
            for minute in range(start_time.minute, end_time.minute):
                guards_sleep_minutes[current_guard][minute] += 1
    return guards_sleep_minutes

def main():
    with open('input.txt') as file:
        records = [parse_record(line.strip()) for line in file]
    guards_sleep_minutes = process_records(records)
    max_sleepy_guard = max(guards_sleep_minutes, key=lambda guard: sum(guards_sleep_minutes[guard]))
    max_minute = guards_sleep_minutes[max_sleepy_guard].index(max(guards_sleep_minutes[max_sleepy_guard]))
    print(int(max_sleepy_guard) * max_minute)

if __name__ == '__main__':
    main()
",2
79,2018,5,1,no_error,"9686
",9686,,"
from typing import List

def react_polymer(polymer: str) -> int:
    stack: List[str] = []
    for unit in polymer:
        if stack and abs(ord(unit) - ord(stack[-1])) == 32:  # Check if the current unit has opposite polarity with the top of the stack
            stack.pop()
        else:
            stack.append(unit)
    return len(stack)

with open(""input.txt"", ""r"") as f:
    polymer = f.read().strip()

result = react_polymer(polymer)
print(result)
",1
80,2018,6,1,no_error,"3909
",3909,,"
import sys
from collections import defaultdict

coords = []
min_x = sys.maxsize
max_x = -sys.maxsize
min_y = sys.maxsize
max_y = -sys.maxsize

with open('input.txt', 'r') as file:
    for line in file:
        x, y = line.strip().split(',')
        coords.append((int(x), int(y)))
        min_x = min(min_x, int(x))
        max_x = max(max_x, int(x))
        min_y = min(min_y, int(y))
        max_y = max(max_y, int(y))


def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def find_closest_coord(point, coords):
    min_dist = sys.maxsize
    closest_coord = None
    for coord in coords:
        distance = manhattan_distance(point, coord)
        if distance < min_dist:
            min_dist = distance
            closest_coord = coord
        elif distance == min_dist:
            closest_coord = None
    return closest_coord

def generate_grid(coords, min_x, max_x, min_y, max_y):
    grid = defaultdict(int)
    for x in range(min_x, max_x + 1):
        for y in range(min_y, max_y + 1):
            closest_coord = find_closest_coord((x, y), coords)
            if closest_coord:
                grid[(x, y)] = closest_coord
    return grid


def find_areas(grid):
    areas = defaultdict(int)
    for coord, closest_coord in grid.items():
        areas[closest_coord] += 1
    return areas

def find_largest_area(areas):
    max_area = 0
    for coord, area in areas.items():
        if area > max_area:
            max_area = area
    return max_area

grid = generate_grid(coords, min_x, max_x, min_y, max_y)
areas = find_areas(grid)
largest_area = find_largest_area(areas)

print(largest_area)
",1
81,2018,7,1,runtime_error,,GKRVWBESYAMZDPTIUCFXQJLHNO,"Traceback (most recent call last):
  File ""/tmp/tmpjnyejtqc/tmp.py"", line 29, in <module>
    print(generate_code(input_file))
  File ""/tmp/tmpjnyejtqc/tmp.py"", line 9, in generate_code
    before, after = re.findall(r'Step ([A-Z])', line)
ValueError: not enough values to unpack (expected 2, got 1)
","
import re

def generate_code(input_file):
    with open(input_file, 'r') as file:
        steps = {}
        for line in file:
            line = line.strip()
            before, after = re.findall(r'Step ([A-Z])', line)
            if before not in steps:
                steps[before] = set()
            if after not in steps:
                steps[after] = set()
            steps[after].add(before)

    ordered_steps = []
    while steps:
        next_step = min(steps.keys())
        ordered_steps.append(next_step)
        del steps[next_step]
        for step in steps.copy():
            steps[step].discard(next_step)
            if not steps[step]:
                del steps[step]

    return ''.join(ordered_steps)

input_file = 'input.txt'
print(generate_code(input_file))
",2
82,2018,8,1,no_error,"47244
",47244,,"
import sys

def sum_metadata(nodes):
    # Function to calculate the sum of metadata entries in a tree
    child_count, meta_count, node_value = nodes.pop(0), nodes.pop(0), 0
    for i in range(child_count):
        node_value += sum_metadata(nodes)
    for i in range(meta_count):
        node_value += nodes.pop(0)
    return node_value

# Read the input from the file
with open('input.txt', 'r') as f:
    numbers = list(map(int, f.read().split()))

# Calculate the sum of metadata entries
print(sum_metadata(numbers))
",0
83,2018,9,1,runtime_error,,384288,"Traceback (most recent call last):
  File ""/tmp/tmpcbu03ypm/tmp.py"", line 11, in <module>
    last_marble = int(last_marble.split(' ')[-1])
ValueError: invalid literal for int() with base 10: 'points'
","import sys

# Read input from file
filename = 'input.txt'
with open(filename) as f:
    line = f.readline().strip()

# Extract the number of players and value of last marble
num_players, last_marble = line.split(';')
num_players = int(num_players.split(' ')[0])
last_marble = int(last_marble.split(' ')[-1])

# Initialize variables
players = [0] * num_players
current_player = 0
current_marble = 0
marbles = [0]

# Play the game
for i in range(1, last_marble + 1):
    if i % 23 == 0:
        players[current_player] += i
        remove_index = (current_marble - 7) % len(marbles)
        players[current_player] += marbles.pop(remove_index)
        current_marble = remove_index % len(marbles)
    else:
        insert_index = (current_marble + 1) % len(marbles)
        marbles.insert(insert_index, i)
        current_marble = insert_index
    current_player = (current_player + 1) % num_players

# Find the winner
winner = players.index(max(players))
print(""The winner is player"", winner + 1, ""with"", max(players), ""points!"") ",2
84,2018,10,1,syntax_error,,GFNKCGGH,"  File ""/tmp/tmpqp9qv6nf/tmp.py"", line 17
    velocity = tuple(map(int, velocity.replace('>', '').split(','))
    ^
SyntaxError: invalid syntax
","
from typing import List, Tuple

def get_coordinates(file_name: str) -> List[Tuple[Tuple[int]]]:
    """"""
    Reads the coordinates and velocities from the input file and returns a list of tuples with the position and velocity of each point.
    """"""
    with open(file_name, 'r') as file:
        lines = file.readlines()

    coordinates = []
    for line in lines:
        line = line.strip().split('> ')
        position = line[0].split('position=<')[1]
        velocity = line[1].split('velocity=<')[1]
        position = tuple(map(int, position.replace('>', '').split(','))
        velocity = tuple(map(int, velocity.replace('>', '').split(','))
        coordinates.append((position, velocity))

    return coordinates

def get_message(coordinates: List[Tuple[Tuple[int]]) -> str:
    """"""
    Simulates the movement of the points for 100000 seconds and returns the message that appears in the sky.
    """"""
    for _ in range(100000):
        # Update the position of each point based on its velocity
        for i in range(len(coordinates)):
            coordinates[i] = (coordinates[i][0][0] + coordinates[i][1][0], coordinates[i][0][1] + coordinates[i][1][1])
    
    # Find the boundaries of the message
    min_x = min(coordinates, key=lambda x: x[0][0])[0][0]
    max_x = max(coordinates, key=lambda x: x[0][0])[0][0]
    min_y = min(coordinates, key=lambda x: x[0][1])[0][1]
    max_y = max(coordinates, key=lambda x: x[0][1])[0][1]

    # Generate the message
    message = ''
    for y in range(min_y, max_y + 1):
        for x in range(min_x, max_x + 1):
            if (x, y) in [pos for pos, vel in coordinates]:
                message += '#'
            else:
                message += ' '
        message += '\n'

    return message

if __name__ == '__main__':
    coordinates = get_coordinates('input.txt')
    message = get_message(coordinates)
    print(message)
",2
85,2018,11,1,wrong_output,"21 (234, 100)
","235,63",,"
import math

def calculate_power(x, y, serial_number):
    rack_id = x + 10
    power = rack_id * y
    power += serial_number
    power *= rack_id
    power = (power // 100) % 10 - 5
    return power

def generate_grid(serial_number):
    grid = []
    for y in range(1, 301):
        row = []
        for x in range(1, 301):
            row.append(calculate_power(x, y, serial_number))
        grid.append(row)
    return grid

def find_largest_square(grid):
    max_power = float('-inf')
    max_coords = None
    for y in range(1, 298):
        for x in range(1, 298):
            square_sum = sum(grid[y-1][x-1:x+2]) + sum(grid[y][x-1:x+2]) + sum(grid[y+1][x-1:x+2]) - grid[y][x-1] - grid[y+1][x] - grid[y][x+1]
            if square_sum > max_power:
                max_power = square_sum
                max_coords = (x, y)
    return max_power, max_coords

with open('input.txt') as f:
    serial_number = int(f.read().strip())

grid = generate_grid(serial_number)
max_power, max_coords = find_largest_square(grid)

print(max_power, max_coords)
",2
86,2018,12,1,timeout_error,,4110,TIMEOUT,"
import re

def next_generation(pots, rules):
    new_pots = []
    for i in range(2, len(pots)-2):
        pattern = pots[i-2] + pots[i-1] + pots[i] + pots[i+1] + pots[i+2]
        new_pots.append(rules[pattern])
    return '..' + ''.join(new_pots) + '..'

def sum_plants(pots):
    return sum(i for i, pot in enumerate(pots) if pot == '#')

initial_state = input().split()[2]
rules = {}
while True:
    try:
        pattern, result = input().split("" => "")
        rules[pattern] = result
    except:
        break

for i in range(20):
    initial_state = '..' + initial_state + '..'
    initial_state = next_generation(initial_state, rules)

print(sum_plants(initial_state))
",2
87,2018,13,1,syntax_error,,"79,128","  File ""/tmp/tmp92k4pgwn/tmp.py"", line 81
    while True:
    ^
SyntaxError: invalid syntax
","
from collections import defaultdict
from enum import Enum

class Direction(Enum):
    UP = '^'
    DOWN = 'v'
    LEFT = '<'
    RIGHT = '>'

class Turn(Enum):
    LEFT = 'left'
    STRAIGHT = 'straight'
    RIGHT = 'right'

class Cart:
    def __init__(self, x, y, direction):
        self.x = x
        self.y = y
        self.direction = direction
        self.turn_count = 0
        self.crashed = False

    def move(self, track):
        if not self.crashed:
            self.turn_count += 1
            self.turn(track)
            self.move_forward(track)

    def turn(self, track):
        if track[self.y][self.x] == '+':
            if self.turn_count % 3 == 0:
                self.direction = self.direction.turn_left()
            elif self.turn_count % 2 == 0:
                self.direction = self.direction.go_straight()
            else:
                self.direction = self.direction.turn_right()

    def move_forward(self, track):
        if self.direction == Direction.UP:
            self.y -= 1
        elif self.direction == Direction.DOWN:
            self.y += 1
        elif self.direction == Direction.LEFT:
            self.x -= 1
        elif self.direction == Direction.RIGHT:
            self.x += 1

    def turn_left(self):
        if self.direction == Direction.UP:
            return Direction.LEFT
        elif self.direction == Direction.DOWN:
            return Direction.RIGHT
        elif self.direction == Direction.LEFT:
            return Direction.DOWN
        else:
            return Direction.UP

    def turn_right(self):
        if self.direction == Direction.UP:
            return Direction.RIGHT
        elif self.direction == Direction.DOWN:
            return Direction.LEFT
        elif self.direction == Direction.LEFT:
            return Direction.UP
        else:
            return Direction.DOWN

    def go_straight(self):
        return self.direction

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

def find_first_crash(track_map):
    carts = []
    for y, row in enumerate(track_map):
        for x, char in enumerate(row):
            if char in ['^', 'v', '<', '>']:
                carts.append(Cart(x, y, Direction(char))
    while True:
        carts.sort(key=lambda cart: (cart.y, cart.x))
        for i, cart in enumerate(carts):
            cart.move(track_map)
            for j, other_cart in enumerate(carts[i+1:], i+1):
                if cart == other_cart:
                    cart.crashed = True
                    other_cart.crashed = True
                    return (cart.x, cart.y)


with open('input.txt', 'r') as f:
    track_map = [list(line.strip()) for line in f.readlines()]

print(find_first_crash(track_map))
",2
88,2018,14,1,wrong_output,"7777777777
",9411137133,,"
import math

def elf_move(recipe_scores, elf1, elf2):
    recipe_scores, elf1 = update_recipe(recipe_scores, elf1)
    recipe_scores, elf2 = update_recipe(recipe_scores, elf2)
    return recipe_scores, elf1, elf2

def update_recipe(recipe_scores, elf):
    new_score = recipe_scores[elf]
    recipe_scores.extend(list(str(new_score)) if new_score > 9 else [new_score])
    next_elf = (elf + 1 + new_score) % len(recipe_scores)
    return recipe_scores, next_elf

def generate_scores(n):
    recipe_scores = [3, 7]
    elf1, elf2 = 0, 1
    while len(recipe_scores) < n + 10:
        recipe_scores, elf1, elf2 = elf_move(recipe_scores, elf1, elf2)
    return ''.join(map(str, recipe_scores[n:n+10]))

def main():
    with open('input.txt', 'r') as f:
        n = int(f.read().strip())
    print(generate_scores(n))

if __name__ == '__main__':
    main()
",2
89,2018,15,1,syntax_error,,201638,"  File ""/tmp/tmpq46fri9m/tmp.py"", line 20
    for neighbor in get_neighbors(target[:2], (len(map), len(map[0])):
                                                                     ^
SyntaxError: invalid syntax
","
from collections import deque
from itertools import product
from typing import List, Tuple

def get_neighbors(position: Tuple[int, int], map_size: Tuple[int, int]) -> List[Tuple[int, int]]:
    neighbors = []
    for dx, dy in product([-1, 0, 1], [-1, 0, 1]):
        if dx != 0 or dy != 0:
            x, y = position
            n_x, n_y = x + dx, y + dy
            if 0 <= n_x < map_size[0] and 0 <= n_y < map_size[1]:
                neighbors.append((n_x, n_y))
    return neighbors

def find_nearest_targets(unit_position: Tuple[int, int], unit_type: str, units: List[Tuple[int, int, str, int]]) -> List[Tuple[int, int, str, int]]:
    in_range = []
    for target in units:
        if target[2] != unit_type:
            for neighbor in get_neighbors(target[:2], (len(map), len(map[0])):
                if neighbor != unit_position:
                    in_range.append(neighbor)
    return in_range

def find_nearest_empty(unit_position: Tuple[int, int], units: List[Tuple[int, int, str, int]], map_size: Tuple[int, int]) -> List[Tuple[int, int]]:
    visited = set()
    queue = deque([(unit_position, 0)])
    while queue:
        position, distance = queue.popleft()
        if position in visited:
            continue
        visited.add(position)
        if map[position[0]][position[1]] == '.':
            return position, distance
        for neighbor in get_neighbors(position, map_size):
            if neighbor not in visited and neighbor not in [u[:2] for u in units]:
                queue.append((neighbor, distance + 1))
    return []

def attack(unit_position: Tuple[int, int], units: List[Tuple[int, int, str, int]]) -> bool:
    in_range = find_nearest_targets(unit_position, unit_type, units)
    if in_range:
        target = min(in_range, key=lambda x: (x[2], x[0], x[1])
        target[2] -= 3
        if target[2] <= 0:
            units.remove(target)
        return True
    return False

def move_to_nearest_target(unit_position: Tuple[int, int], unit_type: str, units: List[Tuple[int, int, str, int], map_size: Tuple[int, int]) -> bool:
    nearest_empty = find_nearest_empty(unit_position, units, map_size)
    if nearest_empty:
        unit_position = nearest_empty
        return attack(unit_position, unit_type, units)
    return False

def process_turn(units: List[Tuple[int, int, str, int], map: List[str]) -> bool:
    units = sorted(units, key=lambda x: (x[0], x[1])
    for unit in units:
        if not attack(unit[:2], unit[2], units) and not move_to_nearest_target(unit[:2], unit[2], units, map_size):
            return False
    return True

def count_remaining_hit_points(units: List[Tuple[int, int, str, int]) -> int:
    return sum(unit[2] for unit in units)

def simulate_combat(map: List[str]) -> int:
    units = []
    for y, row in enumerate(map):
        for x, char in enumerate(row):
            if char in ('G', 'E'):
                units.append((x, y, char, 200))
    rounds = 0
    while process_turn(units, map):
        rounds += 1
    return rounds * count_remaining_hit_points(units)

with open('input.txt') as f:
    map = [list(line.strip()) for line in f.readlines()]

map_size = (len(map), len(map[0]))

result = simulate_combat(map)
print(result)
",2
90,2018,16,1,syntax_error,,642,"  File ""/tmp/tmpkdi4bd0c/tmp.py"", line 44
    if op_name == 'addr':
                        ^
SyntaxError: invalid syntax
","
import sys

def count_samples_with_three_or_more_opcodes(input_file):
    with open(input_file, 'r') as f:
        data = f.readlines()

    samples = []
    sample = []
    for line in data:
        if line == '\n':
            if sample:
                samples.append(sample)
                sample = []
        else:
            sample.append(line.strip())

    opcodes = {
        '0': 'addr',
        '1': 'addi',
        '2': 'mulr',
        '3': 'muli',
        '4': 'banr',
        '5': 'bani',
        '6': 'borr',
        '7': 'bori',
        '8': 'setr',
        '9': 'seti',
        '10': 'gtir',
        '11': 'gtri',
        '12': 'gtrr',
        '13': 'eqir',
        '14': 'eqri',
        '15': 'eqrr'
    }

    count = 0
    for sample in samples:
        initial_register, instruction, final_register = sample
        opcode, a, b, c = map(int, instruction.split())
        opcode_behavior = set()
        for op, op_name in opcodes.items():
            register = list(map(int, initial_register.split(':')[1].strip('[]').split(','))
            if op_name == 'addr':
                register[c] = register[a] + register[b]
            elif op_name == 'addi':
                register[c] = register[a] + b
            elif op_name == 'mulr':
                register[c] = register[a] * register[b]
            elif op_name == 'muli':
                register[c] = register[a] * b
            elif op_name == 'banr':
                register[c] = register[a] & register[b]
            elif op_name == 'bani':
                register[c] = register[a] & b
            elif op_name == 'borr':
                register[c] = register[a] | register[b]
            elif op_name == 'bori':
                register[c] = register[a] | b
            elif op_name == 'setr':
                register[c] = register[a]
            elif op_name == 'seti':
                register[c] = a
            elif op_name == 'gtir':
                register[c] = int(a > register[b])
            elif op_name == 'gtri':
                register[c] = int(register[a] > b)
            elif op_name == 'gtrr':
                register[c] = int(register[a] > register[b])
            elif op_name == 'eqir':
                register[c] = int(a == register[b])
            elif op_name == 'eqri':
                register[c] = int(register[a] == b)
            elif op_name == 'eqrr':
                register[c] = int(register[a] == register[b])

            if list(map(int, final_register.split(':')[1].strip('[]').split(',')) == register:
                opcode_behavior.add(op)

        if len(opcode_behavior) >= 3:
            count += 1

    return count
",2
91,2018,17,1,syntax_error,,31788,"  File ""/tmp/tmp0vzvy7sf/tmp.py"", line 59
    def count_water(water: Set[Tuple[int, int], Tuple[int, int], int, int) -> int:
                                                                         ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple, Dict, Set

def parse_input(input_file: str) -> List[Tuple[int, int, int, int]]:
    with open(input_file, ""r"") as f:
        data = f.readlines()
    
    parsed_data = []
    for line in data:
        line = line.strip()
        x_or_y, value = line.split(""="")
        if x_or_y == ""x"":
            x1, x2 = map(int, value.split(""..""))
            y1, y2 = int(data[0].split(""="")[1].split("".."")[0]), int(data[-1].split(""="")[1].split("".."")[1])
            parsed_data.append((x1, x2, y1, y2))
        else:
            x1, x2 = int(data[-1].split(""="")[1].split("".."")[0]), int(data[-1].split(""="")[1].split("".."")[1])
            y1, y2 = map(int, value.split("".."")[0])
            parsed_data.append((x1, x2, y1, y2))
    
    return parsed_data

def generate_clay(clay_data: List[Tuple[int, int, int, int]]) -> Dict[int, Set[int]]:
    clay_horizontal = {}
    for x1, x2, y1, y2 in clay_data:
        for x in range(x1, x2+1):
            if x not in clay_horizontal:
                clay_horizontal[x] = set()
            clay_horizontal[x].update(range(y1, y2+1))
    
    return clay_horizontal

def water_fall(clay_horizontal: Dict[int, Set[int]], spring_x: int, spring_y: int) -> Set[Tuple[int, int]]:
    water = set()
    settled = set()
    to_check = {(spring_x, spring_y)}
    while to_check:
        x, y = to_check.pop()
        water.add((x, y))
        if y == max(clay_horizontal.keys()):
            continue
        for x_delta in [-1, 1]:
            if x+x_delta in clay_horizontal and y+1 in clay_horizontal[x+x_delta]:
                if (x+x_delta, y+1) not in water:
                    to_check.add((x+x_delta, y+1))
            elif y+1 not in clay_horizontal.get(x, set()):
                to_check.add((x, y+1))
        if y+1 not in clay_horizontal.get(x, set()):
            continue
        for x_delta in [-1, 1]:
            if x+x_delta not in clay_horizontal or y in clay_horizontal.get(x+x_delta, set()):
                if (x+x_delta, y) in water:
                    settled.add((x, y))
        if (x, y+1) in water:
            settled.add((x, y))
    
    return water, settled

def count_water(water: Set[Tuple[int, int], Tuple[int, int], int, int) -> int:
    return sum(1 for x, y in water if y >= min_y and y <= max_y)

def count_settled(settled: Set[Tuple[int, int], Tuple[int, int], int, int) -> int:
    return sum(1 for x, y in settled if y >= min_y and y <= max_y)

if __name__ == ""__main__"":
    input_file = ""input.txt""
    clay_data = parse_input(input_file)
    clay_horizontal = generate_clay(clay_data)
    min_y = min(clay_horizontal.values(), key=min)[0]
    max_y = max(clay_horizontal.keys())
    water, settled = water_fall(clay_horizontal, 500, 0)
    print(""Water can reach"", count_water(water), ""tiles."")
    print(""Water can settle on"", count_settled(settled), ""tiles."")
",2
92,2018,18,1,wrong_output,"306090
",653184,,"
from copy import deepcopy
from os import path

def main():
    file_path = path.join('input.txt')
    with open(file_path, 'r') as file:
        data = file.read().splitlines()

    grid = [list(line) for line in data]

    for _ in range(10):
        grid = update_grid(grid)

    wooded_acres = sum(row.count('|') for row in grid)
    lumberyards = sum(row.count('#') for row in grid)
    resource_value = wooded_acres * lumberyards
    print(resource_value)

def update_grid(grid):
    new_grid = deepcopy(grid)
    for y in range(len(grid)):
        for x in range(len(grid[0])):
            adjacent_acres = get_adjacent_acres(grid, x, y)
            if grid[y][x] == '.':
                if adjacent_acres.count('|') >= 3:
                    new_grid[y][x] = '|'
            elif grid[y][x] == '|':
                if adjacent_acres.count('#') >= 3:
                    new_grid[y][x] = '#'
            elif grid[y][x] == '#':
                if adjacent_acres.count('#') >= 1 and adjacent_acres.count('|') >= 1:
                    new_grid[y][x] = '#'
                else:
                    new_grid[y][x] = '.'
    return new_grid

def get_adjacent_acres(grid, x, y):
    adjacent_acres = []
    for dy in [-1, 0, 1]:
        for dx in [-1, 0, 1]:
            if 0 <= y + dy < len(grid) and 0 <= x + dx < len(grid[0]):
                adjacent_acres.append(grid[y + dy][x + dx])
    return adjacent_acres

if __name__ == '__main__':
    main()
",2
93,2018,19,1,runtime_error,,2520,"Traceback (most recent call last):
  File ""/tmp/tmpib2kefy3/tmp.py"", line 36, in <module>
    opcode, a, b, c = re.findall(r'(\w+) (\d+) (\d+)', instructions[instruction_pointer])[0]
IndexError: list index out of range
","
import re

# Read input file
with open('input.txt') as f:
    instructions = f.readlines()

# Initialize registers and instruction pointer
registers = [0] * 6
ip_register = int(instructions[0].split()[1])
instruction_pointer = 0

# Function to execute instructions
def execute_instruction(opcode, a, b, c):
    global registers
    global instruction_pointer
    if opcode == 'set':
        registers[a] = b
    elif opcode == 'add':
        registers[a] += b
    elif opcode == 'mul':
        registers[a] *= b
    elif opcode == 'sub':
        registers[a] -= b
    elif opcode == 'jnz':
        if registers[a] != 0:
            instruction_pointer += c - 1
    
    # Update the value of the instruction pointer
    registers[ip_register] += 1
    instruction_pointer += 1

# Execute instructions
while 0 <= instruction_pointer < len(instructions):
    # Extract opcode, a, b, c from the current line
    opcode, a, b, c = re.findall(r'(\w+) (\d+) (\d+)', instructions[instruction_pointer])[0]
    if opcode == '#ip':
        ip_register = int(b)
    else:
        # Execute the instruction and update the instruction pointer
        execute_instruction(opcode, int(a), int(b))

# Print the value in register 0 at the end of the program
print(registers[0])
",2
94,2018,20,1,runtime_error,,4432,"Traceback (most recent call last):
  File ""/tmp/tmp89cndad8/tmp.py"", line 98, in <module>
    room, doors = furthest_room(regex)
  File ""/tmp/tmp89cndad8/tmp.py"", line 89, in furthest_room
    traverse((0, 0), 0, regex)
TypeError: traverse() missing 1 required positional argument: 'regex'
","
import re
import math


def furthest_room(regex):
    # Initialize variables
    max_doors = 0
    current_doors = 0
    max_room = None
    current_room = None
    current_position = (0, 0)
    visited_rooms = set()
    
    # Helper function to check if a room is valid
    def is_valid_room(x, y):
        return -1 <= x <= 10 and -1 <= y <= 10
    
    # Helper function to check if a room has already been visited
    def is_visited_room(x, y):
        return (x, y) in visited_rooms
    
    # Helper function to add a room to the visited set
    def add_visited_room(x, y):
        visited_rooms.add((x, y))
    
    # Helper function to move to a new position based on direction
    def move(direction, x, y):
        if direction == 'N':
            return (x, y + 1)
        elif direction == 'S':
            return (x, y - 1)
        elif direction == 'E':
            return (x + 1, y)
        elif direction == 'W':
            return (x - 1, y)
    
    # Helper function to get the next position and number of doors
    def next_position_and_doors(position, direction):
        new_position = move(*position, direction)
        doors = 0
        
        if not is_valid_room(*new_position):
            return None, doors
        
        if is_visited_room(new_position):
            return position, doors
        
        add_visited_room(*new_position)
        
        if direction == 'N' and (position[0], position[1] + 1) in visited_rooms:
            doors += 1
        elif direction == 'S' and (position[0], position[1] - 1) in visited_rooms:
            doors += 1
        elif direction == 'E' and (position[0] + 1, position[1]) in visited_rooms:
            doors += 1
        elif direction == 'W' and (position[0] - 1, position[1]) in visited_rooms:
            doors += 1
        
        return new_position, doors
    
    # Recursive function to traverse the maze
    def traverse(position, doors, regex_index, regex):
        global max_doors, max_room
        
        # Base case: we have reached the end of the regex
        if regex_index == len(regex):
            if doors > max_doors:
                max_doors = doors
                max_room = position
            return
        
        # If the current position is a branch, traverse both options
        if regex[regex_index] == '(':
            options = []
            option_index = regex.find(')', regex_index)
            options = regex[regex_index + 1:option_index].split('|')
            for option in options:
                traverse(position, doors, regex_index + 1 + len(option))
            return
        
        # If the current position is a direction, move to the next room
        direction = regex[regex_index]
        new_position, new_doors = next_position_and_doors(position, direction)
        if new_position:
            traverse(new_position, doors + new_doors, regex_index + 1)
    
    # Start traversing the maze
    traverse((0, 0), 0, regex)
    return max_room, max_doors


if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as f:
        regex = f.readline().strip()
        
    # Call the helper function and print the result
    room, doors = furthest_room(regex)
    print(f""The furthest room is {room} with {doors} doors."")
",2
95,2018,21,1,syntax_error,,2159153,"  File ""/tmp/tmp3vk753rs/tmp.py"", line 37
    reg[int(c)] = bitwise_or(reg[int(a), reg[int(b)] if b.isdigit() else int(b))
                                                                               ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import re

def bitwise_and(a, b):
    return a & b

def bitwise_or(a, b):
    return a | b

def bitwise_lshift(a, b):
    return a << b

def bitwise_rshift(a, b):
    return a >> b

def equal_to(a, b):
    return int(a == b)

def program_halted(ip, reg, instructions, min_instructions):
    if ip >= len(instructions):
        return True, min_instructions
    else:
        op, a, b, c = instructions[ip].split()
        if op == ""set"":
            reg[int(c)] = int(b)
            ip += 1
        elif op == ""add"":
            reg[int(c)] = reg[int(a)] + reg[int(b)]
            ip += 1
        elif op == ""mul"":
            reg[int(c)] = reg[int(a)] * reg[int(b)]
            ip += 1
        elif op == ""bitand"":
            reg[int(c)] = bitwise_and(reg[int(a)], reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        elif op == ""bitor"":
            reg[int(c)] = bitwise_or(reg[int(a), reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        elif op == ""lshift"":
            reg[int(c)] = bitwise_lshift(reg[int(a), reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        elif op == ""rshift"":
            reg[int(c)] = bitwise_rshift(reg[int(a), reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        elif op == ""eq"":
            reg[int(c)] = equal_to(reg[int(a), reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        elif op == ""gt"":
            reg[int(c)] = int(reg[int(a)] > reg[int(b)] if b.isdigit() else int(b))
            ip += 1
        else:
            raise ValueError(""Invalid operation"")
        return False, min_instructions

def main():
    with open(""input.txt"", ""r"") as f:
        lines = f.readlines()
        ip_reg = int(re.match(r""#ip (\d)"", lines[0]).group(1))
        instructions = [line.strip() for line in lines[1:]]

    reg = [0] * 6
    min_instructions = float(""inf"")
    ip = 0
    halted = False
    while not halted:
        halted, min_instructions = program_halted(ip, reg, instructions, min_instructions)
        ip = reg[ip_reg]
        if ip >= len(instructions):
            break
        if reg[0] > 0:
            return min_instructions
        if reg[0] == 0:
            for i in range(1, 2**36):
                reg[0] = i
                halted, min_instructions = program_halted(ip, reg, instructions, min_instructions)
                if halted:
                    break

    return min_instructions

if __name__ == ""__main__"":
    print(main())
",2
96,2018,22,1,syntax_error,,11972,"  File ""/tmp/tmphb0jyutd/tmp.py"", line 29
    target_x, target_y = target_coordinates
    ^
SyntaxError: invalid syntax
","
import math

def calculate_geologic_index(x, y, depth):
    return (x * 16807 + y + depth) % 20183

def calculate_erosion_level(geologic_index):
    return (geologic_index + depth) % 20183

def calculate_type(erosion_level):
    return erosion_level % 3

def calculate_risk_level(x, y, depth):
    geologic_index = calculate_geologic_index(x, y, depth)
    erosion_level = calculate_erosion_level(geologic_index)
    return calculate_type(erosion_level)

def calculate_total_risk_level(depth, target_x, target_y):
    risk_level = 0
    for x in range(target_x + 1):
        for y in range(target_y + 1):
            risk_level += calculate_risk_level(x, y, depth)
    return risk_level

if __name__ == ""__main__"":
    with open('input.txt') as file:
        depth = int(file.readline().strip())
        target_coordinates = tuple(map(int, file.readline().strip().split(','))
        target_x, target_y = target_coordinates
        risk_level = calculate_total_risk_level(depth, target_x, target_y)
        print(risk_level)
",2
97,2018,23,1,syntax_error,,270,"  File ""/tmp/tmpmm84mgjo/tmp.py"", line 16
    max_radius_bot = max(nanobots, key=lambda x: x[-1])
    ^
SyntaxError: invalid syntax
","
from itertools import combinations
import re

# Read the input file
with open('input.txt', 'r') as file:
    data = file.readlines()

# Extract the position and signal radius of each nanobot
nanobots = []
for line in data:
    x, y, z, r = map(int, re.findall(r'[-\d]+', line))
    nanobots.append(((x, y, z, r))

# Find the nanobot with the largest signal radius
max_radius_bot = max(nanobots, key=lambda x: x[-1])

# Count the number of nanobots in range of the max_radius_bot
in_range = 0
for bot in nanobots:
    dist = sum((a-b)**2 for a, b in zip(max_radius_bot[:-1], bot[:-1])) ** 0.5
    if dist <= max_radius_bot[-1]:
        in_range += 1

print(in_range)
",2
98,2018,24,1,syntax_error,,14377,"  File ""/tmp/tmpyzf6ehso/tmp.py"", line 67
    for group in sorted(chain(immune, infection), key=lambda x: (x.effective_power(), x.initiative, x.attack_type):
                                                                                                                  ^
SyntaxError: invalid syntax
","
import re
from collections import defaultdict
from itertools import chain
from typing import List, Tuple

class Group:
    def __init__(self, units: int, hp: int, damage: int, attack_type: str, initiative: int, weaknesses: List[str], immunities: List[str]):
        self.units = units
        self.hp = hp
        self.damage = damage
        self.attack_type = attack_type
        self.initiative = initiative
        self.weaknesses = weaknesses
        self.immunities = immunities
        self.target = None

    def __repr__(self):
        return f""Group({self.units}, {self.hp}, {self.damage}, {self.attack_type}, {self.initiative}, {self.weaknesses}, {self.immunities})""

    def effective_power(self):
        return self.units * self.damage

    def calculate_damage(self, other: 'Group') -> int:
        if self.attack_type in other.immunities:
            return 0
        elif self.attack_type in other.weaknesses:
            return self.effective_power() * 2
        else:
            return self.effective_power()

    def attack(self) -> bool:
        if self.target:
            damage = self.calculate_damage(self.target)
            self.target.take_damage(damage)
            return self.target.is_alive()
        return False

    def take_damage(self, damage: int):
        self.units = max(0, self.units - damage // self.hp)

    def is_alive(self) -> bool:
        return self.units > 0

def parse_input(filename: str) -> Tuple[List[Group], List[Group]]:
    immune, infection = [], []
    current_army = None
    with open(filename, 'r') as f:
        for line in f:
            line = line.strip()
            if line.startswith('Immune'):
                current_army = immune
                continue
            if line.startswith('Infection'):
                current_army = infection
                continue
            if not line:
                continue
            if line.startswith(':'):
                _, units, hp, damage, attack_type, initiative, weaknesses, immunities = re.findall(r'(\d+)\s+(\d+)\s+(\w+)\s+(\d+)\s+(\d+)\s+\((.*)\)', line)[0]
                weaknesses = weaknesses.split('; ')
                immunities = immunities[1:-1].split(', ') if immunities != 'none' else []
                current_army.append(Group(int(units), int(hp), attack_type, int(initiative), weaknesses, immunities))
    return immune, infection

def target_selection(immune: List[Group], infection: List[Group]):
    for group in sorted(chain(immune, infection), key=lambda x: (x.effective_power(), x.initiative, x.attack_type):
        enemy = max([g for g in infection if g.attack_type not in group.immunities], key=lambda x: (group.calculate_damage(x), x.effective_power(), x.initiative) if group in immune else (x.calculate_damage(group), x.effective_power(), x.initiative, x.attack_type), default=None)
        if enemy and group.calculate_damage(enemy) > 0:
            group.target = enemy

def fight(immune: List[Group], infection: List[Group]) -> bool:
    while immune and infection:
        target_selection(immune, infection)
        target_selection(infection, immune)
        for group in sorted(chain(immune, infection), key=lambda x: x.initiative):
            if group.attack():
                continue
        immune = [g for g in immune if g.is_alive()]
        infection = [g for g in infection if g.is_alive()]
        if not immune or not infection:
            break
    return bool(immune)

def main():
    immune, infection = parse_input('input.txt')
    while fight(immune, infection):
        immune, infection = immune, infection
    winning_army = immune or infection
    print(sum(g.units for g in winning_army))

if __name__ == '__main__':
    main()
",2
99,2018,25,1,runtime_error,,363,"Traceback (most recent call last):
  File ""/tmp/tmpw1q5ngbv/tmp.py"", line 27, in <module>
    main()
  File ""/tmp/tmpw1q5ngbv/tmp.py"", line 23, in main
    constellations = find_constellations(coordinates)
  File ""/tmp/tmpw1q5ngbv/tmp.py"", line 17, in find_constellations
    merge_constellations(constellations, i, j)
  File ""/tmp/tmpw1q5ngbv/tmp.py"", line 9, in merge_constellations
    for c in constellations[j]:
TypeError: 'NoneType' object is not iterable
","
import math
from itertools import combinations

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2]) + abs(a[3] - b[3])

def merge_constellations(constellations, i, j):
    for c in constellations[j]:
        constellations[i].add(c)
    constellations[j] = None

def find_constellations(coordinates):
    constellations = [{c} for c in coordinates]
    for i, j in combinations(range(len(constellations)), 2):
        if manhattan_distance(coordinates[i], coordinates[j]) <= 3:
            merge_constellations(constellations, i, j)
    return [c for c in constellations if c is not None]

def main():
    with open('input.txt', 'r') as file:
        coordinates = [tuple(int(x) for x in line.strip().split(',')) for line in file.readlines()]
    constellations = find_constellations(coordinates)
    print(len(constellations))

if __name__ == ""__main__"":
    main()
",2
100,2019,1,1,no_error,"3336439
",3336439,,"
import math

def calculate_fuel(mass):
    return math.floor(mass / 3) - 2

total_fuel = 0

with open('input.txt', 'r') as file:
    for line in file:
        total_fuel += calculate_fuel(int(line))

print(total_fuel)
",0
101,2019,2,1,no_error,"4138658
",4138658,,"
import sys

# Read the input file
with open('input.txt', 'r') as file:
    data = file.read()

# Convert the input string to a list of integers
intcode = [int(i) for i in data.split(',')]

# Replace position 1 and 2 with the given values
intcode[1] = 12
intcode[2] = 2

# Initialise the instruction pointer
ptr = 0

# Run the Intcode program until it halts
while intcode[ptr] != 99:
    opcode = intcode[ptr]
    if opcode == 1:
        # Addition operation
        a = intcode[intcode[ptr+1]]
        b = intcode[intcode[ptr+2]]
        output_address = intcode[ptr+3]
        intcode[output_address] = a + b
    elif opcode == 2:
        # Multiplication operation
        a = intcode[intcode[ptr+1]]
        b = intcode[intcode[ptr+2]]
        output_address = intcode[ptr+3]
        intcode[output_address] = a * b
    ptr += 4

# Print the output
print(intcode[0])
",2
102,2019,3,1,wrong_output,"Closest intersection point: (248, 0), distance: 248
",248,,"
import sys
from collections import defaultdict

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def generate_path(path):
    x, y = 0, 0
    points = set()
    for instruction in path.split(','):
        direction = instruction[0]
        distance = int(instruction[1:])
        if direction == 'R':
            for i in range(distance):
                x += 1
                point = (x, y)
                points.add(point)
        elif direction == 'L':
            for i in range(distance):
                x -= 1
                point = (x, y)
                points.add(point)
        elif direction == 'U':
            for i in range(distance):
                y += 1
                point = (x, y)
                points.add(point)
        elif direction == 'D':
            for i in range(distance):
                y -= 1
                point = (x, y)
                points.add(point)
    return points

def find_closest_intersection(path1, path2):
    points1 = generate_path(path1)
    points2 = generate_path(path2)
    min_distance = float('inf')
    closest_point = None
    for point in points1.intersection(points2):
        distance = manhattan_distance(point, (0, 0))
        if distance < min_distance:
            min_distance = distance
            closest_point = point
    return closest_point, min_distance

if __name__ == '__main__':
    with open('input.txt', 'r') as f:
        wire1, wire2 = f.readlines()
        closest_point, min_distance = find_closest_intersection(wire1.strip(), wire2.strip())
        print(f""Closest intersection point: {closest_point}, distance: {min_distance}"")
",2
103,2019,4,1,no_error,"454
",454,,"
import re

def is_valid_password(password):
    if len(password) != 6:
        return False
    if not password.isdigit():
        return False
    if not re.search(r'(\d)\1', password):
        return False
    if not all(password[i] <= password[i+1] for i in range(len(password) - 1)):
        return False
    return True

def count_valid_passwords(start, end):
    count = 0
    for password in range(start, end + 1):
        if is_valid_password(str(password)):
            count += 1
    return count

with open('input.txt') as f:
    start, end = f.read().strip().split('-')
    start, end = int(start), int(end)
    count = count_valid_passwords(start, end)
    print(count)
",0
104,2019,5,1,syntax_error,,6069343,"  File ""/tmp/tmp7z1lesst/tmp.py"", line 13
    print(""Diagnostic code:"", diagnostic_code)
    ^
SyntaxError: invalid syntax
","
import sys

def main():
    with open('input.txt', 'r') as f:
        program = list(map(int, f.readline().split(','))

    # Your implementation of the diagnostic program goes here.
    # You should read the input.txt file, run the program, and output the diagnostic code.
    # You can use any necessary libraries or modules in your implementation.
    # For example, you might want to use the `sys` module to read input from the user.

    print(""Diagnostic code:"", diagnostic_code)

if __name__ == ""__main__"":
    main()


import sys

def run_intcode(program, input_value):
    """"""Runs the Intcode program and returns the diagnostic code.""""""
    # Your implementation of the Intcode computer goes here.
    # This function should take the Intcode program as input and return the diagnostic code.
    # You can use the `sys` module to read the input value from the user.
    pass

def main():
    with open('input.txt', 'r') as f:
        program = list(map(int, f.readline().split(','))

    input_value = int(input(""Enter input value: ""))
    diagnostic_code = run_intcode(program, input_value)
    print(""Diagnostic code:"", diagnostic_code)

if __name__ == ""__main__"":
    main()
",2
105,2019,6,1,runtime_error,,142497,"Traceback (most recent call last):
  File ""/tmp/tmpl59hiz_4/tmp.py"", line 14, in <module>
    obj1, obj2 = re.match(r""(\w+)\)\)(\w+)"", line.strip()).groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re

# Reading the input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Creating a dictionary to store the orbital relationships
orbits = {}

# Looping through each line in the input file
for line in lines:
    # Extracting the objects from the relationship
    obj1, obj2 = re.match(r""(\w+)\)\)(\w+)"", line.strip()).groups()
    
    # Adding to the dictionary
    if obj1 in orbits:
        orbits[obj1].append(obj2)
    else:
        orbits[obj1] = [obj2]

# Recursive function to calculate the total number of direct and indirect orbits
def count_orbits(obj, visited, total):
    # If the object is not in the dictionary, it has no orbit
    if obj not in orbits:
        return 0
    
    # Incrementing the total number of orbits for the current object
    total += len(orbits[obj])
    
    # Marking the object as visited
    visited.add(obj)
    
    # Looping through each child object and recursively calling the function
    for child in orbits[obj]:
        if child not in visited:
            total = count_orbits(child, visited, total) + 1
            
    return total

# Initializing the visited set and calculating the total number of orbits
visited = set()
total = 0
for obj in orbits.keys():
    total += count_orbits(obj, visited, 0)

# Printing the total number of orbits
print(total)
",2
106,2019,7,1,runtime_error,,77500,"Traceback (most recent call last):
  File ""/tmp/tmpv26n0e5w/tmp.py"", line 118, in <module>
    output = run_amplifiers(program, phase_settings)
  File ""/tmp/tmpv26n0e5w/tmp.py"", line 11, in run_amplifiers
    input_signal = run_amplifier(amplifiers[i], input_signal)
  File ""/tmp/tmpv26n0e5w/tmp.py"", line 110, in run_amplifier
    raise Exception(""Invalid opcode"")
Exception: Invalid opcode
","
import itertools

def run_amplifiers(program, phase_settings):
    amplifiers = []
    for i in range(len(phase_settings)):
        amplifiers.append(program.copy())
        amplifiers[i].append(phase_settings[i])
    input_signal = 0
    for i in range(len(amplifiers)):
        input_signal = run_amplifier(amplifiers[i], input_signal)
    return input_signal

def run_amplifier(program, input_signal):
    ip = 0
    while ip < len(program):
        opcode = program[ip] % 100
        mode_1 = (program[ip] // 100) % 10
        mode_2 = (program[ip] // 1000) % 10
        mode_3 = (program[ip] // 10000) % 10
        if opcode == 1:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            program[program[ip+3]] = operand_1 + operand_2
            ip += 4
        elif opcode == 2:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            program[program[ip+3]] = operand_1 * operand_2
            ip += 4
        elif opcode == 3:
            program[program[ip+1]] = input_signal
            ip += 2
        elif opcode == 4:
            if mode_1 == 0:
                output = program[program[ip+1]]
            else:
                output = program[ip+1]
            ip += 2
            return output
        elif opcode == 5:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            if operand_1 != 0:
                ip = operand_2
            else:
                ip += 3
        elif opcode == 6:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            if operand_1 == 0:
                ip = operand_2
            else:
                ip += 3
        elif opcode == 7:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            if operand_1 < operand_2:
                program[program[ip+3]] = 1
            else:
                program[program[ip+3]] = 0
            ip += 4
        elif opcode == 8:
            if mode_1 == 0:
                operand_1 = program[program[ip+1]]
            else:
                operand_1 = program[ip+1]
            if mode_2 == 0:
                operand_2 = program[program[ip+2]]
            else:
                operand_2 = program[ip+2]
            if operand_1 == operand_2:
                program[program[ip+3]] = 1
            else:
                program[program[ip+3]] = 0
            ip += 4
        elif opcode == 99:
            return None
        else:
            raise Exception(""Invalid opcode"")
    return None

file = open('input.txt', 'r')
program = [int(x) for x in file.read().split(',')]

max_output = 0
for phase_settings in itertools.permutations(range(5, 10)):
    output = run_amplifiers(program, phase_settings)
    if output > max_output:
        max_output = output

print(max_output)
",2
107,2019,8,1,runtime_error,,1742,"Traceback (most recent call last):
  File ""/tmp/tmpc2gv6fw7/tmp.py"", line 2, in <module>
    from PIL import Image
ModuleNotFoundError: No module named 'PIL'
","
from PIL import Image
import numpy as np
import sys

# Open the file and read the input
with open('input.txt', 'r') as file:
    data = file.readline().strip()

# Convert the string into a numpy array
arr = np.array(list(data))

# Calculate the dimensions of the image
width = 25
height = 6
size = width * height

# Reshape the array into layers of size (height, width)
layers = arr.reshape(-1, height, width)

# Initialize the count of zeros and twos to infinity
zeros = sys.maxsize
twos = sys.maxsize

# Initialize the index of the layer with minimum zeros and twos to -1
min_index = -1

for i in range(layers.shape[0]):
    # Count the number of zeros and twos in the current layer
    zero_count = np.count_nonzero(layers[i] == '0')
    two_count = np.count_nonzero(layers[i] == '2')
    
    # If the count of zeros is less than the current minimum, update the minimum count and the index
    if zero_count < zeros:
        zeros = zero_count
        twos = two_count
        min_index = i

# Calculate the product of ones and twos on the layer with minimum zeros
product = np.count_nonzero(layers[min_index] == '1') * twos

print(product)
",2
108,2019,9,1,runtime_error,,3780860499,"Traceback (most recent call last):
  File ""/tmp/tmpetsmjv8r/tmp.py"", line 106, in <module>
    main()
  File ""/tmp/tmpetsmjv8r/tmp.py"", line 7, in main
    boost_keycode = generate_boost_keycode(program)
  File ""/tmp/tmpetsmjv8r/tmp.py"", line 16, in generate_boost_keycode
    return boost_keycode
NameError: name 'boost_keycode' is not defined
","
import sys

def main():
    with open('input.txt', 'r') as f:
        program = [int(i) for i in f.read().strip().split(',')]
    boost_keycode = generate_boost_keycode(program)
    print(f""BOOST keycode: {boost_keycode}"")

def generate_boost_keycode(program):
    # Your code here to modify the Intcode program and compute the BOOST keycode
    # You may use the following function to execute the modified program
    # boost_keycode = execute_intcode(program, input_value)
    # Your code here to generate the BOOST keycode

    return boost_keycode

def execute_intcode(program, input_value):
    relative_base = 0
    pointer = 0
    while pointer < len(program):
        instruction = program[pointer]
        opcode, modes = parse_instruction(instruction)
        if opcode == 1:
            a, b, c = program[pointer+1], program[pointer+2], program[pointer+3]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            program[get_pointer(program, c, modes[2], relative_base)] = a + b
            pointer += 4
        elif opcode == 2:
            a, b, c = program[pointer+1], program[pointer+2], program[pointer+3]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            program[get_pointer(program, c, modes[2], relative_base)] = a * b
            pointer += 4
        elif opcode == 3:
            a = program[pointer+1]
            program[get_pointer(program, a, modes[0], relative_base)] = input_value
            pointer += 2
        elif opcode == 4:
            a = program[pointer+1]
            return get_value(program, a, modes[0], relative_base)
            pointer += 2
        elif opcode == 5:
            a, b = program[pointer+1], program[pointer+2]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            if a != 0:
                pointer = b
            else:
                pointer += 3
        elif opcode == 6:
            a, b = program[pointer+1], program[pointer+2]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            if a == 0:
                pointer = b
            else:
                pointer += 3
        elif opcode == 7:
            a, b, c = program[pointer+1], program[pointer+2], program[pointer+3]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            program[get_pointer(program, c, modes[2], relative_base)] = int(a < b)
            pointer += 4
        elif opcode == 8:
            a, b, c = program[pointer+1], program[pointer+2], program[pointer+3]
            a = get_value(program, a, modes[0], relative_base)
            b = get_value(program, b, modes[1], relative_base)
            program[get_pointer(program, c, modes[2], relative_base)] = int(a == b)
            pointer += 4
        elif opcode == 9:
            a = program[pointer+1]
            relative_base += get_value(program, a, modes[0], relative_base)
            pointer += 2
        elif opcode == 99:
            break
        else:
            raise ValueError(f""Invalid opcode: {opcode}"")
    return None

def parse_instruction(instruction):
    opcode = instruction % 100
    modes = [int(d) for d in str(instruction // 100).zfill(3)]
    return opcode, modes[::-1]

def get_pointer(program, pointer, mode, relative_base):
    if mode == 0:
        return pointer
    elif mode == 2:
        return pointer + relative_base
    else:
        raise ValueError(f""Invalid mode: {mode}"")

def get_value(program, pointer, mode, relative_base):
    if mode == 0:
        return program[pointer]
    elif mode == 1:
        return pointer
    elif mode == 2:
        return program[pointer + relative_base]
    else:
        raise ValueError(f""Invalid mode: {mode}"")

if __name__ == ""__main__"":
    main()


def generate_boost_keycode(program):
    boost_keycode = execute_intcode(program, 1)
    return boost_keycode
",2
109,2019,10,1,syntax_error,,309,"  File ""/tmp/tmpj6u4p9xr/tmp.py"", line 5
    def count_visible_asteroids(x: int, y: int, asteroid_map: List[List[str]) -> int:
                                                                            ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple, Set

def findBestAsteroid(input: str) -> int:
    def count_visible_asteroids(x: int, y: int, asteroid_map: List[List[str]) -> int:
        directions = [(dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if (dx, dy) != (0, 0)]
        count = 0
        for dx, dy in directions:
            for depth in range(1, len(asteroid_map) + len(asteroid_map[0])):
                new_x, new_y = x + dx * depth, y + dy * depth
                if 0 <= new_x < len(asteroid_map) and 0 <= new_y < len(asteroid_map[0]) and asteroid_map[new_x][new_y] == '#':
                    count += 1
                    break
        return count

    def find_best_location(asteroid_map: List[List[str]) -> Tuple[int, int]:
        best_location = (-1, -1)
        max_visible = -1
        for x, row in enumerate(asteroid_map):
            for y, value in enumerate(row):
                if value == '#':
                    visible_count = count_visible_asteroids(x, y, asteroid_map)
                    if visible_count > max_visible:
                        max_visible = visible_count
                        best_location = (x, y)
        return best_location

    asteroid_map = [list(line) for line in input.split('\n')]
    x, y = find_best_location(asteroid_map)
    return count_visible_asteroids(x, y, asteroid_map)

def main():
    with open(""input.txt"", ""r"") as f:
        input_string = f.read()
        print(findBestAsteroid(input_string))

if __name__ == ""__main__"":
    main()
",2
110,2019,11,1,syntax_error,,2336,"  File ""/tmp/tmp65bwmixn/tmp.py"", line 150
    input_code = [0]
    ^
SyntaxError: invalid syntax
","
import sys
from collections import defaultdict

def run_intcode(program, input_code):
    ip = 0
    relative_base = 0
    while ip < len(program):
        opcode = program[ip] % 100
        mode1 = (program[ip] // 100) % 10
        mode2 = (program[ip] // 1000) % 10
        mode3 = (program[ip] // 10000) % 10

        if opcode == 1:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if mode3 == 0:
                program[program[ip+3]] = op1 + op2
            elif mode3 == 2:
                program[program[ip+3] + relative_base] = op1 + op2
            ip += 4
        elif opcode == 2:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if mode3 == 0:
                program[program[ip+3]] = op1 * op2
            elif mode3 == 2:
                program[program[ip+3] + relative_base] = op1 * op2
            ip += 4
        elif opcode == 3:
            if mode1 == 0:
                program[program[ip+1]] = input_code.pop(0)
            elif mode1 == 2:
                program[program[ip+1] + relative_base] = input_code.pop(0)
            ip += 2
        elif opcode == 4:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            print(op1)
            ip += 2
        elif opcode == 5:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if op1 != 0:
                ip = op2
            else:
                ip += 3
        elif opcode == 6:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if op1 == 0:
                ip = op2
            else:
                ip += 3
        elif opcode == 7:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if mode3 == 0:
                program[program[ip+3]] = 1 if op1 < op2 else 0
            elif mode3 == 2:
                program[program[ip+3] + relative_base] = 1 if op1 < op2 else 0
            ip += 4
        elif opcode == 8:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            if mode2 == 0:
                op2 = program[program[ip+2]]
            elif mode2 == 1:
                op2 = program[ip+2]
            elif mode2 == 2:
                op2 = program[program[ip+2] + relative_base]
            if mode3 == 0:
                program[program[ip+3]] = 1 if op1 == op2 else 0
            elif mode3 == 2:
                program[program[ip+3] + relative_base] = 1 if op1 == op2 else 0
            ip += 4
        elif opcode == 9:
            if mode1 == 0:
                op1 = program[program[ip+1]]
            elif mode1 == 1:
                op1 = program[ip+1]
            elif mode1 == 2:
                op1 = program[program[ip+1] + relative_base]
            relative_base += op1
            ip += 2
        else:
            print(""ERROR: bad opcode"")
            sys.exit(1)

def main():
    program = list(map(int, input().rstrip().split(','))
    input_code = [0]
    run_intcode(program, input_code)

if __name__ == ""__main__"":
    main()
",2
111,2019,12,1,syntax_error,,6220,"  File ""/tmp/tmpb1tovnzn/tmp.py"", line 5
    def simulateMotion(moons: List[Tuple[int, int, int], steps: int) -> int:
                                                                   ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple
import re

def simulateMotion(moons: List[Tuple[int, int, int], steps: int) -> int:
    # Initialize the moons
    positions = moons
    velocities = [(0, 0, 0) for _ in range(len(moons))]

    for _ in range(steps):
        # Update velocities for each pair of moons
        for i in range(4):
            for j in range(i+1, 4):
                # Calculate the gravity effect between each pair of moons
                for k in range(3):
                    if positions[i][k] > positions[j][k]:
                        velocities[i] = (velocities[i][0] - 1, velocities[i][1] - 1, velocities[i][2] - 1)
                        velocities[j] = (velocities[j][0] + 1, velocities[j][1] + 1, velocities[j][2] + 1)
                    elif positions[i][k] < positions[j][k]:
                        velocities[i] = (velocities[i][0] + 1, velocities[i][1] + 1, velocities[i][2] + 1)
                        velocities[j] = (velocities[j][0] - 1, velocities[j][1] - 1, velocities[j][2] - 1)

        # Update positions for each moon
        for i in range(4):
            positions[i] = (positions[i][0] + velocities[i][0], positions[i][1] + velocities[i][1], positions[i][2] + velocities[i][2])

    # Calculate and return the total energy
    totalEnergy = 0
    for i in range(4):
        potentialEnergy = sum(abs(x) for x in positions[i])
        kineticEnergy = sum(abs(x) for x in velocities[i])
        totalEnergy += potentialEnergy * kineticEnergy

    return totalEnergy

# Read the input file
with open('input.txt', 'r') as f:
    input_data = f.readlines()

# Extract the positions from the input file
positions = []
for line in input_data:
    x, y, z = re.findall(r'-?\d+', line)
    positions.append((int(x), int(y), int(z))

# Simulate the motion and calculate the total energy
totalEnergy = simulateMotion(positions, 10000)

print(totalEnergy)
",2
112,2019,13,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmprrt3l71r/tmp.py"", line 69, in <module>
    main()
  File ""/tmp/tmprrt3l71r/tmp.py"", line 64, in main
    output = run_intcode(code, [])
  File ""/tmp/tmprrt3l71r/tmp.py"", line 13, in run_intcode
    a, b, c, d = values[i+1:i+4]
ValueError: not enough values to unpack (expected 4, got 3)
","
import sys

def run_intcode(code, input_values):
    # Initialize the Intcode computer
    values = code[:]
    input_index = 0
    output = []
    i = 0
    while i < len(values):
        opcode = values[i]
        if opcode == 1:
            a, b, c, d = values[i+1:i+4]
            values[d] = values[a] + values[b]
            i += 4
        elif opcode == 2:
            a, b, c, d = values[i+1:i+4]
            values[d] = values[a] * values[b]
            i += 4
        elif opcode == 3:
            a = values[i+1]
            values[a] = input_values[input_index]
            input_index += 1
            i += 2
        elif opcode == 4:
            a = values[i+1]
            output.append(values[a])
            i += 2
        elif opcode == 5:
            a, b, c = values[i+1:i+3]
            if values[a] != 0:
                i = values[c]
            else:
                i += 3
        elif opcode == 6:
            a, b, c = values[i+1:i+3]
            if values[a] == 0:
                i = values[c]
            else:
                i += 3
        elif opcode == 7:
            a, b, c, d = values[i+1:i+4]
            values[d] = 1 if values[a] < values[b] else 0
            i += 4
        elif opcode == 8:
            a, b, c, d = values[i+1:i+4]
            values[d] = 1 if values[a] == values[b] else 0
            i += 4
        elif opcode == 99:
            break
        else:
            raise ValueError(""Invalid opcode: {}"".format(opcode))
            
    return output

def parse_input(filename):
    with open(filename, 'r') as f:
        contents = f.read().strip().split(',')
        code = [int(x) for x in contents]
    return code

def main():
    code = parse_input('input.txt')
    output = run_intcode(code, [])
    block_count = output.count(2)
    print(""The number of block tiles on the screen is: {}"".format(block_count))

if __name__ == ""__main__"":
    main()
",2
113,2019,14,1,wrong_output,,532506,,"
import re

def produce_fuel(reactions, fuel_amount=1):
    surplus = {}
    def get_required_ore(fuel_amount):
        if fuel_amount <= surplus.get('ORE', 0):
            surplus['ORE'] -= fuel_amount
            return 0
        
        # Calculate the minimum amount of ORE required to produce 1 unit of FUEL
        ore_required = 0
        produced_fuel = 0
        while produced_fuel < fuel_amount:
            for output, inputs in reactions.items():
                output_quantity, output_chemical = output
                if output_chemical == 'ORE':
                    continue

                if surplus.get(output_chemical, 0) >= output_quantity:
                    surplus[output_chemical] -= output_quantity
                    continue
                
                input_ore = 0
                for input_quantity, input_chemical in inputs:
                    if input_chemical == 'ORE':
                        input_ore += input_quantity
                    else:
                        input_ore += get_required_ore(input_quantity * (int(fuel_amount / produced_fuel + 1)) - surplus.get(input_chemical, 0))
                        surplus[input_chemical] = max(0, surplus.get(input_chemical, 0) - input_quantity * (int(fuel_amount / produced_fuel + 1)) + output_quantity)

                produced_fuel += output_quantity * (int(fuel_amount / produced_fuel + 1)) - surplus.get(output_chemical, 0)
                surplus[output_chemical] = max(0, surplus.get(output_chemical, 0) - output_quantity * (int(fuel_amount / produced_fuel + 1)) + output_quantity)

                if produced_fuel >= fuel_amount:
                    break

            ore_required += input_ore
        
        return ore_required

    # Read input from file
    with open('input.txt', 'r') as f:
        reactions = {}
        for line in f:
            output, inputs = line.strip().split(' => ')
            output_quantity, output_chemical = re.findall(r'(\d+) (\w+)', output)[0]
            reactions[output_chemical] = []
            for input_str in inputs.split(', '):
                input_quantity, input_chemical = re.findall(r'(\d+) (\w+)', input_str)[0]
                reactions[output_chemical].append((int(input_quantity), input_chemical))

    # Calculate the minimum amount of ORE required to produce 1 unit of FUEL
    ore_required = get_required_ore(fuel_amount)
    print(f""Minimum amount of ORE required to produce {fuel_amount} units of FUEL: {ore_required}"")
",2
114,2019,15,1,wrong_output,"Error: Unknown instruction
",300,,"
import os
import sys

def intcode_interpreter(program, input_list):
    """"""
    Interprets an Intcode program and returns the output

    Args:
    program: A list of integers representing the Intcode program
    input_list: A list of input values

    Returns:
    The output of the Intcode program
    """"""
    output = []
    index = 0
    input_index = 0
    while True:
        instruction = program[index]
        if instruction == 1:
            a_index = program[index+1]
            b_index = program[index+2]
            c_index = program[index+3]
            program[c_index] = program[a_index] + program[b_index]
            index += 4
        elif instruction == 2:
            a_index = program[index+1]
            b_index = program[index+2]
            c_index = program[index+3]
            program[c_index] = program[a_index] * program[b_index]
            index += 4
        elif instruction == 3:
            a_index = program[index+1]
            program[a_index] = input_list[input_index]
            input_index += 1
            index += 2
        elif instruction == 4:
            a_index = program[index+1]
            output.append(program[a_index])
            index += 2
        elif instruction == 5:
            if program[index+1] != 0:
                index = program[index+2]
            else:
                index += 3
        elif instruction == 6:
            if program[index+1] == 0:
                index = program[index+2]
            else:
                index += 3
        elif instruction == 7:
            a_index = program[index+1]
            b_index = program[index+2]
            c_index = program[index+3]
            if program[a_index] < program[b_index]:
                program[c_index] = 1
            else:
                program[c_index] = 0
            index += 4
        elif instruction == 8:
            a_index = program[index+1]
            b_index = program[index+2]
            c_index = program[index+3]
            if program[a_index] == program[b_index]:
                program[c_index] = 1
            else:
                program[c_index] = 0
            index += 4
        elif instruction == 99:
            return output
        else:
            print(""Error: Unknown instruction"")
            sys.exit(1)

def generate_movement_commands(program, direction):
    """"""
    Generates a list of movement commands to move the repair droid in the given direction

    Args:
    program: A list of integers representing the Intcode program
    direction: A string representing the direction to move the droid

    Returns:
    A list of movement commands
    """"""
    movement_commands = []
    while True:
        if direction == ""north"":
            input_list = [1]
        elif direction == ""south"":
            input_list = [2]
        elif direction == ""west"":
            input_list = [3]
        elif direction == ""east"":
            input_list = [4]
        else:
            print(""Error: Invalid direction"")
            sys.exit(1)

        output = intcode_interpreter(program, input_list)
        if output[0] == 0:
            movement_commands.append(direction)
        elif output[0] == 1:
            if direction == ""north"":
                return movement_commands + generate_movement_commands(program, ""west"")
            elif direction == ""south"":
                return movement_commands + generate_movement_commands(program, ""east"")
            elif direction == ""west"":
                return movement_commands + generate_movement_commands(program, ""south"")
            elif direction == ""east"":
                return movement_commands + generate_movement_commands(program, ""north"")
        elif output[0] == 2:
            return movement_commands + [""found""]
        else:
            print(""Error: Unknown output"")
            sys.exit(1)

def main():
    """"""
    Main function to run the program
    """"""
    # Read input from file
    with open(""input.txt"", ""r"") as file:
        input_program = [int(x) for x in file.readline().strip().split("","")]

    # Generate movement commands
    movement_commands = generate_movement_commands(input_program, ""north"")
    print(""Movement commands to reach the oxygen system:"", movement_commands)
    print(""Number of steps to reach the oxygen system:"", len(movement_commands))

if __name__ == ""__main__"":
    main() ",2
115,2019,16,1,syntax_error,,68317988,"  File ""/tmp/tmpo46ct39r/tmp.py"", line 10
    output.append(sum(signal[j] * pattern[((i+1) % len(pattern)) % len(pattern)) for j in range(len(signal))) % 10)
                                                                               ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import re
from typing import List

def fft(signal: List[int], phases: int) -> List[int]:
    pattern = [0, 1, 0, -1]
    for _ in range(phases):
        output = []
        for i in range(len(signal)):
            output.append(sum(signal[j] * pattern[((i+1) % len(pattern)) % len(pattern)) for j in range(len(signal))) % 10)
        signal = output
    return signal

def main():
    with open('input.txt', 'r') as file:
        input_list = list(map(int, re.findall(r'\d', file.read().strip()))
    result = fft(input_list, 100)
    print(''.join(map(str, result[:8]))

if __name__ == '__main__':
    main()
",2
116,2019,17,1,syntax_error,,9876,"  File ""/tmp/tmpvgoxzwbo/tmp.py"", line 17
    scaffold = [''.join(scaffold[i:i+len(scaffold[0])] for i in range(0, len(scaffold), len(scaffold[0]))]
                                                                                                         ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import sys

def find_intersection_parameters(scaffold):
    intersections = []
    for i in range(1, len(scaffold)-1):
        for j in range(1, len(scaffold[i])-1):
            if scaffold[i][j] == '#' and scaffold[i][j-1] == scaffold[i][j+1] == '#' and scaffold[i-1][j] == scaffold[i+1][j] == '#':
                intersections.append((j, i))
    return intersections

def align_parameter(coordinates, scaffold):
    return coordinates[0]*len(scaffold) + coordinates[1]

def main():
    scaffold = sys.stdin.readlines()[0].strip().split(',')
    scaffold = [''.join(scaffold[i:i+len(scaffold[0])] for i in range(0, len(scaffold), len(scaffold[0]))]
    intersections = find_intersection_parameters(scaffold)
    alignment_parameters = sum([align_parameter(coords, scaffold) for coords in intersections])
    print(alignment_parameters)

if __name__ == ""__main__"":
    main()
",2
117,2019,18,1,syntax_error,,6316,"  File ""/tmp/tmp4hhi14v1/tmp.py"", line 49
    else:
    ^
SyntaxError: invalid syntax
","
from queue import PriorityQueue
import heapq

def shortest_path(grid, rows, cols):
    # Initialize variables
    start = None
    keys = []
    doors = {}
    for i in range(rows):
        for j in range(cols):
            if grid[i][j] == '@':
                start = (i, j)
            elif grid[i][j].islower():
                keys.append(grid[i][j])
            elif grid[i][j].isupper():
                doors[grid[i][j]] = (i, j)
    
    queue = PriorityQueue()
    queue.put((0, start, '', set()))
    visited = set()

    while not queue.empty():
        # Get the current location and its path
        dist, (i, j), path, collected_keys = queue.get()

        # Check if all keys are collected
        if len(set(collected_keys) | set(keys)) == len(keys):
            return dist

        # Check if the current location is already visited
        if (i, j, collected_keys) in visited:
            continue
        visited.add((i, j, collected_keys))

        # Check for all possible directions to move
        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            ni, nj = i+di, j+dj

            # Check if the next location is within the boundaries
            if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] != '#':
                # Check if the next location is a key or a door
                if grid[ni][nj].islower():
                    new_collected_keys = set(collected_keys)
                    new_collected_keys.add(grid[ni][nj])
                    queue.put((dist+1, (ni, nj), path + grid[ni][nj], new_collected_keys))
                elif grid[ni][nj].isupper() and grid[ni][nj].lower() in collected_keys:
                    queue.put((dist+1, (ni, nj), path + grid[ni][nj], collected_keys)
                else:
                    queue.put((dist+1, (ni, nj), path + grid[ni][nj], collected_keys)

    return -1

# Driver code
if __name__ == '__main__':
    with open('input.txt', 'r') as f:
        grid = [list(line.strip()) for line in f.readlines()]
        rows, cols = len(grid), len(grid[0])
        print(shortest_path(grid, rows, cols))
",2
118,2019,19,1,runtime_error,,150,"Traceback (most recent call last):
  File ""/tmp/tmp349x0fvh/tmp.py"", line 60, in <module>
    main()
  File ""/tmp/tmp349x0fvh/tmp.py"", line 56, in main
    count = count_affected_points(input_list, 10, 10)
  File ""/tmp/tmp349x0fvh/tmp.py"", line 44, in count_affected_points
    output = intcode_program(input_list.copy(), [x, y])
TypeError: intcode_program() takes 1 positional argument but 2 were given
","
import itertools

def intcode_program(input_list):
    def get_value(mode, index, program):
        if mode == 0:
            return program[program[index]]
        elif mode == 1:
            return program[index]
        else:
            raise Exception(""Unknown mode: {}"".format(mode))

    def run_intcode(input_program, input_values):
        program = input_program.copy()
        input_index = 0
        output = []
        i = 0
        while i < len(program):
            opcode = program[i] % 100
            modes = [program[i] // 100 % 10, program[i] // 1000 % 10, program[i] // 10000 % 10, program[i] // 100000 % 10]
            if opcode == 1:
                program[program[i+3]] = get_value(modes[0], i+1, program) + get_value(modes[1], i+2, program)
                i += 4
            elif opcode == 2:
                program[program[i+3]] = get_value(modes[0], i+1, program) * get_value(modes[1], i+2, program)
                i += 4
            elif opcode == 3:
                program[program[i+1]] = input_values.pop(0)
                i += 2
            elif opcode == 4:
                output.append(get_value(modes[0], i+1, program))
                i += 2
            elif opcode == 99:
                return output
            else:
                raise Exception(""Unknown opcode: {}"".format(opcode))
        return output

    return run_intcode(input_list, [])

def count_affected_points(input_list, max_x, max_y):
    count = 0
    for x, y in itertools.product(range(max_x+1), range(max_y+1)):
        output = intcode_program(input_list.copy(), [x, y])
        if output[0] == 1:
            count += 1
    return count

def read_input_file(file_name):
    with open(file_name, 'r') as f:
        input_list = [int(x) for x in f.readline().strip().split(',')]
    return input_list

def main():
    input_list = read_input_file(""input.txt"")
    count = count_affected_points(input_list, 10, 10)
    print(""Number of affected points: {}"".format(count))

if __name__ == ""__main__"":
    main()
",2
119,2019,20,1,syntax_error,,608,"  File ""/tmp/tmp20yhzpus/tmp.py"", line 61
    queue.append((portals[maze[neighbor[0]][neighbor[1]], steps + 1))
                                                                   ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys
from collections import deque

def get_neighbors(x, y, maze):
    """"""
    Returns a list of valid neighboring tiles.
    """"""
    neighbors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] != '#':
            neighbors.append((nx, ny))
    return neighbors

def find_portals(maze):
    """"""
    Returns a dictionary of portal positions with their destinations.
    """"""
    portals = {}
    for i in range(1, len(maze) - 1):
        for j in range(1, len(maze[0]) - 1):
            if maze[i][j].isupper():
                if maze[i - 1][j].isupper():
                    portals[maze[i - 1][j] + maze[i][j]] = (i + 1, j)
                elif maze[i + 1][j].isupper():
                    portals[maze[i][j] + maze[i + 1][j]] = (i - 1, j)
                elif maze[i][j - 1].isupper():
                    portals[maze[i][j - 1] + maze[i][j]] = (i, j + 1)
                elif maze[i][j + 1].isupper():
                    portals[maze[i][j] + maze[i][j + 1]] = (i, j - 1)
    return portals

def shortest_path(maze, portals):
    """"""
    Returns the shortest path from start to end.
    """"""
    start = None
    end = None
    for i in range(len(maze)):
        for j in range(len(maze[0])):
            if maze[i][j] == 'AA':
                start = (i, j)
            elif maze[i][j] == 'ZZ':
                end = (i, j)
    if not start or not end:
        return None

    queue = deque([(start, 0)])
    visited = set()
    while queue:
        pos, steps = queue.popleft()
        if pos == end:
            return steps
        if pos in visited:
            continue
        visited.add(pos)

        for neighbor in get_neighbors(*pos, maze):
            if neighbor in portals:
                queue.append((portals[maze[neighbor[0]][neighbor[1]], steps + 1))
            else:
                queue.append((neighbor, steps + 1))

    return None

def main():
    maze = [list(line.strip()) for line in sys.stdin.readlines()]
    portals = find_portals(maze)
    path_length = shortest_path(maze, portals)
    if path_length is not None:
        print(path_length)
    else:
        print(""No path found."")

if __name__ == '__main__':
    main()
",2
120,2019,21,1,syntax_error,,19358688,"  File ""/tmp/tmp264k8vu2/tmp.py"", line 37
    else:
    ^
SyntaxError: invalid syntax
","
import sys
import os

def run_intcode(intcode):
    index = 0
    relative_base = 0
    while True:
        opcode = intcode[index]
        if opcode == 1:
            # Addition
            first_param = intcode[intcode[index + 1]]
            second_param = intcode[intcode[index + 2]]
            third_param = intcode[index + 3]
            intcode[intcode[index + 3]] = first_param + second_param
            index += 4
        elif opcode == 2:
            # Multiplication
            first_param = intcode[intcode[index + 1]]
            second_param = intcode[intcode[index + 2]]
            third_param = intcode[index + 3]
            intcode[intcode[index + 3]] = first_param * second_param
            index += 4
        elif opcode == 3:
            # Input
            input_value = input(""Enter input: "")
            intcode[intcode[index + 1]] = int(input_value)
            index += 2
        elif opcode == 4:
            # Output
            print(intcode[intcode[index + 1]])
            index += 2
        elif opcode == 5:
            # Jump-if-true
            if intcode[intcode[index + 1]] != 0:
                index = intcode[intcode[index + 2]
            else:
                index += 3
        elif opcode == 6:
            # Jump-if-false
            if intcode[intcode[index + 1]] == 0:
                index = intcode[intcode[index + 2]
            else:
                index += 3
        elif opcode == 7:
            # Less than
            if intcode[intcode[index + 1] < intcode[intcode[index + 2]:
                intcode[intcode[intcode[index + 3]] = 1
            else:
                intcode[intcode[index + 3] = 0
            index += 4
        elif opcode == 8:
            # Equals
            if intcode[intcode[index + 1] == intcode[intcode[index + 2]:
                intcode[intcode[intcode[index + 3] = 1
            else:
                intcode[intcode[index + 3] = 0
            index += 4
        elif opcode == 9:
            # Adjust relative base
            relative_base += intcode[intcode[index + 1]
            index += 2
        elif opcode == 99:
            # Halt
            break
        else:
            raise ValueError(""Invalid opcode"")
    return intcode[0]

if __name__ == ""__main__"":
    with open(os.path.join(sys.path[0], ""input.txt""), ""r"") as f:
        intcode = [int(x) for x in f.read().split("","")]
    run_intcode(intcode)
",2
121,2019,22,1,runtime_error,,1252,"Traceback (most recent call last):
  File ""/tmp/tmp85wmol97/tmp.py"", line 30, in <module>
    main()
  File ""/tmp/tmp85wmol97/tmp.py"", line 26, in main
    deck = shuffle(deck, technique)
  File ""/tmp/tmp85wmol97/tmp.py"", line 14, in shuffle
    N = int(technique.split()[-1])
ValueError: invalid literal for int() with base 10: 'stack'
","
from collections import deque

def shuffle(deck, technique):
    if technique == ""deal into new stack"":
        deck.reverse()
    elif ""cut"" in technique:
        N = int(technique.split()[1])
        if technique.startswith(""cut""):
            deck.rotate(-N)
        else:
            deck.rotate(N)
    else:
        N = int(technique.split()[-1])
        new_deck = deque(maxlen=len(deck))
        for i in range(len(deck)):
            new_deck.append(deck[i * N % len(deck)])
        deck = new_deck
    return deck

def main():
    with open(""input.txt"", ""r"") as f:
        techniques = f.readlines()
    deck = deque(range(1007)[:-1])
    for technique in techniques:
        deck = shuffle(deck, technique)
    print(deck.index(2019))

if __name__ == ""__main__"":
    main()
",2
122,2019,23,1,syntax_error,,24922,"  File ""/tmp/tmp2u62yp73/tmp.py"", line 75
    initial_states = [list(map(int, line.strip().split(',')) for line in f]
                                                                          ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import threading
import queue

class Computer:
    def __init__(self, id, initial_state):
        self.id = id
        self.state = initial_state
        self.inputs = queue.Queue()
        self.outputs = queue.Queue()
        self.packet_queue = queue.Queue()
        self.is_running = True
        
    def receive_packet(self, packet):
        self.packet_queue.put(packet)
        
    def run_program(self):
        while self.is_running:
            opcode = self.state[0]
            if opcode == 1:
                # Send packet
                if not self.outputs.empty():
                    self.packet_queue.put((self.id, self.outputs.get(), self.outputs.get()))
            elif opcode == 2:
                # Receive packet
                if not self.inputs.empty():
                    packet = self.inputs.get()
                    self.state[1] = packet[1]
                    self.state[2] = packet[2]
            elif opcode == 3:
                # Halt
                self.is_running = False
                break
            else:
                # Invalid opcode
                raise ValueError(""Invalid opcode"")
            self.state = self.state[1:]
            
    def send(self, dest, x, y):
        self.outputs.put(dest)
        self.outputs.put(x)
        self.outputs.put(y)
        
    def receive(self):
        if not self.packet_queue.empty():
            return self.packet_queue.get()
        else:
            return (-1, -1)

class Network:
    def __init__(self, initial_states):
        self.computers = [Computer(i, initial_state) for i, initial_state in enumerate(initial_states)]
        self.network = {i: [] for i in range(50)}
        for i in range(50):
            for j in range(50):
                if i != j:
                    self.network[i].append(j)
        
    def send_packet(self, source, dest, x, y):
        self.computers[dest].receive_packet((x, y))
        
    def run_network(self):
        threads = []
        for computer in self.computers:
            thread = threading.Thread(target=computer.run_program)
            threads.append(thread)
            thread.start()
        for thread in threads:
            thread.join()
        
        return self.computers[255].receive()[1]

# Read input from file
with open(""input.txt"", ""r"") as f:
    initial_states = [list(map(int, line.strip().split(',')) for line in f]

# Create network and run program
network = Network(initial_states)
network.run_network()
",2
123,2019,24,1,no_error,"1151290
",1151290,,"
from collections import defaultdict
from copy import deepcopy

def get_biodiversity_rating(grid):
    rating = 0
    for i, row in enumerate(grid):
        for j, cell in enumerate(row):
            if cell == '#':
                rating += 2**(i*5+j)
    return rating

def update_grid(grid):
    new_grid = deepcopy(grid)
    for i in range(5):
        for j in range(5):
            adjacent_bugs = 0
            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:
                if 0 <= x < 5 and 0 <= y < 5 and grid[x][y] == '#':
                    adjacent_bugs += 1
            if grid[i][j] == '#' and adjacent_bugs != 1:
                new_grid[i][j] = '.'
            elif grid[i][j] == '.' and adjacent_bugs in [1, 2]:
                new_grid[i][j] = '#'
    return new_grid

def find_duplicate_layout(grid):
    layouts = defaultdict(int)
    layouts[tuple(tuple(row) for row in grid)] += 1
    while True:
        grid = update_grid(grid)
        layout = tuple(tuple(row) for row in grid)
        if layout in layouts:
            return get_biodiversity_rating(grid)
        layouts[layout] += 1

with open('input.txt', 'r') as f:
    grid = [list(line.strip()) for line in f]
    print(find_duplicate_layout(grid))
",0
124,2019,25,1,runtime_error,,25166400,"Traceback (most recent call last):
  File ""/tmp/tmpy7fbmhge/tmp.py"", line 144, in <module>
    main()
  File ""/tmp/tmpy7fbmhge/tmp.py"", line 141, in main
    program, ip, acc, relative_base = execute(program, inputs, ip, acc, relative_base)
  File ""/tmp/tmpy7fbmhge/tmp.py"", line 46, in execute
    program[p3 + relative_base] = p1 * p2
IndexError: list assignment index out of range
","
import sys
import os
from collections import defaultdict
from typing import List, Tuple, Dict

def load_input(file_name: str) -> List[int]:
    with open(file_name) as f:
        program = [int(x) for x in f.read().strip().split(',')]
    return program

def execute(program: List[int], inputs: List[int], ip: int, acc: int, relative_base: int) -> Tuple[List[int], int, int, int]:
    input_idx = 0

    while ip < len(program):
        opcode = program[ip]
        inst = opcode % 100
        mode_1, mode_2, mode_3 = (opcode // 100) % 10, (opcode // 1000) % 10, (opcode // 10000) % 10
        p1_mode, p2_mode, p3_mode = (mode_1, mode_2, mode_3) if inst in [1, 2, 5, 6, 7, 8, 9] else (0, 0, 0)
        p1, p2, p3 = program[ip+1:ip+4]

        if inst == 1:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p3_mode == 2:
                program[p3 + relative_base] = p1 + p2
            else:
                program[p3] = p1 + p2
            ip += 4
        elif inst == 2:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p3_mode == 2:
                program[p3 + relative_base] = p1 * p2
            else:
                program[p3] = p1 * p2
            ip += 4
        elif inst == 3:
            if p1_mode == 2:
                program[p1 + relative_base] = inputs[input_idx]
            else:
                program[p1] = inputs[input_idx]
            input_idx += 1
            ip += 2
        elif inst == 4:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 1:
                p1 = p1
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            print(p1)
            ip += 2
        elif inst == 5:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p1 != 0:
                ip = p2
            else:
                ip += 3
        elif inst == 6:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p1 == 0:
                ip = p2
            else:
                ip += 3
        elif inst == 7:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p3_mode == 2:
                program[p3 + relative_base] = 1 if p1 < p2 else 0
            else:
                program[p3] = 1 if p1 < p2 else 0
            ip += 4
        elif inst == 8:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            if p2_mode == 0:
                p2 = program[p2]
            elif p2_mode == 2:
                p2 = program[p2 + relative_base]
            if p3_mode == 2:
                program[p3 + relative_base] = 1 if p1 == p2 else 0
            else:
                program[p3] = 1 if p1 == p2 else 0
            ip += 4
        elif inst == 9:
            if p1_mode == 0:
                p1 = program[p1]
            elif p1_mode == 2:
                p1 = program[p1 + relative_base]
            relative_base += p1
            ip += 2
        elif inst == 99:
            return (program, ip, acc, relative_base)
        else:
            raise ValueError('Invalid opcode: {}'.format(inst))

    return (program, ip, acc, relative_base)

def main():
    program = load_input('input.txt')
    inputs = [1] # Input the instructions for the droid here
    ip = 0
    acc = 0
    relative_base = 0
    while ip < len(program):
        program, ip, acc, relative_base = execute(program, inputs, ip, acc, relative_base)

if __name__ == '__main__':
    main()
",2
125,2020,1,1,runtime_error,,928896,"Traceback (most recent call last):
  File ""/tmp/tmp8z4rw_o1/tmp.py"", line 12, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import sys

def find_pair(numbers):
    for i in range(len(numbers)):
        for j in range(i+1, len(numbers)):
            if numbers[i] + numbers[j] == 2020:
                return numbers[i] * numbers[j]
    return None

if __name__ == '__main__':
    input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        numbers = [int(line.strip()) for line in f.readlines()]
        result = find_pair(numbers)
        print(result)
",2
126,2020,2,1,no_error,"434
",434,,"
import re

def is_valid_password(policy, password):
    min_occurrences, max_occurrences, letter = re.findall(r'(\d+)-(\d+) ([a-z])', policy)[0]
    min_occurrences, max_occurrences = int(min_occurrences), int(max_occurrences)
    letter_count = password.count(letter)
    return min_occurrences <= letter_count <= max_occurrences

valid_passwords = 0

with open('input.txt', 'r') as file:
    for line in file:
        policy, password = line.strip().split(': ')
        if is_valid_password(policy, password):
            valid_passwords += 1

print(valid_passwords)
",0
127,2020,3,1,no_error,"292
",292,,"
from collections import Counter
from itertools import cycle

def count_trees(grid, right, down):
    trees = 0
    row, col = 0, 0
    while row < len(grid):
        if grid[row][col] == '#':
            trees += 1
        row += down
        col = (col + right) % len(grid[0])
    return trees

with open('input.txt', 'r') as f:
    grid = [line.strip() for line in f]

slope = (3, 1)
trees_count = count_trees(grid, *slope)
print(trees_count)
",2
128,2020,4,1,wrong_output,"Usage: python count_valid_passports.py input_file
",233,,"
import sys

def count_valid_passports(filename):
    required_fields = {'byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid'}
    valid_passports = 0
    current_passport = {}

    with open(filename, 'r') as f:
        for line in f.readlines():
            if line.strip() == '':
                if required_fields.issubset(current_passport):
                    valid_passports += 1
                current_passport = {}
            else:
                fields = line.strip().split()
                for field in fields:
                    key, value = field.split(':')
                    current_passport[key] = value

    if required_fields.issubset(current_passport):
        valid_passports += 1

    return valid_passports

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(""Usage: python count_valid_passports.py input_file"")
        sys.exit(1)

    input_file = sys.argv[1]
    valid_count = count_valid_passports(input_file)
    print(f""Number of valid passports: {valid_count}"")
",2
129,2020,5,1,no_error,"987
",987,,"
import re

def find_seat_id(boarding_pass):
    row, col = boarding_pass[:7], boarding_pass[7:]
    row = binary_search(row, 'F', 'B', 0, 127)
    col = binary_search(col, 'L', 'R', 0, 7)
    return row * 8 + col

def binary_search(seq, lower_half, upper_half, start, end):
    for char in seq:
        mid = (start + end) // 2
        if char == lower_half:
            end = mid
        else:
            start = mid + 1
    return start

def main():
    with open('input.txt', 'r') as file:
        boarding_passes = file.readlines()

    seat_ids = [find_seat_id(line.strip()) for line in boarding_passes]
    max_seat_id = max(seat_ids)
    print(max_seat_id)

if __name__ == '__main__':
    main()
",1
130,2020,6,1,wrong_output,"3356
",6775,,"
from collections import Counter

def count_yes(groups):
    total_count = 0
    for group in groups:
        group_count = Counter(''.join(group))
        total_count += sum(1 for letter, count in group_count.items() if count == len(group))
    return total_count

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        groups = [group.split('\n') for group in f.read().split('\n\n')]
        print(count_yes(groups))
",2
131,2020,7,1,no_error,"226
",226,,"
import re

def generate_bags(input_file):
    bag_rules = {}
    with open(input_file, 'r') as f:
        for line in f:
            bag_color, contents = line.strip().split(' bags contain ')
            contents = contents.rstrip('.')
            if contents == 'no other bags':
                bag_rules[bag_color] = []
            else:
                contents = re.findall(r'\d+ (\w+ \w+) bag', contents)
                bag_rules[bag_color] = contents
                
    return bag_rules

def count_gold_bags(bag_rules, bag_color):
    if bag_color == 'shiny gold':
        return True
    elif not bag_rules[bag_color]:
        return False
    else:
        return any(count_gold_bags(bag_rules, bag) for bag in bag_rules[bag_color])

def count_gold_bags_count(input_file):
    bag_rules = generate_bags(input_file)
    count = 0
    for bag_color in bag_rules:
        if count_gold_bags(bag_rules, bag_color):
            count += 1
    return count - 1

input_file = 'input.txt'
print(count_gold_bags_count(input_file))
",2
132,2020,8,1,wrong_output,"Accumulator value before infinite loop: 1384
Fixed program's accumulator value: 761
",1384,,"
from typing import List, Tuple

def execute_program(instructions: List[str]) -> Tuple[int, bool]:
    accumulator = 0
    executed_instructions = set()
    current_instruction_index = 0
    while current_instruction_index not in executed_instructions:
        executed_instructions.add(current_instruction_index)
        instruction, argument = instructions[current_instruction_index].split()
        if instruction == ""acc"":
            accumulator += int(argument)
            current_instruction_index += 1
        elif instruction == ""jmp"":
            current_instruction_index += int(argument)
        elif instruction == ""nop"":
            current_instruction_index += 1
        else:
            raise ValueError(""Invalid instruction"")
        if current_instruction_index >= len(instructions):
            return accumulator, True
        if current_instruction_index < 0:
            raise ValueError(""Invalid instruction"")
    return accumulator, False

def fix_program(instructions: List[str]) -> int:
    for i in range(len(instructions)):
        if ""jmp"" in instructions[i]:
            fixed_instructions = instructions.copy()
            fixed_instructions[i] = fixed_instructions[i].replace(""jmp"", ""nop"")
            accumulator, terminated = execute_program(fixed_instructions)
            if terminated:
                return accumulator
        elif ""nop"" in instructions[i]:
            fixed_instructions = instructions.copy()
            fixed_instructions[i] = fixed_instructions[i].replace(""nop"", ""jmp"")
            accumulator, terminated = execute_program(fixed_instructions)
            if terminated:
                return accumulator
    raise ValueError(""No valid program found"")

def main():
    with open(""input.txt"", ""r"") as f:
        instructions = f.readlines()
    accumulator, _ = execute_program(instructions)
    print(""Accumulator value before infinite loop:"", accumulator)
    fixed_accumulator = fix_program(instructions)
    print(""Fixed program's accumulator value:"", fixed_accumulator)

if __name__ == ""__main__"":
    main()
",2
133,2020,9,1,wrong_output,"9
",258585477,,"
import sys

def find_first_non_summable_number(numbers):
    """"""
    Returns the first number in the list that cannot be expressed as the sum of any 25 previous numbers.
    """"""
    # Store the previous 25 numbers in a list
    prev_nums = numbers[:25]
    for i, num in enumerate(numbers[25:]):
        found_sum = False
        for j in range(len(prev_nums)):
            for k in range(j+1, len(prev_nums)):
                if prev_nums[j] + prev_nums[k] == num:
                    found_sum = True
                    break
            if not found_sum:
                return num
            prev_nums.pop(0)
            prev_nums.append(num)

    return None

if __name__ == '__main__':
    # Read input file
    with open('input.txt', 'r') as f:
        numbers = [int(line.strip()) for line in f.readlines()]
    
    # Process input
    result = find_first_non_summable_number(numbers)
    
    # Print result
    print(result)
",2
134,2020,10,1,timeout_error,,2263,TIMEOUT,"
import sys

def jolt_difference_distribution(adapters):
    adapters.sort()
    differences = [0] * 4
    for i in range(1, len(adapters)):
        differences[adapters[i] - adapters[i-1]] += 1
    return differences

if __name__ == ""__main__"":
    adapters = [int(line.strip()) for line in sys.stdin]
    differences = jolt_difference_distribution(adapters)
    print(differences)
",2
135,2020,11,1,syntax_error,,2368,"  File ""/tmp/tmpu3cm1ssn/tmp.py"", line 4
    def count_occupied_seats(grid: List[List[str]) -> int:
                                                 ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def count_occupied_seats(grid: List[List[str]) -> int:
    count = 0
    for row in grid:
        for seat in row:
            if seat == '#':
                count += 1
    return count

def is_occupied(x: int, y: int, grid: List[List[str]) -> bool:
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
        return False
    return grid[x][y] == '#'

def is_empty(x: int, y: int, grid: List[List[str]) -> bool:
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
        return False
    return grid[x][y] == 'L'

def count_adjacent_occupied_seats(x: int, y: int, grid: List[List[str]) -> int:
    count = 0
    for i in range(max(0, x-1), min(x+2, len(grid)):
        for j in range(max(0, y-1), min(y+2, len(grid[0])):
            if i == x and j == y:
                continue
            if is_occupied(i, j, grid):
                count += 1
    return count

def generate_new_grid(grid: List[List[str]) -> List[List[str]:
    new_grid = []
    for i in range(len(grid)):
        row = []
        for j in range(len(grid[0]):
            if grid[i][j] == 'L' and count_adjacent_occupied_seats(i, j, grid) == 0:
                row.append('#')
            elif grid[i][j] == '#' and count_adjacent_occupied_seats(i, j, grid) >= 4:
                row.append('L')
            else:
                row.append(grid[i][j])
        new_grid.append(row)
    return new_grid

def simulate_seating_area(grid: List[List[str]) -> List[List[str]:
    while True:
        new_grid = generate_new_grid(grid)
        if new_grid == grid:
            break
        grid = new_grid
    return grid

def main():
    with open('input.txt', 'r') as f:
        grid = [list(line.strip()) for line in f.readlines()]
    final_grid = simulate_seating_area(grid)
    print(count_occupied_seats(final_grid))

if __name__ == '__main__':
    main()
",2
136,2020,12,1,wrong_output,"932
",962,,"
from math import sin, cos, radians

def move_ship(action, value, x, y, angle):
    if action == 'N':
        y += value
    elif action == 'S':
        y -= value
    elif action == 'E':
        x += value
    elif action == 'W':
        x -= value
    elif action == 'L':
        angle -= radians(value)
    elif action == 'R':
        angle += radians(value)
    elif action == 'F':
        x += round(value * cos(angle))
        y += round(value * sin(angle))
    return x, y, angle

def manhattan_distance(x, y):
    return abs(x) + abs(y)

with open('input.txt', 'r') as f:
    x, y, angle = 0, 0, 0
    for line in f:
        action, value = line[0], int(line[1:])
        x, y, angle = move_ship(action, value, x, y, angle)

    print(manhattan_distance(x, y))
",2
137,2020,13,1,wrong_output,"The earliest bus you can take is bus 419 and you will need to wait for 5 minutes.
",2095,,"
import sys
from datetime import datetime

def find_closest_bus(timestamp, bus_ids):
    min_wait_time = float('inf')
    closest_bus_id = None
    for bus_id in bus_ids:
        if bus_id != 'x':
            wait_time = bus_id - (timestamp % bus_id)
            if wait_time < min_wait_time:
                min_wait_time = wait_time
                closest_bus_id = bus_id
    return min_wait_time, closest_bus_id

def main():
    with open('input.txt', 'r') as file:
        timestamp = int(file.readline().strip())
        bus_ids = file.readline().strip().split(',')
        min_wait_time, closest_bus_id = find_closest_bus(timestamp, [int(bus) if bus != 'x' else bus for bus in bus_ids])
        print(f'The earliest bus you can take is bus {closest_bus_id} and you will need to wait for {min_wait_time} minutes.')

if __name__ == '__main__':
    main()
",2
138,2020,14,1,wrong_output,"7274953882594
",14553106347726,,"
import re

def mask_value(mask, value):
    mask = mask.replace('X', '0')
    value = bin(value)[2:].zfill(36)
    masked_value = ''.join([value[i] if mask[i] == 'X' else mask[i] for i in range(36)])
    return int(masked_value, 2)

def part1():
    mask = None
    memory = {}
    with open(""input.txt"") as f:
        for line in f:
            if line.startswith(""mask""):
                mask = line.strip().split('=')[-1]
            elif line.startswith(""mem""):
                address, value = map(int, re.findall(r'\d+', line))
                memory[address] = mask_value(mask, value)

    return sum(memory.values())

print(part1())
",2
139,2020,15,1,no_error,"468
",468,,"
from collections import defaultdict

def main():
    # Read input from the file
    with open('input.txt', 'r') as f:
        input_list = f.readline().strip().split(',')
    
    numbers = [int(num) for num in input_list]
    # Convert the input list of strings to a list of integers
    
    # Initialize the dictionary to keep track of the last spoken numbers
    last_spoken = defaultdict(list)
    for i, num in enumerate(numbers):
        last_spoken[num].append(i)
    
    # Initialize variables for the current turn and last spoken number
    turn = len(numbers)
    last_num = numbers[-1]
    
    # Loop until we reach the 2020th turn
    while turn < 2020:
        if len(last_spoken[last_num]) == 1:
            new_num = 0
        else:
            new_num = last_spoken[last_num][-1] - last_spoken[last_num][-2]
        
        last_spoken[new_num].append(turn)
        last_num = new_num
        turn += 1
        
        # If we have reached the 2020th turn, break the loop
        if turn == 2020:
            break
    
    print(last_num)

if __name__ == ""__main__"":
    main()
",0
140,2020,16,1,runtime_error,,26026,"Traceback (most recent call last):
  File ""/tmp/tmpuoqi5a75/tmp.py"", line 40, in <module>
    print(find_ticket_scanning_error_rate(rules, nearby_tickets))
  File ""/tmp/tmpuoqi5a75/tmp.py"", line 11, in find_ticket_scanning_error_rate
    if not any(validate_value(value, rule) for field, rule in rules.items()):
  File ""/tmp/tmpuoqi5a75/tmp.py"", line 11, in <genexpr>
    if not any(validate_value(value, rule) for field, rule in rules.items()):
  File ""/tmp/tmpuoqi5a75/tmp.py"", line 5, in validate_value
    return any(int(rule[0]) <= value <= int(rule[1]) or int(rule[2]) <= value <= int(rule[3]) for rule in rules[field])
  File ""/tmp/tmpuoqi5a75/tmp.py"", line 5, in <genexpr>
    return any(int(rule[0]) <= value <= int(rule[1]) or int(rule[2]) <= value <= int(rule[3]) for rule in rules[field])
TypeError: 'int' object is not subscriptable
","
import re

def validate_value(value, rule):
    return any(int(rule[0]) <= value <= int(rule[1]) or int(rule[2]) <= value <= int(rule[3]) for rule in rules[field])

def find_ticket_scanning_error_rate(rules, tickets):
    error_rate = 0
    for ticket in tickets:
        for value in ticket:
            if not any(validate_value(value, rule) for field, rule in rules.items()):
                error_rate += value
    return error_rate

input_file = open('input.txt', 'r')
input_data = input_file.read().split('\n')
rules = {}
my_ticket = []
nearby_tickets = []
input_mode = 0

for line in input_data:
    if line == 'your ticket:':
        input_mode = 1
        continue
    elif line == 'nearby tickets:':
        input_mode = 2
        continue
    elif not line:
        continue

    if input_mode == 0:
        field, rule = line.split(': ')
        rules[field] = [int(n) for n in re.findall(r'\d+', rule)]
    elif input_mode == 1:
        my_ticket = [int(n) for n in line.split(',')]
    elif input_mode == 2:
        nearby_tickets.append([int(n) for n in line.split(',')])

print(find_ticket_scanning_error_rate(rules, nearby_tickets))
",2
141,2020,17,1,syntax_error,,263,"  File ""/tmp/tmpfg83v_np/tmp.py"", line 29
    for x in range(len(grid[0][0]):
                                  ^
SyntaxError: invalid syntax
","
import os
from copy import deepcopy

def read_input(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        grid = [list(line.strip()) for line in lines]
    return grid

def get_neighbors(grid, x, y, z):
    neighbors = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            for dz in [-1, 0, 1]:
                if dx == 0 and dy == 0 and dz == 0:
                    continue
                if x + dx < 0 or y + dy < 0 or z + dz < 0:
                    continue
                if x + dx >= len(grid) or y + dy >= len(grid[0]) or z + dz >= len(grid[0][0]):
                    continue
                neighbors.append((x + dx, y + dy, z + dz))
    return neighbors

def simulate_cycle(grid):
    new_grid = deepcopy(grid)
    for z in range(len(grid)):
        for y in range(len(grid[0])):
            for x in range(len(grid[0][0]):
                active_neighbors = 0
                for neighbor in get_neighbors(grid, x, y, z):
                    if grid[neighbor[0]][neighbor[1]][neighbor[2]] == '#':
                        active_neighbors += 1
                if grid[x][y][z] == '#' and (active_neighbors < 2 or active_neighbors > 3):
                    new_grid[x][y][z] = '.'
                elif grid[x][y][z] == '.' and active_neighbors == 3:
                    new_grid[x][y][z] = '#'
    return new_grid

def count_active_cubes(grid):
    count = 0
    for layer in grid:
        for row in layer:
            count += row.count('#')
    return count

def main():
    grid = read_input(""input.txt"")
    for _ in range(6):
        grid = simulate_cycle(grid)
    print(count_active_cubes(grid))

if __name__ == ""__main__"":
    main()
",2
142,2020,18,1,timeout_error,,31142189909908,TIMEOUT,"
import operator
import re

with open(""input.txt"") as f:
    data = f.readlines()

def evaluate(expression):
    expression = expression.replace("" "", """")
    stack = []
    i = 0
    while i < len(expression):
        if expression[i] == ""("":
            stack.append(""("")
            i += 1
        elif expression[i] == "")"":
            sub_expression = []
            while stack and stack[-1] != ""("":
                sub_expression.append(stack.pop())
            stack.pop()
            sub_expression.reverse()
            sub_result = evaluate("""".join(sub_expression[1:]) if len(sub_expression) > 1 else sub_expression[0])
            if not stack:
                stack.append(sub_result)
            elif stack[-1] == ""+"":
                stack.pop()
                stack[-1] = str(int(stack[-1]) + int(sub_result))
            elif stack[-1] == ""*"":
                stack.pop()
                stack[-1] = str(int(stack[-1]) * int(sub_result))
            i += 1
        elif expression[i] in [""+"", ""*""]:
            stack.append(expression[i])
            i += 1
        else:
            num = """"
            while i < len(expression) and re.match(r""\d"", expression[i]):
                num += expression[i]
                i += 1
            stack.append(num)
    while len(stack) > 1:
        a = int(stack.pop())
        op = stack.pop()
        b = int(stack.pop())
        if op == ""+"":
            stack.append(a + b)
        else:
            stack.append(a * b)
    return stack[0]

total_sum = 0
for expression in data:
    total_sum += evaluate(expression)

print(total_sum)
",2
143,2020,19,1,no_error,"173
",173,,"
import re

def generate_regex(rules, rule_num):
    if rules[rule_num] in 'ab':
        return rules[rule_num]
    else:
        regex = ""(""
        for sub_rule in rules[rule_num].split("" | ""):
            regex += """".join(generate_regex(rules, int(x)) for x in sub_rule.split()) + ""|""
        regex = regex[:-1] + "")""
        return regex

with open(""input.txt"", ""r"") as f:
    data = f.read().split(""\n\n"")
    rules = {}
    for line in data[0].split(""\n""):
        rule_num, rule_def = line.split("": "")
        rules[int(rule_num)] = rule_def.strip('""')
    messages = data[1].split(""\n"")

    regex = re.compile(generate_regex(rules, 0))
    valid_count = sum(1 for message in messages if regex.fullmatch(message))
    print(valid_count)
",1
144,2020,20,1,no_error,"15003787688423
",15003787688423,,"
import re
from collections import defaultdict
from itertools import product

def parse_input(filename):
    tiles = []
    with open(filename, 'r') as f:
        lines = f.readlines()
        for line in lines:
            if line.startswith('Tile'):
                tile_id = int(re.search(r'Tile (\d+):', line).group(1))
                tile_data = []
            elif line.strip():
                tile_data.append(line.strip())
            else:
                tiles.append((tile_id, tile_data))
    return tiles

def rotate(tile_data):
    return [''.join(tile_data[i][::-1]) for i in range(len(tile_data))]

def flip(tile_data):
    return [''.join(tile_data)[::-1] for tile_data in tile_data]

def get_borders(tile_data):
    top = tile_data[0]
    bottom = tile_data[-1]
    left = ''.join([row[0] for row in tile_data])
    right = ''.join([row[-1] for row in tile_data])
    return [top, bottom, left, right]

def all_borders(tile_data):
    borders = get_borders(tile_data)
    return borders + [borders[0][::-1], borders[1][::-1], borders[2][::-1], borders[3][::-1]]

def get_matches(tiles):
    matches = defaultdict(set)
    for (id1, tile_data1), (id2, tile_data2) in product(tiles, tiles):
        if id1 != id2:
            for border1 in all_borders(tile_data1):
                for border2 in all_borders(tile_data2):
                    if border1 == border2:
                        matches[id1].add(id2)
    return matches

def find_corners(tiles, matches):
    corners = []
    for id, match_set in matches.items():
        if len(match_set) == 2:
            corners.append(id)
    return corners

def part1(tiles):
    matches = get_matches(tiles)
    corners = find_corners(tiles, matches)
    product = 1
    for corner in corners:
        product *= corner
    return product

def main():
    tiles = parse_input('input.txt')
    print(part1(tiles))
    
if __name__ == '__main__':
    main()
",1
145,2020,21,1,wrong_output,"0
",2542,,"
import re
from collections import defaultdict

# Open and read the input file
with open('input.txt', 'r') as file:
    data = file.readlines()

# Initialize variables
allergens = defaultdict(set)
ingredients = defaultdict(int)

# Loop through each line in the input file
for line in data:
    # Extract the ingredients and allergens
    ingredients_list = re.findall(r'([a-z]+)', line.split('(')[0].strip())
    allergens_list = re.findall(r'([a-z]+)', line.split('(contains')[1].strip())
    
    # Store the allergens and their corresponding ingredients
    for allergen in allergens_list:
        allergens[allergen] |= set(ingredients_list)

    # Count the ingredients
    for ingredient in ingredients_list:
        ingredients[ingredient] += 1

    # Increment the ingredient count if it is not an allergen
    for ingredient in ingredients:
        if all(ingredient not in allergens[allergen] for allergen in allergens):
            ingredients[ingredient] += 1

# Count the total number of times non-allergenic ingredients appear
count = sum(ingredients[ingredient] for ingredient in ingredients if all(ingredient not in allergens[allergen] for allergen in allergens))

print(count)
",2
146,2020,22,1,runtime_error,,34255,"Traceback (most recent call last):
  File ""/tmp/tmp1kb7rpkp/tmp.py"", line 24, in <module>
    main()
  File ""/tmp/tmp1kb7rpkp/tmp.py"", line 18, in main
    deck1 = list(map(int, file.readline().split(':')[1].split(',')))
ValueError: invalid literal for int() with base 10: '\n'
","
from typing import List, Tuple

def calculate_score(deck: List[int]) -> int:
    return sum(i * deck[i] for i in range(len(deck)))

def play_game(deck1: List[int], deck2: List[int]) -> Tuple[int, int]:
    while deck1 and deck2:
        card1, card2 = deck1.pop(0), deck2.pop(0)
        if card1 > card2:
            deck1.extend([card1, card2])
        else:
            deck2.extend([card2, card1])
    return calculate_score(deck1), calculate_score(deck2)

def main():
    with open('input.txt') as file:
        deck1 = list(map(int, file.readline().split(':')[1].split(',')))
        deck2 = list(map(int, file.readline().split(':')[1].split(',')))
    score1, score2 = play_game(deck1, deck2)
    print(max(score1, score2))

if __name__ == '__main__':
    main()
",2
147,2020,23,1,timeout_error,,49576328,TIMEOUT,"
from collections import deque

def move_cups(cups, current_cup):
    pick_up = []
    for i in range(3):
        pick_up.append(cups.pop(cups.index(current_cup) + 1 + i))
    dest_cup = current_cup - 1
    if dest_cup == 0:
        dest_cup = len(cups)
    while dest_cup in pick_up:
        dest_cup -= 1
        if dest_cup == 0:
            dest_cup = len(cups)
    for c in reversed(pick_up):
        cups.insert(cups.index(dest_cup) + 1, c)
    return cups

def part1(cups):
    cups = deque(cups)
    current_cup = cups[0]
    for i in range(100):
        current_cup = cups[(cups.index(current_cup) + 1) % len(cups)]
        cups = deque(move_cups(list(cups), current_cup))
    return list(cups)

with open('input.txt', 'r') as f:
    input_cups = f.read().strip()
    cups_list = [int(c) for c in input_cups]
    cups_list.extend(list(range(len(cups_list) + 1, 10000001)) if len(cups_list) < 10000000 else [])
    final_order = part1(cups_list)
    print("""".join(str(c) for c in final_order[final_order.index(1) + 1:] + final_order[:final_order.index(1)])[1:])
",2
148,2020,24,1,wrong_output,"20
",356,,"
from collections import defaultdict

def flip_tiles(instructions):
    flipped_tiles = defaultdict(bool)
    for instruction in instructions:
        x, y = 0, 0
        for step in instruction:
            if step == 'e':
                y += 1
            elif step == 'se':
                x += 1
                y -= 1
            elif step == 'sw':
                x += 1
            elif step == 'w':
                y -= 1
            elif step == 'nw':
                x -= 1
                y += 1
            elif step == 'ne':
                y += 1
        flipped_tiles[(x, y)] = not flipped_tiles[(x, y)]
    return sum(flipped_tiles.values())

with open('input.txt', 'r') as file:
    instructions = [line.strip() for line in file.readlines()]

print(flip_tiles(instructions))
",2
149,2020,25,1,no_error,"711945
",711945,,"
def transform(subject_number, loop_size):
    value = 1
    for i in range(loop_size):
        value = (value * subject_number) % 20201227
    return value

def find_loop_size(public_key, subject_number=7):
    value = 1
    loop_size = 0
    while value != public_key:
        value = (value * subject_number) % 20201227
        loop_size += 1
    return loop_size

def calculate_encryption_key(public_key, loop_size):
    return transform(public_key, loop_size)

def main():
    with open('input.txt', 'r') as input_file:
        public_keys = [int(public_key) for public_key in input_file.read().splitlines()]
    loop_sizes = [find_loop_size(public_key) for public_key in public_keys]
    encryption_key = calculate_encryption_key(public_keys[1], loop_sizes[0])
    print(encryption_key)

if __name__ == '__main__':
    main()
",1
150,2021,1,1,no_error,"1532
",1532,,"
def count_increases(filename):
    with open(filename, 'r') as file:
        depths = list(map(int, file.readlines()))
    increases = 0
    for i in range(1, len(depths)):
        if depths[i] > depths[i-1]:
            increases += 1
    return increases

if __name__ == ""__main__"":
    print(count_increases('input.txt'))
",0
151,2021,2,1,no_error,"1990000
",1990000,,"
import os

# Read input file
with open('input.txt', 'r') as file:
    commands = file.readlines()

horizontal_position = 0
depth = 0

# Iterate through each command and update the horizontal position and depth
for command in commands:
    if command.startswith('forward'):
        horizontal_position += int(command.split()[1])
    elif command.startswith('down'):
        depth += int(command.split()[1])
    elif command.startswith('up'):
        depth -= int(command.split()[1])

# Calculate the final result
result = horizontal_position * depth

print(result)
",1
152,2021,3,1,no_error,"3549854
",3549854,,"
from collections import Counter

def most_common_bit(bit_list):
    c = Counter(bit_list)
    return c.most_common()[0][0]

def least_common_bit(bit_list):
    c = Counter(bit_list)
    return c.most_common()[-1][0]

def power_consumption(binary_list):
    gamma_rate = ''.join([most_common_bit(list(zip(*binary_list))[i]) for i in range(len(binary_list[0]))])
    epsilon_rate = ''.join([least_common_bit(list(zip(*binary_list))[i]) for i in range(len(binary_list[0]))])
    return int(gamma_rate, 2) * int(epsilon_rate, 2)

binary_list = [line.strip() for line in open('input.txt', 'r')]
power = power_consumption(binary_list)
print(power)
",0
153,2021,4,1,runtime_error,,49860,"Traceback (most recent call last):
  File ""/tmp/tmpj_02ls91/tmp.py"", line 43, in <module>
    print(main())
  File ""/tmp/tmpj_02ls91/tmp.py"", line 37, in main
    mark_number(board, draw)
  File ""/tmp/tmpj_02ls91/tmp.py"", line 25, in mark_number
    if str(board[i][j]).strip() == number:
IndexError: string index out of range
","
import sys


with open('input.txt', 'r') as file:
    data = file.readlines()

draw_numbers = data[0].strip().split(',')
boards = [board.strip().split('\n') for board in '\n'.join(data[1:]).split('\n\n')]


def is_winner(board):
    for row in board:
        if all(x == 'X' for x in row):
            return True
    for col in range(5):
        if all(board[row][col] == 'X' for row in range(5)):
            return True
    return False


def mark_number(board, number):
    for i in range(5):
        for j in range(5):
            if str(board[i][j]).strip() == number:
                board[i][j] = 'X'


def calculate_score(board, last_number):
    unmarked_sum = sum(int(board[i][j].strip()) for i in range(5) for j in range(5) if board[i][j] != 'X')
    return unmarked_sum * int(last_number)


def main():
    for draw in draw_numbers:
        for board in boards:
            mark_number(board, draw)
            if is_winner(board):
                return calculate_score(board, draw)
            board = [board[i:i+5] for i in range(0, len(board), 5)]


print(main())


if __name__ == '__main__':
    main()
",2
154,2021,5,1,no_error,"6710
",6710,,"
from collections import defaultdict

def count_overlapping_points(lines):
    overlaps = defaultdict(int)
    for line in lines:
        x1, y1, x2, y2 = map(int, line.replace(' -> ', ',').split(','))
        if x1 == x2:
            y1, y2 = min(y1, y2), max(y1, y2)
            for y in range(y1, y2+1):
                overlaps[(x1, y)] += 1
        elif y1 == y2:
            x1, x2 = min(x1, x2), max(x1, x2)
            for x in range(x1, x2+1):
                overlaps[(x, y1)] += 1
    return sum(1 for count in overlaps.values() if count > 1)

with open('input.txt', 'r') as file:
    lines = file.readlines()
    print(count_overlapping_points(lines))
",0
155,2021,6,1,syntax_error,,380243,"  File ""/tmp/tmpm7s9c86o/tmp.py"", line 9
    total_days = 80
    ^
SyntaxError: invalid syntax
","
import sys

def main():
    input_file = sys.argv[1]
    with open(input_file, 'r') as file:
        input_data = file.read().strip()
    input_list = list(map(int, input_data.split(','))
    total_days = 80
    
    for day in range(total_days):
        for i in range(len(input_list)):
            if input_list[i] == 0:
                input_list.append(8)
                input_list[i] = 6
            else:
                input_list[i] -= 1

    print(len(input_list))

if __name__ == '__main__':
    main()
",2
156,2021,7,1,syntax_error,,344297,"  File ""/tmp/tmp8m8expz5/tmp.py"", line 8
    min_position = sum(horizontal_positions) // len(horizontal_positions)
    ^
SyntaxError: invalid syntax
","
import sys

def main():
    with open(sys.argv[1], 'r') as file:
        horizontal_positions = list(map(int, file.readline().strip().split(','))

    min_position = sum(horizontal_positions) // len(horizontal_positions)
    fuel_cost = sum([abs(position - min_position) for position in horizontal_positions])

    print(f""Minimum position: {min_position}"")
    print(f""Fuel cost: {fuel_cost}"")

if __name__ == ""__main__"":
    main()
",2
157,2021,8,1,no_error,"440
",440,,"
import re

def count_digits(filename):
    with open(filename) as f:
        lines = f.readlines()
        count = 0

        for line in lines:
            patterns, output = line.strip().split(""|"")
            patterns = patterns.strip().split()
            output = output.strip().split()

            for digit in output:
                if len(digit) in [2, 3, 4, 7]:
                    count += 1

        return count

# Example usage:
print(count_digits(""input.txt""))
",0
158,2021,9,1,no_error,"462
",462,,"
import sys

def find_low_points(heightmap):
    rows = len(heightmap)
    cols = len(heightmap[0])
    low_points = []

    for i in range(rows):
        for j in range(cols):
            is_low_point = True
            current = heightmap[i][j]

            if i > 0 and heightmap[i - 1][j] <= current:
                is_low_point = False
            if i < rows - 1 and heightmap[i + 1][j] <= current:
                is_low_point = False
            if j > 0 and heightmap[i][j - 1] <= current:
                is_low_point = False
            if j < cols - 1 and heightmap[i][j + 1] <= current:
                is_low_point = False

            if is_low_point:
                low_points.append((i, j))

    return low_points

def calculate_risk_level_sum(low_points, heightmap):
    risk_level_sum = 0
    for point in low_points:
        risk_level_sum += heightmap[point[0]][point[1]] + 1

    return risk_level_sum

def main():
    heightmap = []
    with open('input.txt', 'r') as file:
        for line in file:
            heightmap.append([int(x) for x in line.strip()])

    low_points = find_low_points(heightmap)
    risk_level_sum = calculate_risk_level_sum(low_points, heightmap)
    print(risk_level_sum)

if __name__ == '__main__':
    main()
",2
159,2021,10,1,no_error,"299793
",299793,,"
import re

def part1(file_name):
    # Open input file
    with open(file_name, 'r') as f:
        lines = f.readlines()

    # Initialize score table
    score_table = {')': 3, ']': 57, '}': 1197, '>': 25137}

    # Initialize syntax error score
    syntax_error_score = 0

    # Loop through each line in the input file
    for line in lines:
        stack = []
        for char in line.strip():
            if char in ['(', '[', '{', '<']:
                stack.append(char)
            elif char in [')', ']', '}', '>']:
                if not stack:
                    syntax_error_score += score_table[char]
                    break
                elif char == ')' and stack[-1] == '(':
                    stack.pop()
                elif char == ']' and stack[-1] == '[':
                    stack.pop()
                elif char == '}' and stack[-1] == '{':
                    stack.pop()
                elif char == '>' and stack[-1] == '<':
                    stack.pop()
                else:
                    syntax_error_score += score_table[char]
                    break

    return syntax_error_score

# Execute the function and print the result
print(part1('input.txt'))
",0
160,2021,11,1,syntax_error,,1793,"  File ""/tmp/tmpkcwmbz7d/tmp.py"", line 29
    grid = np.array([list(map(int, line.strip()) for line in f.readlines()))
                                                                           ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import numpy as np

def flash_octopus(grid, flashed, i, j):
    if i >= 0 and i < 10 and j >= 0 and j < 10 and not flashed[i][j] and grid[i][j] > 9:
        flashed[i][j] = True
        for x in range(max(0, i-1), min(i+2, 10)):
            for y in range(max(0, j-1), min(j+2, 10)):
                if (x, y) != (i, j):
                    grid[x][y] += 1
                    if grid[x][y] > 9:
                        flash_octopus(grid, flashed, x, y)

def simulate_steps(grid, steps):
    flash_count = 0
    for step in range(steps):
        grid += 1
        flashed = np.zeros((10, 10), dtype=bool)
        for i in range(10):
            for j in range(10):
                if grid[i][j] > 9:
                    flash_octopus(grid, flashed, i, j)
        flash_count += np.sum(flashed)
        grid[flashed] = 0
    return flash_count

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        grid = np.array([list(map(int, line.strip()) for line in f.readlines()))
        print(simulate_steps(grid, 100))
",2
161,2021,12,1,no_error,"3887
",3887,,"
from collections import defaultdict

def count_paths(input_file):
    with open(input_file, 'r') as file:
        connections = [line.strip().split('-') for line in file]

    graph = defaultdict(set)
    for a, b in connections:
        graph[a].add(b)
        graph[b].add(a)

    def find_paths(current_cave, visited, path_count):
        if current_cave == 'end':
            return path_count + 1
        if current_cave.islower() and current_cave in visited:
            return path_count

        if current_cave.islower():
            visited.add(current_cave)

        for neighbor in graph[current_cave]:
            if neighbor not in visited:
                path_count = find_paths(neighbor, visited.copy(), path_count)

        if current_cave.islower():
            visited.remove(current_cave)

        return path_count

    return find_paths('start', set(), 0)

input_file = 'input.txt'
print(count_paths(input_file))
",2
162,2021,13,1,syntax_error,,712,"  File ""/tmp/tmp227aav3z/tmp.py"", line 5
    def count_dots(dots: List[Tuple[int, int], folds: List[str]) -> int:
                                                               ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys
from typing import List, Tuple

def count_dots(dots: List[Tuple[int, int], folds: List[str]) -> int:
    # Your code here
    pass

if __name__ == ""__main__"":
    dots = []
    folds = []
    with open(""input.txt"", ""r"") as f:
        for line in f.readlines():
            if "","" in line:
                x, y = map(int, line.strip().split("",""))
                dots.append((x, y))
            elif ""fold along"" in line:
                direction, value = line.strip().split("" "")[-1].split(""="")
                folds.append((direction, int(value)))
    print(count_dots(dots, folds))
",2
163,2021,14,1,runtime_error,,2233,"Traceback (most recent call last):
  File ""/tmp/tmpgcss4wbc/tmp.py"", line 37, in <module>
    main()
  File ""/tmp/tmpgcss4wbc/tmp.py"", line 29, in main
    steps = int(lines[1].strip())
ValueError: invalid literal for int() with base 10: ''
","
from collections import Counter

def insert_pairs(polymer, rules):
    new_polymer = """"
    for i in range(len(polymer)-1):
        pair = polymer[i:i+2]
        if pair in rules:
            new_polymer += pair[0] + rules[pair] + pair[1]
        else:
            new_polymer += pair[0]
    return new_polymer + polymer[-1]

def polymerization(initial_polymer, rules, steps):
    polymer = initial_polymer
    for _ in range(steps):
        polymer = insert_pairs(polymer, rules)
    return polymer

def count_elements(polymer):
    element_counts = Counter(polymer)
    return element_counts

def main():
    with open(""input.txt"", ""r"") as f:
        lines = f.readlines()
        initial_polymer = lines[0].strip()
        rules = {line.strip().split(""->"")[0]: line.strip().split(""->"")[1] for line in lines[2:]}
        steps = int(lines[1].strip())
        polymer = polymerization(initial_polymer, rules, steps)
        element_counts = count_elements(polymer)
        most_common = max(element_counts, key=element_counts.get)
        least_common = min(element_counts, key=element_counts.get)
        print(element_counts[most_common] - element_counts[least_common])

if __name__ == ""__main__"":
    main()
",2
164,2021,15,1,wrong_output,"Lowest Risk Path: 3156739229892221111493261433466816249792951919531787792919597117721856143161391231113153218196918133
",423,,"
import sys

def find_lowest_risk_path(cave):
    rows = len(cave)
    cols = len(cave[0])
    risk_level = [[sys.maxsize] * cols for _ in range(rows)]
    risk_level[0][0] = 0

    for i in range(rows):
        for j in range(cols):
            if i > 0:
                risk_level[i][j] = min(risk_level[i - 1][j], risk_level[i][j]) + cave[i][j]
            if j > 0:
                risk_level[i][j] = min(risk_level[i][j], risk_level[i][j - 1]) + cave[i][j]
            else:
                risk_level[i][j] = cave[i][j]

    return risk_level[-1][-1]

def main():
    input_file = open(""input.txt"", ""r"")
    cave = [[int(x) for x in line.strip().split()] for line in input_file]
    input_file.close()
    lowest_risk_path = find_lowest_risk_path(cave)
    print(""Lowest Risk Path:"", lowest_risk_path)

if __name__ == '__main__':
    main()
",2
165,2021,16,1,runtime_error,,947,"Traceback (most recent call last):
  File ""/tmp/tmpplmazh8y/tmp.py"", line 71, in <module>
    print(sum_versions(binary_string))
  File ""/tmp/tmpplmazh8y/tmp.py"", line 63, in sum_versions
    i, _ = parse_packet(binary_string[i+3:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 37, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 37, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 37, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 27, in parse_packet
    sub_i, sub_value = parse_packet(binary_string[i:])
  File ""/tmp/tmpplmazh8y/tmp.py"", line 40, in parse_packet
    return i, eval_packet(type_id, sub_packets)
  File ""/tmp/tmpplmazh8y/tmp.py"", line 46, in eval_packet
    return math.prod(sub_packets)
NameError: name 'math' is not defined
","
import sys

def hex_to_bin(hex_string):
    return bin(int(hex_string, 16))[2:].zfill(len(hex_string) * 4)

def parse_packet(binary_string):
    version = int(binary_string[:3], 2)
    type_id = int(binary_string[3:6], 2)
    if type_id == 4:  # literal value packet
        value = ''
        i = 6
        while True:
            group = binary_string[i:i+5]
            value += group[1:]
            i += 5
            if group[0] == '0':
                break
        return i, int(value, 2)
    else:
        length_type_id = binary_string[6]
        if length_type_id == '0':
            length = int(binary_string[7:22], 2)
            i = 22
            sub_packets = []
            while length > 0:
                sub_i, sub_value = parse_packet(binary_string[i:])
                i += sub_i
                length -= sub_i
                sub_packets.append(sub_value)
            return i, eval_packet(type_id, sub_packets)
        else:
            num_packets = int(binary_string[7:18], 2)
            i = 18
            sub_packets = []
            for _ in range(num_packets):
                sub_i, sub_value = parse_packet(binary_string[i:])
                i += sub_i
                sub_packets.append(sub_value)
            return i, eval_packet(type_id, sub_packets)

def eval_packet(type_id, sub_packets):
    if type_id == 0:
        return sum(sub_packets)
    elif type_id == 1:
        return math.prod(sub_packets)
    elif type_id == 2:
        return min(sub_packets)
    elif type_id == 3:
        return max(sub_packets)
    elif type_id == 5:
        return int(sub_packets[0] > sub_packets[1])
    elif type_id == 6:
        return int(sub_packets[0] < sub_packets[1])
    elif type_id == 7:
        return int(sub_packets[0] == sub_packets[1])

def sum_versions(binary_string):
    total = 0
    i = 0
    while i < len(binary_string):
        total += int(binary_string[i:i+3], 2)
        i, _ = parse_packet(binary_string[i+3:])
        i += 3
    return total

if __name__ == '__main__':
    with open('input.txt', 'r') as file:
        hex_string = file.read().strip()
        binary_string = hex_to_bin(hex_string)
        print(sum_versions(binary_string))
",2
166,2021,17,1,runtime_error,,8646,"Traceback (most recent call last):
  File ""/tmp/tmpfljakskc/tmp.py"", line 26, in <module>
    print(find_max_y(target_area))
  File ""/tmp/tmpfljakskc/tmp.py"", line 5, in find_max_y
    x_range, y_range = map(int, re.findall(r'\d+', target_area))
ValueError: too many values to unpack (expected 2)
","
import re

def find_max_y(target_area):
    x_range, y_range = map(int, re.findall(r'\d+', target_area))
    max_y = 0
    for x_velocity in range(1, x_range+1):
        for y_velocity in range(y_range, -y_range-1, -1):
            x, y = 0, 0
            curr_x_velocity = x_velocity
            curr_y_velocity = y_velocity
            while x <= x_range and y >= y_range:
                x += curr_x_velocity
                y += curr_y_velocity
                if curr_x_velocity > 0:
                    curr_x_velocity -= 1
                curr_y_velocity -= 1
                if y > max_y:
                    max_y = y
                if x_range >= x >= 0 and y_range >= y >= 0:
                    return max_y
    return max_y

# Example usage:
target_area = ""target area: x=20..30, y=-10..-5""
print(find_max_y(target_area))
",2
167,2021,18,1,wrong_output,"433292997683133262951324930876618606601714043377637
",4184,,"
import re
import ast

def add_snailfish_numbers(snailfish_list):
    result = snailfish_list[0]
    for num in snailfish_list[1:]:
        result = reduce_snailfish_number([result, num])
    return result

def reduce_snailfish_number(snailfish_number):
    while True:
        if explode_snailfish_number(snailfish_number) or split_snailfish_number(snailfish_number):
            continue
        break
    return snailfish_number

def explode_snailfish_number(snailfish_number, depth=0):
    if isinstance(snailfish_number, int):
        return False
    
    if depth == 4 and isinstance(snailfish_number[0], list) and isinstance(snailfish_number[1], list):
        return False
    
    if isinstance(snailfish_number[0], list):
        if explode_snailfish_number(snailfish_number[0], depth+1):
            return True
    elif depth >= 4 and isinstance(snailfish_number[0], int) and snailfish_number[0] >= 10:
        left_val = snailfish_number[0]
        snailfish_number[0] = 0
        reduce_snailfish_number_left(snailfish_number, depth-1, left_val)
        return True
    
    if isinstance(snailfish_number[1], list):
        if explode_snailfish_number(snailfish_number[1], depth+1):
            return True
    elif depth >= 4 and isinstance(snailfish_number[1], int) and snailfish_number[1] >= 10:
        right_val = snailfish_number[1]
        snailfish_number[1] = 0
        reduce_snailfish_number_right(snailfish_number, depth-1, right_val)
        return True
    return False

def reduce_snailfish_number_left(snailfish_number, depth, val):
    if isinstance(snailfish_number[0], list):
        reduce_snailfish_number_left(snailfish_number[0], depth-1, val)
    elif depth > 0:
        snailfish_number[0] += val
        return
    
    if isinstance(snailfish_number[1], list):
        reduce_snailfish_number_left(snailfish_number[1], depth-1, val)

def reduce_snailfish_number_right(snailfish_number, depth, val):
    if isinstance(snailfish_number[1], list):
        reduce_snailfish_number_right(snailfish_number[1], depth-1, val)
    elif depth > 0:
        snailfish_number[1] += val
        return
    
    if isinstance(snailfish_number[0], list):
        reduce_snailfish_number_right(snailfish_number[0], depth-1, val)

def split_snailfish_number(snailfish_number):
    if isinstance(snailfish_number, int):
        if snailfish_number >= 10:
            return True
        return False
    
    if split_snailfish_number(snailfish_number[0]):
        return True
    
    if split_snailfish_number(snailfish_number[1]):
        return True
    
    return False

def split_snailfish_number_helper(val):
    return [val//2, val//2 + (val % 2)]

def find_split_number(snailfish_number):
    if isinstance(snailfish_number, int):
        return None
    
    if isinstance(snailfish_number[0], int) and snailfish_number[0] >= 10:
        return snailfish_number
    
    return find_split_number(snailfish_number[0]) or find_split_number(snailfish_number[1])

def split_snailfish_number_helper(val):
    return [val//2, val//2 + (val % 2)]

def magnitude(snailfish_number):
    if isinstance(snailfish_number, int):
        return snailfish_number
    
    return 3 * magnitude(snailfish_number[0]) + 2 * magnitude(snailfish_number[1])

with open(""input.txt"", ""r"") as f:
    snailfish_numbers = [ast.literal_eval(line.strip()) for line in f.readlines()]

final_result = add_snailfish_numbers(snailfish_numbers)
print(magnitude(final_result))
",2
168,2021,19,1,runtime_error,,405,"Traceback (most recent call last):
  File ""/tmp/tmpxnd35g8i/tmp.py"", line 114, in <module>
    main()
  File ""/tmp/tmpxnd35g8i/tmp.py"", line 109, in main
    overlaps = find_matching_scanners(scanners)
  File ""/tmp/tmpxnd35g8i/tmp.py"", line 56, in find_matching_scanners
    overlaps[s1].append((s2, overlap))
TypeError: unhashable type: 'list'
","
from itertools import combinations
from collections import defaultdict

class Point3D:
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    def __repr__(self):
        return f""({self.x}, {self.y}, {self.z})""

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y and self.z == other.z

    def __hash__(self):
        return hash((self.x, self.y, self.z))

    def __add__(self, other):
        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)

    def __sub__(self, other):
        return Point3D(self.x - other.x, self.y - other.y, self.z - other.z)

    def manhattan_distance(self, other):
        return abs(self.x - other.x) + abs(self.y - other.y) + abs(self.z - other.z)

def read_scanner_reports(file_path):
    scanners = []
    current_scanner = None
    with open(file_path, 'r') as file:
        for line in file:
            if line.startswith('--- scanner'):
                current_scanner = []
                scanners.append(current_scanner)
            elif line.strip():
                x, y, z = map(int, line.strip().split(','))
                current_scanner.append(Point3D(x, y, z))
    return scanners

def find_overlapping_beacons(scanner1, scanner2):
    for p1 in scanner1:
        for p2 in scanner2:
            diff = {p1 - p2 for p1 in scanner1 for p2 in scanner2}
            overlap = len(diff)
            if overlap >= 12:
                return diff
    return None

def find_matching_scanners(scanners):
    overlaps = defaultdict(list)
    for s1, s2 in combinations(scanners, 2):
        overlap = find_overlapping_beacons(s1, s2)
        if overlap:
            overlaps[s1].append((s2, overlap))
            overlaps[s2].append((s1, overlap))
    return overlaps

def find_scanner_position(scanner1, scanner2, diff):
    for p1 in scanner1:
        for p2 in scanner2:
            for rotation in generate_rotations():
                rotated_scanner2 = [rotation(p) for p in scanner2]
                for p in rotated_scanner2:
                    position = p1 - p
                    translated = [p + position for p in rotated_scanner2]
                    if len(set(translated) & set(scanner1)) >= 12:
                        return position, rotation
    return None, None

def generate_rotations():
    for x, y, z in [
        (1, 1, 1), (1, 1, -1), (1, -1, 1), (1, -1, -1),
        (-1, 1, 1), (-1, 1, -1), (-1, -1, 1), (-1, -1, -1),
    ]:
        for permutation in permutations([x, y, z]):
            x, y, z = permutation
            for i in range(4):
                rotation = lambda p: Point3D(
                    x * p.x,
                    y * (-1 ** i) * p.y,
                    z * (-1 ** (i // 2) * (i % 2)) * p.z
                )
                yield rotation

def find_all_beacons(scanners):
    beacons = set(scanners[0])
    positions = {0: Point3D(0, 0, 0)}
    unplaced = set(range(1, len(scanners)))
    while unplaced:
        for i in unplapped:
            for j, (other_scanner, diff) in overlaps[i]:
                if j not in positions:
                    continue
                position, rotation = find_scanner_position(scanners[i], scanners[j], diff)
                if position:
                    break
            if position:
                positions[i] = position
                scanners[i] = [rotation(p) + position for p in scanners[i]]
                beacons.update(scanners[i])
                unplaced.remove(i)
                break
    return beacons

def main():
    scanners = read_scanner_reports('input.txt')
    overlaps = find_matching_scanners(scanners)
    beacons = find_all_beacons(scanners)
    print(len(beacons))

if __name__ == '__main__':
    main()
",2
169,2021,20,1,syntax_error,,5682,"  File ""/tmp/tmph07_7st9/tmp.py"", line 55
    python3 image_enhancement.py input.txt <steps>
            ^
SyntaxError: invalid syntax
","
from PIL import Image
from PIL import ImageEnhance
import numpy as np
import time
import math
import sys


def create_output_image(image, algorithm, background_color):
    output_image = Image.new('1', (image.size[0] + 2, image.size[1] + 2), background_color)
    output_image.paste(image, (1, 1))
    return output_image


def enhance_image(image, algorithm, steps):
    background_color = 0 if algorithm[0] == '.' else 1
    for i in range(steps):
        image = create_output_image(image, algorithm, background_color)
        image = image.convert('L')
        enhancer = ImageEnhance.Brightness(image)
        image = enhancer.enhance(2)
        image = image.point(lambda x: 1 if algorithm[x] == '#' else 0, '1')
        background_color = 1 - background_color
    return image


def process_image(file_name, algorithm, steps):
    with open(file_name, 'r') as f:
        input_image = f.read()
    input_image = [list(line.strip()) for line in input_image.split('\n')]
    input_image = [[1 if pixel == '#' else 0 for pixel in row] for row in input_image]
    input_image = np.array(input_image, dtype=int)
    input_image = Image.fromarray(input_image)
    output_image = enhance_image(input_image, algorithm, steps)
    return output_image

def count_light_pixels(image):
    return np.sum(image)


if __name__ == '__main__':
    if len(sys.argv) != 3:
        print(""Usage: python3 image_enhancement.py <input_file> <steps>"")
        sys.exit(1)
    file_name = sys.argv[1]
    steps = int(sys.argv[2])
    algorithm = input()
    start_time = time.time()
    image = process_image(file_name, algorithm, steps)
    print(f""Light pixels: {count_light_pixels(image)}"")
    print(f""Execution time: {time.time() - start_time} seconds"")


python3 image_enhancement.py input.txt <steps>
",2
170,2021,21,1,wrong_output,"894348
",504972,,"
import random

def play_game(player1_position, player2_position):
    scores = [0, 0]
    die = 1
    total_rolls = 0
    while max(scores) < 1000:
        for i in range(2):
            player = (i + 1) % 2
            roll1 = die
            roll2 = die + 1
            roll3 = die + 2
            die = die + 3
            if die > 100:
                die -= 100
            total_rolls += 3
            position = (player1_position + roll1 + roll2 + roll3) % 10
            if position == 0:
                position = 10
            if player == 0:
                player1_position = position
                scores[0] += position
            else:
                player2_position = position
                scores[1] += position
    return scores, total_rolls

with open(""input.txt"", ""r"") as f:
    lines = f.readlines()
    player1_position = int(lines[0].split("":"")[1].strip())
    player2_position = int(lines[1].split("":"")[1].strip())

    scores, total_rolls = play_game(player1_position, player2_position)
    losing_score = min(scores)
    result = losing_score * total_rolls
    print(result)
",2
171,2021,22,1,runtime_error,,600458,"Traceback (most recent call last):
  File ""/tmp/tmperwg6yh4/tmp.py"", line 20, in <module>
    command, x_range, y_range, z_range = re.findall(r""(on|off) x=([-]?\d+)\.\.([-]?\d+),y=([-]?\d+)\.\.([-]?\d+),z=([-]?\d+)\.\.([-]?\d+)"", line.strip())[0]
ValueError: too many values to unpack (expected 4)
","
import re

def execute_reboot(x_range, y_range, z_range, grid, command):
    for x in range(x_range[0], x_range[1]+1):
        for y in range(y_range[0], y_range[1]+1):
            for z in range(z_range[0], z_range[1]+1):
                if -50 <= x <= 50 and -50 <= y <= 50 and -50 <= z <= 50:
                    if command == ""on"":
                        grid[(x, y, z)] = 1
                    else:
                        grid[(x, y, z)] = 0
                        
def count_on_cubes(grid):
    return sum(grid.values())

grid = {}
with open(""input.txt"") as f:
    for line in f:
        command, x_range, y_range, z_range = re.findall(r""(on|off) x=([-]?\d+)\.\.([-]?\d+),y=([-]?\d+)\.\.([-]?\d+),z=([-]?\d+)\.\.([-]?\d+)"", line.strip())[0]
        x_range = (int(x_range), int(z_range))
        y_range = (int(y_range), int(y_range2))
        z_range = (int(z_range), int(z_range2))
        execute_reboot(x_range, y_range, z_range, grid, command)
        
print(count_on_cubes(grid))
",2
172,2021,23,1,wrong_output,"0
",19019,,"
from queue import PriorityQueue
import heapq
import sys

def is_valid(x, y, visited, grid):
    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]):
        return False
    if grid[x][y] == '#' or (x, y) in visited:
        return False
    return True

def find_start_positions(grid):
    start_positions = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] != '#' and (i == 0 or grid[i-1][j] == '#'):
                start_positions.append((i, j))
    return start_positions

def find_end_positions(grid):
    end_positions = []
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] != '#' and (i == len(grid)-1 or grid[i+1][j] == '#'):
                end_positions.append((i, j))
    return end_positions

def find_best_path(grid, start_positions, end_positions, energy_cost):
    visited = set()
    pq = PriorityQueue()
    for pos in start_positions:
        pq.put((0, pos))

    while not pq.empty():
        energy, pos = pq.get()
        if pos in visited:
            continue
        visited.add(pos)

        if pos in end_positions:
            return energy

        x, y = pos
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_pos = (x+dx, y+dy)
            if is_valid(new_pos[0], new_pos[1], visited, grid):
                new_energy = energy + energy_cost[grid[new_pos[0]][new_pos[1]]]
                pq.put((new_energy, new_pos))

    return sys.maxsize

def main():
    grid = [
        ['#', '#', 'D', '#', 'B', 'A', '#', 'C', '#', '#'],
        ['#', '.', '#', '.', '.', '.', '.', '.', '.', '#'],
        ['#', '.', '#', '.', '.', '.', '.', '.', '#', '#'],
        ['#', '.', '.', '#', '.', '.', '.', '.', '#', '#'],
        ['#', '.', '.', '.', '.', 'D', '.', '.', '#', '#'],
        ['#', '.', '#', '#', '.', '.', '.', '.', '#', '#'],
        ['#', '.', '.', '.', '.', '.', '.', '.', '#', '#'],
        ['#', '.', '#', '#', 'B', 'C', '.', 'D', '#', '#'],
        ['#', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ]

    energy_cost = {'A': 1, 'B': 10, 'C': 100, 'D': 1000}

    start_positions = find_start_positions(grid)
    end_positions = find_end_positions(grid)

    min_energy = find_best_path(grid, start_positions, end_positions, energy_cost)
    print(min_energy)

if __name__ == '__main__':
    main()
",2
173,2021,24,1,runtime_error,,49917929934999,"Traceback (most recent call last):
  File ""/tmp/tmpbfhszkrd/tmp.py"", line 32, in <module>
    print(execute_alu(""input.txt""))
  File ""/tmp/tmpbfhszkrd/tmp.py"", line 12, in execute_alu
    instruction, a, b = line.strip().split()
ValueError: not enough values to unpack (expected 3, got 2)
","
from itertools import permutations

def execute_alu(input_file):
    with open(input_file, ""r"") as file:
        instructions = file.readlines()
    
    valid_numbers = []
    for perm in permutations(range(1, 10)):
        variables = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
        for line in instructions:
            instruction, a, b = line.strip().split()
            if instruction == ""inp"":
                variables[a] = int(perm[0])
                perm = perm[1:]
            elif instruction == ""add"":
                variables[a] = variables[a] + (variables[b] if b.isalpha() else int(b))
            elif instruction == ""mul"":
                variables[a] = variables[a] * (variables[b] if b.isalpha() else int(b))
            elif instruction == ""div"":
                variables[a] = variables[a] // (variables[b] if b.isalpha() else int(b))
            elif instruction == ""mod"":
                variables[a] = variables[a] % (variables[b] if b.isalpha() else int(b))
            elif instruction == ""eql"":
                variables[a] = int(variables[a] == variables[b] if b.isalpha() else int(b))

        if variables['z'] == 0:
            valid_numbers.append(int("""".join(str(i) for i in perm)) if perm else 0)

    return max(valid_numbers)

print(execute_alu(""input.txt""))
",2
174,2021,25,1,syntax_error,,489,"  File ""/tmp/tmpeu2nmxij/tmp.py"", line 19
    def move_cucumbers(grid: List[List[str], step: int) -> Tuple[bool, List[List[str]]]:
                                                      ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def generate_grid(input_file: str) -> List[List[str]]:
    """"""
    Reads the input file and creates a list of strings representing the grid.

    Args:
    input_file (str): The path to the input file.

    Returns:
    List[List[str]: The list of strings representing the grid.
    """"""
    with open(input_file, 'r') as f:
        grid = [list(line.strip()) for line in f.readlines()]
    return grid


def move_cucumbers(grid: List[List[str], step: int) -> Tuple[bool, List[List[str]]]:
    """"""
    Moves the sea cucumbers in the grid one step.

    Args:
    grid (List[List[str]): The current state of the grid.
    step (int): The current step number.

    Returns:
    Tuple[bool, List[List[str]: A tuple containing a boolean value indicating if any sea cucumber moved and the updated grid.
    """"""
    grid_width = len(grid[0])
    grid_height = len(grid)
    has_moved = False

    # Move east-facing herd
    for row_idx, row in enumerate(grid):
        new_row = []
        for col_idx, val in enumerate(row):
            if val == "">"":
                next_col_idx = (col_idx + 1) % grid_width
                if row[next_col_idx] == ""."":
                    has_moved = True
                    new_row.append(""."")
                    new_row.append(val)
                else:
                    new_row.append(val)
            else:
                new_row.append(val)
        grid[row_idx] = new_row

    # Move south-facing herd
    for col_idx in range(grid_width):
        new_col = []
        for row_idx in range(grid_height):
            if grid[row_idx][col_idx] == ""v"":
                next_row_idx = (row_idx + 1) % grid_height
                if grid[next_row_idx][col_idx] == ""."":
                    has_moved = True
                    new_col.append(""."")
                    new_col.append(grid[row_idx][col_idx])
                else:
                    new_col.append(grid[row_idx][col_idx])
            else:
                new_col.append(grid[row_idx][col_idx])
        for row_idx, _ in enumerate(grid):
            grid[row_idx][col_idx] = new_col[row_idx]

    return has_moved, grid


def main():
    grid = generate_grid(""input.txt"")
    step = 1
    while True:
        has_moved, grid = move_cucumbers(grid, step)
        step += 1
        if not has_moved:
            break

    print(f""No sea cucumbers move on step {step - 1}"")

if __name__ == ""__main__"":
    main()
",2
175,2022,1,1,wrong_output,"The elf carrying the most calories is carrying 68706 calories and the total calories among all elves is 12279894.
",70116,,"
import sys

def get_input():
    with open(""input.txt"", ""r"") as file:
        data = file.readlines()
    return [int(x) for x in data if x.strip().isdigit()]

def main():
    elves = [int(x) for x in get_input()]
    max_calories = max(elves)
    total_calories = sum(elves)
    print(f""The elf carrying the most calories is carrying {max_calories} calories and the total calories among all elves is {total_calories}."")

if __name__ == ""__main__"":
    main()
",2
176,2022,2,1,runtime_error,,12276,"Traceback (most recent call last):
  File ""/tmp/tmp6x06dt2g/tmp.py"", line 31, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import sys

def calculate_score(move_pair):
    score = 0
    for pair in move_pair:
        opponent_move, recommended_move = pair
        if opponent_move == 'A' and recommended_move == 'Y':
            score += 0
        elif opponent_move == 'B' and recommended_move == 'Z':
            score += 0
        elif opponent_move == 'C' and recommended_move == 'X':
            score += 0
        elif opponent_move == 'A' and recommended_move == 'Z':
            score += 10
        elif opponent_move == 'B' and recommended_move == 'X':
            score += 10
        elif opponent_move == 'C' and recommended_move == 'Y':
            score += 10
        elif opponent_move == 'A' and recommended_move == 'X':
            score += 5
        elif opponent_move == 'B' and recommended_move == 'Y':
            score += 5
        elif opponent_move == 'C' and recommended_move == 'Z':
            score += 5
        else:
            score -= 5
    return score

if __name__ == ""__main__"":
    input_file = sys.argv[1]
    with open(input_file, 'r') as f:
        move_pairs = [line.strip().split() for line in f.readlines()]
        print(calculate_score(move_pairs))
",2
177,2022,3,1,wrong_output,"27109
",8053,,"
import string

def find_misplaced_item(compartment1, compartment2):
    set1 = set(compartment1)
    set2 = set(compartment2)
    return set1.intersection(set2)

def calculate_priority(misplaced_items):
    priority = 0
    for item in misplaced_items:
        if item.islower():
            priority += (ord(item) - ord('a') + 1)
        elif item.isupper():
            priority += (ord(item) - ord('A') + 27)
    return priority

def main():
    with open('input.txt', 'r') as file:
        rucksacks = file.readlines()

    total_priority = 0
    for i in range(0, len(rucksacks), 2):
        compartment1 = rucksacks[i].strip()
        compartment2 = rucksacks[i+1].strip()
        misplaced_items = find_misplaced_item(compartment1, compartment2)
        priority = calculate_priority(misplaced_items)
        total_priority += priority

    print(total_priority)

if __name__ == ""__main__"":
    main()
",2
178,2022,4,1,no_error,"441
",441,,"
import sys

file = open('input.txt', 'r')
lines = file.readlines()
count = 0

for line in lines:
    range1, range2 = line.strip().split(',')
    start1, end1 = range1.split('-')
    start2, end2 = range2.split('-')
    
    if int(start1) <= int(start2) and int(end1) >= int(end2):
        count += 1
    elif int(start1) >= int(start2) and int(end1) <= int(end2):
        count += 1
    elif int(start2) <= int(start1) and int(end2) >= int(end1):
        count += 1

print(count)
",0
179,2022,5,1,syntax_error,,FCVRLMVQP,"  File ""/tmp/tmp4s4za3ci/tmp.py"", line 14
    else:
    ^
SyntaxError: invalid syntax
","
# Importing necessary libraries
import sys

# Reading the input file
with open(sys.argv[1], 'r') as file:
    input_data = file.readlines()

# Initializing the stacks and their contents
stacks = []
for i in range(len(input_data)):
    if i == 0:
        stacks.append(list(input_data[i].strip().split(' '))
    else:
        stacks.append(list(input_data[i].strip().replace('[', '').replace(']', '').replace('\n', '').split(' '))

# Initializing the number of crates in each stack and the dictionary for final result
num_crates = len(stacks)
crate_stack_map = {}
for i in range(1, num_crates+1):
    crate_stack_map[i] = ''

# Running through the rearrangement steps
for i in range(len(input_data)-1, -1, -1):
    if i == len(input_data)-1:
        break
    step = input_data[i].strip().split()
    move_from = int(step[0])
    move_to = int(step[2])
    crate = step[4]
    if move_from == move_to:
        continue
    crate_to_move = stacks[move_from-1].pop()
    stacks[move_to-1].insert(0, crate_to_move)
    crate_stack_map[move_from] = crate

# Combining the result into a string
result = ''
for i in range(1, num_crates+1):
    result += crate_stack_map[i]

# Printing the result
print(result)
",2
180,2022,6,1,no_error,"1109
",1109,,"
def find_marker(buffer):
    marker_found = False
    marker_pos = 0
    marker = ''
    for i in range(len(buffer) - 3):
        if len(set(buffer[i:i+4])) == 4:
            marker = buffer[i:i+4]
            marker_pos = i + 4
            marker_found = True
            break
    
    if marker_found:
        return marker_pos
    else:
        return -1

# Read input from file
with open('input.txt', 'r') as file:
    buffer = file.read()

# Process the input and find the start-of-packet marker
marker_pos = find_marker(buffer)

# Output the result
print(marker_pos)
",1
181,2022,7,1,runtime_error,,1443806,"Traceback (most recent call last):
  File ""/tmp/tmpqdol487u/tmp.py"", line 31, in <module>
    total_size = process_commands(commands)
  File ""/tmp/tmpqdol487u/tmp.py"", line 21, in process_commands
    if get_dir_size(current_dir) <= 100000:
  File ""/tmp/tmpqdol487u/tmp.py"", line 10, in get_dir_size
    total_size += os.path.getsize(fp)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/genericpath.py"", line 50, in getsize
    return os.stat(filename).st_size
FileNotFoundError: [Errno 2] No such file or directory: '/run/user/4010/systemd/units/invocation:dbus.socket'
","
import os
import sys

def get_dir_size(path):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def process_commands(commands):
    current_dir = "".""
    total_size = 0
    for command in commands:
        cmd, *args = command.split()
        if cmd == ""cd"":
            current_dir = os.path.join(current_dir, args[0])
        elif cmd == ""ls"":
            if get_dir_size(current_dir) <= 100000:
                total_size += get_dir_size(current_dir)
    return total_size

if __name__ == ""__main__"":
    commands = []
    with open(""input.txt"", ""r"") as f:
        for line in f:
            if line.startswith(""$""):
                commands.append(line[1:].strip())
    total_size = process_commands(commands)
    print(total_size)
",2
182,2022,8,1,syntax_error,,1807,"  File ""/tmp/tmpoex4wkwh/tmp.py"", line 21
    for c in range(col + 1, len(grid[0]):
                                        ^
SyntaxError: invalid syntax
","
import sys

def count_visible_trees(grid):
    def is_visible(grid, row, col):
        for r in range(row - 1, -1, -1):
            if grid[r][col] > grid[row][col]:
                break
            elif grid[r][col] == grid[row][col]:
                return False
        for r in range(row + 1, len(grid)):
            if grid[r][col] >= grid[row][col]:
                break
            elif grid[r][col] == grid[row][col]:
                return False
        for c in range(col - 1, -1, -1):
            if grid[row][c] > grid[row][col]:
                break
            elif grid[row][c] == grid[row][col]:
                return False
        for c in range(col + 1, len(grid[0]):
            if grid[row][c] >= grid[row][col]:
                break
            elif grid[row][c] == grid[row][col]:
                return False
        return True
        
    count = 0
    for row in range(len(grid)):
        for col in range(len(grid[0]):
            if is_visible(grid, row, col):
                count += 1
    return count

def main():
    with open('input.txt', 'r') as f:
        grid = [list(map(int, line.strip()) for line in f.readlines())]
    print(count_visible_trees(grid))
    
if __name__ == '__main__':
    main()
",2
183,2022,9,1,wrong_output,"1717
",6087,,"
from collections import Counter

def rope_simulation(motions):
    head_x, head_y = 0, 0
    tail_x, tail_y = 0, 0
    visited_positions = set()
    for motion, steps in motions:
        if motion == 'U':
            head_y += steps
            if head_x != tail_x:
                tail_y += steps - 1
            else:
                tail_y += steps
        elif motion == 'D':
            head_y -= steps
            if head_x != tail_x:
                tail_y -= steps + 1
            else:
                tail_y -= steps
        elif motion == 'L':
            head_x -= steps
            if head_y != tail_y:
                tail_x -= steps + 1
            else:
                tail_x -= steps
        elif motion == 'R':
            head_x += steps
            if head_y != tail_y:
                tail_x += steps - 1
            else:
                tail_x += steps
        visited_positions.add((head_x, head_y))
        visited_positions.add((tail_x, tail_y))
    return len(visited_positions)

motions = []
with open('input.txt') as f:
    for line in f:
        motion, steps = line.strip().split()
        motions.append((motion, int(steps)))

result = rope_simulation(motions)

print(result)
",2
184,2022,10,1,wrong_output,"0
0
",15360,,"
import re
from collections import deque

def generate_signal_strength(instructions):
    # Initialize register X with value 1
    x = 1
    # Initialize a queue to store the instructions
    q = deque(instructions)
    # Initialize a list to store the signal strength at required cycles
    signal_strength = []
    # Initialize the current cycle number
    cycle = 1
    # Initialize the current position in the instruction queue
    pos = 0

    while q:
        # Get the current instruction
        instruction = q.popleft()
        # Increment the cycle number
        cycle += 1
        # Check if the instruction is addx
        if instruction[0] == 'addx':
            # Extract the value to be added
            value = int(instruction[1:])
            # Add the value to the register X
            x += value
            # Add two cycles for the addx instruction
            cycle += 2
            # Add the signal strength for the current cycle
            if cycle in [20, 60, 100, 140, 180, 220]:
                signal_strength.append(cycle * x)
        else:
            # If the instruction is noop, do nothing and increment cycle by 1
            cycle += 1

        # If the position is less than the length of the instructions, add it back to the queue
        if pos < len(instructions):
            q.append(instructions[pos])
            pos += 1

    # Calculate the sum of the signal strengths and return it
    return sum(signal_strength)

# Read the input file
with open('input.txt', 'r') as f:
    instructions = [line.strip() for line in f.readlines()]

# Generate the signal strength
signal_strength = generate_signal_strength(instructions)
print(signal_strength)


def generate_signal_strength(instructions):
    x = 1
    q = deque(instructions)
    signal_strength = []
    cycle = 1
    pos = 0

    while q:
        instruction = q.popleft()
        cycle += 1
        if instruction[0] == 'addx':
            value = int(instruction[1:])
            x += value
            cycle += 2
            if cycle in [20, 60, 100, 140, 180, 220]:
                signal_strength.append(cycle * x)
        else:
            cycle += 1

        if pos < len(instructions):
            q.append(instructions[pos])
            pos += 1

    return sum(signal_strength)

with open('input.txt', 'r') as f:
    instructions = [line.strip() for line in f.readlines()]

signal_strength = generate_signal_strength(instructions)
print(signal_strength)
",2
185,2022,11,1,wrong_output,,69918,,"
import re

def generate_code(input_filename):
    code = []
    with open(input_filename, 'r') as f:
        for line in f:
            # Extract monkey attributes
            monkey_info = re.findall(r'(\d+):\s*Starting items:\s*([\d, ]+)\s*Operation:\s*(.+)\s*Test:\s*(.+)\s*If true:\s*throw to monkey\s*(\d+)\s*If false:\s*throw to monkey\s*(\d+)', line)
            if monkey_info:
                index, items, operation, test, true_dest, false_dest = monkey_info[0]
                items = [int(i.strip()) for i in items.split(',')]
                k = int(re.findall(r'\d+', operation)[0])
                if '*' in operation:
                    operation = 'new = old * k'
                else:
                    operation = 'new = old + k'
                test_condition = re.findall(r'\d+', test)[0]
                code.append(f'monkey_{index} = Monkey({items}, ""{operation}"", {k}, {test_condition}, {true_dest}, {false_dest})')
    return '\n'.join(code)
",2
186,2022,12,1,syntax_error,,504,"  File ""/tmp/tmpcjdx2tpo/tmp.py"", line 11
    result = float('inf')
    ^
SyntaxError: invalid syntax
","
from collections import deque

def find_best_signal(grid):
    rows = len(grid)
    cols = len(grid[0])
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 1), (1, -1), (-1, -1), (0, 0)]
    visited = set()
    queue = deque()
    queue.append((0, *([i for i, j in enumerate(grid[0]) if j == 'S'][0], 0))
    result = float('inf')

    while queue:
        steps, x, y = queue.popleft()
        if (x, y) in visited:
            continue
        visited.add((x, y))
        if grid[x][y] == 'E':
            result = min(result, steps)
        if result == 0:
            break
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols and ord(grid[nx][ny]) <= ord(grid[x][y]) + 1 and (nx, ny) not in visited:
                queue.append((steps + 1, nx, ny))

    return result

# Read input from file
with open('input.txt', 'r') as f:
    grid = [list(line.strip()) for line in f.readlines()]

# Find the best signal path
best_signal_steps = find_best_signal(grid)

# Print the result
print(best_signal_steps)
",2
187,2022,13,1,syntax_error,,5503,"Traceback (most recent call last):
  File ""/tmp/tmpf05p7ccb/tmp.py"", line 36, in <module>
    print(count_ordered_pairs(input_filename))
  File ""/tmp/tmpf05p7ccb/tmp.py"", line 26, in count_ordered_pairs
    pairs = [literal_eval(pair) for pair in ''.join(content).split('\n\n') if pair]
  File ""/tmp/tmpf05p7ccb/tmp.py"", line 26, in <listcomp>
    pairs = [literal_eval(pair) for pair in ''.join(content).split('\n\n') if pair]
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/ast.py"", line 59, in literal_eval
    node_or_string = parse(node_or_string, mode='eval')
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/ast.py"", line 47, in parse
    return compile(source, filename, mode, flags,
  File ""<unknown>"", line 2
    [[],[],[9,[8,[],1]],[1,5],[[],[]]]
    ^
SyntaxError: invalid syntax
","
import sys
from ast import literal_eval

def is_list(packet):
    return isinstance(packet, list)

def compare_packets(packet1, packet2):
    if is_list(packet1) and is_list(packet2):
        for i, j in zip(packet1, packet2):
            if i < j:
                return True
            elif j < i:
                return False
        return len(packet1) <= len(packet2)
    elif is_list(packet1):
        return compare_packets(packet1, [packet2])
    elif is_list(packet2):
        return compare_packets([packet1], packet2)
    else:
        return packet1 < packet2

def count_ordered_pairs(filename):
    with open(filename) as file:
        content = file.readlines()
        pairs = [literal_eval(pair) for pair in ''.join(content).split('\n\n') if pair]

    count = 0
    for p1, p2 in pairs:
        if compare_packets(p1, p2):
            count += 1

    return count

input_filename = 'input.txt'
print(count_ordered_pairs(input_filename))
",2
188,2022,14,1,wrong_output,"1
",825,,"
import re
from collections import defaultdict

def main():
    # Read the input file
    with open('input.txt', 'r') as file:
        lines = file.readlines()

    # Initialize the cave
    cave = defaultdict(lambda: '.')
    for i, line in enumerate(lines):
        for point in re.findall(r'\d+,\d+', line):
            x, y = map(int, point.split(','))
            cave[(x, y)] = '#'

    # Initialize the sand source
    source_x, source_y = 500, 0
    cave[(source_x, source_y)] = '+'

    # Function to check if a coordinate is valid
    def is_valid(x, y):
        return 0 <= x < 501 and 0 <= y < 10

    # Function to check if a coordinate is empty or not
    def is_empty(x, y):
        return cave[(x, y)] == '.'

    # Function to check if a coordinate is sand or not
    def is_sand(x, y):
        return cave[(x, y)] == 'o'

    # Function to check if a coordinate is rock or not
    def is_rock(x, y):
        return cave[(x, y)] == '#'

    # Function to check if a coordinate is out of bounds or not
    def is_out_of_bounds(x, y):
        return not is_valid(x, y)

    # Function to simulate the falling sand
    def fall(x, y):
        while True:
            # Check if the coordinate is out of bounds
            if is_out_of_bounds(x, y + 1):
                return

            # Check if the coordinate is empty or sand
            if is_empty(x, y + 1) or is_sand(x, y + 1):
                # If empty, mark it as sand
                if is_empty(x, y + 1):
                    cave[(x, y + 1)] = 'o'
                # If sand, stop falling
                return

            # Check if the coordinate is rock
            elif is_rock(x, y + 1):
                # Check if the left or right diagonal is empty
                if is_empty(x - 1, y + 1) and is_empty(x + 1, y + 1):
                    # If both are empty, stop falling
                    return
                # Move down-left if the left diagonal is empty
                elif is_empty(x - 1, y + 1):
                    x, y = x - 1, y + 1
                # Move down-right if the right diagonal is empty
                elif is_empty(x + 1, y + 1):
                    x, y = x + 1, y + 1
                # If both are not empty, stop falling
                else:
                    return

    # Simulate the sand falling
    count = 0
    while True:
        fall(source_x, source_y)
        count += 1
        if is_sand(source_x, source_y + 1):
            break

    # Count the number of units of sand that have come to rest
    units = sum(1 for x in range(501) for y in range(10) if is_sand(x, y))
    print(units)

if __name__ == '__main__':
    main()
",2
189,2022,15,1,runtime_error,,4861076,"Traceback (most recent call last):
  File ""/tmp/tmp0g__9g7z/tmp.py"", line 36, in <module>
    main()
  File ""/tmp/tmp0g__9g7z/tmp.py"", line 29, in main
    sensor_x, sensor_y, beacon_x, beacon_y = [int(x.split('=')[1]) for x in line.strip().split(', ')]
  File ""/tmp/tmp0g__9g7z/tmp.py"", line 29, in <listcomp>
    sensor_x, sensor_y, beacon_x, beacon_y = [int(x.split('=')[1]) for x in line.strip().split(', ')]
ValueError: invalid literal for int() with base 10: '2163633: closest beacon is at x'
","
from typing import List, Tuple

def generate_code(sensor_beacon_list: List[Tuple[int, int, int, int, int]]) -> str:
    code = """"""
def count_impossible_positions(sensor_beacon_list: List[Tuple[int, int, int, int, int]) -> int:
    def manhattan_distance(x1: int, y1: int, x2: int, y2: int) -> int:
        return abs(x1 - x2) + abs(y1 - y2)

    impossible_positions = []
    for beacon_x, beacon_y, sensor_x, sensor_y in sensor_beacon_list:
        min_distance = float('inf')
        for x in range(min(sensor_x, beacon_x), max(sensor_x, beacon_x) + 1):
            for y in range(min(sensor_y, beacon_y), max(sensor_y, beacon_y) + 1):
                distance = manhattan_distance(x, y, sensor_x, sensor_y)
                if distance < min_distance:
                    min_distance = distance
                    min_distance_x, min_distance_y = x, y
        impossible_positions.append((min_distance_x, min_distance_y))

    return len(set(impossible_positions))
    """"""
    return code

def main():
    sensor_beacon_list = []
    with open('input.txt', 'r') as file:
        for line in file.readlines():
            sensor_x, sensor_y, beacon_x, beacon_y = [int(x.split('=')[1]) for x in line.strip().split(', ')]
            sensor_beacon_list.append((beacon_x, beacon_y, sensor_x, sensor_y))

    code = generate_code(sensor_beacon_list)
    print(code)

if __name__ == '__main__':
    main()
",2
190,2022,16,1,timeout_error,,2080,TIMEOUT,"
import sys
from collections import defaultdict

def get_max_pressure(valves):
    G = defaultdict(list)
    for valve in valves:
        valve_name, flow_rate, connected_valves = valve.split("" "")
        flow_rate = int(flow_rate.split(""="")[-1])
        connected_valves = [int(v.strip(""Valve"").strip("";"")) for v in connected_valves.split(""tunnels lead to valves"")[-1].split("","") if v.strip()]
        G[int(valve_name.strip(""Valve""))] = (flow_rate, connected_valves)

    visited = set()
    max_pressure = 0
    max_valve = None
    for valve in G:
        if valve not in visited:
            visited.add(valve)
            queue = [(valve, flow_rate)]
            while queue:
                current_valve, current_pressure = queue.pop(0)
                next_valves = G[current_valve][1]
                for next_valve in next_valves:
                    if next_valve not in visited:
                        visited.add(next_valve)
                        queue.append((next_valve, current_pressure + G[next_valve][0]))
                        if current_pressure + G[next_valve][0] > max_pressure:
                            max_pressure = current_pressure + G[next_valve][0]
                            max_valve = next_valve

    return max_valve, max_pressure

if __name__ == ""__main__"":
    valves = [line.strip() for line in sys.stdin.readlines()]
    max_valve, max_pressure = get_max_pressure(valves)
    print(f""The valve with the maximum pressure is Valve {max_valve} with a pressure of {max_pressure} units."")
",2
191,2022,17,1,runtime_error,,3235,"Traceback (most recent call last):
  File ""/tmp/tmpesujjv_z/tmp.py"", line 20, in <module>
    num_rocks = int(file.readline().strip())
ValueError: invalid literal for int() with base 10: ''
","
from collections import deque

def rock_tower(jet_pattern, num_rocks):
    # Initialize the tower with the first rock at the top
    tower = deque([1])
    for i in range(num_rocks):
        # Check the current direction and move the rock accordingly
        if jet_pattern[i] == '<':
            if tower and tower[0] == i % 2 + 1:
                tower.appendleft(i % 2 + 1)
        elif jet_pattern[i] == '>':
            if tower and tower[-1] == (i + 1) % 2:
                tower.append(i % 2 + 1)
    return len(tower)

# Read the input from the file
with open('input.txt') as file:
    jet_pattern = file.readline().strip()
    num_rocks = int(file.readline().strip())

# Generate the output by calling the function with the input
print(rock_tower(jet_pattern, num_rocks))
",2
192,2022,18,1,runtime_error,,4310,"Traceback (most recent call last):
  File ""/tmp/tmpawhmjh7v/tmp.py"", line 27, in <module>
    cubes = read_input(sys.argv[1])
IndexError: list index out of range
","
import sys
import re
from itertools import product

def read_input(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    return [tuple(map(int, re.findall(r'\d+', line)) for line in lines) for line in lines]

def find_neighbors(cube):
    x, y, z = cube
    return [(x+dx, y+dy, z+dz) for dx, dy, dz in product([-1, 0, 1], repeat=3) if (dx, dy, dz) != (0, 0, 0)]

def is_valid_neighbor(cubes, neighbor):
    return neighbor in cubes

def surface_area(cubes):
    total_area = 0
    for cube in cubes:
        neighbors = find_neighbors(cube)
        num_exposed_sides = sum(1 for neighbor in neighbors if not is_valid_neighbor(cubes, neighbor))
        total_area += num_exposed_sides
    return total_area

if __name__ == ""__main__"":
    cubes = read_input(sys.argv[1])
    print(surface_area(cubes))
",2
193,2022,19,1,wrong_output,,1613,,"
import sys
from typing import List, Tuple

def max_geodes_24_minutes(blueprints: List[str]) -> Tuple[int, List[int]]:
    # Read the input file
    with open('input.txt', 'r') as file:
        blueprints = file.readlines()
    
    # Initialize variables
    max_geodes = 0
    best_blueprint = None
    best_combination = None
    
    # Parse the input blueprints
    for line in blueprints:
        resources = line.strip().split(': ')
        ore, clay, obsidian = 0, 0, 0
        robots = resources[1].split('.')[0].split(' ')
        for robot in robots:
            if 'ore' in robot:
                ore = int(robot.split()[0])
            elif 'clay' in robot:
                clay = int(robot.split()[0])
            elif 'obsidian' in robot:
                obsidian = int(robot.split()[0])
        # Calculate the number of geodes that can be opened in 24 minutes
        geodes = 24 // (ore + clay // 3 + obsidian // 8)
        # Update the maximum geodes and the best blueprint if this blueprint is the best
        if geodes > max_geodes:
            max_geodes = geodes
            best_blueprint = line.strip()
            best_combination = (ore, clay, obsidian)
    
    # Return the result
    print(f""The blueprint that maximizes the number of geodes in 24 minutes is: {best_blueprint}"")
    print(f""The maximum number of geodes that can be opened is: {max_geodes}"")
    print(f""The resources required are: {best_combination[0]} ore, {best_combination[1]} clay, and {best_combination[2]} obsidian"")
    return max_geodes, best_combination
",2
194,2022,20,1,wrong_output,"601
",18257,,"
import sys

def get_input():
    with open(""input.txt"", ""r"") as f:
        data = f.read().splitlines()
    return [int(x) for x in data]

def process_list(steps):
    pos = 0
    lst = [0]
    for i in range(1, 2018):
        lst.append(i)
    current_index = 0
    for step in steps:
        current_index = (current_index + step) % len(lst)
        lst.insert(current_index + 1, lst.pop(current_index))
    return lst

def find_result(lst):
    return lst[99] + lst[199] + lst[299]

def main():
    input_list = get_input()
    result_list = process_list(input_list)
    result = find_result(result_list)
    print(result)

if __name__ == ""__main__"":
    main()
",2
195,2022,21,1,timeout_error,,118565889858886,TIMEOUT,"
import re
import sys

# Read input from file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Dictionary to store monkey jobs
monkey_jobs = {}

# Dict to store monkey numbers
monkey_numbers = {}

# Function to perform math operations
def perform_operation(operation, x, y):
    if operation == '+':
        return x + y
    elif operation == '-':
        return x - y
    elif operation == '*':
        return x * y
    elif operation == '/':
        return x / y
    else:
        return None

# Loop through each line in input file
for line in lines:
    # Remove newline character and split by colon
    monkey, job = line.strip().split(':')
    
    # Check if the job is a number or math operation
    if re.match(r'^\d+$', job):
        monkey_numbers[monkey] = int(job)
    elif re.match(r'^[\+\-\*/]\s\w+\s\w+$', job):
        operation, monkey1, monkey2 = job.split()
        if monkey1 in monkey_numbers and monkey2 in monkey_numbers:
            monkey_numbers[monkey] = perform_operation(operation, monkey_numbers[monkey1], monkey_numbers[monkey2])
        else:
            monkey_jobs[monkey] = job
    else:
        monkey_jobs[monkey] = job

# Loop until root monkey is found
while 'root' in monkey_jobs:
    for monkey, job in monkey_jobs.items():
        if re.match(r'^\d+$', job):
            monkey_numbers[monkey] = int(job)
            del monkey_jobs[monkey]
        elif re.match(r'^[\+\-\*/]\s\w+\s\w+$', job):
            operation, monkey1, monkey2 = job.split()
            if monkey1 in monkey_numbers and monkey2 in monkey_numbers:
                monkey_numbers[monkey] = perform_operation(operation, monkey_numbers[monkey1], monkey_numbers[monkey2])
                del monkey_jobs[monkey]
        else:
            continue

print(monkey_numbers['root'])
",2
196,2022,22,1,timeout_error,,93226,TIMEOUT,"
from collections import deque

def move(row, col, facing, command, steps):
    if command == 'R':
        facing = (facing + 1) % 4
    elif command == 'L':
        facing = (facing - 1) % 4

    if facing == 0:
        col += steps
    elif facing == 1:
        row += steps
    elif facing == 2:
        col -= steps
    elif facing == 3:
        row -= steps

    return row % 50, col % 50, facing

def process_path(map, path):
    row, col, facing = 0, 0, 0
    for i in range(0, len(path), 2):
        if path[i].isdigit():
            steps = int(path[i])
            row, col, facing = move(row, col, facing, path[i+1], steps)

    return row, col, facing

def main():
    with open('input.txt', 'r') as f:
        map = [list(line.strip()) for line in f]
        path = input().strip()
        row, col, facing = process_path(map, path)
        password = 100 * row + 4 * col + facing
        print(password)

if __name__ == ""__main__"":
    main()
",2
197,2022,23,1,syntax_error,,4109,"  File ""/tmp/tmpaflhjcm_/tmp.py"", line 40
    elf_positions = {i: (i, j) for i in range(len(grid)) for j in range(len(grid[0]) if grid[i][j] == '#'}
                                                                                                         ^
SyntaxError: closing parenthesis '}' does not match opening parenthesis '('
","
from collections import defaultdict
from itertools import product

def find_neighbors(i, j, grid):
    """"""
    A helper function to find all neighboring cells of a given cell (i, j) in the grid.
    """"""
    for di, dj in product([-1, 0, 1], [-1, 0, 1]):
        if 0 <= i+di < len(grid) and 0 <= j+dj < len(grid[0]) and (di, dj) != (0, 0):
            yield i+di, j+dj

def move_elves(grid, elf_positions):
    """"""
    A function to move the Elves based on the given rules.
    """"""
    new_positions = defaultdict(int)
    for elf, pos in elf_positions.items():
        for neighbor in find_neighbors(*pos, grid):
            new_positions[neighbor] += 1
    for elf, pos in elf_positions.items():
        for neighbor in find_neighbors(*pos, grid):
            if new_positions[neighbor] == 1:
                elf_positions[elf] = neighbor
                break
    return elf_positions

def count_empty_tiles(grid, elf_positions):
    """"""
    A function to count the number of empty tiles in the smallest rectangle containing all Elves.
    """"""
    rows = [min(i for i, j in elf_positions.values()), max(i for i, j in elf_positions.values())]
    cols = [min(j for i, j in elf_positions.values()), max(j for i, j in elf_positions.values())]
    return len([1 for i in range(rows[0], rows[1]+1) for j in range(cols[0], cols[1]+1) if grid[i][j] == '.'])

def main():
    with open('input.txt') as f:
        grid = [list(line.strip()) for line in f]

    elf_positions = {i: (i, j) for i in range(len(grid)) for j in range(len(grid[0]) if grid[i][j] == '#'}

    for _ in range(10):
        elf_positions = move_elves(grid, elf_positions)

    print(count_empty_tiles(grid, elf_positions))

if __name__ == '__main__':
    main()
",2
198,2022,24,1,syntax_error,,279,"  File ""/tmp/tmp07srv15p/tmp.py"", line 9
    queue = deque([((0, 0, 0)])])
                             ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
from collections import deque

def find_path(valley):
    rows = len(valley)
    cols = len(valley[0])
    
    # Initialize the queue with starting position and the current time
    queue = deque([((0, 0, 0)])])
    visited = set()
    
    # Directions for moving up, down, left, and right
    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]
    
    # Function to check if a given position is valid
    def is_valid(x, y):
        return 0 <= x < rows and 0 <= y < cols and valley[x][y] != '#'
    
    # Function to check if a given position is already visited
    def is_visited(x, y, time):
        return (x, y, time) in visited
    
    # Function to add a new position to the queue
    def add_to_queue(x, y, time):
        if is_valid(x, y) and not is_visited(x, y, time):
            queue.append((x, y, time))
            visited.add((x, y, time))
    
    # Function to move a blizzard
    def move_blizzard(x, y, time):
        char = valley[x][y]
        if char == '>':
            add_to_queue(x, y + 1, time + 1)
            add_to_queue(x, y - 1, time + 1)
        elif char == '<':
            add_to_queue(x, y - 1, time + 1)
            add_to_queue(x, y + 1, time + 1)
        elif char == '^':
            add_to_queue(x - 1, y, time + 1)
            add_to_queue(x + 1, y, time + 1)
        elif char == 'v':
            add_to_queue(x + 1, y, time + 1)
            add_to_queue(x - 1, y, time + 1)
    
    # Main loop
    while queue:
        x, y, time = queue.popleft()
        if x == rows - 1:
            return time
        for dx, dy in directions:
            new_x, new_y = x + dx, y + dy
            if is_valid(new_x, new_y) and not is_visited(new_x, new_y, time):
                if valley[new_x][new_y] != '>':
                    add_to_queue(new_x, new_y, time)
                if valley[new_x][new_y] != '<':
                    add_to_queue(new_x, new_y, time)
                if valley[new_x][new_y] != '^':
                    add_to_queue(new_x, new_y, time)
                if valley[new_x][new_y] != 'v':
                    add_to_queue(new_x, new_y, time)
        move_blizzard(x, y, time + 1)
    
    # If the queue is empty, return -1
    return -1

# Read the input file
with open('input.txt', 'r') as f:
    valley = [list(line.strip()) for line in f]

# Call the function to find the path
result = find_path(valley)

# Print the result
print(result)
",2
199,2022,25,1,wrong_output,"1211---221-211-
",2=0=02-0----2-=02-10,,"
def snauf_to_decimal(snauf):
    decimal = 0
    for char in snauf:
        if char == '=':
            decimal *= 2
        elif char == '-':
            decimal += 1
        else:
            decimal *= 3
    return decimal


def decimal_to_snauf(decimal):
    snauf = ''
    while decimal > 0:
        if decimal % 3 == 1:
            snauf = '1' + snauf
        elif decimal % 3 == 2:
            snauf = '2' + snauf
        else:
            snauf = '-' + snauf
        decimal //= 3
    return snauf


# Read input file
with open('input.txt') as f:
    snauf_list = f.readlines()

# Initializing total fuel
total_fuel = 0

# Converting SNAFU to Decimal and summing up
for snauf in snauf_list:
    decimal = snauf_to_decimal(snauf.strip())
    total_fuel += decimal

# Converting total_fuel to SNAFU
total_fuel_snauf = decimal_to_snauf(total_fuel)

# Printing the result
print(total_fuel_snauf)
",2
