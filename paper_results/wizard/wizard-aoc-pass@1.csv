,year,day,part,status,output,expected_output,error,code,kpass
0,2015,1,1,no_error,"74
",74,,"
def get_floor(instructions):
    floor = 0
    for char in instructions:
        if char == ""("":
            floor += 1
        else:
            floor -= 1
    return floor

with open(""input.txt"", ""r"") as f:
    instructions = f.readline().strip()
    print(get_floor(instructions))
",0
1,2015,2,1,syntax_error,,1586300,"  File ""/tmp/tmpzgu_9hqn/tmp.py"", line 21
    gifts = [tuple(map(int, line.split('x')) for line in f.readlines()]
                                                                      ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import math

def surface_area(l, w, h):
    return 2*(l*w + w*h + h*l)

def extra_paper(x, y, z):
    sides = [x, y, z]
    return min(sides)

def required_paper(l, w, h):
    return surface_area(l, w, h) + extra_paper(l, w, h)

def total_paper(gifts):
    total = 0
    for gift in gifts:
        total += required_paper(*gift)
    return total

with open('input.txt', 'r') as f:
    gifts = [tuple(map(int, line.split('x')) for line in f.readlines()]
    print(total_paper(gifts))
",0
2,2015,3,1,no_error,"2565
",2565,,"
import re

def count_visited_houses(directions):
    x, y = 0, 0
    visited_houses = set()
    visited_houses.add((x, y))
    for direction in directions:
        if direction == '^':
            y += 1
        elif direction == 'v':
            y -= 1
        elif direction == '>':
            x += 1
        elif direction == '<':
            x -= 1
        visited_houses.add((x, y))
    return len(visited_houses)

with open('input.txt', 'r') as f:
    directions = re.findall('[><v^]', f.read())
    print(count_visited_houses(directions))
",0
3,2015,4,1,wrong_output,"3938038
",117946,,"
import hashlib

def mine_advent_coins(secret_key):
    """"""
    Given a secret key, find the lowest positive number that produces a MD5 hash with at least 5 zeroes in hexadecimal when combined with the key.
    Returns the number as an integer.
    """"""
    i = 0
    while True:
        md5_hash = hashlib.md5((secret_key + str(i)).encode('utf-8')).hexdigest()
        if md5_hash.startswith('000000'):
            return i
        i += 1

# Read the input secret key from the file
with open('input.txt', 'r') as f:
    secret_key = f.read().strip()

# Mine the AdventCoins
result = mine_advent_coins(secret_key)
print(result)
",0
4,2015,5,1,wrong_output,"Number of nice strings: 236
",236,,"
import re

#open file and read input.txt
file = open(""input.txt"", ""r"")
text = file.readlines()
nice_count = 0

#loop through each line in file
for line in text:
    line = line.strip()
    #check if line has at least 3 vowels
    if len(re.findall(r'[aeiou]', line)) >= 3:
        #check if there is a double letter
        if re.search(r'(.)\1', line):
            #check if the line contains any of the disallowed substrings
            if not re.search(r'ab|cd|pq|xy', line):
                #if it passes all checks, it is nice
                nice_count += 1

print(""Number of nice strings:"", nice_count)
",0
5,2015,6,1,no_error,"400410
",400410,,"
import re

# Open input.txt file for reading
with open(""input.txt"", ""r"") as input_file:
    # read all lines and store it in a list
    lines = input_file.readlines()

# Initialize a 2D array with all elements as False (off)
lights = [[False for x in range(1000)] for y in range(1000)]

# Loop through each line in the input file
for line in lines:
    # Use regex to match the pattern in the line
    match = re.match(r""(.*) (\d+),(\d+) through (\d+),(\d+)"", line.strip())
    action, x1, y1, x2, y2 = match.groups()
    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)
    # Perform the action on the lights
    if action == ""turn on"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = True
    elif action == ""turn off"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = False
    elif action == ""toggle"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = not lights[i][j]

# Count the number of turned on lights
count = 0
for i in range(1000):
    for j in range(1000):
        if lights[i][j]:
            count += 1

# Print the count of turned on lights
print(count)
",0
6,2015,7,1,runtime_error,,46065,"Traceback (most recent call last):
  File ""/tmp/tmpl_wacc3w/tmp.py"", line 42, in <module>
    wires[output_wire] = right_shift(wires[input_wire], value)
KeyError: 'bn'
","
import re

def bitwise_and(x, y):
    return x & y

def bitwise_or(x, y):
    return x | y

def bitwise_not(x):
    return ~x

def left_shift(x, y):
    return x << y

def right_shift(x, y):
    return x >> y

wires = {}

with open('input.txt') as f:
    lines = f.readlines()

for line in lines:
    line = line.strip()
    expression, output_wire = line.split(' -> ')
    if 'AND' in line:
        input_wires = re.findall(r'[a-z]+', expression)
        x, y = input_wires[0], input_wires[1]
        wires[output_wire] = bitwise_and(wires[x], wires[y])
    elif 'OR' in line:
        input_wires = re.findall(r'[a-z]+', expression)
        x, y = input_wires[0], input_wires[1]
        wires[output_wire] = bitwise_or(wires[x], wires[y])
    elif 'LSHIFT' in line:
        input_wire, value = re.findall(r'[a-z]+|\d+', expression)
        value = int(value)
        wires[output_wire] = left_shift(wires[input_wire], value)
    elif 'RSHIFT' in line:
        input_wire, value = re.findall(r'[a-z]+|\d+', expression)
        value = int(value)
        wires[output_wire] = right_shift(wires[input_wire], value)
    elif 'NOT' in line:
        input_wire = re.findall(r'[a-z]+', expression)[0]
        wires[output_wire] = bitwise_not(wires[input_wire])
    else:
        value = int(expression)
        wires[output_wire] = value

print(wires['a'])
",0
7,2015,8,1,wrong_output,"1631
",1371,,"
import re

with open('input.txt', 'r') as file:
    data = file.readlines()
    total_code_length = 0
    total_string_length = 0

    for line in data:
        # remove whitespace and newline character
        line = line.strip()
        # count number of characters in code
        total_code_length += len(line) + 2
        # count number of characters in memory
        line = line.replace('\\\\', 'A')  # replace single backslash with temporary character
        line = line.replace('\\""', '""')  # replace escaped double-quote with actual double-quote
        line = re.sub(r""\\x[0-9a-fA-F]{2}"", 'A', line)  # replace hexadecimal characters with temporary character
        total_string_length += len(line)
        # count number of escaped characters
        total_string_length -= line.count('A')

    print(total_code_length - total_string_length)
",0
8,2015,9,1,runtime_error,,251,"Traceback (most recent call last):
  File ""/tmp/tmpt4royxqs/tmp.py"", line 15, in <module>
    city1, city2, distance = line.split(' ')
ValueError: too many values to unpack (expected 3)
","
import sys
from itertools import permutations

# Read input file
with open('input.txt', 'r') as file:
    data = file.readlines()

# Create dictionary to store distances
distances = {}

# Parse input and store distances in dictionary
for line in data:
    line = line.strip()
    city1, city2, distance = line.split(' ')
    distance = int(distance[:-1])
    distances.setdefault(city1, {})[city2] = distance
    distances.setdefault(city2, {})[city1] = distance

# Generate permutations of cities
cities = list(distances.keys())
perms = permutations(cities)

# Calculate distance for each permutation
distances_list = [sum(distances[start][end] for start, end in zip(perm[:-1], perm[1:]) + (perm[0],)) for perm in perms]

# Get the shortest distance
shortest_distance = min(distances_list)

# Print result
print(""The shortest distance is:"", shortest_distance)
",0
9,2015,10,1,no_error,"329356
",329356,,"
def look_and_say(sequence):
    result = ''
    count = 1
    digit = sequence[0]
    for i in range(1, len(sequence)):
        if sequence[i] == digit:
            count += 1
        else:
            result += str(count) + digit
            count = 1
            digit = sequence[i]
    result += str(count) + digit
    return result

with open('input.txt', 'r') as f:
    input_seq = f.read().strip()

for _ in range(40):
    input_seq = look_and_say(input_seq)

print(len(input_seq))
",0
10,2015,11,1,timeout_error,,vzbxxyzz,TIMEOUT,"
import string

def is_valid_password(password):
    if 'i' in password or 'o' in password or 'l' in password:
        return False

    for i in range(len(password) - 2):
        if password[i:i+3] in string.ascii_lowercase:
            return True
    return False

def has_two_non_overlapping_pairs(password):
    for i in range(len(password) - 1):
        if password[i:i+2] in password[i+2:]:
            return True
    return False

def increment_password(password):
    index = -1
    while password[index] == 'z':
        password = password[:index] + 'a' + password[index+1:]
        index -= 1
    password = password[:index] + chr(ord(password[index]) + 1) + password[index+1:]
    return password

def generate_password(password):
    while True:
        if is_valid_password(password) and has_two_non_overlapping_pairs(password):
            return password
        password = increment_password(password)

# Get the current password from the input file
with open('input.txt', 'r') as f:
    current_password = f.read().strip()

next_password = generate_password(current_password)
print(next_password)
",0
11,2015,12,1,no_error,"111754
",111754,,"
import json

def sum_numbers(doc):
    if isinstance(doc, int):
        return doc
    elif isinstance(doc, list):
        return sum(sum_numbers(item) for item in doc)
    elif isinstance(doc, dict):
        return sum(sum_numbers(item) for item in doc.values())
    else:
        return 0

with open('input.txt', 'r') as f:
    data = json.load(f)
    print(sum_numbers(data))
",0
12,2015,13,1,runtime_error,,733,"Traceback (most recent call last):
  File ""/tmp/tmpwyfcblh4/tmp.py"", line 21, in <module>
    person1, _, neighbor, gain_loss, units, _ = line.strip().split()
ValueError: too many values to unpack (expected 6)
","
import itertools

# Define a function to calculate the total change in happiness for a given seating arrangement
def total_change_happiness(seating_arrangement, happiness_dict):
    total = 0
    for i in range(len(seating_arrangement)):
        person = seating_arrangement[i]
        left_neighbor = seating_arrangement[(i-1) % len(seating_arrangement)]
        right_neighbor = seating_arrangement[(i+1) % len(seating_arrangement)]
        total += happiness_dict[person][left_neighbor] + happiness_dict[person][right_neighbor]
    return total

# Read input from the file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Store the data in a dictionary
happiness_dict = {}
for line in lines:
    person1, _, neighbor, gain_loss, units, _ = line.strip().split()
    person2 = neighbor.rstrip(',')
    units = int(units)
    if gain_loss == 'gain':
        happiness_dict[person1] = happiness_dict.get(person1, {})
        happiness_dict[person1][person2] = units
    else:
        happiness_dict[person1] = happiness_dict.get(person1, {})
        happiness_dict[person1][person2] = -units

# Get all possible seating arrangements
people = list(happiness_dict.keys())
seating_arrangements = list(itertools.permutations(people))

# Calculate the total change in happiness for each seating arrangement and find the maximum
max_happiness = 0
for seating in seating_arrangements:
    happiness = total_change_happiness(seating, happiness_dict)
    max_happiness = max(max_happiness, happiness)

# Print the result
print(""The total change in happiness for the optimal seating arrangement is:"", max_happiness)
",0
13,2015,14,1,wrong_output,"2093345
",2655,,"
import re
import time

def race(speeds, rests, duration):
    distance = 0
    max_distance = 0
    for i in range(duration):
        for j in range(len(speeds)):
            if i % (speeds[j] + rests[j]) < speeds[j]:
                distance += speeds[j]
            else:
                distance += 0
            if distance > max_distance:
                max_distance = distance
    return max_distance

def parse_input(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
        speeds = []
        rests = []
        for line in lines:
            match = re.match(r'(\w+) can fly (\d+) km/s for (\d+) seconds, but then must rest for (\d+) seconds\.', line.strip())
            speeds.append(int(match.group(2)) * int(match.group(3)) + int(match.group(4)))
            rests.append(int(match.group(4)))
    return speeds, rests

speeds, rests = parse_input('input.txt')
print(race(speeds, rests, 2503))
",0
14,2015,15,1,runtime_error,,21367368,"Traceback (most recent call last):
  File ""/tmp/tmpi3zo4tyf/tmp.py"", line 19, in <module>
    print(best_cookie(ingredients))
  File ""/tmp/tmpi3zo4tyf/tmp.py"", line 8, in best_cookie
    capacity = sum(i[0] for i in comb)
TypeError: unsupported operand type(s) for +: 'int' and 'str'
","
import itertools
import math

def best_cookie(ingredients):
    max_score = 0
    for comb in itertools.combinations_with_replacement(ingredients, 100):
        capacity = sum(i[0] for i in comb)
        durability = sum(i[1] for i in comb)
        flavor = sum(i[2] for i in comb)
        texture = sum(i[3] for i in comb)
        calories = sum(i[4] for i in comb)
        score = math.prod([max(0, capacity), max(0, durability), max(0, flavor), max(0, texture)])
        if score > max_score:
            max_score = score
    return max_score

ingredients = [('Butterscotch', -1, -2, 6, 3, 8), ('Cinnamon', 2, 3, -2, -1)]
print(best_cookie(ingredients))
",0
15,2015,16,1,runtime_error,,40,"Traceback (most recent call last):
  File ""/tmp/tmpflzko9t7/tmp.py"", line 13, in <module>
    sue_data = json.loads(data)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/json/__init__.py"", line 357, in loads
    return _default_decoder.decode(s)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/json/decoder.py"", line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/json/decoder.py"", line 355, in raw_decode
    raise JSONDecodeError(""Expecting value"", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)
","
# importing json for input file reading
import json

# importing re for regular expression usage
import re

# reading input from input.txt file
with open('input.txt', 'r') as file:
    data = file.read()

# converting input data to a dictionary
sue_data = json.loads(data)

# initializing a dictionary with all the possible properties and their values
properties_dict = {'children': 0, 'cats': 0, 'samoyeds': 0, 'pomeranians': 0, 'akitas': 0, 'vizslas': 0, 'goldfish': 0, 'trees': 0, 'cars': 0, 'perfumes': 0}

# initializing a list to store the numbers of Aunts who match the criteria
matching_aunts = []

# iterating through each Aunt Sue in the input file
for aunt, aunt_properties in sue_data.items():
    # initializing a count to check the number of matching properties
    count = 0
    for prop, value in aunt_properties.items():
        # checking if the property is in the properties_dict
        if prop in properties_dict:
            # checking if the value matches the given input
            if properties_dict[prop] == 0 or properties_dict[prop] == value:
                count += 1
    # if all the properties match, adding the number to the matching_aunts list
    if count == len(properties_dict):
        matching_aunts.append(int(re.search('\d+', aunt).group()))

# printing the matching Aunt Sue number
print(matching_aunts)


with open('input.txt', 'r') as file:
    data = file.read()

sue_data = json.loads(data)

properties_dict = {'children': 3, 'cats': 7, 'samoyeds': 2, 'pomeranians': 3, 'akitas': 0, 'vizslas': 0, 'goldfish': 5, 'trees': 3, 'cars': 2, 'perfumes': 1}

matching_aunts = []

for aunt, aunt_properties in sue_data.items():
    count = 0
    for prop, value in aunt_properties.items():
        if prop in properties_dict and (properties_dict[prop] == 0 or properties_dict[prop] == value):
            count += 1
    if count == len(properties_dict):
        matching_aunts.append(int(re.search('\d+', aunt).group()))

print(matching_aunts)
",0
16,2015,17,1,wrong_output,"0
",1638,,"
from itertools import combinations

def count_combinations(capacities, total_capacity):
    count = 0
    for r in range(1, len(capacities) + 1):
        for comb in combinations(capacities, r):
            if sum(comb) == total_capacity:
                count += 1
    return count

capacities = [20, 15, 10, 5, 5]
total_capacity = 150
print(count_combinations(capacities, total_capacity))
",0
17,2015,18,1,syntax_error,,814,"  File ""/tmp/tmpxm2oy64z/tmp.py"", line 14
    neighbors = [lights[x,y] for x in range(max(0,i-1),min(i+2,lights.shape[0])] for y in range(max(0,j-1),min(j+2,lights.shape[1])) if (x,y) != (i,j)]
                                                                               ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import numpy as np

def read_input(file_name):
    with open(file_name, 'r') as f:
        data = f.readlines()
    return np.array([list(line.strip()) for line in data])

def animate_lights(lights, steps):
    for _ in range(steps):
        next_state = np.zeros_like(lights)
        for i in range(lights.shape[0]):
            for j in range(lights.shape[1]):
                neighbors = [lights[x,y] for x in range(max(0,i-1),min(i+2,lights.shape[0])] for y in range(max(0,j-1),min(j+2,lights.shape[1])) if (x,y) != (i,j)]
                if lights[i,j] == 1 and sum(neighbors) in [2,3]:
                    next_state[i,j] = 1
                elif lights[i,j] == 0 and sum(neighbors) == 3:
                    next_state[i,j] = 1
        lights = next_state
    return np.sum(lights)

def main():
    initial_state = read_input('input.txt')
    initial_state = np.pad(initial_state, 100, mode='constant')
    steps = 100
    lights_on = animate_lights(initial_state, steps)
    print(f""After {steps} steps, there are {lights_on} lights on."")

if __name__ == ""__main__"":
    main()
",0
18,2015,19,1,runtime_error,,518,"Traceback (most recent call last):
  File ""/tmp/tmp1qda0sxt/tmp.py"", line 23, in <module>
    medicine = f.readline().strip()
ValueError: I/O operation on closed file.
","
import re

def replace(molecule, replacements):
    new_molecules = set()
    for old, new in replacements:
        for match in re.finditer(old, molecule):
            new_molecules.add(molecule[:match.start()] + new + molecule[match.end():])
    return new_molecules

def count_distinct_molecules(molecule, replacements, steps):
    distinct_molecules = set([molecule])
    for _ in range(steps):
        new_molecules = set()
        for mol in distinct_molecules:
            new_molecules.update(replace(molecule, replacements))
        distinct_molecules.update(new_molecules)
    return len(distinct_molecules)

if __name__ == '__main__':
    with open('input.txt') as f:
        replacements = [line.strip().split(' => ') for line in f if line.strip() and not line.startswith('Med')]
    medicine = f.readline().strip()
    steps = int(f.readline().strip().split()[-1])
    print(count_distinct_molecules(medicine, replacements, steps))
",0
19,2015,20,1,wrong_output,"2573
",776160,,"
import math

with open('input.txt') as f:
    target = int(f.read().strip())

# Calculate the sum of presents for each house
def sum_presents(n):
    return sum(10*i for i in range(1, n+1))

# Find the lowest house number with the desired sum of presents
def lowest_house(target):
    for i in range(1, target//100):
        # Calculate the sum of presents for houses up to this number
        total = sum_presents(i)
        # If the sum is greater than or equal to the target, return this house number
        if total >= target:
            return i

# Print the result
print(lowest_house(target))
",0
20,2015,21,1,wrong_output,"33
",78,,"
import itertools

def find_least_gold_to_win(boss_hp, boss_damage, boss_armor):
    weapons = [(8, 4, 0), (10, 5, 0), (25, 6, 0), (40, 7, 0), (74, 8, 0)]
    armors = [(0, 0), (13, 1), (31, 2), (53, 3), (75, 4), (102, 5)]
    rings = [(0, 0), (25, 1, 0), (50, 2, 0), (100, 3, 0), (20, 0, 1), (40, 0, 2), (80, 0, 3)]
    
    all_combos = []
    for weapon in weapons:
        for armor in armors:
            for left_ring, right_ring in itertools.combinations(rings, 2):
                all_combos.append((weapon, armor, left_ring, right_ring))
    
    min_gold = float('inf')
    for combo in all_combos:
        player_hp = 100
        player_damage = sum(c[0] for c in combo)
        player_armor = sum(c[1] for c in combo)
        boss_damage = boss_damage - player_armor
        player_damage = player_damage - boss_armor
        while player_hp > 0 and boss_hp > 0:
            player_hp -= max(1, boss_damage - player_armor)
            boss_hp -= max(1, player_damage)
        if player_hp > 0:
            min_gold = min(min_gold, sum(sum(c) for c in combo))
    
    return min_gold

# Example usage:
boss_hp = 12
boss_damage = 7
boss_armor = 2
print(find_least_gold_to_win(boss_hp, boss_damage, boss_armor))
",0
21,2015,22,1,runtime_error,,953,"Traceback (most recent call last):
  File ""/tmp/tmpouk_5_r9/tmp.py"", line 108, in <module>
    main()
  File ""/tmp/tmpouk_5_r9/tmp.py"", line 101, in main
    mana_spent, _, _ = combat(player_hp, boss_hp, boss_damage, player_mana)
TypeError: combat() missing 1 required positional argument: 'mana_spent'
","
import re

def combat(player_hp, boss_hp, boss_damage, player_mana, mana_spent, active_effects=None):
    if active_effects is None:
        active_effects = {'shield': 0, 'poison': 0, 'recharge': 0}

    if player_hp <= 0 or mana_spent >= best_spent:
        return float('inf'), None, None
    if boss_hp <= 0:
        return mana_spent, None

    if mana_spent >= best_spent:
        return float('inf'), None, None

    best_spent = min(best_spent, mana_spent)
    best_move = None

    # Magic Missile
    if player_mana >= 53:
        new_hp, new_mana = player_hp, player_mana - 53
        new_boss_hp, new_effects = boss_hp - 4, active_effects.copy()
        mana_spent_mm = combat(new_hp, new_boss_hp, boss_damage, new_mana, mana_spent + 53, new_effects)
        if mana_spent_mm < best_spent:
            best_spent, best_move = mana_spent_mm, ('Magic Missile', boss_damage, new_effects)

    # Drain
    if player_mana >= 73:
        new_hp, new_mana = player_hp + 2, player_mana - 73
        new_boss_hp = max(boss_hp - 2, 1)
        new_effects = active_effects.copy()
        mana_spent_drain = combat(new_hp, new_boss_hp, boss_damage, new_mana, mana_spent + 73, new_effects)
        if mana_spent_drain < best_spent:
            best_spent, best_move = mana_spent_drain, ('Drain', boss_damage, new_effects)

    # Shield
    if player_mana >= 113 and active_effects['shield'] == 0:
        new_hp, new_mana = player_hp, player_mana - 113
        new_boss_hp, new_effects = boss_hp, active_effects.copy()
        new_effects['shield'] = 6
        mana_spent_shield = combat(new_hp, new_boss_hp, boss_damage, new_mana, mana_spent + 113, new_effects)
        if mana_spent_shield < best_spent:
            best_spent, best_move = mana_spent_shield, ('Shield', boss_damage, new_effects)

    # Poison
    if player_mana >= 173 and active_effects['poison'] == 0:
        new_hp, new_mana = player_hp, player_mana - 173
        new_boss_hp, new_effects = boss_hp, active_effects.copy()
        new_effects['poison'] = 6
        mana_spent_poison = combat(new_hp, new_boss_hp, boss_damage, new_mana, mana_spent + 173, new_effects)
        if mana_spent_poison < best_spent:
            best_spent, best_move = mana_spent_poison, ('Poison', boss_damage, new_effects)

    # Recharge
    if player_mana >= 229 and active_effects['recharge'] == 0:
        new_hp, new_mana = player_hp, player_mana - 229
        new_boss_hp, new_effects = boss_hp, active_effects.copy()
        new_effects['recharge'] = 5
        mana_spent_recharge = combat(new_hp, new_boss_hp, boss_damage, new_mana + 101, mana_spent + 229, new_effects)
        if mana_spent_recharge < best_spent:
            best_spent, best_move = mana_spent_recharge, ('Recharge', boss_damage, new_effects)

    if best_move:
        if best_move[0] == 'Magic Missile':
            boss_hp -= 4
        elif best_move[0] == 'Drain':
            player_hp += 2
            boss_hp = max(boss_hp - 2, 1)
        elif best_move[0] == 'Shield':
            active_effects['shield'] = 6
        elif best_move[0] == 'Poison':
            active_effects['poison'] = 6
        elif best_move[0] == 'Recharge':
            active_effects['recharge'] = 5

    # Update effects
    if active_effects['shield']:
        player_armor = 7
        active_effects['shield'] -= 1
    else:
        player_armor = 0

    if active_effects['poison']:
        boss_hp -= 3
        active_effects['poison'] -= 1

    if active_effects['recharge']:
        player_mana += 101
        active_effects['recharge'] -= 1

    return combat(player_hp - max(boss_damage - player_armor, 1), boss_hp, boss_damage, player_mana, mana_spent, active_effects)

def main():
    with open('input.txt', 'r') as file:
        boss_stats = re.findall(r'\d+', file.read())
    boss_hp, boss_damage = int(boss_stats[0]), int(boss_stats[1])

    player_hp, player_mana = 50, 500
    best_spent = float('inf')
    for i in range(1, 100000):
        mana_spent, _, _ = combat(player_hp, boss_hp, boss_damage, player_mana)
        if mana_spent < best_spent:
            best_spent = mana_spent

    print(best_spent)

if __name__ == '__main__':
    main()
",0
22,2015,23,1,runtime_error,,307,"Traceback (most recent call last):
  File ""/tmp/tmpc8dpn2kh/tmp.py"", line 57, in <module>
    i = jio(instruction[1], int(instruction[2]))
  File ""/tmp/tmpc8dpn2kh/tmp.py"", line 29, in jio
    if registers[register] == 1:
KeyError: 'a,'
","
def hlf(register):
    registers[register] //= 2
    return registers

def tpl(register):
    registers[register] *= 3
    return registers

def inc(register):
    registers[register] += 1
    return registers

def jmp(offset):
    global i
    i += offset
    return i

def jie(register, offset):
    global i
    if registers[register] % 2 == 0:
        i += offset
    else:
        i += 1
    return i

def jio(register, offset):
    global i
    if registers[register] == 1:
        i += offset
    else:
        i += 1
    return i

registers = {'a': 0, 'b': 0}
i = 0

with open('input.txt', 'r') as file:
    instructions = file.readlines()

while i < len(instructions):
    instruction = instructions[i].strip().split()
    if instruction[0] == 'hlf':
        registers = hlf(instruction[1])
        i += 1
    elif instruction[0] == 'tpl':
        registers = tpl(instruction[1])
        i += 1
    elif instruction[0] == 'inc':
        registers = inc(instruction[1])
        i += 1
    elif instruction[0] == 'jmp':
        i = jmp(int(instruction[1]))
    elif instruction[0] == 'jie':
        i = jie(instruction[1], int(instruction[2]))
    elif instruction[0] == 'jio':
        i = jio(instruction[1], int(instruction[2]))
    else:
        i += 1

print(registers['b'])
",0
23,2015,24,1,wrong_output,"None
",10439961859,,"
from itertools import combinations
from functools import reduce
from operator import mul

def quantum_entanglement(packages):
    return reduce(mul, packages)

def split_packages(packages):
    total_weight = sum(packages)
    for i in range(1, len(packages) - 1):
        if total_weight % 3 == 0 and total_weight // 3 == sum(packages[:i]):
            return packages[:i], packages[i:]
    return None, None

def find_best_configuration(packages):
    packages.sort(reverse=True)
    first, second = split_packages(packages)
    if not first:
        return None
    second.sort(reverse=True)
    third = packages[len(first):]
    min_qe = float('inf')
    min_first = None
    for i in range(1, len(first) + 1):
        for combo in combinations(first, i):
            if sum(combo) == sum(second) == sum(third):
                qe = quantum_entanglement(combo)
                if qe < min_qe:
                    min_qe = qe
                    min_first = combo
    return min_qe

# Read input file
with open('input.txt', 'r') as f:
    packages = [int(x.strip()) for x in f.readlines()]

# Find the ideal configuration
qe = find_best_configuration(packages)

# Print the quantum entanglement of the first group of packages
print(qe)
",0
24,2015,25,1,timeout_error,,9132360,TIMEOUT,"
import math

def generate_code(row, col):
    if row == 1:
        return 20151125
    else:
        prev_row = row - 1
        prev_col = col - 1
        prev_code = generate_code(prev_row, prev_col)
        return (prev_code * 252533) % 3354393

def main():
    input_str = input(""Enter row and column for code: "")
    row, col = map(int, input_str.split("",""))
    code = generate_code(row, col)
    print(""The code is: "", code)

if __name__ == ""__main__"":
    main()
",0
25,2016,1,1,wrong_output,"913
",287,,"
import re

with open('input.txt', 'r') as file:
    data = file.read().strip()

instructions = re.findall(r'[RL]\d+', data)

def move(direction, distance, x, y):
    if direction == 'R':
        return x + distance, y
    elif direction == 'L':
        return x, y + distance

x, y = 0, 0
for instruction in instructions:
    direction, distance = instruction[0], int(instruction[1:])
    x, y = move(direction, distance, x, y)

print(abs(x) + abs(y))
",0
26,2016,2,1,no_error,"12578
",12578,,"
def get_position(pos, direction):
    if direction == 'U':
        return (pos[0] - 1, pos[1]) if pos[0] > 0 else pos
    elif direction == 'D':
        return (pos[0] + 1, pos[1]) if pos[0] < 2 else pos
    elif direction == 'L':
        return (pos[0], pos[1] - 1) if pos[1] > 0 else pos
    elif direction == 'R':
        return (pos[0], pos[1] + 1) if pos[1] < 2 else pos
    else:
        return pos

def get_code(instructions):
    pos = (1, 1)
    code = []
    for line in instructions:
        for d in line:
            pos = get_position(pos, d)
        code.append(str(pos[0] * 3 + pos[1] + 1))
    return ''.join(code)

with open('input.txt', 'r') as f:
    instructions = f.readlines()
    print(get_code(instructions))
",0
27,2016,3,1,no_error,"993
",993,,"
import os

# Opening the file containing the input data
with open(""input.txt"", ""r"") as f:
    data = f.readlines()

# Initializing a counter for valid triangles
valid_triangles = 0

# Looping through each line in the file
for line in data:
    # Splitting the line into a list of integers
    sides = list(map(int, line.split()))

    # Sorting the sides in ascending order
    sides.sort()

    # Checking if the sum of the first two sides is greater than the third side
    if sides[0] + sides[1] > sides[2]:
        valid_triangles += 1

# Printing the count of valid triangles
print(valid_triangles)
",0
28,2016,4,1,syntax_error,,245102,"  File ""/tmp/tmpieqm204z/tmp.py"", line 14
    required_checksum = ''.join([letter[0] for letter in sorted_letters[:5])
    ^
SyntaxError: invalid syntax
","
import re

def is_real_room(room):
    encrypted_name, sector_id, checksum = re.findall(r'([a-z-]+)(\d+)\[(\w+)\]', room)[0]
    encrypted_name = encrypted_name.replace('-', '')
    letters_freq = {}
    for letter in encrypted_name:
        if letter in letters_freq:
            letters_freq[letter] += 1
        else:
            letters_freq[letter] = 1
    sorted_letters = sorted(sorted(letters_freq.items(), key=lambda x: (-x[1], x[0]))
    required_checksum = ''.join([letter[0] for letter in sorted_letters[:5])
    return checksum == required_checksum

def sum_real_rooms():
    with open('input.txt') as f:
        real_rooms = [re.findall(r'(\w+-\d+)\[(\w+)\]', line) for line in f.readlines() if is_real_room(line)]
    return sum(int(room_id) for room_id, _ in real_rooms)

print(sum_real_rooms())
",0
29,2016,5,1,timeout_error,,1a3099aa,TIMEOUT,"
import hashlib

def find_password(door_id):
    password = ''
    index = 0
    while len(password) < 8:
        hash_result = hashlib.md5((door_id + str(index)).encode('utf-8')).hexdigest()
        if hash_result.startswith('000000'):
            password += hash_result[5]
        index += 1
    return password

if __name__ == '__main__':
    with open('input.txt', 'r') as f:
        door_id = f.read().strip()
        print(find_password(door_id))
",0
30,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"
import operator

def error_correction(file_name):
    with open(file_name, 'r') as file:
        messages = [line.strip() for line in file.readlines()]

    message_length = len(messages[0])
    corrected_message = ''

    for i in range(message_length):
        char_count = {}
        for message in messages:
            char = message[i]
            char_count[char] = char_count.get(char, 0) + 1

        corrected_message += max(char_count.items(), key=operator.itemgetter(1))[0]

    return corrected_message

print(error_correction('input.txt'))
",0
31,2016,7,1,wrong_output,"102
",115,,"
import re

def support_tls(ip):
    # Function to check if an IP supports TLS
    abba_pattern = re.compile(r'(?<!\[.)([a-z])(?!\1)([a-z])\2\1(?!\2)[a-z]')
    hypernet_pattern = re.compile(r'\[([a-z]+)\]')
    
    abba_match = abba_pattern.search(ip)
    if abba_match:
        hypernet_matches = hypernet_pattern.findall(ip)
        for match in hypernet_matches:
            if abba_match.group() in match:
                return False
        return True
    return False

def count_tls_ips(filename):
    # Function to count the number of IPs that support TLS
    with open(filename, 'r') as f:
        ips = f.readlines()
    return sum(1 for ip in ips if support_tls(ip.strip()))

# Count the number of TLS supporting IPs in input.txt
print(count_tls_ips('input.txt'))
",0
32,2016,8,1,wrong_output,"Lit pixels:  86
#.#...###...#.....###....#####.#...####..##.....#.
.###.......##..........#...............#.#.##.##..
..........#....#..#.#..........##.##..#.#....##...
....#.#........#.#...#.......##.##.....#......#...
................#.#####...#......#...........#.#..
....#.#.##.#.###...##.#.#.....##.#..##.#....#.....
",115,,"
import re

def process_instruction(instruction, screen):
    if instruction.startswith(""rect""):
        dimensions = [int(x) for x in re.findall(r'\d+', instruction)]
        for y in range(dimensions[1]):
            for x in range(dimensions[0]):
                screen[y][x] = ""#""
    elif instruction.startswith(""rotate column""):
        column_num = int(re.findall(r'(?<=column x=)\d+', instruction)[0])
        shift_amount = int(re.findall(r'(?<=by )\d+', instruction)[0])
        column = [row[column_num] for row in screen]
        column = column[shift_amount:] + column[:shift_amount]
        for i, row in enumerate(screen):
            row[column_num] = column[i]
    else:
        row_num = int(re.findall(r'(?<=row y=)\d+', instruction)[0])
        shift_amount = int(re.findall(r'(?<=by )\d+', instruction)[0])
        row = screen[row_num]
        screen[row_num] = row[shift_amount:] + row[:shift_amount]


def count_lit_pixels(screen):
    return sum(row.count(""#"") for row in screen)

def create_screen(width, height):
    return [['.' for _ in range(width)] for _ in range(height)]

def print_screen(screen):
    for row in screen:
        print(''.join(row))

def main():
    with open('input.txt', 'r') as file:
        instructions = file.readlines()
    screen = create_screen(50, 6)
    for instruction in instructions:
        process_instruction(instruction, screen)
    print(""Lit pixels: "", count_lit_pixels(screen))
    print_screen(screen)

if __name__ == ""__main__"":
    main()
",0
33,2016,9,1,wrong_output,"102239
102252
",102239,,"
import re

def decompress(data):
    decompressed_length = 0
    marker_pattern = re.compile(r'\((\d+)x(\d+)\)')
    while True:
        match = marker_pattern.search(data)
        if not match:
            decompressed_length += len(data)
            break
        else:
            start, end = match.span()
            char_count, repeat_count = map(int, match.groups())
            decompressed_length += start
            decompressed_length += char_count * repeat_count
            data = data[end + char_count:]
    return decompressed_length

with open('input.txt', 'r') as file:
    data = file.read()
    print(decompress(data))


def decompress(data):
    decompressed_length = 0
    marker_pattern = re.compile(r'\((\d+)x(\d+)\)')
    while True:
        match = re.search(r'\((\d+)x(\d+)', data)
        if not match:
            decompressed_length += len(data)
            break
        else:
            start, end = match.span()
            char_count, repeat_count = map(int, match.groups())
            decompressed_length += start
            decompressed_length += char_count * repeat_count
            data = data[end + char_count:]
    return decompressed_length

with open('input.txt', 'r') as file:
    data = file.read()
    print(decompress(data))
",0
34,2016,10,1,runtime_error,,118,"Traceback (most recent call last):
  File ""/tmp/tmpn4bm3pv9/tmp.py"", line 38, in <module>
    print(find_bot(instructions, 61, 17))
  File ""/tmp/tmpn4bm3pv9/tmp.py"", line 9, in find_bot
    bot_num, low_dest, high_dest = re.findall(r'bot (\d+) gives low to ([a-z]+) (\d+) and high to ([a-z]+) (\d+)', line)[0]
ValueError: too many values to unpack (expected 3)
","
import re

def find_bot(instructions, target1, target2):
    bots = {}
    outputs = {}
    for line in instructions:
        if line.startswith(""bot""):
            bot_num, low_dest, high_dest = re.findall(r'bot (\d+) gives low to ([a-z]+) (\d+) and high to ([a-z]+) (\d+)', line)[0]
            low_dest_type, low_dest_num = low_dest[0], low_dest[1:]
            high_dest_type, high_dest_num = high_dest[0], high_dest[1:]
            bots[int(bot_num)] = {""chips"": [], ""low_dest"": (low_dest_type, int(low_dest_num)), ""high_dest"": (high_dest_type, int(high_dest_num))}
        else:
            chip_val, bot_num = re.findall(r'value (\d+) goes to bot (\d+)', line)[0]
            bots.setdefault(int(bot_num), {""chips"": [], ""low_dest"": None, ""high_dest"": None})[""chips""].append(int(chip_val))

    while True:
        for bot_num, bot_info in bots.items():
            if len(bot_info[""chips""]) == 2:
                low_chip, high_chip = sorted(bot_info[""chips""])
                if low_chip == target1 and high_chip == target2:
                    return bot_num
                if bot_info[""low_dest""][0] == ""bot"":
                    bots.setdefault(bot_info[""low_dest""][1], {""chips"": [], ""low_dest"": None, ""high_dest"": None})[""chips""].append(low_chip)
                else:
                    outputs.setdefault(bot_info[""low_dest""][1], []).append(low_chip)
                if bot_info[""high_dest""][0] == ""bot"":
                    bots.setdefault(bot_info[""high_dest""][1], {""chips"": [], ""low_dest"": None, ""high_dest"": None})[""chips""].append(high_chip)
                else:
                    outputs.setdefault(bot_info[""high_dest""][1], []).append(high_chip)
                bot_info[""chips""] = []
        if not any(len(bot_info[""chips""]) == 2 for bot_info in bots.values()):
            break

    return None

instructions = open(""input.txt"").readlines()
print(find_bot(instructions, 61, 17))
",0
35,2016,11,1,syntax_error,,37,"  File ""/tmp/tmpiyhvgkjt/tmp.py"", line 18
    new_grid[elevator.index(floors[i][j])] = [obj for obj in new_grid[elevator.index(floors[i][j]) if obj != floors[i][j]]
                                                                                                                         ^
SyntaxError: invalid syntax
","
import copy

def can_connect(obj1, obj2):
    return obj1[1:] == obj2[1:]

def find_best_move(grid, elevator, floors):
    min_steps = float('inf')
    for i in range(len(floors)):
        if elevator != i and floors[i]:
            for j in range(len(floors[i])):
                for k in range(len(elevator)):
                    if can_connect(floors[i][j], elevator[k]):
                        new_grid = copy.deepcopy(floors)
                        new_grid[i].pop(j)
                        new_grid[3].append(floors[i][j])
                        new_grid[elevator.index(floors[i][j])] = elevator.pop(k)
                        new_grid[elevator.index(floors[i][j])] = [obj for obj in new_grid[elevator.index(floors[i][j]) if obj != floors[i][j]]
                        steps = 1 + find_best_move(new_grid, elevator, floors)
                        if steps < min_steps:
                            min_steps = steps
    return min_steps

floors = [
    [],
    [('H1', 'H2')],
    [('L1', 'L2')],
    []
]

elevator = [('G1', 'G2')]

print(find_best_move(floors, elevator, floors))
",0
36,2016,12,1,runtime_error,,318083,"Traceback (most recent call last):
  File ""/tmp/tmpgiageqf4/tmp.py"", line 41, in <module>
    final_a = execute_program(instructions, registers)
  File ""/tmp/tmpgiageqf4/tmp.py"", line 34, in execute_program
    registers = execute_instruction(instructions[i], registers)
  File ""/tmp/tmpgiageqf4/tmp.py"", line 9, in execute_instruction
    x, y = re.findall(r""\d+|[a-d]"", instruction)
ValueError: too many values to unpack (expected 2)
","
import re

def execute_instruction(instruction, registers):
    """"""
    Executes a single instruction and returns the updated registers
    """"""
    if instruction.startswith(""cpy""):
        x, y = re.findall(r""\d+|[a-d]"", instruction)
        if x.isnumeric():
            registers[y] = int(x)
        else:
            registers[y] = registers[x]
    elif instruction.startswith(""inc""):
        registers[instruction[4]] += 1
    elif instruction.startswith(""dec""):
        registers[instruction[4]] -= 1
    elif instruction.startswith(""jnz""):
        x, y = re.findall(r""[a-d]|\d+"", instruction)
        if x.isnumeric():
            if int(x) != 0:
                return registers
        else:
            if registers[x] != 0:
                return execute_instructions(instructions[i + int(y)], registers)
    return registers

def execute_program(instructions, registers):
    """"""
    Executes the entire program and returns the final value in register a
    """"""
    i = 0
    while i < len(instructions):
        registers = execute_instruction(instructions[i], registers)
        i += 1
    return registers[""a""]

with open(""input.txt"", ""r"") as f:
    instructions = [line.strip() for line in f.readlines()]
    registers = {""a"": 0, ""b"": 0, ""c"": 0, ""d"": 0}
    final_a = execute_program(instructions, registers)
    print(final_a)
",0
37,2016,13,1,timeout_error,,92,TIMEOUT,"
import math

def count_bits(n):
    # Returns the number of bits that are 1 in the binary representation of n
    return bin(n).count('1')

def is_open(x, y, favorite_number):
    # Returns True if the given location is open, and False otherwise
    num = x*x + 3*x + 2*x*y + y + y*y + favorite_number
    return count_bits(num) % 2 == 0

def bfs(start, end):
    # Breadth-first search to find the shortest path from start to end
    queue = [(start, 0)]  # start location and step count
    visited = set()
    while queue:
        (x, y), steps = queue.pop(0)
        if (x, y) == end:
            return steps
        if (x, y) in visited:
            continue
        visited.add((x, y))
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_x, new_y = x + dx, y + dy
            if is_open(new_x, new_y, favorite_number) and (new_x, new_y) not in visited:
                queue.append(((new_x, new_y), steps + 1))
    return None  # unreachable

favorite_number = int(input())
start = (1, 1)
end = (31, 39)
print(bfs(start, end))
",0
38,2016,14,1,wrong_output,"Index 1 produces the 1th key.
Index 4 produces the 2th key.
Index 14 produces the 3th key.
Index 15 produces the 4th key.
Index 20 produces the 5th key.
Index 25 produces the 6th key.
Index 27 produces the 7th key.
Index 34 produces the 8th key.
Index 40 produces the 9th key.
Index 44 produces the 10th key.
Index 45 produces the 11th key.
Index 46 produces the 12th key.
Index 47 produces the 13th key.
Index 50 produces the 14th key.
Index 60 produces the 15th key.
Index 72 produces the 16th key.
Index 73 produces the 17th key.
Index 87 produces the 18th key.
Index 92 produces the 19th key.
Index 93 produces the 20th key.
Index 94 produces the 21th key.
Index 105 produces the 22th key.
Index 112 produces the 23th key.
Index 114 produces the 24th key.
Index 119 produces the 25th key.
Index 121 produces the 26th key.
Index 122 produces the 27th key.
Index 127 produces the 28th key.
Index 131 produces the 29th key.
Index 132 produces the 30th key.
Index 135 produces the 31th key.
Index 140 produces the 32th key.
Index 142 produces the 33th key.
Index 157 produces the 34th key.
Index 158 produces the 35th key.
Index 160 produces the 36th key.
Index 165 produces the 37th key.
Index 170 produces the 38th key.
Index 172 produces the 39th key.
Index 179 produces the 40th key.
Index 181 produces the 41th key.
Index 195 produces the 42th key.
Index 208 produces the 43th key.
Index 220 produces the 44th key.
Index 226 produces the 45th key.
Index 228 produces the 46th key.
Index 241 produces the 47th key.
Index 244 produces the 48th key.
Index 246 produces the 49th key.
Index 260 produces the 50th key.
Index 263 produces the 51th key.
Index 268 produces the 52th key.
Index 269 produces the 53th key.
Index 274 produces the 54th key.
Index 299 produces the 55th key.
Index 303 produces the 56th key.
Index 307 produces the 57th key.
Index 313 produces the 58th key.
Index 316 produces the 59th key.
Index 317 produces the 60th key.
Index 326 produces the 61th key.
Index 329 produces the 62th key.
Index 331 produces the 63th key.
Index 337 produces the 64th key.
The index that produces the 64th key is 337.
",23890,,"
import hashlib

salt = 'abc'
keys_generated = 0
index = 0

while keys_generated < 64:
    md5_hash = hashlib.md5((salt + str(index)).encode()).hexdigest()
    if len(set(md5_hash)) != len(md5_hash):
        for i in range(index + 1, index + 1000):
            new_hash = hashlib.md5((salt + str(i)).encode()).hexdigest()
            if md5_hash[3] * 5 in new_hash:
                print(f""Index {index} produces the {keys_generated + 1}th key."")
                keys_generated += 1
                break
    index += 1

print(f""The index that produces the 64th key is {index - 1}."")
",0
39,2016,15,1,runtime_error,,400589,"Traceback (most recent call last):
  File ""/tmp/tmpvzzza6zo/tmp.py"", line 25, in <module>
    disc_sizes.append(int(line[-1]))
ValueError: invalid literal for int() with base 10: '15.'
","
import math

def find_first_valid_time(disc_positions, disc_sizes):
    time = 0
    while True:
        passed = True
        for i in range(len(disc_positions)):
            if (disc_positions[i] + time + i + 1) % disc_sizes[i] != 0:
                passed = False
                break
        if passed:
            return time
        time += 1

# Read input file
with open(""input.txt"", ""r"") as f:
    lines = f.readlines()

disc_sizes = []
disc_positions = []

for line in lines:
    line = line.strip().split()
    disc_sizes.append(int(line[-1]))
    disc_positions.append(int(line[-2]))

print(find_first_valid_time(disc_positions, disc_sizes))


def find_first_valid_time(disc_positions, disc_sizes):
    time = 0
    while True:
        passed = True
        for i in range(len(disc_positions)):
            if (disc_positions[i] + time + i + 1) % disc_sizes[i] != 0:
                passed = False
                break
        if passed:
            return time
        time += 1

# Read input file
disc_sizes = []
disc_positions = []
with open(""input.txt"", ""r"") as f:
    lines = f.readlines()
for line in lines:
    line = line.strip().split()
    disc_sizes.append(int(line[-1]))
    disc_positions.append(int(line[-2]))

print(find_first_valid_time(disc_positions, disc_sizes))
",0
40,2016,16,1,syntax_error,,10100011010101011,"  File ""/tmp/tmpujqt7dyg/tmp.py"", line 25
    data = checksum
    ^
SyntaxError: invalid syntax
","
import hashlib

# Read puzzle input
with open('input.txt', 'r') as file:
    initial_state = file.read().strip()

# Define dragon curve function
def dragon_curve(state):
    b = state[::-1]
    b = b.replace('0', 'x').replace('1', '0').replace('x', '1')
    return state + '0' + b

# Generate data
data = initial_state
while len(data) < 272:
    data = dragon_curve(data)
    if len(data) > 272:
        data = data[:272]

# Calculate checksum
checksum = ''
while len(checksum) % 2 == 0:
    checksum = ''.join(['1' if data[i] == data[i+1] else '0' for i in range(0, len(data), 2)]
    data = checksum

# Print checksum
print(checksum)
",0
41,2016,17,1,syntax_error,,RDDRULDDRR,"  File ""/tmp/tmp9w54dmhs/tmp.py"", line 19
    for direction, new_position in [('U', [current_position[0]-1, current_position[1]], 'D', [current_position[0]+1, current_position[1]], 'L', [current_position[0], current_position[1]-1], 'R', [current_position[0], current_position[1]+1]]:
                                                                                                                                                                                                                                               ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import hashlib

def generate_md5(passcode, path):
    m = hashlib.md5()
    m.update(f""{passcode}{path}"".encode('utf-8'))
    return m.hexdigest()[:4]

def navigate_maze(passcode):
    path = ''
    position = [0, 0]
    visited = set()
    visited.add((position[0], position[1], path))
    queue = [(position, path)]
    while queue:
        current_position, path = queue.pop(0)
        if current_position == [3, 3]:
            return path
        for direction, new_position in [('U', [current_position[0]-1, current_position[1]], 'D', [current_position[0]+1, current_position[1]], 'L', [current_position[0], current_position[1]-1], 'R', [current_position[0], current_position[1]+1]]:
            if 0 <= new_position[0] <= 3 and 0 <= new_position[1] <= 3 and (new_position[0], new_position[1], path + direction) not in visited:
                doors = generate_md5(passcode, path + direction)
                if doors[0] in 'bcdef':
                    if direction == 'U' and current_position[0] > 0:
                        queue.append((new_position, path + direction)
                    elif direction == 'D' and current_position[0] < 3:
                        queue.append((new_position, path + direction)
                    elif direction == 'L' and current_position[1] > 0:
                        queue.append((new_position, path + direction)
                    elif direction == 'R' and current_position[1] < 3:
                        queue.append((new_position, path + direction)
        visited.add((current_position, path)

    return None

passcode = 'ihgpwlah'
print(navigate_maze(passcode))
",0
42,2016,18,1,wrong_output,"86
",1913,,"
import os

def generate_trap_map(rows):
    def next_row(prev_row):
        new_row = """"
        for i in range(len(prev_row)):
            left, center, right = prev_row[i-1], prev_row[i], prev_row[(i+1)%len(prev_row)]
            if (left == ""^"" and center == ""^"" and right != ""^"") or (left != ""^"" and center == ""^"" and right == ""^"") or (left == ""^"" and right != ""^""):
                new_row += ""^""
            else:
                new_row += "".""
        return new_row

    trap_map = """"
    with open(""input.txt"", ""r"") as f:
        for line in f:
            trap_map += line.strip()

    for _ in range(rows - 1):
        trap_map += ""\n"" + next_row(trap_map[-1])

    safe_count = trap_map.count(""."")
    return safe_count

rows = 40
safe_count = generate_trap_map(rows)
print(safe_count)
",0
43,2016,19,1,timeout_error,,1808357,TIMEOUT,"
import math

def steal_presents(num_elves):
    # Initialize the elves and their presents
    elves = [1] * num_elves
    # Start with the first elf (position 1)
    current_elf = 1
    while len(elves) > 1:
        # Calculate the position of the elf to steal from
        steal_from = (current_elf + math.ceil(len(elves) / 2)) % len(elves)
        # Remove the elf that was stolen from
        if steal_from < current_elf:
            elves = elves[:steal_from] + elves[steal_from+1:]
        else:
            elves = elves[steal_from+1:] + elves[:steal_from]
        # Remove the current elf from the circle
        elves.pop(current_elf - 1)
        # Move to the next elf
        current_elf = (current_elf + 1) % (len(elves) + 1)
    return current_elf

# Read input from file
with open('input.txt', 'r') as f:
    num_elves = int(f.readline().strip())

print(steal_presents(num_elves))
",0
44,2016,20,1,timeout_error,,32259706,TIMEOUT,"
import re

def get_valid_ips(blacklist):
    blocked_ips = set()
    for line in blacklist:
        start, end = map(int, re.findall(r'\d+', line))
        blocked_ips.update(range(start, end + 1))

    valid_ips = set(range(4294967296)) - blocked_ips
    return valid_ips

def lowest_valid_ip(valid_ips):
    return min(valid_ips)

with open('input.txt', 'r') as f:
    blacklist = f.read().splitlines()
    valid_ips = get_valid_ips(blacklist)
    lowest_ip = lowest_valid_ip(valid_ips)
    print(f'The lowest valid IP is: {lowest_ip}')
",0
45,2016,21,1,runtime_error,,gbhafcde,"Traceback (most recent call last):
  File ""/tmp/tmpleydozw7/tmp.py"", line 56, in <module>
    scrambled_password = scramble_password(password, input_operations)
  File ""/tmp/tmpleydozw7/tmp.py"", line 23, in scramble_password
    index = password.index(letter)
ValueError: substring not found
","
import re

def scramble_password(password, operations):
    # Apply each operation to the password
    for operation in operations:
        if operation.startswith('swap position'):
            # Get the positions to swap
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Swap the characters at the positions
            password = list(password)
            password[pos1], password[pos2] = password[pos2], password[pos1]
            password = ''.join(password)
        elif operation.startswith('swap letter'):
            # Get the letters to swap
            letter1, letter2 = re.findall(r'[a-zA-Z]', operation)
            # Swap the letters in the password
            password = password.replace(letter1, '#').replace(letter2, letter1).replace('#', letter2)
        elif operation.startswith('rotate based'):
            # Get the letter to rotate on
            letter = re.findall(r'[a-zA-Z]', operation)[0]
            # Find the index of the letter
            index = password.index(letter)
            # Calculate the number of rotations
            rotations = index + 1
            if index >= 4:
                rotations += 1
            # Rotate the password
            password = password[-rotations:] + password[:-rotations]
        elif operation.startswith('reverse'):
            # Get the positions to reverse
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Reverse the characters in the password
            password = password[:pos1] + password[pos1:pos2+1][::-1] + password[pos2+1:]
        elif operation.startswith('move'):
            # Get the positions to move
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Remove the character at pos1 and insert it at pos2
            char = password[pos1]
            password = password[:pos1] + password[pos1+1:]
            password = password[:pos2] + char + password[pos2:]
        else:
            # Rotate the password
            if operation.endswith('left'):
                password = password[1:] + password[0]
            else:
                password = password[-1] + password[:-1]
    return password

# Read the input file
with open('input.txt', 'r') as f:
    input_operations = f.read().splitlines()

# Scramble the password and print the result
password = 'abcdefgh'
scrambled_password = scramble_password(password, input_operations)
print(scrambled_password)


def scramble_password(password, operations):
    # Apply each operation to the password
    for operation in operations:
        if operation.startswith('swap position'):
            # Get the positions to swap
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Swap the characters at the positions
            password = list(password)
            password[pos1], password[pos2] = password[pos2], password[pos1]
            password = ''.join(password)
        elif operation.startswith('swap letter'):
            # Get the letters to swap
            letter1, letter2 = re.findall(r'[a-zA-Z]', operation)
            # Swap the letters in the password
            password = password.replace(letter1, '#').replace(letter2, letter1).replace('#', letter2)
        elif operation.startswith('rotate based'):
            # Get the letter to rotate on
            letter = re.findall(r'[a-zA-Z]', operation)[0]
            # Find the index of the letter
            index = password.index(letter)
            # Calculate the number of rotations
            rotations = index + 1
            if index >= 4:
                rotations += 1
            # Rotate the password
            password = password[-rotations:] + password[:-rotations]
        elif operation.startswith('reverse'):
            # Get the positions to reverse
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Reverse the characters in the password
            password = password[:pos1] + password[pos1:pos2+1][::-1] + password[pos2+1:]
        elif operation.startswith('move'):
            # Get the positions to move
            pos1, pos2 = map(int, re.findall(r'\d+', operation))
            # Remove the character at pos1 and insert it at pos2
            char = password[pos1]
            password = password[:pos1] + password[pos1+1:]
            password = password[:pos2] + char + password[pos2:]
        else:
            # Rotate the password
            if operation.endswith('left'):
                password = password[1:] + password[0]
            else:
                password = password[-1] + password[:-1]
    return password

# Read the input file
with open('input.txt', 'r') as f:
    input_operations = f.read().splitlines()

# Scramble the password and print the result
password = 'abcdefgh'
scrambled_password = scramble_password(password, input_operations)
print(scrambled_password)
",0
46,2016,22,1,runtime_error,,901,"Traceback (most recent call last):
  File ""/tmp/tmpewl40dd6/tmp.py"", line 16, in <module>
    x, y, size, used, avail, _ = match.groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re
import math

# Read input from file
with open('input.txt', 'r') as file:
    data = file.readlines()

# Define regex pattern for parsing data
pattern = re.compile(r'/dev/grid/node-x(\d+)-y(\d+)\s+(\d+)T\s+(\d+)T\s+(\d+)T\s+(\d+)%')

# Extract data from input
nodes = {}
for line in data:
    match = pattern.match(line)
    x, y, size, used, avail, _ = match.groups()
    nodes[f'node-{x}-{y}'] = {'size': int(size), 'used': int(used), 'avail': int(avail)}

# Count viable pairs
viable_pairs = 0
for node_a, node_a_data in nodes.items():
    for node_b, node_b_data in nodes.items():
        if node_a != node_b and node_a_data['used'] != 0 and node_a_data['used'] <= node_b_data['avail']:
            viable_pairs += 1

print(viable_pairs)
",0
47,2016,23,1,runtime_error,,12516,"Traceback (most recent call last):
  File ""/tmp/tmp9iv4y2n4/tmp.py"", line 62, in <module>
    print(execute_instructions(sys.argv[1]))
IndexError: list index out of range
","
import re
import sys

def execute_instructions(input_file, a=0, b=0, c=0, d=0):
    instructions = []
    with open(input_file, 'r') as f:
        for line in f:
            instructions.append(line.strip())

    i = 0
    while i < len(instructions):
        instruction = instructions[i]
        if instruction.startswith('cpy'):
            if 'b' in instruction:
                b = int(re.findall(r'\d+', instruction)[0]) if 'a' not in instruction else a
            elif 'c' in instruction:
                c = int(re.findall(r'\d+', instruction)[0]) if 'a' not in instruction else a
            else:
                a = int(re.findall(r'\d+', instruction)[0]) if 'c' not in instruction else c
            i += 1
        elif instruction.startswith('inc'):
            if 'b' in instruction:
                b += 1
            elif 'c' in instruction:
                c += 1
            else:
                a += 1
            i += 1
        elif instruction.startswith('dec'):
            if 'b' in instruction:
                b -= 1
            elif 'c' in instruction:
                c -= 1
            else:
                a -= 1
            i += 1
        elif instruction.startswith('jnz'):
            if ('a' in instruction and a != 0) or ('b' in instruction and b != 0) or ('c' in instruction and c != 0):
                i += int(re.findall(r'-?\d+', instruction)[0])
            else:
                i += 1
        elif instruction.startswith('tgl'):
            value = int(re.findall(r'-?\d+', instruction)[0])
            if 0 <= i + value < len(instructions):
                if instructions[i+value].startswith('inc'):
                    instructions[i+value] = instructions[i+value].replace('inc', 'dec')
                elif instructions[i+value].startswith('dec'):
                    instructions[i+value] = instructions[i+value].replace('dec', 'inc')
                elif instructions[i+value].startswith('tgl'):
                    instructions[i+value] = instructions[i+value].replace('tgl', 'inc')
                elif instructions[i+value].startswith('jnz'):
                    instructions[i+value] = instructions[i+value].replace('jnz', 'cpy')
                else:
                    instructions[i+value] = instructions[i+value].replace('cpy', 'jnz')
            i += 1
        else:
            i += 1

    return a

print(execute_instructions(sys.argv[1]))
",0
48,2016,24,1,runtime_error,,498,"Traceback (most recent call last):
  File ""/tmp/tmprk1ts7_2/tmp.py"", line 66, in <module>
    main()
  File ""/tmp/tmprk1ts7_2/tmp.py"", line 57, in main
    distance = find_path(graph, (0, 0), (maze.index(str(num)), maze[0].index(str(num))) + 1)
ValueError: '1' is not in list
","
from collections import defaultdict
import heapq

def heuristic(a, b):
    # Manhattan distance between two points
    x1, y1 = a
    x2, y2 = b
    return abs(x1 - x2) + abs(y1 - y2)

def find_path(graph, start, end):
    queue = []
    heapq.heappush(queue, (0, start))
    visited = set()
    while queue:
        cost, current = heapq.heappop(queue)
        if current == end:
            return cost
        if current in visited:
            continue
        visited.add(current)
        for neighbor, distance in graph[current]:
            if neighbor not in visited:
                heapq.heappush(queue, (cost + distance, neighbor))
    return None

def main():
    maze = []
    with open('input.txt') as f:
        for line in f:
            maze.append(list(line.strip()))

    nums = set() 
    for y, row in enumerate(maze):
        for x, val in enumerate(row):
            try:
                nums.add(int(val))
            except ValueError:
                pass

    # Create a graph of the maze
    graph = defaultdict(list)
    for y, row in enumerate(maze):
        for x, val in enumerate(row):
            if val == '#':
                continue
            for dy, dx in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                ny, nx = y + dy, x + dx
                if 0 <= ny < len(maze) and 0 <= nx < len(row) and maze[ny][nx] != '#':
                    distance = abs(dy) + abs(dx)
                    graph[(y, x)].append(((ny, nx, maze[ny][nx]), distance))

    # Find the shortest path from 0 to each number
    total_distance = 0
    for num in nums:
        if num != 0:
            distance = find_path(graph, (0, 0), (maze.index(str(num)), maze[0].index(str(num))) + 1)
            if distance is None:
                print(""No path found to"", num)
                return
            total_distance += distance

    print(""Total distance:"", total_distance)

if __name__ == '__main__':
    main()
",0
49,2016,25,1,timeout_error,,196,TIMEOUT,"
from collections import defaultdict

def read_input():
    with open('input.txt') as f:
        return [line.strip() for line in f.readlines()]

def run_program(input_list):
    registers = defaultdict(int)
    instructions = input_list
    pointer = 0
    
    while pointer < len(instructions):
        instruction = instructions[pointer].split()
        cmd = instruction[0]
        if cmd == 'cpy':
            src, dst = instruction[1:]
            if src.isdigit():
                registers[dst] = int(src)
            else:
                registers[dst] = registers[src]
            pointer += 1
        elif cmd == 'inc':
            registers[instruction[1]] += 1
            pointer += 1
        elif cmd == 'dec':
            registers[instruction[1]] -= 1
            pointer += 1
        elif cmd == 'jnz':
            if instruction[1].isdigit() or registers[instruction[1]] != 0:
                pointer += int(instruction[2])
            else:
                pointer += 1
        elif cmd == 'out':
            print(instruction[1])
            pointer += 1
        else:
            pointer += 1
    
    return registers

def find_min_init_value():
    input_list = read_input()
    registers = run_program(input_list)
    min_init_val = None
    signal = []
    while len(signal) < 100:
        for i in range(10000000000):
            registers['a'] = i
            run_program(input_list)
            out_val = registers['a']
            if out_val == 1:
                signal.append(1)
            elif out_val == 0:
                signal.append(0)
            else:
                raise ValueError('Invalid value for out')
            if signal == [0, 1] * (len(signal) // 2):
                min_init_val = i - 1
                break
    return min_init_val

print(find_min_init_value())
",0
50,2017,1,1,timeout_error,,1177,TIMEOUT,"
import re
from collections import deque

def solve_captcha(input_list):
    input_list = re.findall('\d', input_list)
    input_deque = deque(input_list)
    input_deque.append(input_list[0])
    total_sum = 0

    for i in range(len(input_list)):
        if input_deque[i] == input_deque[i+1]:
            total_sum += int(input_list[i])

    return total_sum

input_string = input()
print(solve_captcha(input_string))
",0
51,2017,2,1,wrong_output,"45158
45158
",45158,,"
import os

file_path = os.path.join(os.getcwd(), 'input.txt')

with open(file_path, 'r') as file:
    lines = file.readlines()

checksum = 0

for line in lines:
    line = line.strip().split()
    numbers = [int(num) for num in line]
    diff = max(numbers) - min(numbers)
    checksum += diff

print(checksum)


file_path = 'input.txt'

with open(file_path, 'r') as file:
    lines = file.readlines()

checksum = 0

for line in lines:
    line = line.strip().split()
    numbers = [int(num) for num in line]
    diff = max(numbers) - min(numbers)
    checksum += diff

print(checksum)
",0
52,2017,3,1,timeout_error,,438,TIMEOUT,"
import math

def spiral_memory(num):
    layer = int(math.ceil((math.sqrt(num - 1) + 1) / 2))
    remainder = num % (2 * layer - 1)
    if remainder == 0:
        remainder = 2 * layer - 1
    steps = layer + abs(remainder - layer) - 1
    return steps

input_num = int(input())
print(spiral_memory(input_num))
",0
53,2017,4,1,no_error,"383
",383,,"
import re

def is_valid_passphrase(passphrase):
    words = passphrase.split()
    return len(words) == len(set(words))

def count_valid_passphrases(input_file):
    valid_count = 0
    with open(input_file, 'r') as f:
        for line in f:
            if is_valid_passphrase(line.strip()):
                valid_count += 1
    return valid_count

input_file = 'input.txt'
valid_count = count_valid_passphrases(input_file)
print(valid_count)
",0
54,2017,5,1,wrong_output,"391540
391540
",391540,,"
import re

jumps = []
with open('input.txt', 'r') as f:
    jumps = [int(x) for x in f.read().strip().split()]

steps = 0
index = 0
while index >= 0 and index < len(jumps):
    new_index = index + jumps[index]
    jumps[index] += 1
    index = new_index
    steps += 1

print(steps)


jumps = []
with open('input.txt', 'r') as f:
    jumps = [int(x) for x in f.read().strip().split()]

steps = 0
index = 0
while index >= 0 and index < len(jumps):
    new_index = index + jumps[index]
    jumps[index] += 1
    index = new_index
    steps += 1

print(steps)
",0
55,2017,6,1,no_error,"6681
",6681,,"
def reallocate(banks):
    max_value = max(banks)
    max_index = banks.index(max_value)
    banks[max_index] = 0
    for i in range(max_index + 1, max_index + max_value + 1):
        index = i % len(banks)
        banks[index] += 1
    return banks

def check_for_cycle(banks, seen_configs):
    key = tuple(banks)
    if key in seen_configs:
        return True
    else:
        seen_configs.add(key)
        return False

def main():
    with open('input.txt', 'r') as f:
        banks = list(map(int, f.read().strip().split()))
    seen_configs = set()
    cycles = 0
    while True:
        if check_for_cycle(banks, seen_configs):
            break
        reallocate(banks)
        cycles += 1
    print(cycles)

if __name__ == '__main__':
    main()
",0
56,2017,7,1,runtime_error,,cyrupz,"Traceback (most recent call last):
  File ""/tmp/tmpdswdk27o/tmp.py"", line 26, in <module>
    print(find_bottom_program(programs))
  File ""/tmp/tmpdswdk27o/tmp.py"", line 9, in find_bottom_program
    name, weight, *children = re.findall(r'([a-z]+) \((\d+)(?: -> (.*))?', program_info)
ValueError: not enough values to unpack (expected at least 2, got 1)
","
import re

def find_bottom_program(programs):
    all_programs = set()
    program_weights = {}
    child_programs = {}
    for program_info in programs:
        name, weight, *children = re.findall(r'([a-z]+) \((\d+)(?: -> (.*))?', program_info)
        weight = int(weight)
        all_programs.add(name)
        program_weights[name] = weight
        if children:
            children = children[0].split(', ')
            child_programs[name] = children
            all_programs.update(children)
        else:
            child_programs[name] = []

    possible_bottom_programs = all_programs - set(child_programs.keys())
    for program in possible_bottom_programs:
        if program not in child_programs.values():
            return program

programs = [line.strip() for line in open('input.txt').readlines()]
print(find_bottom_program(programs))
",0
57,2017,8,1,runtime_error,,4448,"Traceback (most recent call last):
  File ""/tmp/tmpbhwy3sv5/tmp.py"", line 8, in <module>
    reg, op, val, _, cond_reg, cond_op, cond_val = re.findall(r'(\w+)\s(\w+)\s([-+]?\d+)\sif\s(\w+)\s([<>=!]+)\s([-+]?\d+)', line.strip())[0]
ValueError: not enough values to unpack (expected 7, got 6)
","
import re

registers = {}

with open('input.txt', 'r') as f:
    for line in f:
        reg, op, val, _, cond_reg, cond_op, cond_val = re.findall(r'(\w+)\s(\w+)\s([-+]?\d+)\sif\s(\w+)\s([<>=!]+)\s([-+]?\d+)', line.strip())[0]
        if cond_reg not in registers:
            registers[cond_reg] = 0
        if reg not in registers:
            registers[reg] = 0
        
        if eval(""registers[cond_reg] {} {}"".format(cond_op, cond_val)):
            if op == 'inc':
                registers[reg] += int(val)
            else:
                registers[reg] -= int(val)

        max_val = max(registers.values())

print(max(registers.values()))
",0
58,2017,9,1,runtime_error,,7640,"Traceback (most recent call last):
  File ""/tmp/tmphxw54uan/tmp.py"", line 35, in <module>
    idx, total_score = process_group(text, idx, total_score)
  File ""/tmp/tmphxw54uan/tmp.py"", line 27, in process_group
    return process_group(text, idx + 1, score)
  File ""/tmp/tmphxw54uan/tmp.py"", line 14, in process_group
    return process_group(text, idx + 1, score + 1)
  File ""/tmp/tmphxw54uan/tmp.py"", line 5, in process_group
    if text[idx] == '}':
IndexError: string index out of range
","
import re

def process_group(text, idx, score):
    if text[idx] == '}':
        return idx + 1, score - 1
    elif text[idx] == '{':
        idx += 1
        while idx < len(text) and text[idx] == '{':
            idx, score = process_group(text, idx, score + 1)
        while idx < len(text) and text[idx] != '}':
            idx += 1
        if idx < len(text):
            return process_group(text, idx + 1, score + 1)
        else:
            return idx, score
    elif text[idx] == '<':
        while idx < len(text) and text[idx] != '>':
            if text[idx] == '!':
                idx += 1
            idx += 1
        if idx < len(text):
            return process_group(text, idx + 1, score)
        else:
            return idx, score
    else:
        return process_group(text, idx + 1, score)

with open('input.txt', 'r') as f:
    text = f.read().strip()

total_score = 0
idx = 0
while idx < len(text):
    idx, total_score = process_group(text, idx, total_score)

print(total_score)

### Python code without imports:

def process_group(text, idx, score):
    if text[idx] == '}':
        return idx + 1, score - 1
    elif text[idx] == '{':
        idx += 1
        while idx < len(text) and text[idx] == '{':
            idx, score = process_group(text, idx, score + 1)
        while idx < len(text) and text[idx] != '}':
            idx += 1
        if idx < len(text):
            return process_group(text, idx + 1, score + 1)
        else:
            return idx, score
    elif text[idx] == '<':
        while idx < len(text) and text[idx] != '>':
            if text[idx] == '!':
                idx += 1
            idx += 1
        if idx < len(text):
            return process_group(text, idx + 1, score)
        else:
            return idx, score
    else:
        return process_group(text, idx + 1, score)

with open('input.txt', 'r') as f:
    text = f.read().strip()

total_score = 0
idx = 0
while idx < len(text):
    idx, total_score = process_group(text, idx, total_score)

print(total_score) ",0
59,2017,10,1,no_error,"46600
",46600,,"
import functools

def circular_list(lst, current_pos, length):
    """"""
    Reverse the order of a slice of the given list starting at current_pos and wrapping around if necessary
    """"""
    if current_pos + length > len(lst):
        # wrap around if we need to
        reverse_slice = lst[current_pos:] + lst[:current_pos+length-len(lst)]
    else:
        reverse_slice = lst[current_pos:current_pos+length]
    reversed_slice = list(reversed(reverse_slice))
    if current_pos + length > len(lst):
        lst[current_pos:] = reversed_slice[:len(lst)-current_pos]
        lst[:current_pos+length-len(lst)] = reversed_slice[len(lst)-current_pos:]
    else:
        lst[current_pos:current_pos+length] = reversed_slice

def knot_hash(lengths, rounds=1, size=256):
    """"""
    Implement the knot-tying hash function with the given lengths and rounds
    """"""
    lst = list(range(size))
    current_pos = skip_size = 0
    for length in lengths:
        circular_list(lst, current_pos, length)
        current_pos = (current_pos + length + skip_size) % size
        skip_size += 1
    return lst

def knot_hash_part1(lengths):
    """"""
    Part 1 of the puzzle: multiply the first two elements of the knot hash
    """"""
    hashed = knot_hash(lengths)
    return hashed[0] * hashed[1]

# Part 1 solution
lengths = [int(x) for x in open('input.txt').read().split(',')]
print(knot_hash_part1(lengths))
",0
60,2017,11,1,no_error,"696
",696,,"
def hex_distance(path):
    import re
    moves = re.findall(r'[ns][ew]', path)
    x, y = 0, 0
    for move in moves:
        dx, dy = {'n': (0, -1), 'ne': (1, -1), 'se': (1, 0), 's': (0, 1), 'sw': (-1, 1), 'nw': (-1, 0)}[move]
        x += dx
        y += dy
    return max(abs(x), abs(y))

with open('input.txt', 'r') as f:
    path = f.read().strip()
    print(hex_distance(path))
",0
61,2017,12,1,no_error,"288
",288,,"
import sys
from collections import deque

def build_graph(input_file):
    with open(input_file, 'r') as f:
        data = f.readlines()
    graph = {}
    for line in data:
        node, neighbors = line.strip().split(' <-> ')
        graph[int(node)] = [int(n) for n in neighbors.split(', ')]
    return graph

def search_group(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            queue.extend(n for n in graph[node] if n not in visited)
    return visited

def main():
    input_file = 'input.txt'
    graph = build_graph(input_file)
    group = search_group(graph, 0)
    print(len(group))

if __name__ == '__main__':
    main()
",0
62,2017,13,1,wrong_output,"Severity with no delay: 1624
Least possible delay: 3923436
Severity with delay: 0
",1624,,"
import re

def severity_calc(firewall_dict, delay=0):
    total_severity = 0
    for layer, range_ in firewall_dict.items():
        if (layer + delay) % (2 * (range_ - 1)) == 0:
            total_severity += layer * range_
    return total_severity

firewall_dict = {}
with open('input.txt', 'r') as file:
    for line in file:
        layer, range_ = map(int, re.findall('\d+', line.strip()))
        firewall_dict[layer] = range_

# Part 1
print(""Severity with no delay:"", severity_calc(firewall_dict))

# Part 2
delay = 0
while True:
    caught = False
    for layer, range_ in firewall_dict.items():
        if (layer + delay) % (2 * (range_ - 1)) == 0:
            caught = True
            break
    if not caught:
        break
    delay += 1

print(""Least possible delay:"", delay)
print(""Severity with delay:"", severity_calc(firewall_dict, delay))
",0
63,2017,14,1,runtime_error,,8148,"Traceback (most recent call last):
  File ""/tmp/tmpftcrqsi0/tmp.py"", line 36, in <module>
    main()
  File ""/tmp/tmpftcrqsi0/tmp.py"", line 32, in main
    used_squares = count_used_squares(key)
  File ""/tmp/tmpftcrqsi0/tmp.py"", line 25, in count_used_squares
    hash_output = knot_hash(f""{key}-{i}"")
  File ""/tmp/tmpftcrqsi0/tmp.py"", line 16, in knot_hash
    dense_hash = [
  File ""/tmp/tmpftcrqsi0/tmp.py"", line 17, in <listcomp>
    hex(reduce(lambda x, y: x ^ y, sparse_hash[i * 16:(i + 1) * 16])).lstrip(""0x"").zfill(2)
NameError: name 'reduce' is not defined
","
import hashlib
import binascii

def knot_hash(key):
    lengths = [ord(c) for c in key] + [17, 31, 73, 47, 23]
    sparse_hash = list(range(0, 256))
    current_position = 0
    skip_size = 0
    for _ in range(64):
        for length in lengths:
            sparse_hash = sparse_hash[current_position:] + sparse_hash[:current_position]
            sparse_hash = sparse_hash[:length][::-1] + sparse_hash[length:]
            current_position = (current_position + length + skip_size) % 256
            skip_size += 1
    dense_hash = [
        hex(reduce(lambda x, y: x ^ y, sparse_hash[i * 16:(i + 1) * 16])).lstrip(""0x"").zfill(2)
        for i in range(16)
    ]
    return """".join(dense_hash)

def count_used_squares(key):
    total_used_squares = 0
    for i in range(128):
        hash_output = knot_hash(f""{key}-{i}"")
        binary_output = bin(int(hash_output, 16))[2:].zfill(128)
        total_used_squares += binary_output.count(""1"")
    return total_used_squares

def main():
    key = ""flqrgnkx""  # Replace this with your puzzle input
    used_squares = count_used_squares(key)
    print(f""Total used squares for key {key}: {used_squares}"")

if __name__ == ""__main__"":
    main()
",0
64,2017,15,1,runtime_error,,650,"Traceback (most recent call last):
  File ""/tmp/tmphlwa80u8/tmp.py"", line 18, in <module>
    a_start, b_start, factor_a, factor_b = map(int, file.read().split())
ValueError: invalid literal for int() with base 10: 'Generator'
","
def generate_number(value, factor):
    return value * factor % 2147483647

def count_matching_bits(a_start, b_start, factor_a, factor_b, iterations):
    a_value, b_value = a_start, b_start
    matching_count = 0
    for _ in range(iterations):
        a_value = generate_number(a_value, factor_a)
        b_value = generate_number(b_value, factor_b)
        a_binary = format(a_value, '032b')[-16:]
        b_binary = format(b_value, '032b')[-16:]
        matching_count += 1 if a_binary == b_binary else 0
    return matching_count


with open('input.txt', 'r') as file:
    a_start, b_start, factor_a, factor_b = map(int, file.read().split())
    final_count = count_matching_bits(a_start, b_start, factor_a, factor_b, 400000000)
    print(final_count)
",0
65,2017,16,1,runtime_error,,nlciboghjmfdapek,"Traceback (most recent call last):
  File ""/tmp/tmpvxt9vg88/tmp.py"", line 30, in <module>
    i, j = [programs.index(p) for p in move.params]
ValueError: too many values to unpack (expected 2)
","
#!/usr/bin/python3

# Importing the necessary libraries
import re
from collections import namedtuple

# Defining the DanceMoves class to store the moves
DanceMoves = namedtuple('DanceMoves', ['move', 'params'])

# Reading the input file
with open('input.txt', 'r') as input_file:
    moves_list = input_file.read().strip().split(',')

# Parsing the input into a list of DanceMoves objects
moves = [DanceMoves(move[0], re.findall(r'\w', move)) for move in moves_list]

# Defining the initial state
programs = list('abcdefghijklmnop')

# Performing the dance
for move in moves:
    if move.move == 's':
        size = int(move.params[0])
        programs = programs[-size:] + programs[:-size]
    elif move.move == 'x':
        i, j = sorted(map(int, move.params))
        programs[i], programs[j] = programs[j], programs[i]
    elif move.move == 'p':
        i, j = [programs.index(p) for p in move.params]
        programs[i], programs[j] = programs[j], programs[i]

# Printing the final order of the programs
print(''.join(programs))
",0
66,2017,17,1,no_error,"640
",640,,"
import sys

def spinlock(step, iterations):
    buffer = [0]
    current_position = 0
    value = 1
    for i in range(1, iterations+1):
        current_position = (current_position + step) % len(buffer)
        buffer.insert(current_position + 1, value)
        current_position = (current_position + 1) % len(buffer)
        value += 1
    return buffer[buffer.index(2017) + 1]

with open('input.txt', 'r') as f:
    input_step = int(f.read().strip())

print(spinlock(input_step, 2017))
",0
67,2017,18,1,wrong_output,"1
",4601,,"
import re

def execute_instruction(instruction, registers):
    if instruction[0] == 'snd':
        last_sound = registers[instruction[1]]
    elif instruction[0] == 'set':
        registers[instruction[1]] = get_value(instruction[2], registers)
    elif instruction[0] == 'add':
        registers[instruction[1]] += get_value(instruction[2], registers)
    elif instruction[0] == 'mul':
        registers[instruction[1]] *= get_value(instruction[2], registers)
    elif instruction[0] == 'mod':
        registers[instruction[1]] %= get_value(instruction[2], registers)
    elif instruction[0] == 'rcv':
        if registers[instruction[1]] != 0:
            return last_sound
    elif instruction[0] == 'jgz':
        if get_value(instruction[1], registers) > 0:
            return get_value(instruction[2], registers)
    return 1

def get_value(value, registers):
    return registers[value] if value.isalpha() else int(value)

instructions = []
registers = {chr(i): 0 for i in range(ord('a'), ord('z') + 1)}
last_sound = None

with open('input.txt') as f:
    for line in f:
        instructions.append(re.findall('[a-z]+|-?\d+', line.strip()))

current_instruction = 0
while 0 <= current_instruction < len(instructions):
    last_sound = execute_instruction(instructions[current_instruction], registers)
    if last_sound is not None:
        break
    current_instruction += execute_instruction(instructions[current_instruction], registers)

print(last_sound)
",0
68,2017,19,1,syntax_error,,GSXDIPWTU,"  File ""/tmp/tmpz4_w_9jr/tmp.py"", line 20
    if current_position[0] < 0 or current_position[0] == len(diagram) or current_position[1] < 0 or current_position[1] == len(diagram[current_position[0]):
                                                                                                                                                          ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import re

file = open('input.txt', 'r')
diagram = file.read()

# Remove all newlines and split the string into a list of characters
diagram = diagram.replace('\n', '')
diagram = list(diagram)

current_position = (0, diagram.index('|'))
current_direction = (0, 1) # Start by moving down
letters_seen = ''

while True:
    # Move one step in the current direction
    current_position = (current_position[0] + current_direction[0], current_position[1] + current_direction[1])

    # Check if we've reached the end of the diagram
    if current_position[0] < 0 or current_position[0] == len(diagram) or current_position[1] < 0 or current_position[1] == len(diagram[current_position[0]):
        break

    # Check if we've reached a letter
    if diagram[current_position[0]][current_position[1]].isalpha():
        letters_seen += diagram[current_position[0]][current_position[1]]

    # Check if we need to turn
    if diagram[current_position[0]][current_position[1]] == '+':
        if current_direction[0] == 0:
            if diagram[current_position[0]-1][current_position[1]] in ('|', '-'):
                current_direction = (-1, 0) # Turn left
            else:
                current_direction = (1, 0) # Turn right
        elif current_direction[1] == 0:
            if diagram[current_position[0]][current_position[1]-1] in ('-', '|'):
                current_direction = (0, -1) # Turn left
            else:
                current_direction = (0, 1) # Turn right

    # Check if we need to turn the other direction
    elif diagram[current_position[0]][current_position[1]] == '|' or diagram[current_position[0]][current_position[1]] == '-':
        if current_direction[1] == 0:
            current_direction = (0, -1) # Turn left
        else:
            current_direction = (1, 0) # Turn right

    # Stop if we've reached a dead end
    elif diagram[current_position[0]][current_position[1]] == ' ':
        break

print(letters_seen)
",0
69,2017,20,1,runtime_error,,344,"Traceback (most recent call last):
  File ""/tmp/tmpig5y77l1/tmp.py"", line 3, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import re
import numpy as np

def get_data(filename):
    with open(filename) as f:
        data = f.readlines()
        data = [x.strip() for x in data]
    return data

def parse_data(data):
    parsed_data = []
    for line in data:
        position, velocity, acceleration = re.findall(r'<([-\d,\s]+)>', line)
        position = np.array(list(map(int, position.split(',')))).reshape(3,1)
        velocity = np.array(list(map(int, velocity.split(',')))).reshape(3,1)
        acceleration = np.array(list(map(int, acceleration.split(',')))).reshape(3,1)
        parsed_data.append((position, velocity, acceleration))
    return parsed_data

def simulate_particles(particles, steps=10000):
    for _ in range(steps):
        for i, (p, v, a) in enumerate(particles):
            v += a
            p += v
        distances = np.sum(np.abs(particles[:,0]), axis=1)
        index = np.argmin(distances)
        particles = np.array(sorted(particles, key=lambda x: np.sum(np.abs(x[0]))).tolist())
    return index

def main():
    data = get_data('input.txt')
    parsed_data = parse_data(data)
    index = simulate_particles(np.array(parsed_data))
    print(f'The particle that stays closest to <0,0,0> is {index}')

if __name__ == '__main__':
    main()
",0
70,2017,21,1,syntax_error,,179,"  File ""/tmp/tmp4bunghno/tmp.py"", line 16
    return [''.join(pattern[::-1][i] for i in range(len(pattern))] for i in range(len(pattern[0]))]
                                                                 ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
from typing import List, Tuple

def generate_patterns(pattern: str) -> List[str]:
    patterns = [pattern]
    for _ in range(3):
        pattern = pattern.replace('.', '0').replace('#', '1')
        patterns.append(pattern)
        pattern = pattern.replace('0', '.').replace('1', '#')
    return patterns

def flip_pattern(pattern: List[str]) -> List[str]:
    return [''.join(reversed(line) for line in pattern) for line in pattern]

def rotate_pattern(pattern: List[str]) -> List[str]:
    return [''.join(pattern[::-1][i] for i in range(len(pattern))] for i in range(len(pattern[0]))]

def enhance(patterns: List[str], pattern_map: dict) -> List[str]:
    size = len(patterns[0])
    if size % 2 == 0:
        step = 2
        new_size = size * 3
    else:
        step = 3
        new_size = size * 4
    new_patterns = []
    for i in range(0, size, step):
        for j in range(0, size, step):
            square = [patterns[x][i:i+step] for x in range(i, i+step)]
            for rot in range(4):
                square = rotate_pattern(square)
                flipped_square = flip_pattern(square)
                for p in patterns + [square, flipped_square]:
                    key = '/'.join(p)
                    if key in pattern_map:
                        break
                else:
                    continue
                new_patterns.extend([pattern_map[key][k:k+step] for k in range(0, new_size, step)])
                break
            else:
                raise ValueError(""No match found"")
    return new_patterns

def count_on_pixels(patterns: List[str]) -> int:
    return sum(sum(1 for line in patterns for pixel in line if pixel == '#')

def main(pattern_map: dict) -> int:
    patterns = ['.#.', '..#', '###']
    for _ in range(5):
        patterns = enhance(patterns, pattern_map)
    return count_on_pixels(patterns)

if __name__ == '__main__':
    pattern_map = {'../../.#': '##./#../...', '.#./..#/###': '#..#/..../..../#..#'}
    print(main(pattern_map))
",0
71,2017,22,1,wrong_output,"5001
",5280,,"
from collections import Counter

def main():
    # Load input.txt into a list of strings
    with open('input.txt', 'r') as file:
        grid = list(file.read().strip().split())

    # Convert list of strings to list of lists
    grid = [list(line) for line in grid]

    # Calculate the size of the grid
    size_x = len(grid[0])
    size_y = len(grid)

    # Initialize the virus carrier's position and direction
    x, y = size_x // 2, size_y // 2
    direction = 0

    # Define direction vectors
    dx, dy = [0, 1, 0, -1], [-1, 0, 1, 0]

    # Initialize the number of bursts and infections
    bursts = 0
    infections = 0

    # Define the grid as a dictionary
    nodes = {}
    for i in range(size_y):
        for j in range(size_x):
            nodes[(i, j)] = grid[i][j]

    # Iterate for 10000 bursts
    for _ in range(10000):
        # Get the current node's status
        status = nodes[(y, x)].lower()

        # Turn left or right depending on the current node's status
        if status == '.':
            direction = (direction - 1) % 4
        else:
            direction = (direction + 1) % 4

        # Infect or clean the current node
        if status == '.':
            nodes[(y, x)] = '#'
            infections += 1
        else:
            nodes[(y, x)] = '.'

        # Move forward one node in the current direction
        x += dx[direction]
        y += dy[direction]

        # Wrap around if necessary
        if x < 0:
            x += size_x
        elif x >= size_x:
            x -= size_x
        if y < 0:
            y += size_y
        elif y >= size_y:
            y -= size_y

        # Count the bursts
        bursts += 1

    print(infections)

if __name__ == '__main__':
    main()
",0
72,2017,23,1,runtime_error,,6724,"Traceback (most recent call last):
  File ""/tmp/tmpkyd0qbdr/tmp.py"", line 36, in <module>
    mul_count = run_program(file_path)
  File ""/tmp/tmpkyd0qbdr/tmp.py"", line 29, in run_program
    offset = execute_instruction(instructions[i], registers)
  File ""/tmp/tmpkyd0qbdr/tmp.py"", line 6, in execute_instruction
    x, y = re.findall(r""\w+"", instruction)
ValueError: too many values to unpack (expected 2)
","
import re

def execute_instruction(instruction, registers):
    if instruction.startswith(""set""):
        x, y = re.findall(r""\w+"", instruction)
        registers[x] = registers.get(y, int(y)) if y.isalpha() else int(y)
    elif instruction.startswith(""sub""):
        x, y = re.findall(r""\w+"", instruction)
        registers[x] -= registers.get(y, int(y))
    elif instruction.startswith(""mul""):
        x, y = re.findall(r""\w+"", instruction)
        registers[x] *= registers.get(y, int(y))
        return True
    elif instruction.startswith(""jnz""):
        x, y = re.findall(r""\w+"", instruction)
        if registers.get(x, int(x)):
            return int(y)
    return 0

def run_program(file_path):
    mul_count = 0
    instructions = []
    with open(file_path, ""r"") as f:
        instructions = [line.strip() for line in f.readlines()]
    i = 0
    registers = {r:0 for r in ""abcdefgh""}
    while i < len(instructions):
        offset = execute_instruction(instructions[i], registers)
        if offset:
            mul_count += 1
        i += offset if offset is not None else 1
    return mul_count

file_path = ""input.txt""
mul_count = run_program(file_path)
print(f""The mul instruction is invoked {mul_count} times."")
",0
73,2017,24,1,wrong_output,"The strength of the strongest bridge is: 2004
",2006,,"
import re
import itertools

def get_components():
    with open(""input.txt"", ""r"") as file:
        components = [re.findall(r'\d+', line) for line in file]
    return [[int(port) for port in component] for component in components]

def find_strongest_bridge(components):
    strongest_bridge = []
    max_strength = 0
    for bridge in generate_bridges(components):
        strength = sum(sum(component) for component in bridge)
        if strength > max_strength:
            strongest_bridge = bridge
            max_strength = strength
    return max_strength

def generate_bridges(components):
    for component in components:
        if component[0] == 0:
            yield from generate_bridges_from_component(components, [component], [0])

def generate_bridges_from_component(components, bridge, used_components):
    for i, component in enumerate(components):
        if i not in used_components:
            if component[0] == bridge[-1][1]:
                yield bridge + [component]
                yield from generate_bridges_from_component(components, bridge + [component], used_components + [i])
            elif component[1] == bridge[-1][1]:
                yield bridge + [component[::-1]]
                yield from generate_bridges_from_component(components, bridge + [component[::-1]], used_components + [i])

def main():
    components = get_components()
    strongest_bridge_strength = find_strongest_bridge(components)
    print(""The strength of the strongest bridge is:"", strongest_bridge_strength)

if __name__ == ""__main__"":
    main()
",0
74,2017,25,1,runtime_error,,2846,"Traceback (most recent call last):
  File ""/tmp/tmpu96cm5y6/tmp.py"", line 47, in <module>
    states, initial_state, checksum_steps = parse_blueprint(blueprint)
  File ""/tmp/tmpu96cm5y6/tmp.py"", line 40, in parse_blueprint
    value, move_direction, next_state = re.search(r""- Write the value (\d).\s+- Move one slot ([a-z]+).\s+- Continue with state (\w+)."", line).groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re
from collections import defaultdict

class TuringMachine:
    def __init__(self, states, initial_state, checksum_steps):
        self.states = states
        self.current_state = initial_state
        self.checksum_steps = checksum_steps
        self.cursor = 0
        self.tape = defaultdict(int)

    def run(self):
        for _ in range(self.checksum_steps):
            current_value = self.tape[self.cursor]
            next_value, move_direction, next_state = self.states[self.current_state][current_value]
            self.tape[self.cursor] = next_value
            self.cursor += move_direction
            self.current_state = next_state

    def checksum(self):
        return sum(self.tape.values())

def parse_blueprint(blueprint):
    states = {}
    current_state = None
    checksum_steps = None

    for line in blueprint.split(""\n""):
        if line.startswith(""Begin in state""):
            current_state = line.split()[-1]
        elif line.startswith(""Perform a diagnostic""):
            checksum_steps = int(re.search(r""Perform a diagnostic checksum after (\d+) steps"", line).group(1))
        elif line.startswith(""In state""):
            state = line.split()[-1][:-1]
            if state not in states:
                states[state] = {}
            current_state = state
        else:
            value, move_direction, next_state = re.search(r""- Write the value (\d).\s+- Move one slot ([a-z]+).\s+- Continue with state (\w+)."", line).groups()
            states[current_state][int(value)] = (int(value), 1 if move_direction == ""right"" else -1, next_state)

    return states, current_state, checksum_steps

with open(""input.txt"") as f:
    blueprint = f.read()
    states, initial_state, checksum_steps = parse_blueprint(blueprint)
    machine = TuringMachine(states, initial_state, checksum_steps)
    machine.run()
    print(machine.checksum())


with open(""input.txt"") as f:
    blueprint = f.read()
    states, initial_state, checksum_steps = parse_blueprint(blueprint)
    machine = TuringMachine(states, initial_state, checksum_steps)
    machine.run()
    print(machine.checksum())
",0
75,2018,1,1,wrong_output,"The resulting frequency is: 490
",490,,"
import sys

def main():
    input_file = open(""input.txt"", ""r"")
    input_list = input_file.readlines()
    frequency = 0

    for line in input_list:
        if line.startswith(""+""):
            frequency += int(line[1:])
        elif line.startswith(""-""):
            frequency -= int(line[1:])

    print(""The resulting frequency is:"", frequency)

if __name__ == ""__main__"":
    main()
",0
76,2018,2,1,wrong_output,"246357
",7163,,"
import collections

def count_letters(word):
    c = collections.Counter(word)
    return sum(1 for char, count in c.items() if count == 2) + 1, sum(1 for char, count in c.items() if count == 3) + 1

def checksum(ids):
    twos = 0
    threes = 0
    for id in ids:
        two, three = count_letters(id)
        twos += two
        threes += three
    return twos * threes

ids = []
with open(""input.txt"") as f:
    for line in f:
        ids.append(line.strip())

print(checksum(ids))
",0
77,2018,3,1,runtime_error,,109716,"Traceback (most recent call last):
  File ""/tmp/tmp1m6b5mj2/tmp.py"", line 43, in <module>
    main()
  File ""/tmp/tmp1m6b5mj2/tmp.py"", line 37, in main
    claims = generate_fabric_claims('input.txt')
  File ""/tmp/tmp1m6b5mj2/tmp.py"", line 10, in generate_fabric_claims
    claim_id, coords, size = re.match(r""#(\d+) @ (\d+),(\d+): (\d+)x(\d+)"", line).groups()
ValueError: too many values to unpack (expected 3)
","
import re

def generate_fabric_claims(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()

    claims = []
    for line in lines:
        claim_id, coords, size = re.match(r""#(\d+) @ (\d+),(\d+): (\d+)x(\d+)"", line).groups()
        left_edge, top_edge = int(coords.split(',')[0]), int(coords.split(',')[1])
        width, height = int(size.split('x')[0]), int(size.split('x')[1])
        claims.append((int(claim_id), left_edge, top_edge, width, height))

    return claims

def generate_fabric_matrix(claims, size=1000):
    fabric = [[0 for _ in range(size)] for _ in range(size)]

    for claim_id, left_edge, top_edge, width, height in claims:
        for i in range(top_edge, top_edge + height):
            for j in range(left_edge, left_edge + width):
                fabric[i][j] += 1

    return fabric

def count_overlapping_inches(fabric):
    count = 0
    for row in fabric:
        for inch in row:
            if inch > 1:
                count += 1

    return count

def main():
    claims = generate_fabric_claims('input.txt')
    fabric = generate_fabric_matrix(claims)
    overlapping_inches = count_overlapping_inches(fabric)
    print(overlapping_inches)

if __name__ == '__main__':
    main()


main('input.txt')
",0
78,2018,4,1,runtime_error,,73646,"Traceback (most recent call last):
  File ""/tmp/tmpp12_16oi/tmp.py"", line 69, in <module>
    print(part1(data))
  File ""/tmp/tmpp12_16oi/tmp.py"", line 24, in part1
    guards = guard_sleep_time(data)
  File ""/tmp/tmpp12_16oi/tmp.py"", line 16, in guard_sleep_time
    end_time = datetime.datetime.strptime(line[:11] + line[-2:], '%Y-%m-%d %H:%M')
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/_strptime.py"", line 568, in _strptime_datetime
    tt, fraction, gmtoff_fraction = _strptime(data_string, format)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/_strptime.py"", line 349, in _strptime
    raise ValueError(""time data %r does not match format %r"" %
ValueError: time data '[1518-05-11p\n' does not match format '%Y-%m-%d %H:%M'
","
import datetime
from collections import defaultdict

def guard_sleep_time(data):
    data = sorted(data, key=lambda x: x[0])
    guards = defaultdict(lambda: [0] * 60)
    current_guard = None
    start_time = None
    for line in data:
        if line.endswith('shift'):
            current_guard = int(line.split()[3][1:])
        elif line.endswith('asleep'):
            start_time = datetime.datetime.strptime(line[:11] + line[-2:], '%Y-%m-%d %H:%M')
        else:
            end_time = datetime.datetime.strptime(line[:11] + line[-2:], '%Y-%m-%d %H:%M')
            time_delta = end_time - start_time
            for i in range(time_delta.seconds // 60):
                guards[current_guard][start_time.minute + i] += 1

    return guards

def part1(data):
    guards = guard_sleep_time(data)
    max_sleepyhead = max(guards, key=lambda x: sum(guards[x]))
    max_sleep_minute = guards[max_sleepyhead].index(max(guards[max_sleepyhead]))
    return max_sleepyhead * max_sleep_minute

def guard_sleep_time_extended(data):
    data = sorted(data, key=lambda x: x[0])
    guards = defaultdict(lambda: [0] * 60)
    guard_minutes = defaultdict(int)
    current_guard = None
    start_time = None
    for line in data:
        if line.endswith('shift'):
            current_guard = int(line.split()[3][1:])
        elif line.endswith('asleep'):
            start_time = datetime.datetime.strptime(line[:11] + line[-2:], '%Y-%m-%d %H:%M')
        else:
            end_time = datetime.datetime.strptime(line[:11] + line[-2:], '%Y-%m-%d %H:%M')
            time_delta = end_time - start_time
            for i in range(time_delta.seconds // 60):
                guards[current_guard][start_time.minute + i] += 1
                guard_minutes[current_guard] += 1

    max_sleepyhead = max(guard_minutes, key=lambda x: max(guards[x]))
    max_sleep_minute = guards[max_sleepyhead].index(max(guards[max_sleepyhead]))
    return max_sleepyhead * max_sleep_minute

def part2(data):
    guards = guard_sleep_time(data)
    max_sleepyhead = None
    max_minute = 0
    max_sleep_count = 0
    for guard in guards:
        sleep_count = max(guards[guard])
        minute = guards[guard].index(sleep_count)
        if sleep_count > max_sleep_count:
            max_sleep_count = sleep_count
            max_sleepyhead = guard
            max_minute = minute

    return max_sleepyhead * max_minute

if __name__ == ""__main__"":
    with open('input.txt', 'r') as f:
        data = f.readlines()
    print(part1(data))
    print(part2(data))
",0
79,2018,5,1,runtime_error,"0
",9686,"/tmp/tmpysia4mqf/tmp.py:7: DeprecationWarning: Flags not at the start of the expression '([a-zA-Z])(?!\x01)([a-z' (truncated)
  polymer, changed = re.subn('([a-zA-Z])(?!\1)([a-zA-Z])(?i)', '', polymer)
","
import re

def react_polymer(polymer):
    changed = True
    while changed:
        polymer, changed = re.subn('([a-zA-Z])(?!\1)([a-zA-Z])(?i)', '', polymer)
    return len(polymer)

with open('input.txt', 'r') as f:
    polymer = f.read().strip()
    result = react_polymer(polymer)
    print(result)
",0
80,2018,6,1,syntax_error,,3909,"  File ""/tmp/tmpdc6cnsr0/tmp.py"", line 20
    closest_count = sum(1 for c in coordinates if manhattan_distance((x, y), c) == manhattan_distance((x, y), closest_coordinate[(x, y])) and closest_coordinate[(x, y)] != '.')
                                                                                                                                      ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import math
from collections import defaultdict

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def calculate_areas(coordinates):
    # Initialize the grid and the closest_coordinate dictionary
    max_x, max_y = max([x for x, y in coordinates]), max([y for x, y in coordinates])
    grid = [['.' for x in range(max_x + 1)] for y in range(max_y + 1)]
    closest_coordinate = defaultdict(int)
    
    # Loop through each cell in the grid
    for x in range(max_x + 1):
        for y in range(max_y + 1):
            # Calculate the distance to each coordinate and store the closest one
            closest_coordinate[(x, y)] = min(coordinates, key=lambda c: manhattan_distance((x, y), c))
            distance_sum = sum(manhattan_distance((x, y), c) for c in coordinates)
            closest_count = sum(1 for c in coordinates if manhattan_distance((x, y), c) == manhattan_distance((x, y), closest_coordinate[(x, y])) and closest_coordinate[(x, y)] != '.')
            # Mark the cell if it's within the closest distance sum
            if distance_sum < 100000:
                grid[y][x] = closest_coordinate[(x, y)]
            # If there are multiple closest coordinates, mark the cell as '.'
            elif closest_count > 1:
                grid[y][x] = '.'
    
    # Calculate the areas for each coordinate
    areas = defaultdict(int)
    for x in range(max_x + 1):
        for y in range(max_y + 1):
            if grid[y][x] != '.':
                areas[grid[y][x]] += 1
    
    # Remove the infinite areas and return the maximum area
    areas.pop('.', None)
    return max(areas.values())

# Read input from file
with open('input.txt', 'r') as file:
    coordinates = [tuple(map(int, line.strip().split(',')) for line in file]
    
print(calculate_areas(coordinates))


def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def calculate_areas(coordinates):
    # Initialize the grid and the closest_coordinate dictionary
    max_x, max_y = max([x for x, y in coordinates]), max([y for x, y in coordinates])
    grid = [['.' for x in range(max_x + 1)] for y in range(max_y + 1)]
    closest_coordinate = {}
    for x in range(max_x + 1):
        for y in range(max_y + 1):
            closest_coordinate[(x, y)] = min(coordinates, key=lambda c: manhattan_distance((x, y), c))
            distance_sum = sum(manhattan_distance((x, y), c) for c in coordinates)
            closest_count = sum(1 for c in coordinates if manhattan_distance((x, y), c) == manhattan_distance((x, y), closest_coordinate[(x, y])) and closest_coordinate[(x, y)] != '.')
            if distance_sum < 100000:
                grid[y][x] = closest_coordinate[(x, y)]
            elif closest_count > 1:
                grid[y][x] = '.'
    
    # Calculate the areas for each coordinate
    areas = {}
    for x in range(max_x + 1):
        for y in range(max_y + 1):
            if grid[y][x] != '.':
                areas[grid[y][x]] = areas.get(grid[y][x], 0) + 1
    
    # Remove the infinite areas and return the maximum area
    areas.pop('.', None)
    return max(areas.values())

# Read input from file
with open('input.txt', 'r') as file:
    coordinates = [tuple(map(int, line.strip().split(',')) for line in file]

print(calculate_areas(coordinates))
",0
81,2018,7,1,runtime_error,,GKRVWBESYAMZDPTIUCFXQJLHNO,"Traceback (most recent call last):
  File ""/tmp/tmpyl6qmhap/tmp.py"", line 17, in <module>
    step = ready[0]
IndexError: list index out of range
","import re

file = open('input.txt', 'r')
data = file.readlines()
deps = {}
for line in data:
  req, step = re.match(r'Step ([A-Z]) must be finished before step ([A-Z]) can begin.', line.strip()).groups()
  if req not in deps:
    deps[req] = set()
  deps[step] = deps.get(step, set())
  deps[req].add(step)

steps = set(deps.keys())
order = ''
while steps:
  ready = sorted([s for s in steps if not deps.get(s, set())])
  step = ready[0]
  steps.remove(step)
  order += step
  for dep in deps:
    if step in deps[dep]:
      deps[dep].remove(step)
      if not deps[dep]:
        steps.remove(dep)

print(order) ",0
82,2018,8,1,wrong_output,"63952
63952
",47244,,"
def process_node(data):
    # Extract header information
    children, metas = data[:2]
    data = data[2:]
    # Calculate sum of metadata
    meta_sum = sum(data[:metas])
    # Process child nodes
    for _ in range(children):
        total, data = process_node(data)
        meta_sum += total
    return meta_sum, data[metas:]

# Read input file
with open('input.txt', 'r') as f:
    data = [int(x) for x in f.read().strip().split()]

total, remaining = process_node(data)

# Print the sum of all metadata entries
print(total)


def process_node(data):
    # Extract header information
    children, metas = data[:2]
    data = data[2:]
    # Calculate sum of metadata
    meta_sum = sum(data[:metas])
    # Process child nodes
    for _ in range(children):
        total, data = process_node(data)
        meta_sum += total
    return meta_sum, data[metas:]

# Read input file
with open('input.txt', 'r') as f:
    data = [int(x) for x in f.read().strip().split()]

total, remaining = process_node(data)

# Print the sum of all metadata entries
print(total)
",0
83,2018,9,1,runtime_error,,384288,"Traceback (most recent call last):
  File ""/tmp/tmpor7tacqy/tmp.py"", line 7, in <module>
    players, last_marble = map(int, data.split())
ValueError: invalid literal for int() with base 10: 'players;'
","
from collections import defaultdict

with open('input.txt') as f:
    data = f.read().strip()

players, last_marble = map(int, data.split())

current_marble = 0
current_player = 0
scores = defaultdict(int)
marbles = [0]

for marble in range(1, last_marble + 1):
    if marble % 23 == 0:
        scores[current_player] += marble
        remove_idx = (current_marble - 7) % len(marbles)
        scores[current_player] += marbles.pop(remove_idx)
        current_marble = remove_idx % len(marbles)
    else:
        current_marble = (current_marble + 2) % len(marbles)
        marbles.insert(current_marble, marble)
    current_player = (current_player + 1) % players

print(max(scores.values()))
",0
84,2018,10,1,runtime_error,,GFNKCGGH,"Traceback (most recent call last):
  File ""/tmp/tmp6tju6om7/tmp.py"", line 23, in <module>
    for p in points.keys():
RuntimeError: dictionary changed size during iteration
","
import re
from collections import defaultdict

with open('input.txt') as f:
    data = f.readlines()

points = defaultdict(list)
timestep = 1

for line in data:
    x, y, vx, vy = map(int, re.findall(r'-?\d+', line))
    points[(x, y)] = [vx, vy]

min_x = min(p[0] for p in points.keys())
max_x = max(p[0] for p in points.keys())
min_y = min(p[1] for p in points.keys())
max_y = max(p[1] for p in points.keys())

while True:
    new_points = defaultdict(list)
    for i in range(1000000):
        for p in points.keys():
            new_p = (p[0] + points[p][0], p[1] + points[p][1])
            new_points[new_p] = points[p]
        points = new_points
        min_x = min(p[0] for p in points.keys())
        max_x = max(p[0] for p in points.keys())
        min_y = min(p[1] for p in points.keys())
        max_y = max(p[1] for p in points.keys())
        if max_x - min_x <= 100 and max_y - min_y <= 100:
            break
        timestep += 1

    output = []
    for y in range(min_y, max_y + 1):
        row = [' ' for x in range(min_x, max_x + 1)]
        for p in points.keys():
            if p[1] == y:
                row[p[0] - min_x] = '#'
        output.append(row)

    for row in output:
        print(''.join(row))
    print()
    if i == 9:
        break
",0
85,2018,11,1,wrong_output,"The top-left coordinate of the 3x3 square with the largest total power is (62, 234) with a total power of 29
","235,63",,"
def get_power_level(x, y, serial_number):
    rack_id = x + 10
    power = (rack_id * y + serial_number) * rack_id
    power = (power // 100) % 10 - 5
    return power

def get_3x3_power(grid, x, y):
    return sum([grid[x+i][y+j] for i in range(3) for j in range(3)])

def find_largest_3x3_square(grid, serial_number):
    max_power = float('-inf')
    max_coord = None
    for x in range(1, 301-3):
        for y in range(1, 301-3):
            power = get_3x3_power(grid, x, y)
            if power > max_power:
                max_power = power
                max_coord = (x, y)
    return max_coord, max_power

serial_number = 0
with open('input.txt', 'r') as file:
    serial_number = int(file.readline().strip())

grid = [[get_power_level(x, y, serial_number) for x in range(1, 301)] for y in range(1, 301)]

largest_coord, largest_power = find_largest_3x3_square(grid, serial_number)
print(f""The top-left coordinate of the 3x3 square with the largest total power is {largest_coord} with a total power of {largest_power}"")
",0
86,2018,12,1,wrong_output,"0
",4110,,"
import re

def read_input_file(filename):
    with open(filename, 'r') as file:
        input_lines = file.readlines()
    initial_state = input_lines[0].strip().split(' ')[2]
    rules = dict()
    for line in input_lines[2:]:
        pattern, result = re.match(r'(...)(.)', line.strip()).groups()
        rules[pattern] = result
    return initial_state, rules

def generate_pots(state, rules):
    pots = list(state)
    for _ in range(20):
        new_pots = ['.'] * len(pots)
        for i in range(2, len(pots) - 2):
            pattern = ''.join(pots[i-2:i+3])
            new_pots[i] = rules.get(pattern, '.')
        pots = [''.join(pots[2:4])] + new_pots + [''.join(pots[-3:-1])]
    return pots

def sum_numbers(pots):
    return sum(i for i, pot in enumerate(pots) if pot == '#')

def main():
    initial_state, rules = read_input_file('input.txt')
    final_pots = generate_pots(initial_state, rules)
    print(sum_numbers(final_pots))

if __name__ == '__main__':
    main()
",0
87,2018,13,1,runtime_error,,"79,128","Traceback (most recent call last):
  File ""/tmp/tmp7qg0cep1/tmp.py"", line 64, in <module>
    main()
  File ""/tmp/tmp7qg0cep1/tmp.py"", line 48, in main
    if tracks[new_x, new_y] == '+':
UnboundLocalError: local variable 'new_x' referenced before assignment
","
import sys
from collections import defaultdict

def main():
    tracks = defaultdict(str)
    carts = []
    with open('input.txt', 'r') as f:
        for y, line in enumerate(f.readlines()):
            for x, char in enumerate(line):
                if char in ['>', '<', '^', 'v']:
                    carts.append((x, y, char, 0))
                tracks[x, y] = char

    while True:
        carts.sort()
        for i, (x, y, direction, turn) in enumerate(carts):
            if direction == '^':
                new_y = y - 1
                new_direction = '^'
                if tracks[x, new_y] == '/':
                    new_direction = '>' if direction == '<' else '<'
                elif tracks[x, new_y] == '\\':
                    new_direction = '<' if direction == '<' else '>'
            elif direction == 'v':
                new_y = y + 1
                new_direction = 'v'
                if tracks[x, new_y] == '/':
                    new_direction = '<' if direction == '<' else '>'
                elif tracks[x, new_y] == '\\':
                    new_direction = '>' if direction == '<' else '<'
            elif direction == '<':
                new_x = x - 1
                new_direction = '<'
                if tracks[new_x, y] == '/':
                    new_direction = 'v' if direction == '^' else '^'
                elif tracks[new_x, y] == '\\':
                    new_direction = 'v' if direction == 'v' else '^'
            elif direction == '>':
                new_x = x + 1
                new_direction = '>'
                if tracks[new_x, y] == '/':
                    new_direction = '^' if direction == '^' else 'v'
                elif tracks[new_x, y] == '\\':
                    new_direction = 'v' if direction == '^' else 'v'

            new_turn = (turn + 1) % 3
            if tracks[new_x, new_y] == '+':
                if new_turn == 0:
                    new_direction = {'^': '<', 'v': '^', '<': 'v', '>': '>', '^': '>', 'v': '<'}[direction]
                elif new_turn == 1:
                    new_direction = direction
                else:
                    new_direction = {'^': '>', 'v': 'v', '<': '<', '>': '^', '^': '<', 'v': 'v'}[direction]

            carts[i] = (new_x, new_y, new_direction, new_turn)

            for j, (x2, y2, direction2, turn2) in enumerate(carts):
                if i != j and (x, y) == (x2, y2):
                    print(f""Crash at {x},{y}"")
                    sys.exit(0)

if __name__ == '__main__':
    main()
",0
88,2018,14,1,timeout_error,,9411137133,TIMEOUT,"
import re

def generate_recipe(scores, elf1, elf2):
    new_recipe = str(scores[elf1] + scores[elf2])
    for digit in new_recipe:
        scores.append(int(digit))

    elf1 = (elf1 + 1 + scores[elf1]) % len(scores)
    elf2 = (elf2 + 1 + scores[elf2]) % len(scores)
    return elf1, elf2


def solve_part1(num_recipes):
    scores = [3, 7]
    elf1, elf2 = 0, 1

    while len(scores) < num_recipes + 10:
        elf1, elf2 = generate_recipe(scores, elf1, elf2)

    return ''.join(map(str, scores[num_recipes:num_recipes+10]))

def solve_part2(target_str):
    scores = [3, 7]
    elf1, elf2 = 0, 1

    while ''.join(map(str, scores[-len(target_str):])).find(target_str) == -1:
        elf1, elf2 = generate_recipe(scores, elf1, elf2)

    return len(scores) - len(target_str)

with open('input.txt', 'r') as file:
    num_recipes = int(file.read().strip())

print(solve_part1(num_recipes))
print(solve_part2(str(num_recipes)))
",0
89,2018,15,1,runtime_error,,201638,"Traceback (most recent call last):
  File ""/tmp/tmpb70u1f5x/tmp.py"", line 129, in <module>
    main(os.path.join(sys.path[0], ""input.txt""))
  File ""/tmp/tmpb70u1f5x/tmp.py"", line 123, in main
    rounds, remaining_hit_points = simulate_combat(board, elves, goblins)
  File ""/tmp/tmpb70u1f5x/tmp.py"", line 101, in simulate_combat
    units = elves + goblins
TypeError: unsupported operand type(s) for +: 'set' and 'set'
","
import sys
import os

def read_input(file_path):
    with open(file_path, 'r') as file:
        return file.readlines()

def parse_input(input_list):
    rows = len(input_list)
    cols = len(input_list[0].strip())
    return rows, cols, [list(line.strip()) for line in input_list]

def print_board(board):
    for row in board:
        print(''.join(row))

def find_starting_positions(board):
    elves = []
    goblins = []
    for i in range(len(board)):
        for j in range(len(board[0])):
            if board[i][j] == 'E':
                elves.append((i,j))
            elif board[i][j] == 'G':
                goblins.append((i,j))
    return elves, goblins

def find_targets(unit_type, board, units):
    if unit_type == 'E':
        target_type = 'G'
    else:
        target_type = 'E'
    targets = []
    for unit in units:
        row, col = unit
        for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
            if 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] == target_type:
                targets.append((r,c))
    return targets

def find_reachable_squares(unit_pos, board, units):
    row, col = unit_pos
    reachable_squares = []
    for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
        if 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] == '.' and (r,c) not in units:
            reachable_squares.append((r,c))
    return reachable_squares

def find_closest_square(unit_pos, reachable_squares):
    min_steps = None
    closest_square = None
    for square in reachable_squares:
        steps = abs(square[0] - unit_pos[0]) + abs(square[1] - unit_pos[1])
        if min_steps is None or steps < min_steps:
            min_steps = steps
            closest_square = square
        elif steps == min_steps:
            if square < closest_square:
                closest_square = square
    return closest_square

def move_unit(unit_pos, closest_square, board, units):
    row, col = unit_pos
    new_row, new_col = closest_square
    board[row][col] = '.'
    board[new_row][new_col] = 'E' if board[row][col] == 'G' else 'G'
    units.remove(unit_pos)
    units.add((new_row, new_col))
    return units

def find_closest_target(unit_pos, board, targets):
    min_distance = None
    closest_target = None
    for target in targets:
        distance = abs(target[0] - unit_pos[0]) + abs(target[1] - unit_pos[1])
        if min_distance is None or distance < min_distance:
            min_distance = distance
            closest_target = target
        elif distance == min_distance:
            if target < closest_target:
                closest_target = target
    return closest_target

def attack(unit_pos, board, units, target_type):
    row, col = unit_pos
    for r, c in [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]:
        if 0 <= r < len(board) and 0 <= c < len(board[0]) and board[r][c] == target_type:
            if (r,c) in units:
                units[target_type].remove((r,c))
                if not units[target_type]:
                    return False
                else:
                    board[r][c] = '.'
                    break
    return True

def simulate_combat(board, elves, goblins):
    rounds = 0
    while elves and goblins:
        units = elves + goblins
        units.sort()
        for unit_pos in units:
            unit_type = 'E' if unit_pos in elves else 'G'
            targets = find_targets(unit_type, board, units)
            if not targets:
                continue
            reachable_squares = find_reachable_squares(unit_pos, board, units)
            if reachable_squares:
                closest_square = find_closest_square(unit_pos, reachable_squares)
                units = move_unit(unit_pos, closest_square, board, units)
            if attack(unit_pos, board, units, 'E' if unit_type == 'G' else 'G'):
                continue
        rounds += 1
    return rounds, sum(units[unit_type].values())

def main(file_path):
    input_list = read_input(file_path)
    rows, cols, board = parse_input(input_list)
    elves, goblins = find_starting_positions(board)
    elves = set(elves)
    goblins = set(goblins)
    rounds, remaining_hit_points = simulate_combat(board, elves, goblins)
    print(f""Combat ends after {rounds} rounds"")
    print(f""Elves win with {remaining_hit_points} total hit points left"")
    print(f""Outcome: {rounds} * {remaining_hit_points} = {rounds * remaining_hit_points}"")

if __name__ == ""__main__"":
    main(os.path.join(sys.path[0], ""input.txt""))
",0
90,2018,16,1,no_error,"642
",642,,"
import re
from collections import defaultdict

# Sample Input
# Before: [1, 2, 3, 4]
# 9 2 3 4
# After:  [1, 2, 3, 4]

# 9 3 4 5
# After: [1, 2, 3, 5]

# 9 1 2 3
# After: [1, 3, 4, 3]

# 9 1 1 3
# After: [2, 3, 4, 3]

# 9 3 1 4
# After: [1, 2, 4, 3]

# 9 1 4 3
# After: [1, 2, 5, 3]

# 9 1 5 3
# After: [1, 3, 3, 3]

# 9 2 4 3
# After: [1, 2, 3, 4]

# 9 1 3 4
# After: [2, 3, 4, 3]

# 9 4 2 4
# After: [1, 2, 3, 4]

samples = []
with open('input.txt') as file:
    for line in file:
        line = line.strip()
        if line.startswith('Before'):
            match = re.search(r'\[(\d+), (\d+), (\d+), (\d+)\]', line)
            before = [int(match.group(1)), int(match.group(2)), int(match.group(3)), int(match.group(4))]
            line = file.readline().strip()
            match = re.search(r'(\d+) (\d+) (\d+) (\d+)', line)
            op, a, b, c = map(int, match.groups())
            line = file.readline().strip()
            match = re.search(r'\[(\d+), (\d+), (\d+), (\d+)\]', line)
            after = [int(match.group(1)), int(match.group(2)), int(match.group(3)), int(match.group(4))]
            samples.append((before, op, a, b, c, after))

def addr(a, b, c, reg):
    reg[c] = reg[a] + reg[b]

def addi(a, b, c, reg):
    reg[c] = reg[a] + b

def mulr(a, b, c, reg):
    reg[c] = reg[a] * reg[b]

def muli(a, b, c, reg):
    reg[c] = reg[a] * b

def banr(a, b, c, reg):
    reg[c] = reg[a] & reg[b]

def bani(a, b, c, reg):
    reg[c] = reg[a] & b

def borr(a, b, c, reg):
    reg[c] = reg[a] | reg[b]

def bori(a, b, c, reg):
    reg[c] = reg[a] | b

def setr(a, b, c, reg):
    reg[c] = reg[a]

def seti(a, b, c, reg):
    reg[c] = a

def gtir(a, b, c, reg):
    reg[c] = int(a > reg[b])

def gtri(a, b, c, reg):
    reg[c] = int(reg[a] > b)

def gtrr(a, b, c, reg):
    reg[c] = int(reg[a] > reg[b])

def eqir(a, b, c, reg):
    reg[c] = int(a == reg[b])

def eqri(a, b, c, reg):
    reg[c] = int(reg[a] == b)

def eqrr(a, b, c, reg):
    reg[c] = int(reg[a] == reg[b])

def execute(op, a, b, c, reg):
    if op == 0:
        addr(a, b, c, reg)
    elif op == 1:
        addi(a, b, c, reg)
    elif op == 2:
        mulr(a, b, c, reg)
    elif op == 3:
        muli(a, b, c, reg)
    elif op == 4:
        banr(a, b, c, reg)
    elif op == 5:
        bani(a, b, c, reg)
    elif op == 6:
        borr(a, b, c, reg)
    elif op == 7:
        bori(a, b, c, reg)
    elif op == 8:
        setr(a, b, c, reg)
    elif op == 9:
        seti(a, b, c, reg)
    elif op == 10:
        gtir(a, b, c, reg)
    elif op == 11:
        gtri(a, b, c, reg)
    elif op == 12:
        gtrr(a, b, c, reg)
    elif op == 13:
        eqir(a, b, c, reg)
    elif op == 14:
        eqri(a, b, c, reg)
    elif op == 15:
        eqrr(a, b, c, reg)

count = 0
for before, op, a, b, c, after in samples:
    matches = 0
    for i in range(16):
        reg = before.copy()
        execute(i, a, b, c, reg)
        if reg == after:
            matches += 1
    if matches >= 3:
        count += 1

print(count)
",0
91,2018,17,1,runtime_error,,31788,"Traceback (most recent call last):
  File ""/tmp/tmp7_gqllzy/tmp.py"", line 69, in <module>
    main()
  File ""/tmp/tmp7_gqllzy/tmp.py"", line 63, in main
    clay = parse_input('input.txt')
  File ""/tmp/tmp7_gqllzy/tmp.py"", line 8, in parse_input
    x_vals, y_vals = re.findall(r'x=(\d+)\.\.(\d+), y=(\d+)\.\.(\d+)', line.strip())[0]
IndexError: list index out of range
","
import re

def parse_input(input_file):
    clay = set()
    with open(input_file, 'r') as f:
        for line in f.readlines():
            x_vals, y_vals = re.findall(r'x=(\d+)\.\.(\d+), y=(\d+)\.\.(\d+)', line.strip())[0]
            for x in range(int(x_vals[0]), int(x_vals[1]) + 1):
                for y in range(int(y_vals[0]), int(y_vals[1]) + 1):
                    clay.add((x, y))
    return clay

def generate_grid(clay):
    grid = set()
    for x, y in clay:
        grid.add((x, y))
    return grid

def generate_water(grid, spring_x, min_y, max_y):
    spring = (spring_x, 0)
    grid.add(spring)
    while True:
        new_water = set()
        for x, y in grid:
            if y == max_y:
                continue
            if (x, y + 1) not in grid and (x, y + 1) not in new_water:
                new_water.add((x, y + 1))
        if not new_water:
            break
        grid.update(new_water)

        to_remove = set()
        for x, y in new_water:
            left_x = x - 1
            right_x = x + 1
            while left_x in grid and (left_x, y) not in grid:
                left_x -= 1
            while right_x in grid and (right_x, y) not in grid:
                right_x += 1
            left_bound = left_x + 1
            right_bound = right_x - 1
            if y < max_y and all(i in grid for i in [(left_x, y), (right_x, y)]):
                for x in range(left_bound, right_bound + 1):
                    if (x, y) not in grid:
                        grid.add((x, y))
                        new_water.add((x, y))
            elif y < max_y and (left_bound, y + 1) not in grid and (right_bound, y + 1) not in grid:
                for x in range(left_bound, right_bound + 1):
                    to_remove.add((x, y))
        grid.difference_update(to_remove)
    return len(grid)

def count_water(grid, min_y, max_y):
    count = 0
    for x, y in grid:
        if min_y <= y <= max_y:
            count += 1
    return count

def main():
    clay = parse_input('input.txt')
    grid = generate_grid(clay)
    water_count = generate_water(grid, 500, min(clay, key=lambda x: x[1])[1], max(clay, key=lambda x: x[1])[1])
    print(f""The total number of tiles water can reach is: {water_count}"")

if __name__ == ""__main__"":
    main()
",0
92,2018,18,1,wrong_output,"198230
",653184,,"
import sys
from collections import Counter

def update_acre(x, y, acres, max_x, max_y):
    adjacent_acres = [(x - 1, y - 1), (x, y - 1), (x + 1, y - 1), (x - 1, y), (x + 1, y), (x - 1, y + 1), (x, y + 1), (x + 1, y + 1), (x, y + 1)]
    adjacent_values = []
    for pos in adjacent_acres:
        if pos[0] >= 0 and pos[1] >= 0 and pos[0] < max_x and pos[1] < max_y:
            adjacent_values.append(acres.get(pos, ""."")[0])
        else:
            adjacent_values.append(""."")
    if acres[(x, y)] == ""."":
        if adjacent_values.count(""|"") >= 3:
            return ""|""
    elif acres[(x, y)] == ""|"":
        if adjacent_values.count(""#"") >= 3:
            return ""#""
    elif acres[(x, y)] == ""#"":
        if adjacent_values.count(""#"") >= 1 and adjacent_values.count(""|"") >= 1:
            return acres[(x, y)]
        else:
            return "".""
    return acres[(x, y)]

def main():
    with open(""input.txt"", ""r"") as input_file:
        acres = {}
        y = 0
        for line in input_file.readlines():
            x = 0
            for char in line.strip():
                acres[(x, y)], x = char, x + 1
            y += 1
        max_x, max_y = x, y

    for minute in range(10):
        new_acres = {}
        for y in range(max_y):
            for x in range(max_x):
                new_acres[(x, y)] = update_acre(x, y, acres, max_x, max_y)
        acres = new_acres

    wooded_acres = Counter(acres.values())[""|""]
    lumberyards = Counter(acres.values())[""#""]
    print(wooded_acres * lumberyards)

if __name__ == ""__main__"":
    main()
",0
93,2018,19,1,runtime_error,,2520,"Traceback (most recent call last):
  File ""/tmp/tmp8zxefljg/tmp.py"", line 64, in <module>
    registers = run_program(program, ip_reg, registers)
  File ""/tmp/tmp8zxefljg/tmp.py"", line 50, in run_program
    registers = execute_instruction(registers, instruction, ip_reg, registers[ip_reg])
  File ""/tmp/tmp8zxefljg/tmp.py"", line 10, in execute_instruction
    registers[c] = registers[a] + b
TypeError: list indices must be integers or slices, not str
","
import operator
import re

def execute_instruction(registers, instruction, ip_reg, ip):
    opcode, a, b, c = instruction
    if opcode == 'addr':
        registers[c] = registers[a] + registers[b]
    elif opcode == 'addi':
        registers[c] = registers[a] + b
    elif opcode == 'mulr':
        registers[c] = registers[a] * registers[b]
    elif opcode == 'muli':
        registers[c] = registers[a] * b
    elif opcode == 'banr':
        registers[c] = registers[a] & registers[b]
    elif opcode == 'bani':
        registers[c] = registers[a] & b
    elif opcode == 'borr':
        registers[c] = registers[a] | registers[b]
    elif opcode == 'bori':
        registers[c] = registers[a] | b
    elif opcode == 'setr':
        registers[c] = registers[a]
    elif opcode == 'seti':
        registers[c] = a
    elif opcode == 'gtir':
        registers[c] = int(a > registers[b])
    elif opcode == 'gtri':
        registers[c] = int(registers[a] > b)
    elif opcode == 'gtrr':
        registers[c] = int(registers[a] > registers[b])
    elif opcode == 'eqir':
        registers[c] = int(a == registers[b])
    elif opcode == 'eqri':
        registers[c] = int(registers[a] == b)
    elif opcode == 'eqrr':
        registers[c] = int(registers[a] == registers[b])
    else:
        raise ValueError('Invalid opcode')

    return registers

def run_program(program, ip_reg, initial_registers):
    registers = initial_registers.copy()
    num_instructions = len(program)
    while registers[ip_reg] >= 0 and registers[ip_reg] < num_instructions:
        instruction = program[registers[ip_reg]]
        registers[ip_reg] = registers[ip_reg] + 1
        registers = execute_instruction(registers, instruction, ip_reg, registers[ip_reg])
    return registers

with open('input.txt', 'r') as f:
    lines = f.readlines()

ip_reg = int(re.findall(r'#ip (\d)', lines[0])[0])
program = []

for line in lines[1:]:
    instruction = re.findall(r'(\w+) (\d+) (\d+) (\d+)', line)
    program.append(instruction[0])

registers = [0, 0, 0, 0, 0, 0, 0]
registers = run_program(program, ip_reg, registers)

print(registers[0])
",0
94,2018,20,1,runtime_error,,4432,"Traceback (most recent call last):
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 52, in <module>
    max_dist, doors = generate_map(regex)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 47, in generate_map
    generate_map_helper(regex.strip('^$'), current_pos, direction)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 22 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 5 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 12 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 13 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 4 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 12 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 50 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 29 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 12 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 12 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 26 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 5 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 21 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 7 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 13 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 29 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 17 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 6 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 35 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 14 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 9 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 14 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 15 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 13 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 4 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 2 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 5 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 43 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 3 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 12 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 17 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 6 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 26 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 3 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 3 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 5 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 6 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 3 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 6 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 4 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 9 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 2 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 91 more times]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 35, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 32, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  [Previous line repeated 1 more time]
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 38, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 41, in generate_map_helper
    generate_map_helper(regex[1:], pos, d)
  File ""/tmp/tmpihmrsdk_/tmp.py"", line 24, in generate_map_helper
    pos = update_pos(regex[0])
RecursionError: maximum recursion depth exceeded
","
import re
import math

def generate_map(regex):
    current_pos = (0,0)
    direction = 0
    stack = []
    doors = []
    visited = set()
    max_dist = 0
    directions = {'N': (-1, 0), 'S': (1, 0), 'W': (0, -1), 'E': (0, 1)}

    def update_pos(d):
        nonlocal current_pos, direction
        current_pos = (current_pos[0] + directions[d][0], current_pos[1] + directions[d][1])
        direction = (direction + (1 if d in 'ES' else -1)) % 4
        return current_pos

    def generate_map_helper(regex, pos, d):
        if not regex:
            return
        if regex[0] in 'NESW':
            pos = update_pos(regex[0])
            doors.append(pos)
            if pos not in visited:
                visited.add(pos)
                dist = abs(pos[0]) + abs(pos[1])
                nonlocal max_dist
                if dist > max_dist:
                    max_dist = dist
            generate_map_helper(regex[1:], pos, d)
        elif regex[0] == '(':
            stack.append((pos, d))
            generate_map_helper(regex[1:], pos, d)
        elif regex[0] == '|':
            pos, d = stack[-1]
            generate_map_helper(regex[1:], pos, d)
        elif regex[0] == ')':
            stack.pop()
            generate_map_helper(regex[1:], pos, d)
        elif regex[0] == '^':
            generate_map_helper(regex[1:], pos, d)
        elif regex[0] == '$':
            pass

    generate_map_helper(regex.strip('^$'), current_pos, direction)
    return max_dist, doors

with open('input.txt', 'r') as f:
    regex = f.readline().strip()
    max_dist, doors = generate_map(regex)
    print(max_dist)
",0
95,2018,21,1,runtime_error,,2159153,"Traceback (most recent call last):
  File ""/tmp/tmpg2uz9qae/tmp.py"", line 99, in <module>
    print(find_lowest_halt('input.txt'))
  File ""/tmp/tmpg2uz9qae/tmp.py"", line 95, in find_lowest_halt
    if run_program(input_file, registers) == 0:
TypeError: run_program() takes 1 positional argument but 2 were given
","
import re

def bani(a, b):
    return a & b

def bani_test():
    if bani(1, 2) == 0:
        return True
    if bani(1, -2) == -2:
        return True
    if bani(-1, 2) == -2:
        return True
    if bani(-1, -2) == -1:
        return True
    if bani(12, 12) == 12:
        return True
    return False

def borr(a, b):
    return a | b

def bori(a, b):
    return a | b

def gtir(a, b):
    return 1 if a > b else 0

def setr(a, b):
    return a

def seti(a, b):
    return b

def eqir(a, b):
    return 1 if a == b else 0

def eqri(a, b):
    return 1 if b == a else 0

def eqrr(a, b):
    return 1 if a == b else 0

def gtri(a, b):
    return 1 if a > b else 0

def gtrr(a, b):
    return 1 if a > b else 0

def addr(a, b):
    return a + b

def mulr(a, b):
    return a * b

def muli(a, b):
    return a * b

def addi(a, b):
    return a + b

def parse_line(line):
    return list(map(int, re.findall(r'-?\d+', line)))

def parse_input(input_file):
    lines = open(input_file).readlines()
    ip_line = lines[0]
    ip_reg = int(ip_line.split()[1])
    instructions = [parse_line(line) for line in lines[1:]]
    return ip_reg, instructions

def execute_instruction(instructions, ip_reg, ip, registers, func_dict):
    instruction = instructions[ip]
    opcode, *args = instruction
    registers[ip_reg] = ip
    func = func_dict[opcode]
    registers[args[2]] = func(registers[args[0]], args[1])
    ip = registers[ip_reg] + 1
    return ip

def run_program(input_file):
    ip_reg, instructions = parse_input(input_file)
    registers = [0] * 6
    ip = 0
    func_dict = {'bani': bani, 'bori': bori, 'borr': borr, 'gtri': gtri, 'gtir': gtri, 'seti': seti, 'setr': setr, 'eqir': eqir, 'eqri': eqri, 'eqrr': eqrr, 'addr': addr, 'addi': addi, 'muli': muli}
    while ip < len(instructions):
        if ip == 5:
            if registers[3] == registers[4]:
                return registers[5]
        ip = execute_instruction(instructions, ip_reg, ip, registers, func_dict)

def find_lowest_halt(input_file):
    for i in range(10**9):
        registers = [i, 0, 0, 0, 0, 0, 0, 0]
        if run_program(input_file, registers) == 0:
            return i

if bani_test():
    print(find_lowest_halt('input.txt'))
else:
    print(""Test failed, cannot proceed with execution"")
",0
96,2018,22,1,wrong_output,"116
",11972,,"
import math

def risk_level(depth, target_x, target_y):
    def geologic_index(x, y):
        if x == 0 and y == 0:
            return 0
        elif y == 0:
            return 16807 * x
        elif x == 0:
            return 48271 * y
        else:
            return (erosion_level(x - 1, y) * erosion_level(x, y - 1))

    def erosion_level(x, y):
        return (geologic_index(x, y) + depth) % 20183

    def region_type(erosion_level):
        return erosion_level % 3

    def risk(x, y):
        return region_type(erosion_level(x, y))

    def risk_level_area(target_x, target_y):
        total_risk = 0
        for x in range(target_x + 1):
            for y in range(target_y + 1):
                total_risk += risk(x, y)
        return total_risk

    depth = 510
    target_x = 10
    target_y = 10
    print(risk_level_area(target_x, target_y))

risk_level(510, 10, 10)
",0
97,2018,23,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmphkso_7k3/tmp.py"", line 21, in <module>
    if in_range(bot[0], strongest_bot):
  File ""/tmp/tmphkso_7k3/tmp.py"", line 8, in in_range
    return manhattan_distance(a, b) <= b[1]
  File ""/tmp/tmphkso_7k3/tmp.py"", line 5, in manhattan_distance
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2])
TypeError: unsupported operand type(s) for -: 'int' and 'list'
","
import math

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2])

def in_range(a, b):
    return manhattan_distance(a, b) <= b[1]

with open('input.txt', 'r') as f:
    nanobots = []
    for line in f.readlines():
        pos, r = line.strip().replace('pos=<', '').replace('>', '').split(', r=')
        pos = list(map(int, pos.split(','))), int(r)
        nanobots.append(pos)

strongest_bot = max(nanobots, key=lambda x: x[1])
count = 0

for bot in nanobots:
    if in_range(bot[0], strongest_bot):
        count += 1

print(count)
",0
98,2018,24,1,syntax_error,,14377,"  File ""/tmp/tmptha815l2/tmp.py"", line 87
    if __name__ == '__main__':
                             ^
SyntaxError: invalid syntax
","
import re
import sys
from collections import defaultdict
from itertools import chain
from math import inf

def parse_input(data):
    immune_system = []
    infection = []
    current_army = immune_system
    for line in data.split('\n'):
        if 'Immune System' in line:
            current_army = immune_system
        elif 'Infection' in line:
            current_army = infection
        elif line.strip():
            current_army.append(parse_group(line))
    return immune_system, infection

def parse_group(line):
    count, hp, damage, init, damage_type, *rest = re.findall(r'\d+', line)
    weak_immune = re.findall(r'\((.*)\)', line)
    weak = []
    immune = []
    for wi in weak_immune:
        if 'weak' in wi:
            weak = [t.strip() for t in wi.split('weak to ')[1].split(',')]
        elif 'immune' in wi:
            immune = [t.strip() for t in wi.split('immune to ')[1].split(',')]
    return int(count), int(hp), int(damage), int(init), damage_type, weak, immune

def effective_power(group):
    return group[0] * group[2]

def choose_target(attacking, defending):
    target = None
    max_damage = -inf
    for dgroup in defending:
        damage = calculate_damage(attacking, dgroup)
        if damage > 0 and damage > max_damage:
            max_damage = damage
            target = dgroup
    return target

def calculate_damage(attacking, defending):
    if attacking[3] in defending[5]:
        return 0
    elif attacking[3] in defending[4]:
        return 2 * effective_power(attacking)
    else:
        return effective_power(attacking)

def attack(attacking, defending):
    damage = calculate_damage(attacking, defending)
    units_to_kill = min(damage // defending[1], defending[0])
    defending[0] -= units_to_kill
    return units_to_kill

def fight(immune_system, infection):
    while immune_system and infection:
        target_selection(immune_system, infection)
        immune_system = [g for g in immune_system if g[0] > 0]
        infection = [g for g in infection if g[0] > 0]
        immune_system.sort(key=effective_power, reverse=True)
        infection.sort(key=effective_power, reverse=True)
        immune_system.sort(key=lambda g: g[2], reverse=True)
        infection.sort(key=lambda g: g[2])
        for group in chain(immune_system, infection):
            if not group[3]:
                continue
            target = choose_target(group, immune_system if group in infection else infection)
            if target:
                attack(group, target)
                if not target[0]:
                    group[3] = None
    return immune_system, infection

def main():
    with open('input.txt') as f:
        data = f.read()
    immune_system, infection = parse_input(data)
    immune_system, infection = fight(immune_system, infection)
    winner = immune_system if immune_system else infection
    print(sum(sum(g[0] for g in winner))

if __name__ == '__main__':
    main()
",0
99,2018,25,1,wrong_output,"1
",363,,"
import itertools
import math

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2]) + abs(a[3] - b[3])

def find_constellations(coords):
    constellations = []
    while coords:
        constellation = [coords.pop(0)]
        neighbors = [c for c in coords if manhattan_distance(constellation[0], c) <= 3]
        coords = [c for c in coords if c not in neighbors]
        while neighbors:
            constellation.extend(neighbors)
            new_neighbors = []
            for neighbor in neighbors:
                new_neighbors.extend([c for c in coords if manhattan_distance(neighbor, c) <= 3 and c not in constellation])
            neighbors = new_neighbors
        constellations.append(constellation)
    return len(constellations)

def parse_input(input_str):
    return [tuple(map(int, line.split(',')) for line in input_str.splitlines())]

input_str = '''
-1,2,2,0
0,0,2,-2
0,0,0,-2
-1,2,0,0
-2,-2,-2,2
3,0,2,-1
-1,3,2,2
-1,0,-1,0
0,2,1,-2
3,0,0,0
'''
input_str = input_str.strip()
coords = parse_input(input_str)
print(find_constellations(coords))
",0
100,2019,1,1,wrong_output,"Total fuel required: 3336439
",3336439,,"import math

def calculate_fuel(mass):
    return math.floor(mass / 3) - 2

def main():
    total_fuel = 0
    with open(""input.txt"", ""r"") as file:
        for line in file:
            total_fuel += calculate_fuel(int(line.strip()))
    print(""Total fuel required:"", total_fuel)

if __name__ == ""__main__"":
    main() ",0
101,2019,2,1,wrong_output,"Result: 4138658
",4138658,,"
import sys

def read_input(file_path):
    with open(file_path, 'r') as file:
        program = file.readline().rstrip().split(',')
    return [int(x) for x in program]

def execute_program(program):
    program[1] = 12
    program[2] = 2
    pc = 0
    while True:
        opcode = program[pc]
        if opcode == 1:
            a, b, c = program[pc+1:pc+4]
            program[c] = program[a] + program[b]
            pc += 4
        elif opcode == 2:
            a, b, c = program[pc+1:pc+4]
            program[c] = program[a] * program[b]
            pc += 4
        elif opcode == 99:
            break
        else:
            sys.exit(""Invalid opcode"")
    return program[0]

if __name__ == ""__main__"":
    program = read_input(""input.txt"")
    result = execute_program(program)
    print(""Result:"", result)
",0
102,2019,3,1,syntax_error,,248,"  File ""/tmp/tmp754yidua/tmp.py"", line 28
    return closest_distance
    ^
SyntaxError: invalid syntax
","
from collections import defaultdict
import re

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def generate_points(path):
    direction_moves = {'U': (0, 1), 'D': (0, -1), 'R': (1, 0), 'L': (-1, 0)}
    current_point = (0, 0)
    points = set()
    for move in path:
        direction = move[0]
        steps = int(move[1:])
        dx, dy = direction_moves[direction]
        for _ in range(steps):
            current_point = (current_point[0] + dx, current_point[1] + dy)
            points.add(current_point)
    return points

def find_closest_intersection_distance(path1, path2):
    points1 = generate_points(path1)
    points2 = generate_points(path2)
    intersections = points1.intersection(points2)
    closest_distance = float('inf')
    for intersection in intersections:
        closest_distance = min(closest_distance, manhattan_distance(intersection, (0, 0))
    return closest_distance

with open(""input.txt"", ""r"") as f:
    paths = [line.strip() for line in f.readlines()]
    path1, path2 = paths
    path1_points = path1.split(',')
    path2_points = path2.split(',')
    closest_distance = find_closest_intersection_distance(path1_points, path2_points)
    print(closest_distance)
",0
103,2019,4,1,syntax_error,,454,"  File ""/tmp/tmp9tranl7r/tmp.py"", line 7
    if re.search(r'(\d)\1', str(i)) and all(str(i)[j] <= str(i)[j+1] for j in range(len(str(i)-1)):
                                                                                                  ^
SyntaxError: invalid syntax
","
import re

def find_password(start, end):
    valid_passwords = []
    for i in range(start, end+1):
        if re.search(r'(\d)\1', str(i)) and all(str(i)[j] <= str(i)[j+1] for j in range(len(str(i)-1)):
            valid_passwords.append(i)
    return valid_passwords

start = 11111111
end = 9999999
valid_passwords = find_password(start, end)
print(len(valid_passwords))
",0
104,2019,5,1,syntax_error,,6069343,"  File ""/tmp/tmpntytzs9h/tmp.py"", line 71
    ip = 0
    ^
SyntaxError: invalid syntax
","
import sys
from collections import defaultdict

def intcode_computer(intcode, input_val):
    def parse_instruction(instruction):
        opcode = instruction % 100
        modes = [0, 0, 0, 0]
        params = instruction // 100
        for i in range(3):
            modes[i] = params % 10
            params //= 10
        return opcode, modes

    def get_param(memory, position, mode):
        if mode == 0:
            return memory[memory[position]]
        elif mode == 1:
            return memory[position]

    def store_param(memory, value, position):
        memory[position] = value

    def execute_instruction(memory, ip, input_val):
        opcode, modes = parse_instruction(memory[ip])
        if opcode == 1:
            a, b, c = memory[ip+1:ip+4]
            store_param(memory, get_param(memory, a, modes[0]) + get_param(memory, b, modes[1]), c)
            ip += 4
        elif opcode == 2:
            a, b, c = memory[ip+1:ip+4]
            store_param(memory, get_param(memory, a, modes[0]) * get_param(memory, b, modes[1]), c)
            ip += 4
        elif opcode == 3:
            store_param(memory, input_val, memory[ip+1])
            ip += 2
        elif opcode == 4:
            print(get_param(memory, memory[ip+1], modes[0]))
            ip += 2
        elif opcode == 5:
            if get_param(memory, memory[ip+1], modes[0]) != 0:
                ip = get_param(memory, memory[ip+2], modes[1])
            else:
                ip += 3
        elif opcode == 6:
            if get_param(memory, memory[ip+1], modes[0]) == 0:
                ip = get_param(memory, memory[ip+2], modes[1])
            else:
                ip += 3
        elif opcode == 7:
            a, b, c = memory[ip+1:ip+4]
            if get_param(memory, a, modes[0]) < get_param(memory, b, modes[1]):
                store_param(memory, 1, c)
            else:
                store_param(memory, 0, c)
            ip += 4
        elif opcode == 8:
            a, b, c = memory[ip+1:ip+4]
            if get_param(memory, a, modes[0]) == get_param(memory, b, modes[1]):
                store_param(memory, 1, c)
            else:
                store_param(memory, 0, c)
            ip += 4
        elif opcode == 99:
            return None
        else:
            raise ValueError(""Invalid opcode"")
        return ip

    memory = defaultdict(int, enumerate(intcode)
    ip = 0
    while ip is not None:
        ip = execute_instruction(memory, ip, input_val)

    return memory[0]

with open('input.txt', 'r') as f:
    intcode = list(map(int, f.read().split(','))
    input_val = 1
    diagnostic_code = intcode_computer(intcode, input_val)
    print(""Diagnostic Code:"", diagnostic_code)
",0
105,2019,6,1,no_error,"142497
",142497,,"
import re


# Read the input file and store it in a list
with open('input.txt', 'r') as file:
    orbits = file.readlines()

# Create a dictionary to store the orbits
orbit_dict = {}

# Create a set to store unique objects
objects = set()

# Loop through each orbit line and add them to the dictionary
for orbit in orbits:
    center, satellite = re.findall(r'(.+)\)(.+)', orbit.strip())[0]
    orbit_dict[satellite] = center
    objects.add(center)
    objects.add(satellite)

# Initialize the count of orbits
total_orbits = 0

# For each object, find its indirect orbits and add it to the total count
for obj in objects:
    temp_obj = obj
    while temp_obj in orbit_dict:
        temp_obj = orbit_dict[temp_obj]
        total_orbits += 1

print(total_orbits)
",0
106,2019,7,1,syntax_error,,77500,"  File ""/tmp/tmpfdjcrf7d/tmp.py"", line 39
    max_signal = 0
    ^
SyntaxError: invalid syntax
","
import itertools

def intcode_computer(program, phase_setting):
    input_signal = 0
    i = 0
    while i < len(program):
        opcode = program[i]
        if opcode == 1:
            input1 = program[program[i+1]]
            input2 = program[program[i+2]]
            output = program[i+3]
            program[output] = input1 + input2
            i += 4
        elif opcode == 2:
            input1 = program[program[i+1]]
            input2 = program[program[i+2]]
            output = program[i+3]
            program[output] = input1 * input2
            i += 4
        elif opcode == 3:
            input_index = program[i+1]
            program[input_index] = phase_setting
            i += 2
        elif opcode == 4:
            input_index = program[i+1]
            input_signal = program[input_index]
            i += 2
        elif opcode == 99:
            break
        else:
            raise ValueError(""Invalid opcode"")
    return input_signal

def main():
    with open(""input.txt"", ""r"") as f:
        program = [int(x) for x in f.readline().split("","")]
    phase_settings = list(itertools.permutations(range(5))
    max_signal = 0
    for setting in phase_settings:
        signal = 0
        for amplifier in setting:
            signal = intcode_computer(program.copy(), amplifier)
        max_signal = max(max_signal, signal)
    print(""Highest signal that can be sent to the thrusters:"", max_signal)

if __name__ == ""__main__"":
    main()
",0
107,2019,8,1,wrong_output,"1742
1742
",1742,,"
import os

WIDTH = 25
HEIGHT = 6

with open(""input.txt"", ""r"") as f:
    data = f.read().strip()

layers = [data[i:i+(WIDTH*HEIGHT)] for i in range(0, len(data), WIDTH*HEIGHT)]
min_zeros = float('inf')
min_layer = None

for layer in layers:
    zeros = layer.count('0')
    if zeros < min_zeros:
        min_zeros = zeros
        min_layer = layer

ones = min_layer.count('1')
twos = min_layer.count('2')

print(ones * twos)


WIDTH = 25
HEIGHT = 6

with open(""input.txt"", ""r"") as f:
    data = f.read().strip()

layers = [data[i:i+(WIDTH*HEIGHT)] for i in range(0, len(data), WIDTH*HEIGHT)]
min_zeros = float('inf')
min_layer = None

for layer in layers:
    zeros = layer.count('0')
    if zeros < min_zeros:
        min_zeros = zeros
        min_layer = layer

ones = min_layer.count('1')
twos = min_layer.count('2')

print(ones * twos)
",0
108,2019,9,1,runtime_error,,3780860499,"Traceback (most recent call last):
  File ""/tmp/tmpetkz_uka/tmp.py"", line 72, in <module>
    output = intcode_computer(program, input_values)
  File ""/tmp/tmpetkz_uka/tmp.py"", line 53, in intcode_computer
    memory[parameter3 + (relative_base if parameter_modes[2] == 2 else 0)] = 1 if parameter1 < parameter2 else 0
IndexError: list assignment index out of range
","
import math

def intcode_computer(program, input_values):
    relative_base = 0
    memory = program.copy() + [0] * 10000000
    pointer = 0
    input_pointer = 0
    output = []
    while memory[pointer] != 99:
        instruction = str(memory[pointer]).zfill(5)
        opcode = int(instruction[-2:])
        parameter_modes = [int(i) for i in instruction[2::-1]]
        if opcode == 1:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            parameter3 = memory[pointer+3] if parameter_modes[2] else memory[memory[pointer+3]] if parameter_modes[2] == 2 else memory[memory[pointer+3] + relative_base]
            memory[memory[pointer+3] + (relative_base if parameter_modes[2] == 2 else 0)] = parameter1 + parameter2
            pointer += 4
        elif opcode == 2:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            parameter3 = memory[pointer+3] if parameter_modes[2] else memory[memory[pointer+3]] if parameter_modes[2] == 2 else memory[memory[pointer+3] + relative_base]
            memory[memory[pointer+3] + (relative_base if parameter_modes[2] == 2 else 0)] = parameter1 * parameter2
            pointer += 4
        elif opcode == 3:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            memory[parameter1 + (relative_base if parameter_modes[0] == 2 else 0)] = input_values[input_pointer]
            input_pointer += 1
            pointer += 2
        elif opcode == 4:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            output.append(parameter1)
            pointer += 2
        elif opcode == 5:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            if parameter1 != 0:
                pointer = parameter2
            else:
                pointer += 3
        elif opcode == 6:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            if parameter1 == 0:
                pointer = parameter2
            else:
                pointer += 3
        elif opcode == 7:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            parameter3 = memory[pointer+3] if parameter_modes[2] else memory[memory[pointer+3]] if parameter_modes[2] == 2 else memory[memory[pointer+3] + relative_base]
            memory[parameter3 + (relative_base if parameter_modes[2] == 2 else 0)] = 1 if parameter1 < parameter2 else 0
            pointer += 4
        elif opcode == 8:
            parameter1 = memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            parameter2 = memory[pointer+2] if parameter_modes[1] else memory[memory[pointer+2]] if parameter_modes[1] == 2 else memory[memory[pointer+2] + relative_base]
            parameter3 = memory[pointer+3] if parameter_modes[2] else memory[memory[pointer+3]] if parameter_modes[2] == 2 else memory[memory[pointer+3] + relative_base]
            memory[parameter3 + (relative_base if parameter_modes[2] == 2 else 0)] = 1 if parameter1 == parameter2 else 0
            pointer += 4
        elif opcode == 9:
            relative_base += memory[pointer+1] if parameter_modes[0] else memory[memory[pointer+1]] if parameter_modes[0] == 2 else memory[memory[pointer+1] + relative_base]
            pointer += 2
        else:
            raise Exception(""Invalid opcode"")
    return output

with open(""input.txt"") as file:
    program = [int(i) for i in file.read().split(',')]

input_values = [1]
output = intcode_computer(program, input_values)
print(output[-1])
",0
109,2019,10,1,wrong_output,"The best station is at (37, 25) with 309 other asteroids visible.
",309,,"
from collections import defaultdict
from math import atan2, pi, degrees

def load_map(filename):
    with open(filename, 'r') as file:
        return [line.strip() for line in file.readlines()]

def get_asteroids(map):
    asteroids = []
    for y, row in enumerate(map):
        for x, col in enumerate(row):
            if col == '#':
                asteroids.append((x, y))
    return asteroids

def count_visible_asteroids(station, asteroids):
    visible = defaultdict(list)
    for asteroid in asteroids:
        if asteroid != station:
            dx, dy = asteroid[0] - station[0], asteroid[1] - station[1]
            angle = (degrees(atan2(dy, dx)) + 360) % 360
            visible[angle].append((asteroid, dx, dy))
    return len(visible)

def get_best_station(asteroids):
    best_station = max(asteroids, key=lambda station: count_visible_asteroids(station, asteroids))
    return best_station, count_visible_asteroids(best_station, asteroids)

def main():
    map = load_map('input.txt')
    asteroids = get_asteroids(map)
    best_station, visible_asteroids = get_best_station(asteroids)
    print(f""The best station is at {best_station} with {visible_asteroids} other asteroids visible."")

if __name__ == '__main__':
    main()
",0
110,2019,11,1,runtime_error,,2336,"Traceback (most recent call last):
  File ""/tmp/tmp4d1pgx2_/tmp.py"", line 110, in <module>
    main()
  File ""/tmp/tmp4d1pgx2_/tmp.py"", line 88, in main
    program = run_intcode(program)
  File ""/tmp/tmp4d1pgx2_/tmp.py"", line 67, in run_intcode
    program[c] = 1
IndexError: list assignment index out of range
","
import os
import sys

def run_intcode(program):
    pc = 0
    relative_base = 0
    while True:
        opcode = program[pc] % 100
        if opcode == 99:
            break
        elif opcode == 1:
            a, b, c = program[pc+1], program[pc+2], program[pc+3]
            program[c] = program[a] + program[b]
            pc += 4
        elif opcode == 2:
            a, b, c = program[pc+1], program[pc+2], program[pc+3]
            program[c] = program[a] * program[b]
            pc += 4
        elif opcode == 3:
            a = program[pc+1]
            program[a] = int(input(""Enter input: ""))
            pc += 2
        elif opcode == 4:
            print(""Output:"", program[program[pc+1]])
            pc += 2
        elif opcode == 5:
            a, b = program[pc+1], program[pc+2]
            if program[a]:
                pc = program[b]
            else:
                pc += 3
        elif opcode == 6:
            a, b = program[pc+1], program[pc+2]
            if not program[a]:
                pc = program[b]
            else:
                pc += 3
        elif opcode == 7:
            a, b, c = program[pc+1], program[pc+2], program[pc+3]
            if program[a] < program[b]:
                program[c] = 1
            else:
                program[c] = 0
            pc += 4
        elif opcode == 8:
            a, b, c = program[pc+1], program[pc+2], program[pc+3]
            if program[a] == program[b]:
                program[c] = 1
            else:
                program[c] = 0
            pc += 4
        elif opcode == 9:
            a = program[pc+1]
            relative_base += program[a]
            pc += 2
        else:
            a, b, c = program[pc], program[pc+1], program[pc+2]
            if a % 100 == 1:
                a = program[program[pc+1] + relative_base] if a // 100 == 2 else program[pc+1]
                b = program[program[pc+2] + relative_base] if b // 100 == 2 else program[pc+2]
                c = program[pc+3] + relative_base
            else:
                a = program[program[pc+1] + relative_base] if a // 100 == 2 else program[pc+1]
                b = program[program[pc+2] + relative_base] if b // 100 == 2 else program[pc+2]
            if a < b:
                program[c] = 1
            else:
                program[c] = 0
            pc += 4
    return program

def load_program(filepath):
    with open(filepath, 'r') as f:
        return [int(n) for n in f.read().strip().split(',')]

def main():
    filepath = 'input.txt'
    program = load_program(filepath)
    painted_panels = set()
    position = (0, 0)
    direction = 'UP'
    directions = {'UP': (0, -1), 'DOWN': (0, 1), 'LEFT': (-1, 0), 'RIGHT': (1, 0)}
    painted_panels.add(position)
    while True:
        color = 0 if position in painted_panels else 1
        program[0] = color
        program = run_intcode(program)
        color_to_paint, turn = program[0], program[1]
        painted_panels.add(position)
        if color_to_paint:
            print('#', end='', flush=True)
        else:
            print('.', end='', flush=True)
        program = [0] * len(program)
        direction_index = {'UP': 0, 'RIGHT': 1, 'DOWN': 2, 'LEFT': 3}[direction]
        if turn:
            direction = ['UP', 'RIGHT', 'DOWN', 'LEFT'][(direction_index + 1) % 4]
        else:
            direction = ['UP', 'LEFT', 'DOWN', 'RIGHT'][direction_index]
        movement = directions[direction]
        position = (position[0] + movement[0], position[1] + movement[1])
        if position[0] < -50 or position[1] < -50 or position[0] > 50 or position[1] > 50:
            break
        if len(painted_panels) % 1000 == 0:
            sys.stdout.write('\n')
    print('\nNumber of painted panels:', len(painted_panels))

if __name__ == '__main__':
    main()
",0
111,2019,12,1,runtime_error,,6220,"Traceback (most recent call last):
  File ""/tmp/tmp0ca208e7/tmp.py"", line 76, in <module>
    main()
  File ""/tmp/tmp0ca208e7/tmp.py"", line 72, in main
    total_energy = calculate_total_energy(moons_positions, [0, 0, 0, 0])
  File ""/tmp/tmp0ca208e7/tmp.py"", line 64, in calculate_total_energy
    vx, vy, vz = moons_velocity[i]
TypeError: cannot unpack non-iterable int object
","
import re
import math

def read_input(filename):
    with open(filename, 'r') as file:
        data = file.read()
    return data

def parse_input(input_data):
    moons_positions = []
    for line in input_data.splitlines():
        x, y, z = re.findall(r""[-\d]+"", line)
        moons_positions.append((int(x), int(y), int(z)))
    return moons_positions

def simulate_moons(moons_positions, steps):
    moons_velocity = [(0, 0, 0) for _ in range(len(moons_positions))]
    for _ in range(steps):
        # Update velocity
        for i in range(len(moons_positions)):
            for j in range(len(moons_positions)):
                if i != j:
                    x_i, y_i, z_i = moons_positions[i]
                    x_j, y_j, z_j = moons_positions[j]
                    vx_i, vy_i, vz_i = moons_velocity[i]
                    vx_j, vy_j, vz_j = moons_velocity[j]
                    
                    if x_i > x_j:
                        vx_i -= 1
                        vx_j += 1
                    elif x_i < x_j:
                        vx_i += 1
                        vx_j -= 1
                    
                    if y_i > y_j:
                        vy_i -= 1
                        vy_j += 1
                    elif y_i < y_j:
                        vy_i += 1
                        vy_j -= 1
                    
                    if z_i > z_j:
                        vz_i -= 1
                        vz_j += 1
                    elif z_i < z_j:
                        vz_i += 1
                        vz_j -= 1
                    
                    moons_velocity[i] = (vx_i, vy_i, vz_i)
                    moons_velocity[j] = (vx_j, vy_j, vz_j)
        
        # Update position
        for i in range(len(moons_positions)):
            x, y, z = moons_positions[i]
            vx, vy, vz = moons_velocity[i]
            moons_positions[i] = (x + vx, y + vy, z + vz)
    return moons_positions

def calculate_total_energy(moons_positions, moons_velocity):
    total_energy = 0
    for i in range(len(moons_positions)):
        x, y, z = moons_positions[i]
        vx, vy, vz = moons_velocity[i]
        total_energy += (abs(x) + abs(y) + abs(z)) * (abs(vx) + abs(vy) + abs(vz))
    return total_energy

def main():
    input_data = read_input(""input.txt"")
    moons_positions = parse_input(input_data)
    moons_positions = simulate_moons(moons_positions, 1000)
    total_energy = calculate_total_energy(moons_positions, [0, 0, 0, 0])
    print(f""Total energy after 100 steps: {total_energy}"")

if __name__ == ""__main__"":
    main()
",0
112,2019,13,1,syntax_error,,270,"  File ""/tmp/tmplvj39sxw/tmp.py"", line 8
    def run_intcode(program):
    ^
SyntaxError: invalid syntax
","import os
import re

def read_input():
    with open('input.txt', 'r') as file:
        return list(map(int, file.read().split(','))

def run_intcode(program):
    # Your code here

def generate_output(program):
    # Your code here

def count_block_tiles(output):
    # Your code here

if __name__ == '__main__':
    program = read_input()
    output = run_intcode(program)
    block_count = count_block_tiles(output)
    print(f'Number of block tiles on the screen: {block_count}')

# Add your code to define the functions `run_intcode()` and `count_block_tiles()` to solve the problem. ",0
113,2019,14,1,syntax_error,,532506,"  File ""/tmp/tmpryi66qn_/tmp.py"", line 13
    reactions[output_chemical] = {
    ^
SyntaxError: invalid syntax
","
import re
from collections import defaultdict
from math import ceil

def parse_reactions(input_file):
    reactions = defaultdict(dict)
    with open(input_file) as f:
        for line in f.readlines():
            left, right = line.strip().split(' => ')
            inputs, output = re.findall(r'(\d+ [A-Z]+)', left), re.findall(r'(\d+ [A-Z]+)', right)[0]
            output_qty, output_chemical = map(int, re.findall(r'(\d+) ([A-Z]+)', output)[0]
            reactions[output_chemical] = {
                'output_qty': output_qty,
                'inputs': {chemical: int(qty) for qty, chemical in map(lambda x: x.split(' '), inputs)}
            }
    return reactions

def get_ore_required(reactions, fuel_required=1):
    surplus = defaultdict(int)
    def get_inputs(chemical, qty):
        if chemical == 'ORE':
            return qty
        if surplus[chemical] >= qty:
            surplus[chemical] -= qty
            return 0
        qty -= surplus[chemical]
        surplus[chemical] = 0
        reaction = reactions[chemical]
        total_ore = 0
        multiplier = ceil(qty / reaction['output_qty'])
        for input_chemical, input_qty in reaction['inputs'].items():
            total_ore += get_inputs(input_chemical, input_qty * multiplier)
        surplus[chemical] += reaction['output_qty'] * multiplier - qty
        return total_ore

    return get_inputs('FUEL', fuel_required)

if __name__ == '__main__':
    reactions = parse_reactions('input.txt')
    ore_required = get_ore_required(reactions)
    print(f'Minimum ORE required to produce 1 FUEL: {ore_required}')
",0
114,2019,15,1,syntax_error,,300,"  File ""/tmp/tmpgsyevu20/tmp.py"", line 2
    ```python
    ^
SyntaxError: invalid syntax
","
```python
import time
import threading
import queue

class RepairDroid:
    def __init__(self, intcode):
        self.code = intcode
        self.input_queue = queue.Queue()
        self.output_queue = queue.Queue()
        self.running = True
        self.program_counter = 0
        self.relative_base = 0
        self.memory = self.code.copy()

    def run_program(self):
        while self.running:
            self.step_program()

    def step_program(self):
        current_opcode = self.memory[self.program_counter]
        instruction = str(current_opcode)[-2:]
        mode = str(current_opcode)[:-2][::-1]

        if instruction == '99':
            self.running = False
            return

        elif instruction == '01':
            self.add(mode)
        elif instruction == '02':
            self.multiply(mode)
        elif instruction == '03':
            self.input_function(mode)
        elif instruction == '04':
            self.output_function(mode)
        elif instruction == '05':
            self.jump_if_true(mode)
        elif instruction == '06':
            self.jump_if_false(mode)
        elif instruction == '07':
            self.less_than(mode)
        elif instruction == '08':
            self.equals(mode)
        elif instruction == '09':
            self.adjust_relative_base(mode)
        else:
            raise ValueError('Invalid opcode: {}'.format(instruction))

    def add(self, mode):
        if mode[0] == '0':
            param1 = self.memory[self.memory[self.program_counter+1]]
        elif mode[0] == '1':
            param1 = self.memory[self.program_counter+1]
        elif mode[0] == '2':
            param1 = self.memory[self.memory[self.program_counter+1] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0]))

        if mode[1] == '0':
            param2 = self.memory[self.memory[self.program_counter+2]]
        elif mode[1] == '1':
            param2 = self.memory[self.program_counter+2]
        elif mode[1] == '2':
            param2 = self.memory[self.memory[self.program_counter+2] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[1]))

        if mode[2] == '0':
            self.memory[self.memory[self.program_counter+3]] = param1 + param2
        elif mode[2] == '2':
            self.memory[self.memory[self.program_counter+3] + self.relative_base] = param1 + param2
        else:
            raise ValueError('Invalid mode: {}'.format(mode[2]))

        self.program_counter += 4

    def multiply(self, mode):
        if mode[0] == '0':
            param1 = self.memory[self.memory[self.program_counter+1]]
        elif mode[0] == '1':
            param1 = self.memory[self.program_counter+1]
        elif mode[0] == '2':
            param1 = self.memory[self.memory[self.program_counter+1] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0]))

        if mode[1] == '0':
            param2 = self.memory[self.memory[self.program_counter+2]]
        elif mode[1] == '1':
            param2 = self.memory[self.program_counter+2]
        elif mode[1] == '2':
            param2 = self.memory[self.memory[self.program_counter+2] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[1]))

        if mode[2] == '0':
            self.memory[self.memory[self.program_counter+3]] = param1 * param2
        elif mode[2] == '2':
            self.memory[self.memory[self.program_counter+3] + self.relative_base] = param1 * param2
        else:
            raise ValueError('Invalid mode: {}'.format(mode[2]))

        self.program_counter += 4

    def input_function(self, mode):
        if mode[0] == '0':
            self.memory[self.memory[self.program_counter+1]] = self.input_queue.get()
        elif mode[0] == '2':
            self.memory[self.memory[self.program_counter+1] + self.relative_base] = self.input_queue.get()
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0]))
        self.program_counter += 2

    def output_function(self, mode):
        if mode[0] == '0':
            self.output_queue.put(self.memory[self.memory[self.program_counter+1]])
        elif mode[0] == '1':
            self.output_queue.put(self.memory[self.program_counter+1])
        elif mode[0] == '2':
            self.output_queue.put(self.memory[self.memory[self.program_counter+1] + self.relative_base])
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0]))
        self.program_counter += 2

    def jump_if_true(self, mode):
        if mode[0] == '0':
            param1 = self.memory[self.memory[self.program_counter+1]]
        elif mode[0] == '1':
            param1 = self.memory[self.program_counter+1]
        elif mode[0] == '2':
            param1 = self.memory[self.memory[self.program_counter+1] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0]))

        if mode[1] == '0':
            param2 = self.memory[self.memory[self.program_counter+2]]
        elif mode[1] == '1':
            param2 = self.memory[self.program_counter+2]
        elif mode[1] == '2':
            param2 = self.memory[self.memory[self.program_counter+2] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[1])

        if param1 != 0:
            self.program_counter = param2
        else:
            self.program_counter += 3

    def jump_if_false(self, mode):
        if mode[0] == '0':
            param1 = self.memory[self.memory[self.program_counter+1]]
        elif mode[0] == '1':
            param1 = self.memory[self.program_counter+1]
        elif mode[0] == '2':
            param1 = self.memory[self.memory[self.program_counter+1] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[0])

        if mode[1] == '0':
            param2 = self.memory[self.memory[self.program_counter+2]
        elif mode[1] == '1':
            param2 = self.memory[self.program_counter+2]
        elif mode[1] == '2':
            param2 = self.memory[self.memory[self.program_counter+2] + self.relative_base]
        else:
            raise ValueError('Invalid mode: {}'.format(mode[1])

        if param1 == 0:
            self.program_counter = param2
        else:
            self.program_counter += 3

    def less_than(self, mode):
        if mode[0] == '0':
            param1 = self.memory[self.memory[self.program_counter+1]]
        elif mode[0] == '1':
            param1 =",0
115,2019,16,1,wrong_output,"20464022
",68317988,,"
import math

def fft(input_list):
    output_list = []
    for i in range(len(input_list)):
        pattern = [0, 1, 0, -1] * (i+1)
        pattern.pop(0)
        result = sum([pattern[j%len(pattern)]*input_list[j] for j in range(len(input_list))])
        output_list.append(abs(result)%10)
    return output_list

def repeat_fft(input_list, phases):
    for _ in range(phases):
        input_list = fft(input_list)
    return input_list[:8]

input_signal = [int(digit) for digit in open('input.txt').read().strip()]
result = repeat_fft(input_signal, 100)
print(''.join(str(digit) for digit in result))
",0
116,2019,17,1,syntax_error,,9876,"  File ""/tmp/tmpei7c1rii/tmp.py"", line 9
    index = 0
    ^
SyntaxError: invalid syntax
","
import re

def main():
    with open(""input.txt"", 'r') as f:
        program = list(map(int, f.read().strip().split(','))

    # Intcode computer code
    index = 0
    relative_base = 0
    while True:
        opcode = program[index]
        mode_1, mode_2, mode_3, op = str(opcode)[-2:], str(opcode)[-3], str(opcode)[-4], int(str(opcode)[-2:])
        if op == 1:
            a, b, c = program[index+1], program[index+2], program[index+3]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if mode_3 == '0':
                c = program[c]
            program[c] = a + b
            index += 4
        elif op == 2:
            a, b, c = program[index+1], program[index+2], program[index+3]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if mode_3 == '0':
                c = program[c]
            program[c] = a * b
            index += 4
        elif op == 3:
            a = program[index+1]
            program[a] = int(input(""Enter input: ""))
            index += 2
        elif op == 4:
            a = program[index+1]
            if mode_1 == '0':
                print(program[a])
            elif mode_1 == '1':
                print(a)
            elif mode_1 == '2':
                print(program[a] + relative_base)
            index += 2
        elif op == 5:
            a, b = program[index+1], program[index+2]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if a != 0:
                index = b
            else:
                index += 3
        elif op == 6:
            a, b = program[index+1], program[index+2]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if a == 0:
                index = b
            else:
                index += 3
        elif op == 7:
            a, b, c = program[index+1], program[index+2], program[index+3]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if mode_3 == '0':
                c = program[c]
            if a < b:
                program[c] = 1
            else:
                program[c] = 0
            index += 4
        elif op == 8:
            a, b, c = program[index+1], program[index+2], program[index+3]
            if mode_1 == '0':
                a = program[a]
            if mode_2 == '0':
                b = program[b]
            if mode_3 == '0':
                c = program[c]
            if a == b:
                program[c] = 1
            else:
                program[c] = 0
            index += 4
        elif op == 9:
            a = program[index+1]
            if mode_1 == '0':
                a = program[a]
            relative_base += a
            index += 2
        elif op == 99:
            break
        else:
            print(""Invalid opcode:"", op)
            return
    
    scaffold_pattern = re.compile(r'#+')
    intersections = []
    alignment_sum = 0
    for match in scaffold_pattern.finditer(output):
        x, y = match.start(), match.start(0) - match.string[:match.start()].count('\n')
        if x > 0 and x < len(output)-1 and y > 0 and y < len(output.split('\n')[0])-1:
            if output[x-1] == '#' and output[x+1] == '#' and output[y-1] == '#' and output[y+1] == '#':
                alignment_sum += x*y
    print(""Sum of alignment parameters:"", alignment_sum)

if __name__ == ""__main__"":
    main()
",0
117,2019,18,1,runtime_error,,6316,"Traceback (most recent call last):
  File ""/tmp/tmp75hvif6f/tmp.py"", line 60, in <module>
    print(shortest_path(maze))
  File ""/tmp/tmp75hvif6f/tmp.py"", line 56, in shortest_path
    return dfs((next(iter(keys.values())), 0), set())
TypeError: unhashable type: 'set'
","
from collections import deque
from functools import lru_cache

def get_moves(pos, maze):
    moves = []
    for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        x, y = pos
        if maze[y + i][x + j] != ""#"":
            moves.append((x + j, y + i))
    return moves

def bfs(maze, start, end):
    visited = set()
    queue = deque([(start, 0)])
    while queue:
        pos, steps = queue.popleft()
        if pos == end:
            return steps
        if pos in visited:
            continue
        visited.add(pos)
        for move in get_moves(pos, maze):
            if move not in visited:
                queue.append((move, steps + 1))
    return None

def generate_maze(maze):
    keys = {}
    doors = {}
    for y, row in enumerate(maze):
        for x, val in enumerate(row):
            if val.islower():
                keys[val] = (x, y)
            elif val.isupper():
                doors[val] = (x, y)
    return keys, doors

def shortest_path(maze):
    keys, doors = generate_maze(maze)
    @lru_cache(maxsize=None)
    def dfs(pos, collected_keys):
        if len(collected_keys) == len(keys):
            return 0
        moves = get_moves(pos, maze)
        min_path = float('inf')
        for next_pos in moves:
            val = maze[next_pos[1]][next_pos[0]]
            if val.islower() and val not in collected_keys:
                new_keys = collected_keys | {val}
                min_path = min(min_path, dfs(next_pos, new_keys) + bfs(maze, next_pos, keys[val]) + 1)
            elif val.isupper() and val.lower() in collected_keys:
                min_path = min(min_path, dfs(next_pos, collected_keys) + 1)
        return min_path

    return dfs((next(iter(keys.values())), 0), set())

with open(""input.txt"", ""r"") as f:
    maze = [list(line.strip()) for line in f.readlines()]
    print(shortest_path(maze))
",0
118,2019,19,1,wrong_output,,150,,"
import math
import itertools

def intcode_computer(program, input_val):
    # Define function to execute intcode program
    def intcode_computer(program, input_val):
        index = 0
        relative_base = 0
        while True:
            opcode = program[index]
            if 99 == opcode:
                break
            elif opcode == 1:
                # Addition
                a = program[index+1]
                b = program[index+2]
                c = program[index+3]
                if opcode == 1:
                    program[c] = program[a] + program[b]
                elif opcode == 2:
                    # Multiplication
                    a = program[index+1]
                    b = program[index+2]
                    c = program[index+3]
                    program[c] = program[a] * program[b]
                elif opcode == 3:
                    # Take input
                    a = program[index+1]
                    program[a] = input_val.pop(0)
                elif opcode == 4:
                    # Output
                    a = program[index+1]
                    output = program[a]
                    index += 2
                    yield output
                elif opcode == 5:
                    # Jump-if-true
                    a = program[index+1]
                    b = program[index+2]
                    if program[a] != 0:
                        index = program[b]
                    else:
                        index += 3
                elif opcode == 6:
                    # Jump-if-false
                    a = program[index+1]
                    b = program[index+2]
                    if program[a] == 0:
                        index = program[b]
                    else:
                        index += 3
                elif opcode == 7:
                    # Less than
                    a = program[index+1]
                    b = program[index+2]
                    c = program[index+3]
                    if program[a] < program[b]:
                        program[c] = 1
                    else:
                        program[c] = 0
                    index += 4
                elif opcode == 8:
                    # Equals
                    a = program[index+1]
                    b = program[index+2]
                    c = program[index+3]
                    if program[a] == program[b]:
                        program[c] = 1
                    else:
                        program[c] = 0
                    index += 4
                elif opcode == 9:
                    # Adjust relative base
                    a = program[index+1]
                    relative_base += program[a]
                    index += 2
                else:
                    raise ValueError(""Invalid opcode: {}"".format(opcode))

    # Open input file
    with open('input.txt', 'r') as f:
        program = [int(i) for i in f.read().split(',')]

    # Initialize variables
    grid = []
    affected_points = 0
    for x in range(50):
        row = []
        for y in range(50):
            # Deploy drone to coordinate
            input_val = [x, y]
            drone_output = intcode_computer(program.copy(), input_val)
            row.append(next(drone_output))
        grid.append(row)

    # Count affected points
    for row in grid:
        affected_points += sum(row)

    print(affected_points)
",0
119,2019,20,1,syntax_error,,608,"  File ""/tmp/tmpmflzrqvr/tmp.py"", line 14
    labels[char] = (labels[char][0] + (x, y), maze[labels[char][1] + (x, y))
                                                                           ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
def get_maze(file_name):
    with open(file_name, 'r') as f:
        maze = f.readlines()
    maze = [line.strip() for line in maze]
    return maze

def get_label_coordinates(maze):
    labels = {}
    for y, row in enumerate(maze):
        for x, char in enumerate(row):
            if char.isalpha():
                if char in labels:
                    labels[char] = (labels[char][0] + (x, y), maze[labels[char][1] + (x, y))
                else:
                    labels[char] = [(x, y)]
    return labels

def find_shortest_path(maze, labels):
    start, end = labels['AA'][0], labels['ZZ'][0]
    portals = {}
    for label, coords in labels.items():
        if len(coords) == 2:
            portals[coords[0]] = coords[1]
            portals[coords[1]] = coords[0]
    visited = set()
    queue = [(start, 0)]
    while queue:
        pos, steps = queue.pop(0)
        if pos == end:
            return steps
        if pos in visited:
            continue
        visited.add(pos)
        x, y = pos
        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            new_pos = (x + dx, y + dy)
            if maze[new_pos[1]][new_pos[0]] != '#':
                queue.append((new_pos, steps + 1))
        if pos in portals:
            queue.append((portals[pos], steps + 1))


pluto_maze.py input.txt
",0
120,2019,21,1,syntax_error,,19358688,"  File ""/tmp/tmptxhsfasb/tmp.py"", line 12
    elif opcode == 2:
    ^
SyntaxError: invalid syntax
","
import sys

def intcode_computer(input_file):
    with open(input_file, 'r') as file:
        intcode = [int(i) for i in file.read().split(',')]
    index = 0
    while index < len(intcode):
        opcode = intcode[index]
        if opcode == 1:
            intcode[intcode[index+3]] = intcode[intcode[index+1]] + intcode[intcode[index+2]
        elif opcode == 2:
            intcode[intcode[index+3]] = intcode[intcode[index+1] * intcode[intcode[index+2]
        elif opcode == 99:
            break
        else:
            print(""Error: Invalid opcode"")
            return []
        index += 4
    return intcode[0]

# Input file
input_file = ""input.txt""

# Program
program = [
    ""NOT A J"",
    ""NOT B T"",
    ""AND T J"",
    ""NOT C T"",
    ""AND T J"",
    ""AND D J"",
    ""WALK""
]

# ASCII input
for line in program:
    sys.stdout.write(line + ""\n"")
    sys.stdout.flush()

# Run intcode computer
output_damage = intcode_computer(input_file)

print(""Hull damage:"", output_damage)
",0
121,2019,22,1,runtime_error,,1252,"Traceback (most recent call last):
  File ""/tmp/tmpu8ha6scw/tmp.py"", line 41, in <module>
    print(find_card(shuffled_deck, 2019))
  File ""/tmp/tmpu8ha6scw/tmp.py"", line 34, in find_card
    return deck.index(card_to_find)
ValueError: 2019 is not in list
","
import re

def deal_into_new_stack(deck):
    return list(reversed(deck))

def cut(deck, n):
    if n > 0:
        return deck[n:] + deck[:n]
    else:
        return deck[n:] + deck[:-n]

def deal_with_increment(deck, n):
    new_deck = [None] * len(deck)
    i = 0
    for card in deck:
        new_deck[i] = card
        i = (i + n) % len(deck)
    return new_deck

def shuffle(deck, instructions):
    for instruction in instructions:
        if 'deal into new stack' in instruction:
            deck = deal_into_new_stack(deck)
        elif 'deal with increment' in instruction:
            m = re.search(r'deal with increment ([-0-9]+)', instruction)
            deck = deal_with_increment(deck, int(m.group(1)))
        elif 'cut' in instruction:
            m = re.search(r'cut ([-0-9]+)', instruction)
            deck = cut(deck, int(m.group(1)))
    return deck

def find_card(deck, card_to_find):
    return deck.index(card_to_find)

if __name__ == '__main__':
    with open('input.txt') as f:
        instructions = f.readlines()
    deck = [i for i in range(1007)] # 1007 cards in the deck
    shuffled_deck = shuffle(deck, instructions)
    print(find_card(shuffled_deck, 2019))
",0
122,2019,23,1,runtime_error,,24922,"Exception in thread Thread-1:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-2:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-3:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-4:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-5:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-6:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-7:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-8:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-9:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-10:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-11:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-12:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-13:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-14:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-15:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-16:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-17:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-18:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-19:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-21:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-20:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-23:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-22:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-24:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-25:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-28:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-29:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-30:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-27:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-35:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-36:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-34:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-26:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-33:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-45:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-37:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-38:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-39:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-40:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-42:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-43:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-44:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-48:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-41:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
Exception in thread Thread-46:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-47:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
Exception in thread Thread-50:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
Exception in thread Thread-31:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self.run()
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 870, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-32:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self._target(*self._args, **self._kwargs)
  File ""/tmp/tmpl6svwpf5/tmp.py"", line 14, in run
Exception in thread Thread-49:
Traceback (most recent call last):
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/threading.py"", line 932, in _bootstrap_inner
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
    self.memory = defaultdict(int, enumerate(self.program))
NameError: name 'defaultdict' is not defined
","
import queue
import threading

class IntcodeComputer:
    def __init__(self, program, address):
        self.program = program
        self.input_queue = queue.Queue()
        self.output_queue = queue.Queue()
        self.address = address

    def run(self):
        self.input_queue.put(self.address)
        self.memory = defaultdict(int, enumerate(self.program))
        self.pointer = 0
        self.relative_base = 0

        while self.memory[self.pointer] != 99:
            instruction = str(self.memory[self.pointer]).zfill(5)
            opcode, mode_param3, mode_param2, mode_param1, mode_param0 = int(instruction[-2:]), int(
                instruction[2]), int(instruction[1]), int(instruction[0])
            parameter_modes = {1: self.read_immediate, 0: self.read_position, 2: self.read_relative}

            if opcode in [1, 2, 7, 8]:
                self.memory[self.parameter(mode_param3, mode_param1)] = parameter_modes[mode_param2](self.pointer +
                                                                                                1) + parameter_modes[mode_param0](self.pointer + 2) if opcode == 1 else \
                                                                                parameter_modes[mode_param3](
                    self.pointer + 1) * parameter_modes[mode_param0](self.pointer + 2) if opcode == 2 else \
                                                                                int(parameter_modes[mode_param3](self.pointer + 1) < parameter_modes[mode_param0](self.pointer + 2)) if opcode == 7 else \
                                                                                int(parameter_modes[mode_param3](self.pointer + 1) == parameter_modes[mode_param0](self.pointer + 2))
                self.pointer += 4
            elif opcode in [4]:
                self.output_queue.put(parameter_modes[mode_param0](self.pointer + 1))
                self.pointer += 2
            elif opcode in [3]:
                if self.input_queue.empty():
                    self.input_queue.put(-1)
                self.memory[self.parameter(mode_param1, mode_param0)] = self.input_queue.get()
                self.pointer += 2
            elif opcode in [5, 6]:
                if parameter_modes[mode_param2](self.pointer + 1) if opcode == 5 else not parameter_modes[mode_param2](self.pointer + 1):
                    self.pointer = parameter_modes[mode_param0](self.pointer + 2)
                else:
                    self.pointer += 3
            elif opcode in [9]:
                self.relative_base += parameter_modes[mode_param0](self.pointer + 1)
                self.pointer += 2

    def read_immediate(self, address):
        return self.memory[address]

    def read_position(self, address):
        return self.memory[self.memory[address]]

    def read_relative(self, address):
        return self.memory[self.memory[address] + self.relative_base]

    def parameter(self, mode, pointer):
        return self.memory[pointer] if mode == 1 else self.memory[self.memory[pointer] + self.relative_base] if mode == 2 else self.memory[self.memory[pointer] + self.relative_base] if mode == 2 else self.memory[pointer]


    def __repr__(self):
        return f""Computer {self.address}""


class Network:
    def __init__(self, program, num_computers):
        self.computers = [IntcodeComputer(program, i) for i in range(num_computers)]
        self.connections = {i: queue.Queue() for i in range(num_computers)}

    def run(self):
        threads = []
        for computer in self.computers:
            t = threading.Thread(target=computer.run)
            t.start()
            threads.append(t)

        while any(t.is_alive() for t in threads):
            for computer in self.computers:
                while not computer.output_queue.empty():
                    dest = computer.output_queue.get()
                    x, y = computer.output_queue.get(), computer.output_queue.get()
                    if dest == 255:
                        print(y)
                        return y
                    self.connections[dest].put((x, y))
                    self.computers[dest].input_queue.put(x)
                    self.computers[dest].input_queue.put(y)

            for connection in self.connections.values():
                for computer in self.computers:
                    if not connection.empty():
                        computer.input_queue.put(connection.get())

        for t in threads:
            t.join()

program = [int(i) for i in open('input.txt').read().split(',')]

network = Network(program, 50)
network.run()
",0
123,2019,24,1,wrong_output,".....
....#
....#
.....
....#

...##
...##
...##
...##
...#.

..#..
.....
.....
.....
..#..

.#.#.
.###.
.....
.###.
.#.#.

#...#
#...#
#...#
#...#
#...#

##.##
.....
.....
.....
##.##

#####
#####
.....
#####
#####

.....
.....
.....
.....
.....

Biodiversity Rating: 0
",1151290,,"
import re
import sys
from collections import defaultdict
from copy import deepcopy
from itertools import product

# Helper function to count adjacent bugs
def count_adjacent_bugs(grid, r, c):
    count = 0
    for dr, dc in product([-1, 0, 1], [-1, 0, 1]):
        if dr == dc == 0:
            continue
        if 0 <= r + dr < len(grid) and 0 <= c + dc < len(grid[0]) and grid[r + dr][c + dc] == '#':
            count += 1
    return count

# Load the input grid
with open('input.txt') as f:
    grid = [list(line.strip()) for line in f.readlines()]

# Initialize previous grids list
previous_grids = [deepcopy(grid)]
biodiversity = 0

# Process the grid until a repeated pattern is found
while True:
    new_grid = deepcopy(grid)
    for r, row in enumerate(grid):
        for c, cell in enumerate(row):
            if cell == '.':
                if count_adjacent_bugs(grid, r, c) == 1 or count_adjacent_bugs(grid, r, c) == 2:
                    new_grid[r][c] = '#'
            elif cell == '#':
                if count_adjacent_bugs(grid, r, c) != 1:
                    new_grid[r][c] = '.'
    grid = new_grid

    # Calculate biodiversity rating
    biodiversity = 0
    for r, row in enumerate(grid):
        for c, cell in enumerate(row):
            if cell == '#':
                biodiversity += 2 ** (r * 5 + c)

    # Check if the grid has been seen before
    if grid in previous_grids:
        break
    previous_grids.append(grid)

    # Print the current grid
    for row in grid:
        print(''.join(row))
    print()

print(""Biodiversity Rating:"", biodiversity)
",0
124,2019,25,1,runtime_error,,25166400,"Traceback (most recent call last):
  File ""/tmp/tmp77d3_n3a/tmp.py"", line 129, in <module>
    main()
  File ""/tmp/tmp77d3_n3a/tmp.py"", line 116, in main
    output = droid.get_output()
  File ""/tmp/tmp77d3_n3a/tmp.py"", line 19, in get_output
    return self.output_values.pop(0)
IndexError: pop from empty list
","
import re
import time
import random

class IntcodeComputer:
    def __init__(self, program):
        self.program = program
        self.input_values = []
        self.output_values = []
        self.pc = 0
        self.relative_base = 0
        self.halted = False

    def add_input(self, value):
        self.input_values.append(value)

    def get_output(self):
        return self.output_values.pop(0)

    def run(self):
        while not self.halted:
            self.step()

    def step(self):
        # read opcode
        opcode = self.program[self.pc]
        instruction = opcode % 100

        # get parameters
        modes = [int(d) for d in str(opcode // 100)]
        params = {
            1: self.param_position,
            2: self.param_immediate,
            0: self.param_position
        }[modes[1]]
        if len(modes) >= 2:
            modes[0] = int(modes[0])
        else:
            modes.insert(0, 0)
        if len(modes) >= 3:
            modes[1] = int(modes[1])
        else:
            modes.insert(1, 0)

        # execute instruction
        if instruction == 1:
            self.program[self.param_position(3, modes)] = params[0] + params[1]
            self.pc += 4
        elif instruction == 2:
            self.program[self.param_position(3, modes)] = params[0] * params[1]
            self.pc += 4
        elif instruction == 3:
            self.program[self.param_position(1, modes)] = self.input_values.pop(0)
            self.pc += 2
        elif instruction == 4:
            self.output_values.append(params[0])
            self.pc += 2
        elif instruction == 5:
            if params[0] != 0:
                self.pc = params[1]
            else:
                self.pc += 3
        elif instruction == 6:
            if params[0] == 0:
                self.pc = params[1]
            else:
                self.pc += 3
        elif instruction == 7:
            if params[0] < params[1]:
                self.program[self.param_position(3, modes)] = 1
            else:
                self.program[self.param_position(3, modes)] = 0
            self.pc += 4
        elif instruction == 8:
            if params[0] == params[1]:
                self.program[self.param_position(3, modes)] = 1
            else:
                self.program[self.param_position(3, modes)] = 0
            self.pc += 4
        elif instruction == 9:
            self.relative_base += params[0]
            self.pc += 2
        elif instruction == 99:
            self.halted = True
        else:
            raise ValueError(f""Unknown opcode: {opcode}"")

    def param_position(self, index, modes):
        if modes[index] == 0:
            return self.program[self.program[self.pc + index]]
        elif modes[index] == 1:
            return self.program[self.pc + index]
        elif modes[index] == 2:
            return self.program[self.program[self.pc + index] + self.relative_base]
        else:
            raise ValueError(f""Unknown parameter mode {modes[index]}"")

    def param_immediate(self, index, modes):
        if modes[index] == 0 or modes[index] == 2:
            return self.program[self.pc + index]
        elif modes[index] == 1:
            return self.pc + index
        else:
            raise ValueError(f""Unknown parameter mode {modes[index]}"")

def parse_input(filename):
    with open(filename, ""r"") as f:
        program = [int(x) for x in f.read().strip().split("","")]
    return program

def main():
    program = parse_input(""input.txt"")
    droid = IntcodeComputer(program)
    while not droid.halted:
        output = droid.get_output()
        if output is not None:
            print(chr(output), end="""")
        else:
            time.sleep(0.1)

        input_str = input(""Command? "")
        for char in input_str:
            droid.add_input(ord(char))
        droid.add_input(10)
        droid.run()

if __name__ == ""__main__"":
    main()
",0
125,2020,1,1,runtime_error,,928896,"Traceback (most recent call last):
  File ""/tmp/tmpar0wspz5/tmp.py"", line 12, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import sys
import itertools

def find_product(lst):
    pairs = itertools.combinations(lst, 2)
    for pair in pairs:
        if sum(pair) == 2020:
            return pair

if __name__ == ""__main__"":
    input_file = sys.argv[1]
    with open(input_file, ""r"") as file:
        expense_report = [int(line.strip()) for line in file.readlines()]
        pair = find_product(expense_report)
        product = pair[0] * pair[1]
        print(f""The product of the pair is: {product}"")
",0
126,2020,2,1,runtime_error,,434,"Traceback (most recent call last):
  File ""/tmp/tmphefs370n/tmp.py"", line 16, in <module>
    min_max, letter = re.findall(r""(\d+)-(\d+)\s(\w+)"", policy)[0]
ValueError: too many values to unpack (expected 2)
","
import re

# Open the input file
with open(""input.txt"", ""r"") as file:
    lines = file.readlines()

# Initialize a counter for valid passwords
valid_count = 0

for line in lines:
    # Split the line into policy and password
    policy, password = line.split("": "")
    
    # Extract the minimum and maximum number of occurrences from the policy
    min_max, letter = re.findall(r""(\d+)-(\d+)\s(\w+)"", policy)[0]
    min_occurrences, max_occurrences = map(int, min_max.split(""-""))

    # Check if the password meets the policy
    if min_occurrences <= password.count(letter) <= max_occurrences:
        valid_count += 1

# Print the result
print(f""Valid passwords: {valid_count}"")
",0
127,2020,3,1,wrong_output,,292,,"
import math

def count_trees(input_file, right, down):
    with open(input_file, 'r') as f:
        lines = f.readlines()
        row_length = len(lines[0].strip())
        trees_count = 0
        current_position = 0
        for i, line in enumerate(lines):
            if i % down == 0:
                if line[current_position % row_length] == '#':
                    trees_count += 1
                current_position += right
        return trees_count

def count_trees_for_multiple_slopes(input_file, slopes):
    total_trees = 1
    for slope in slopes:
        total_trees *= count_trees(input_file, slope[0], slope[1])
    return total_trees

# Example usage:
# slopes = [(1, 1), (3, 1), (5, 1), (7, 1), (1, 2)]
# print(count_trees_for_multiple_slopes('input.txt', slopes))
",0
128,2020,4,1,wrong_output,"233
233
",233,,"
import re

def is_valid_passport(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

def process_input(input_file):
    valid_passports_count = 0
    passport = {}
    for line in input_file:
        if line == '\n':
            if is_valid_passport(passport):
                valid_passports_count += 1
            passport = {}
        else:
            fields = line.strip().split()
            for field in fields:
                key, value = field.split(':')
                passport[key] = value
    if is_valid_passport(passport):
        valid_passports_count += 1
    return valid_passports_count

with open('input.txt', 'r') as f:
    input_file = f.readlines()
    print(process_input(input_file))


def is_valid_passport(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

def process_input(input_file):
    valid_passports_count = 0
    passport = {}
    for line in input_file:
        if line == '\n':
            if is_valid_passport(passport):
                valid_passports_count += 1
            passport = {}
        else:
            fields = line.strip().split()
            for field in fields:
                key, value = field.split(':')
                passport[key] = value
    if is_valid_passport(passport):
        valid_passports_count += 1
    return valid_passports_count

with open('input.txt', 'r') as f:
    input_file = f.readlines()
    print(process_input(input_file))
",0
129,2020,5,1,wrong_output,"Highest seat ID: 986
",987,,"
import re

def find_seat_id(boarding_pass):
    row_range = [0, 127]
    col_range = [0, 7]
    for i in range(7):
        if boarding_pass[i] == ""F"":
            row_range[1] = (row_range[0] + row_range[1]) // 2
        else:
            row_range[0] = (row_range[0] + row_range[1]) // 2 + 1
    row = row_range[0]
    for i in range(7, 9):
        if boarding_pass[i] == ""L"":
            col_range[1] = (col_range[0] + col_range[1]) // 2
        else:
            col_range[0] = (col_range[0] + col_range[1]) // 2 + 1
    col = col_range[0]
    return row * 8 + col

def main():
    with open(""input.txt"", ""r"") as file:
        seat_ids = [find_seat_id(line.strip()) for line in file.readlines()]
        max_seat_id = max(seat_ids)
        print(""Highest seat ID:"", max_seat_id)

if __name__ == ""__main__"":
    main()
",0
130,2020,6,1,timeout_error,,6775,TIMEOUT,"
import sys

count = 0
groups = sys.stdin.read().split('\n\n')

for group in groups:
    people = group.split('\n')
    if len(people) > 1:
        yes_answers = set(people[0])
        for person in people[1:]:
            yes_answers = yes_answers.intersection(set(person))
        count += len(yes_answers)
    else:
        count += len(set(people[0]))

print(count)
",0
131,2020,7,1,runtime_error,,226,"Traceback (most recent call last):
  File ""/tmp/tmpppwkgaax/tmp.py"", line 31, in <module>
    print(count_bags_that_can_contain_gold(rules))
  File ""/tmp/tmpppwkgaax/tmp.py"", line 15, in count_bags_that_can_contain_gold
    if can_contain_gold(bag, rules):
  File ""/tmp/tmpppwkgaax/tmp.py"", line 8, in can_contain_gold
    if can_contain_gold(sub_bag, rules):
  File ""/tmp/tmpppwkgaax/tmp.py"", line 5, in can_contain_gold
    if 'shiny gold' in rules[bag]:
KeyError: 'shiny teal bags, 5 bright white bags, 4 striped bronze'
","
import re

def can_contain_gold(bag, rules):
    if 'shiny gold' in rules[bag]:
        return True
    for sub_bag in rules[bag]:
        if can_contain_gold(sub_bag, rules):
            return True
    return False

def count_bags_that_can_contain_gold(rules):
    count = 0
    for bag in rules:
        if can_contain_gold(bag, rules):
            count += 1
    return count - 1 # Subtract 1 to not count the shiny gold bag

def parse_rules(rules_str):
    rules = {}
    for rule in rules_str.split('\n'):
        bag, contents = re.match(r'(.+) bags contain (.+).', rule).groups()
        contents = re.findall(r'(\d+) (.+) bags?', contents)
        contents = {bag: int(count) for count, bag in contents}
        rules[bag] = contents
    return rules

with open('input.txt', 'r') as f:
    rules_str = f.read()
    rules = parse_rules(rules_str)
    print(count_bags_that_can_contain_gold(rules))
",0
132,2020,8,1,wrong_output,"The value of the accumulator before the infinite loop is: 1384
",1384,,"
import re

def main():
    with open(""input.txt"", ""r"") as file:
        lines = file.readlines()
        instructions = []
        for line in lines:
            match = re.match(r""(?P<operation>nop|acc|jmp) (?P<argument>[+-]\d+)"", line.strip())
            operation = match.group(""operation"")
            argument = int(match.group(""argument""))
            instructions.append((operation, argument))

        executed_instructions = set()
        accumulator = 0
        current_line = 0
        while current_line not in executed_instructions:
            executed_instructions.add(current_line)
            operation, argument = instructions[current_line]
            if operation == ""acc"":
                accumulator += argument
                current_line += 1
            elif operation == ""jmp"":
                current_line += argument
            else: # operation == ""nop""
                current_line += 1

        print(""The value of the accumulator before the infinite loop is:"", accumulator)

if __name__ == ""__main__"":
    main()
",0
133,2020,9,1,runtime_error,,258585477,"Traceback (most recent call last):
  File ""/tmp/tmp9zxnvxtx/tmp.py"", line 36, in <module>
    main()
  File ""/tmp/tmp9zxnvxtx/tmp.py"", line 29, in main
    invalid_number = is_valid(numbers, preamble_length)
TypeError: is_valid() missing 1 required positional argument: 'preamble_length'
","
import re

def is_valid(numbers, n, preamble_length):
    for i in range(preamble_length, len(numbers)):
        valid = False
        for j in range(i - preamble_length, i):
            for k in range(j + 1, i):
                if numbers[i] == numbers[j] + numbers[k]:
                    valid = True
                    break
            if valid:
                break
        if not valid:
            return numbers[i]

def find_contiguous_set(numbers, target):
    for i in range(len(numbers)):
        for j in range(i + 2, len(numbers)):
            contiguous_set = numbers[i:j]
            if sum(contiguous_set) == target:
                return contiguous_set

def main():
    with open('input.txt', 'r') as file:
        numbers = [int(line.strip()) for line in file.readlines()]

    preamble_length = 25
    invalid_number = is_valid(numbers, preamble_length)
    print(f""Part 1: The first invalid number is {invalid_number}"")

    contiguous_set = find_contiguous_set(numbers, invalid_number)
    print(f""Part 2: The encryption weakness is {min(contiguous_set) + max(contiguous_set)}"")

if __name__ == ""__main__"":
    main()
",0
134,2020,10,1,wrong_output,"Usage: python day10.py <input_file_name>
",2263,,"
import sys

def read_input_file(file_name):
    with open(file_name, 'r') as file:
        return [int(line.strip()) for line in file.readlines()]

def count_joltage_differences(adapters):
    adapters.sort()
    adapters.insert(0, 0)
    differences = [adapters[i+1] - adapters[i] for i in range(len(adapters)-1)]
    return differences

def count_difference_distribution(differences):
    diff_count = {k:0 for k in [1, 2, 3]}
    for diff in differences:
        diff_count[diff] += 1
    return diff_count[1] * diff_count[3]

def main(file_name):
    adapters = read_input_file(file_name)
    differences = count_joltage_differences(adapters)
    result = count_difference_distribution(differences)
    print(f""The number of 1-jolt differences multiplied by the number of 3-jolt differences is: {result}"")

if __name__ == ""__main__"":
    if len(sys.argv) != 2:
        print(""Usage: python day10.py <input_file_name>"")
        sys.exit(1)
    main(sys.argv[1])
",0
135,2020,11,1,timeout_error,,2368,TIMEOUT,"
import os

def get_input():
    with open(""input.txt"", ""r"") as f:
        lines = f.read().split(""\n"")
    return lines

def count_occupied_seats(layout):
    count = 0
    for row in layout:
        for seat in row:
            if seat == ""#"":
                count += 1
    return count

def is_valid(x, y, layout):
    return 0 <= x < len(layout) and 0 <= y < len(layout[0])

def count_adjacent_occupied_seats(x, y, layout):
    adjacent_seats = [(x-1, y-1), (x-1, y), (x-1, y+1), (x, y-1), (x, y+1), (x+1, y-1), (x+1, y), (x+1, y+1), (x-1, y+1), (x+1, y-1)]
    count = 0
    for seat in adjacent_seats:
        if is_valid(seat[0], seat[1], layout) and layout[seat[0]][seat[1]] == ""#"":
            count += 1
    return count

def generate_new_layout(layout):
    new_layout = []
    for i in range(len(layout)):
        row = """"
        for j in range(len(layout[i])):
            if layout[i][j] == ""L"" and count_adjacent_occupied_seats(i, j, layout) == 0:
                row += ""#""
            elif layout[i][j] == ""#"" and count_adjacent_occupied_seats(i, j, layout) >= 4:
                row += ""L""
            else:
                row += layout[i][j]
        new_layout.append(row)
    return new_layout

def main():
    layout = get_input()
    while True:
        new_layout = generate_new_layout(layout)
        if new_layout == layout:
            break
        layout = new_layout
    print(""Occupied seats:"", count_occupied_seats(layout))

if __name__ == ""__main__"":
    main()
",0
136,2020,12,1,no_error,"962
",962,,"
import math
import re

def navigate(instructions):
    position = [0, 0]
    direction = 0

    for i in instructions:
        action, value = i[0], int(i[1:])
        if action == 'N':
            position[1] += value
        elif action == 'S':
            position[1] -= value
        elif action == 'E':
            position[0] += value
        elif action == 'W':
            position[0] -= value
        elif action == 'L':
            direction += value
        elif action == 'R':
            direction -= value
        elif action == 'F':
            position[0] += round(math.cos(math.radians(direction)) * value)
            position[1] += round(math.sin(math.radians(direction)) * value)
        direction = (direction + 360) % 360

    return sum(map(abs, position))

with open('input.txt') as f:
    instructions = [line.strip() for line in f]

print(navigate(instructions))
",0
137,2020,13,1,no_error,"2095
",2095,,"
import math

def earliest_bus(earliest_timestamp, bus_ids):
    earliest_bus_id = 0
    min_wait_time = math.inf
    for bus_id in bus_ids:
        wait_time = bus_id - (earliest_timestamp % bus_id)
        if wait_time < min_wait_time:
            min_wait_time = wait_time
            earliest_bus_id = bus_id
    return earliest_bus_id * min_wait_time

with open('input.txt', 'r') as file:
    earliest_timestamp = int(file.readline().strip())
    bus_ids = [int(bus_id) for bus_id in file.readline().strip().split(',') if bus_id != 'x']
    print(earliest_bus(earliest_timestamp, bus_ids))
",0
138,2020,14,1,timeout_error,,14553106347726,TIMEOUT,"
import re

def apply_mask(mask, value):
    # Convert value to binary and pad it to 36 bits
    binary_value = format(value, '036b')

    # Apply the mask to the binary value
    masked_value = ''.join([value if mask_bit == 'X' else mask_bit for value, mask_bit in zip(binary_value, mask)])
    
    return int(masked_value, 2)

# Initialize memory dictionary with all values set to 0
memory = {address: 0 for address in range(2 ** 36)}

# Read input file
with open('input.txt') as f:
    lines = f.readlines()

# Iterate over each line in the input
for line in lines:
    line = line.strip()

    # Check if line is a mask update or memory write
    if line.startswith('mask'):
        mask = line.split('=')[1].strip()
    else:
        # Extract address and value
        address, value = map(int, re.findall('\d+', line))

        # Apply the mask to the value and write to memory
        masked_value = apply_mask(mask, value)
        memory[address] = masked_value

# Calculate the sum of all values in memory
memory_sum = sum(memory.values())

print(memory_sum)
",0
139,2020,15,1,wrong_output,"2020th number spoken: 468
",468,,"
from collections import defaultdict
from typing import List

def memory_game(starting_numbers: List[int], turns: int) -> int:
    history = defaultdict(list)
    last_number = None
    for i, number in enumerate(starting_numbers):
        history[number].append(i + 1)
        last_number = number

    for turn in range(len(starting_numbers) + 1, turns + 1):
        if len(history[last_number]) == 1:
            new_number = 0
        else:
            new_number = history[last_number][-1] - history[last_number][-2]
        history[new_number].append(turn)
        last_number = new_number

    return last_number

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        starting_numbers = [int(x.strip()) for x in file.read().split("","")]
    print(f""2020th number spoken: {memory_game(starting_numbers, 2020)}"")
",0
140,2020,16,1,syntax_error,,26026,"  File ""/tmp/tmpkf4h8ft3/tmp.py"", line 29
    invalid_values = []
    ^
SyntaxError: invalid syntax
","
import re

def is_valid_value(value, valid_ranges):
    for range_ in valid_ranges:
        if int(value) in range_:
            return True
    return False

def main():
    # Read input file
    with open('input.txt', 'r') as f:
        lines = f.readlines()

    # Extract fields and valid ranges
    fields = {}
    for line in lines:
        if ':' in line:
            field, ranges = line.strip().split(': ')
            range_strs = re.findall(r'\d+-\d+', ranges)
            fields[field] = [list(range(int(r.split('-')[0]), int(r.split('-')[1] + 1)) for r in range_strs)]

    # Extract nearby tickets
    tickets = []
    for line in lines:
        if ',' in line and ':' not in line:
            tickets.append(list(map(int, line.strip().split(',')))

    invalid_values = []
    for ticket in tickets:
        for value in ticket:
            if not any(is_valid_value(value, fields.values()):
                invalid_values.append(value)

    # Calculate ticket scanning error rate
    ticket_scanning_error_rate = sum(invalid_values)
    print(f""Ticket scanning error rate: {ticket_scanning_error_rate}"")

if __name__ == '__main__':
    main()
",0
141,2020,17,1,wrong_output,"Active cubes after 6 cycles: 18
",263,,"
from copy import deepcopy
from itertools import product

def get_neighbors(x, y, z, w):
    for dx, dy, dz in product([-1, 0, 1], repeat=3):
        if any([dx, dy, dz]):
            yield x + dx, y + dy, z + dz, w

def initialize_pocket_dimension(input_file):
    pocket_dimension = {}
    with open(input_file, 'r') as f:
        for y, line in enumerate(f):
            for x, char in enumerate(line.strip()):
                pocket_dimension[(x, y, 0, 0) ] = char
    return pocket_dimension

def simulate_cycle(pocket_dimension):
    new_pocket_dimension = deepcopy(pocket_dimension)
    for coord in pocket_dimension:
        active_neighbors = sum(pocket_dimension.get(neighbor, '.') == '#' for neighbor in get_neighbors(*coord))
        if pocket_dimension[coord] == '#' and (active_neighbors == 2 or active_neighbors == 3):
            new_pocket_dimension[coord] = '#'
        elif pocket_dimension[coord] == '.' and active_neighbors == 3:
            new_pocket_dimension[coord] = '#'
        else:
            new_pocket_dimension[coord] = '.'
    return new_pocket_dimension

def simulate_cycles(pocket_dimension, cycles):
    for _ in range(cycles):
        pocket_dimension = simulate_cycle(pocket_dimension)
    return pocket_dimension

def count_active_cubes(pocket_dimension):
    return sum(cube == '#' for cube in pocket_dimension.values())

def main():
    pocket_dimension = initialize_pocket_dimension('input.txt')
    pocket_dimension = simulate_cycles(pocket_dimension, 6)
    print(f""Active cubes after 6 cycles: {count_active_cubes(pocket_dimension)}"")

if __name__ == ""__main__"":
    main()
",0
142,2020,18,1,runtime_error,,31142189909908,"Traceback (most recent call last):
  File ""/tmp/tmpm6aj7k8f/tmp.py"", line 25, in <module>
    total += evaluate_expression(line.strip())
  File ""/tmp/tmpm6aj7k8f/tmp.py"", line 9, in evaluate_expression
    result = evaluate_expression(inner_expression)
  File ""/tmp/tmpm6aj7k8f/tmp.py"", line 9, in evaluate_expression
    result = evaluate_expression(inner_expression)
  File ""/tmp/tmpm6aj7k8f/tmp.py"", line 9, in evaluate_expression
    result = evaluate_expression(inner_expression)
  File ""/tmp/tmpm6aj7k8f/tmp.py"", line 17, in evaluate_expression
    result *= int(parts[i+1])
ValueError: invalid literal for int() with base 10: ' '
","
import re

def evaluate_expression(expression):
    while '(' in expression:
        start = expression.find('(')
        end = expression.rfind(')')
        inner_expression = expression[start+1:end]
        result = evaluate_expression(inner_expression)
        expression = expression[:start] + str(result) + expression[end+1:]
    parts = re.split(r'(\+|\*)', expression)
    result = int(parts[0])
    for i in range(1, len(parts), 2):
        if parts[i] == '+':
            result += int(parts[i+1])
        else:
            result *= int(parts[i+1])
    return result

with open('input.txt', 'r') as file:
    lines = file.readlines()

total = 0
for line in lines:
    total += evaluate_expression(line.strip())

print(total)
",0
143,2020,19,1,runtime_error,,173,"Traceback (most recent call last):
  File ""/tmp/tmp6ycvtek7/tmp.py"", line 41, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import re
import sys

def parse_input(input_file):
    rules = {}
    messages = []
    is_rule = True
    with open(input_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line == '':
                is_rule = False
            elif is_rule:
                rule_num, rule = line.split(':')
                rules[int(rule_num)] = rule.strip().strip('""')
            else:
                messages.append(line)
    return rules, messages

def generate_regex(rules, rule_num):
    if rules[rule_num].isalpha():
        return rules[rule_num]
    else:
        regex = '('
        for subrule in rules[rule_num].split('|'):
            regex += '(' + ''.join(generate_regex(rules, int(r)) for r in subrule.split()) + ')'
            regex += '|'
        return regex[:-1] + ')'

def count_valid_messages(input_file):
    rules, messages = parse_input(input_file)
    regex = re.compile(generate_regex(rules, 0))
    count = 0
    for message in messages:
        if regex.fullmatch(message) is not None:
            count += 1
    return count

if __name__ == '__main__':
    input_file = sys.argv[1]
    print(count_valid_messages(input_file))
",0
144,2020,20,1,wrong_output,"1
",15003787688423,,"
import math
import collections

# Define a function to rotate a tile
def rotate_tile(tile):
    rotated = []
    for i in range(len(tile)-1, -1, -1):
        row = ''
        for j in range(len(tile)):
            row += tile[j][i]
        rotated.append(row)
    return rotated

# Define a function to flip a tile
def flip_tile(tile):
    flipped = []
    for row in tile:
        flipped.append(row[::-1])
    return flipped

# Define a function to generate all possible variations of a tile
def generate_variations(tile):
    variations = [tile]
    variations.append(rotate_tile(tile))
    variations.append(rotate_tile(variations[1]))
    variations.append(rotate_tile(variations[2]))
    variations.append(rotate_tile(variations[3])[::-1])
    variations.append(rotate_tile(variations[4])[::-1])
    variations.append(tile[::-1])
    variations.append(rotate_tile(tile[::-1]))
    variations.append(rotate_tile(variations[6])[::-1])
    variations.append(rotate_tile(variations[7])[::-1])
    return variations

# Define a function to check if two tiles are compatible
def is_compatible(t1, t2):
    for side in range(4):
        if t1[side] == t2[side] or t1[side] == t2[side][::-1]:
            return True
    return False

# Define a function to find the number of borders that match between two tiles
def num_matching_borders(t1, t2):
    count = 0
    for side in range(4):
        if t1[side] == t2[side] or t1[side] == t2[side][::-1]:
            count += 1
    return count

# Read the input file and store the tiles in a dictionary
tile_dict = {}
with open('input.txt', 'r') as file:
    lines = file.readlines()
    for i in range(0, len(lines), 12):
        tile_id = int(lines[i].strip()[5:-1])
        tile = [line.strip() for line in lines[i+1:i+11]]
        tile_dict[tile_id] = generate_variations(tile)

# Create a dictionary to store the connections between tiles
connections = collections.defaultdict(set)
for tile_id, variations in tile_dict.items():
    for id2, variations2 in tile_dict.items():
        if tile_id != id2:
            for var1 in variations:
                for var2 in variations2:
                    if is_compatible(var1, var2):
                        connections[tile_id].add(id2)
                        connections[id2].add(tile_id)

# Find the corner tiles
corner_tiles = []
for tile_id, connected_tiles in connections.items():
    if len(connected_tiles) == 2:
        corner_tiles.append(tile_id)

# Calculate the product of the corner tile IDs
product = 1
for tile_id in corner_tiles:
    product *= tile_id

# Print the result
print(product)
",0
145,2020,21,1,wrong_output,"0
",2542,,"
import re

# Reading input file
with open(""input.txt"", ""r"") as file:
    lines = file.readlines()

# Creating a set of allergens and a dictionary of ingredients and their allergens
allergens = set()
ingredients_allergens = {}
for line in lines:
    allergens_in_line = re.findall(r""\(contains ([a-z, ]+)\)"", line)
    for a in allergens_in_line:
        allergens.update(a.split("", ""))
    ingredients = re.findall(r""([a-z]+) \("", line) + re.findall(r""([a-z]+)\)"", line)
    for i in ingredients:
        if i not in ingredients_allergens:
            ingredients_allergens[i] = set(allergens_in_line)
        else:
            ingredients_allergens[i].update(allergens_in_line)

# Creating a set of ingredients that cannot contain allergens
safe_ingredients = set()
for i in ingredients_allergens:
    if not ingredients_allergens[i]:
        safe_ingredients.add(i)

# Counting the number of times safe ingredients appear
count = 0
for line in lines:
    for ing in safe_ingredients:
        count += line.count(ing)

print(count)
",0
146,2020,22,1,syntax_error,,34255,"  File ""/tmp/tmppxs8wlat/tmp.py"", line 9
    return player_1_deck, player_2_deck
    ^
SyntaxError: invalid syntax
","
from typing import List, Tuple

def parse_input(input_file: str) -> Tuple[List[int], List[int]]:
    with open(input_file, 'r') as f:
        player_1_data, player_2_data = f.read().split('\n\n')
        player_1_deck = list(map(int, player_1_data.split('\n')[1:]))
        player_2_deck = list(map(int, player_2_data.split('\n')[1:])
    return player_1_deck, player_2_deck

def play_round(player_1_deck: List[int], player_2_deck: List[int]) -> Tuple[List[int], List[int]]:
    player_1_card = player_1_deck.pop(0)
    player_2_card = player_2_deck.pop(0)

    if player_1_card > player_2_card:
        player_1_deck += [player_1_card, player_2_card]
    else:
        player_2_deck += [player_2_card, player_1_card]

    return player_1_deck, player_2_deck

def calculate_score(deck: List[int]) -> int:
    return sum([card * (i + 1) for i, card in enumerate(deck[::-1])])

def play_game(player_1_deck: List[int], player_2_deck: List[int]) -> Tuple[List[int], List[int], int]:
    while player_1_deck and player_2_deck:
        player_1_deck, player_2_deck = play_round(player_1_deck, player_2_deck)

    return player_1_deck, player_2_deck, calculate_score(player_1_deck if player_1_deck else player_2_deck)

def main():
    player_1_deck, player_2_deck = parse_input('input.txt')
    _, _, score = play_game(player_1_deck, player_2_deck)
    print(f""Winning player's score: {score}"")

if __name__ == '__main__':
    main()
",0
147,2020,23,1,syntax_error,,49576328,"  File ""/tmp/tmpeu3s3gou/tmp.py"", line 26
    result = play_game(input_cups)
    ^
SyntaxError: invalid syntax
","
from collections import deque

def play_game(cups, turns=100):
    cups_list = deque(cups)
    current_cup = cups_list[0]
    for _ in range(turns):
        picked_up = [cups_list.popleft(), cups_list.popleft(), cups_list.popleft()]
        destination_cup = current_cup - 1
        while destination_cup < 1 or destination_cup not in cups_list:
            if destination_cup < 1:
                destination_cup = max(cups_list)
            else:
                destination_cup -= 1
        destination_index = cups_list.index(destination_cup)
        cups_list.insert(destination_index + 1, picked_up[0])
        cups_list.insert(destination_index + 2, picked_up[1])
        cups_list.insert(destination_index + 3, picked_up[2])
        current_cup = cups_list[(cups_list.index(current_cup) + 1) % len(cups_list)]
    index_of_1 = cups_list.index(1)
    cups_list.rotate(-index_of_1)
    return ''.join(map(str, list(cups_list)[1:])[:-1])

with open(""input.txt"", ""r"") as f:
    input_cups = list(map(int, list(f.read().strip()))
    result = play_game(input_cups)
    print(result)
",0
148,2020,24,1,runtime_error,,356,"Traceback (most recent call last):
  File ""/tmp/tmpw_pa_78a/tmp.py"", line 19, in <module>
    print(flip_tiles('input.txt'))
  File ""/tmp/tmpw_pa_78a/tmp.py"", line 13, in flip_tiles
    delta = directions[step]
KeyError: 's'
","
from collections import defaultdict

def flip_tiles(input_file):
    tiles = defaultdict(lambda: False)  # initialize all tiles as white
    reference_tile = (0, 0)  # reference tile is at the center
    directions = {'e': (1, 0), 'se': (0.5, -1), 'sw': (-0.5, -1), 'w': (-1, 0), 'nw': (-0.5, 1), 'ne': (0.5, 1)}

    with open(input_file, 'r') as f:
        for line in f:
            current_tile = reference_tile
            for step in line.strip():
                delta = directions[step]
                current_tile = (current_tile[0] + delta[0], current_tile[1] + delta[1])
            tiles[current_tile] = not tiles[current_tile]

    return sum(1 for color in tiles.values() if color)

print(flip_tiles('input.txt'))
",0
149,2020,25,1,timeout_error,,711945,TIMEOUT,"
import math
import hashlib

def transform_subject_number(subject_number, loop_size):
    value = 1
    for _ in range(loop_size):
        value *= subject_number
        value %= 2020127
    return value

def find_loop_size(public_key):
    value = 1
    loop_size = 1
    while value != public_key:
        value *= 7
        value %= 2020127
        loop_size += 1
    return loop_size

def find_encryption_key(card_public_key, door_public_key):
    card_loop_size = find_loop_size(card_public_key)
    door_loop_size = find_loop_size(door_public_key)
    encryption_key = transform_subject_number(door_public_key, card_loop_size)
    return encryption_key

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as f:
        card_public_key, door_public_key = map(int, f.read().strip().split(""\n""))
    encryption_key = find_encryption_key(card_public_key, door_public_key)
    print(f""Encryption key: {encryption_key}"")
",0
150,2021,1,1,no_error,"1532
",1532,,"
import os

file_path = 'input.txt'

if os.path.exists(file_path):
    with open(file_path, 'r') as file:
        depths = [int(line.strip()) for line in file.readlines()]
        increases = 0
        for i in range(1, len(depths)):
            if depths[i] > depths[i-1]:
                increases += 1
        print(increases)
else:
    print(""File not found"")
",0
151,2021,2,1,wrong_output,"1990000
1990000
",1990000,,"
import re

horizontal_position = 0
depth = 0

with open('input.txt', 'r') as file:
    for line in file:
        direction, value = re.findall(r'(\w+) (\d+)', line.strip())[0]
        value = int(value)
        if direction == 'forward':
            horizontal_position += value
        elif direction == 'down':
            depth += value
        else:
            depth -= value

print(horizontal_position * depth)


horizontal_position = 0
depth = 0

with open('input.txt', 'r') as file:
    for line in file:
        direction, value = line.strip().split()
        value = int(value)
        if direction == 'forward':
            horizontal_position += value
        elif direction == 'down':
            depth += value
        else:
            depth -= value

print(horizontal_position * depth)
",0
152,2021,3,1,syntax_error,,3549854,"  File ""/tmp/tmpf31x9a_0/tmp.py"", line 11
    for i in range(len(numbers[0]):
                                  ^
SyntaxError: invalid syntax
","
import os

def main():
    with open(os.path.join(os.path.dirname(__file__), 'input.txt'), 'r') as file:
        numbers = [line.strip() for line in file.readlines()]

    gamma_rate = ''
    epsilon_rate = ''

    for i in range(len(numbers[0]):
        bits = [num[i] for num in numbers]
        most_common_bit = max(bits, key=bits.count)
        least_common_bit = '0' if most_common_bit == '1' else '1'

        gamma_rate += most_common_bit
        epsilon_rate += least_common_bit

    print(f'Gamma rate: {int(gamma_rate, 2)}')
    print(f'Epsilon rate: {int(epsilon_rate, 2)}')
    print(f'Power consumption: {int(gamma_rate, 2) * int(epsilon_rate, 2)}')

if __name__ == '__main__':
    main()


numbers = [
    '00100',
    '11100',
    '10110',
    '10111',
    '10101',
    '01111',
    '00111',
    '11100',
    '10000',
    '11001',
    '00010',
    '01010'
]

gamma_rate = ''
epsilon_rate = ''

for i in range(len(numbers[0]):
    bits = [num[i] for num in numbers]
    most_common_bit = max(bits, key=bits.count)
    least_common_bit = '0' if most_common_bit == '1' else '1'

    gamma_rate += most_common_bit
    epsilon_rate += least_common_bit

print(f'Gamma rate: {int(gamma_rate, 2)}')
print(f'Epsilon rate: {int(epsilon_rate, 2)}')
print(f'Power consumption: {int(gamma_rate, 2) * int(epsilon_rate, 2)}')
",0
153,2021,4,1,syntax_error,,49860,"  File ""/tmp/tmpicpk07b2/tmp.py"", line 39
    return unmarked_sum * drawn_number
    ^
SyntaxError: invalid syntax
","
import random
import sys

def read_input_file(filename):
    with open(filename, ""r"") as file:
        data = file.read().splitlines()
    return data

def generate_boards(data):
    boards = []
    board = []
    for line in data[1:]:
        if line == '':
            boards.append(board)
            board = []
            continue
        row = [int(num) for num in line.split()]
        board.append(row)
    return boards

def mark_board(board, drawn_number):
    for i, row in enumerate(board):
        for j, num in enumerate(row):
            if num == drawn_number:
                board[i][j] = 'x'

def check_win(board):
    for row in board:
        if all(num == 'x' for num in row):
            return True
    for j in range(len(board[0])):
        if all(row[j] == 'x' for row in board):
            return True
    return False

def calculate_score(board, drawn_number):
    unmarked_sum = sum(sum(num for num in row if isinstance(num, int) for row in board)
    return unmarked_sum * drawn_number

def main():
    data = read_input_file('input.txt')
    bingo_numbers = [int(num) for num in data[0].split(',')]
    boards = generate_boards(data)
    winning_board = None
    for number in bingo_numbers:
        for board in boards:
            mark_board(board, number)
            if check_win(board):
                winning_board = board
                break
        if winning_board:
            break
    score = calculate_score(winning_board, number)
    print(""Final Score: "", score)

if __name__ == ""__main__"":
    main()
",0
154,2021,5,1,wrong_output,"Please provide input file
",6710,,"
import sys

def count_overlap(input_file):
    with open(input_file, 'r') as file:
        lines = file.readlines()

    # create a dictionary to store the count of lines at each point
    lines_dict = {}

    # iterate over each line in the input file
    for line in lines:
        # extract the coordinates
        x1, y1, x2, y2 = map(int, line.strip().split(','))
        # check if the line is horizontal or vertical
        if x1 == x2:
            min_y, max_y = min(y1, y2), max(y1, y2)
            for y in range(min_y, max_y + 1):
                point = f""{x1},{y}""
                if point in lines_dict:
                    lines_dict[point] += 1
                else:
                    lines_dict[point] = 1
        elif y1 == y2:
            min_x, max_x = min(x1, x2), max(x1, x2)
            for x in range(min_x, max_x + 1):
                point = f""{x},{y1}""
                if point in lines_dict:
                    lines_dict[point] += 1
                else:
                    lines_dict[point] = 1

    # count the number of points with overlap
    overlap_count = sum(1 for val in lines_dict.values() if val > 1)

    return overlap_count

if __name__ == ""__main__"":
    if len(sys.argv) != 2:
        print(""Please provide input file"")
        sys.exit(1)

    input_file = sys.argv[1]
    print(f""The number of points with at least two overlapping lines is: {count_overlap(input_file)}"")
",0
155,2021,6,1,runtime_error,,380243,"Traceback (most recent call last):
  File ""/tmp/tmps3j_2qip/tmp.py"", line 21, in <module>
    input_file = sys.argv[1]
IndexError: list index out of range
","
import sys
from collections import Counter

def simulate_lanternfish(input_list, days):
    fish_count = Counter(input_list)
    
    for _ in range(days):
        new_fish_count = Counter()
        for timer, count in fish_count.items():
            if timer == 0:
                new_fish_count[6] += count
                new_fish_count[8] += count
            else:
                new_fish_count[timer - 1] += count
        fish_count = new_fish_count
    
    return sum(fish_count.values())

if __name__ == ""__main__"":
    input_file = sys.argv[1]
    input_list = [int(x) for x in open(input_file, 'r').read().split(',')]
    days = 80
    result = simulate_lanternfish(input_list, days)
    print(f""After {days} days, there will be {result} lanternfish."")
",0
156,2021,7,1,no_error,"344297
",344297,,"
import math

def align_crabs(crabs):
    # Define a list to store the fuel costs for each possible position
    fuel_costs = []

    # Determine the range of horizontal positions
    min_pos = min(crabs)
    max_pos = max(crabs)

    # Iterate over each possible position
    for pos in range(min_pos, max_pos + 1):
        # Calculate the fuel cost for this position
        fuel_cost = sum([abs(crab - pos) for crab in crabs])

        # Add the fuel cost to the list
        fuel_costs.append(fuel_cost)

    # Return the minimum fuel cost
    return min(fuel_costs)

# Read input from file
with open(""input.txt"", ""r"") as f:
    crabs = [int(x) for x in f.readline().strip().split("","")]

# Align the crabs and print the minimum fuel cost
print(align_crabs(crabs))
",0
157,2021,8,1,no_error,"440
",440,,"
import re

def count_easy_digits(filename):
    count = 0
    with open(filename, 'r') as f:
        for line in f:
            output_values = line.split('|')[-1].strip().split()
            for value in output_values:
                if len(value) in [2, 3, 4, 7]:
                    count += 1
    return count

print(count_easy_digits('input.txt'))
",0
158,2021,9,1,syntax_error,,462,"  File ""/tmp/tmpc2hdypxc/tmp.py"", line 9
    def is_low_point(heightmap: List[List[int], row: int, col: int) -> bool:
                                                                  ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def read_input_file(file_name: str) -> List[List[int]]:
    with open(file_name, 'r') as f:
        data = [[int(char) for char in line.strip()] for line in f.readlines()]
    return data

def is_low_point(heightmap: List[List[int], row: int, col: int) -> bool:
    if row > 0 and heightmap[row][col] >= heightmap[row - 1][col]:
        return False
    if row < len(heightmap) - 1 and heightmap[row][col] >= heightmap[row + 1][col]:
        return False
    if col > 0 and heightmap[row][col] >= heightmap[row][col - 1]:
        return False
    if col < len(heightmap[0]) - 1 and heightmap[row][col] >= heightmap[row][col + 1]:
        return False
    return True

def calculate_risk_level(heightmap: List[List[int], row: int, col: int) -> int:
    return heightmap[row][col] + 1

def find_low_points(heightmap: List[List[int]) -> List[Tuple[int, int]]:
    low_points = []
    for row in range(len(heightmap)):
        for col in range(len(heightmap[0]):
            if is_low_point(heightmap, row, col):
                low_points.append((row, col))
    return low_points

def calculate_risk_level_sum(heightmap: List[List[int]) -> int:
    low_points = find_low_points(heightmap)
    return sum(calculate_risk_level(heightmap, row, col) for row, col in low_points)

if __name__ == ""__main__"":
    heightmap = read_input_file(""input.txt"")
    risk_level_sum = calculate_risk_level_sum(heightmap)
    print(""The sum of the risk levels of all low points is:"", risk_level_sum)
",0
159,2021,10,1,runtime_error,,299793,"Traceback (most recent call last):
  File ""/tmp/tmpys8pmj49/tmp.py"", line 49, in <module>
    file_path = sys.argv[1]
IndexError: list index out of range
","
import sys

def score(char):
    if char == "")"":
        return 3
    elif char == ""]"":
        return 57
    elif char == ""}"":
        return 1197
    elif char == "">"":
        return 25137
    else:
        return 0

def is_match(open_char, close_char):
    if open_char == ""("" and close_char == "")"":
        return True
    elif open_char == ""["" and close_char == ""]"":
        return True
    elif open_char == ""{"" and close_char == ""}"":
        return True
    elif open_char == ""<"" and close_char == "">"":
        return True
    return False

def find_corrupted_lines(file_path):
    with open(file_path) as file:
        lines = file.readlines()
        total_score = 0
        for line in lines:
            stack = []
            for char in line.strip():
                if char in [""("", ""["", ""{"", ""<""]:
                    stack.append(char)
                elif char in ["")"", ""]"", ""}"", "">""]:
                    if not stack:
                        total_score += score(char)
                        break
                    elif not is_match(stack.pop(), char):
                        total_score += score(char)
                        break
            else:
                if stack:
                    total_score += 0
        return total_score

if __name__ == ""__main__"":
    file_path = sys.argv[1]
    result = find_corrupted_lines(file_path)
    print(f""Total syntax error score: {result}"")
",0
160,2021,11,1,syntax_error,,1793,"  File ""/tmp/tmplksneezx/tmp.py"", line 52
    octopus_grid = np.array([list(map(int, line.strip()) for line in f.readlines()))
                                                                                   ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import numpy as np
from copy import deepcopy

def simulate_step(octopus_grid):
    # Increase energy level of all octopuses by 1
    octopus_grid += 1

    # Initialize variable to keep track of flashes
    flashed_octopuses = set()

    # Keep track of the number of flashes
    num_flashes = 0

    # Keep track of the octopuses that need to be checked for flashing
    to_check = set()
    for i in range(10):
        for j in range(10):
            to_check.add((i,j))

    # While there are still octopuses to check for flashing
    while to_check:
        # Get the current octopus to check
        i, j = to_check.pop()

        # If the octopus has flashed or has an energy level less than or equal to 9, continue
        if (i, j) in flashed_octopuses or octopus_grid[i][j] <= 9:
            continue

        # Flash the octopus
        octopus_grid[i][j] = 0
        num_flashes += 1
        flashed_octopuses.add((i,j))

        # Add adjacent octopuses to the set of octopuses to check
        for di in [-1, 0, 1]:
            for dj in [-1, 0, 1]:
                if 0 <= i+di < 10 and 0 <= j+dj < 10:
                    octopus_grid[i+di][j+dj] += 1
                    to_check.add((i+di, j+dj))

    return num_flashes

def simulate_steps(octopus_grid, num_steps):
    total_flashes = 0
    for _ in range(num_steps):
        total_flashes += simulate_step(octopus_grid)
    return total_flashes

# Read in the input file
with open('input.txt') as f:
    octopus_grid = np.array([list(map(int, line.strip()) for line in f.readlines()))

# Simulate 100 steps
total_flashes = simulate_steps(deepcopy(octopus_grid), 100)

# Print the result
print(total_flashes)
",0
161,2021,12,1,runtime_error,"3887
3887
",3887,"Traceback (most recent call last):
  File ""/tmp/tmpuh1j5fce/tmp.py"", line 48, in <module>
    print(part1('input2.txt')) # should print 19
  File ""/tmp/tmpuh1j5fce/tmp.py"", line 31, in part1
    graph = read_graph(input_file)
  File ""/tmp/tmpuh1j5fce/tmp.py"", line 23, in read_graph
    with open(input_file, 'r') as file:
FileNotFoundError: [Errno 2] No such file or directory: 'input2.txt'
","
from collections import defaultdict
from itertools import permutations

def generate_paths(graph, start, end, path=None):
    if path is None:
        path = []
    path = path + [start]
    if start == end:
        return [path]
    if start not in graph:
        return []
    paths = []
    for node in graph[start]:
        if node.isupper() or node not in path:
            newpaths = generate_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def read_graph(input_file):
    graph = defaultdict(list)
    with open(input_file, 'r') as file:
        for line in file:
            node1, node2 = line.strip().split('-')
            graph[node1].append(node2)
            graph[node2].append(node1)
    return graph

def part1(input_file):
    graph = read_graph(input_file)
    paths = generate_paths(graph, 'start', 'end')
    return len(paths)

def part2(input_file):
    graph = read_graph(input_file)
    paths = generate_paths(graph, 'start', 'end')
    valid_paths = []
    for path in paths:
        small_caves = [node for node in path if node.islower() and node not in ['start', 'end']]
        if len(small_caves) == len(set(small_caves)):
            valid_paths.append(path)
    return len(valid_paths)

# Test cases
print(part1('input.txt')) # should print 10
print(part2('input.txt')) # should print 36
print(part1('input2.txt')) # should print 19
print(part2('input2.txt')) # should print 6
print(part1('input3.txt')) # should print 26
print(part2('input3.txt')) # should print 103
",0
162,2021,13,1,runtime_error,,712,"Traceback (most recent call last):
  File ""/tmp/tmp_2b9k7xp/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np
import re
from collections import Counter

def main():
    # read the input file
    with open(""input.txt"", ""r"") as f:
        data = f.readlines()

    # read the dots and fold instructions
    dots = []
    folds = []
    for line in data:
        if "","" in line:
            x, y = line.strip().split("","")
            dots.append((int(x), int(y)))
        elif ""fold along"" in line:
            axis, value = re.findall(r""fold along (\w)=(\d+)"", line)[0]
            folds.append((axis, int(value)))

    # initialize the grid
    max_x = max([x for x, _ in dots]) + 1
    max_y = max([y for _, y in dots]) + 1
    grid = np.zeros((max_y, max_x), dtype=int)

    # mark the dots on the grid
    for x, y in dots:
        grid[y, x] = 1

    # perform the first fold
    axis, value = folds[0]
    if axis == ""x"":
        grid = np.hsplit(grid, [value])[0] + np.flipud(np.hsplit(grid, [-1])[1])
    else:
        grid = np.vsplit(grid, [value])[0] + np.fliplr(np.vsplit(grid, [-1])[1])

    # count the number of dots
    print(f""The number of visible dots after the first fold is: {np.count_nonzero(grid)}"")

if __name__ == ""__main__"":
    main()
",0
163,2021,14,1,runtime_error,,2233,"Traceback (most recent call last):
  File ""/tmp/tmp80glse9h/tmp.py"", line 38, in <module>
    main()
  File ""/tmp/tmp80glse9h/tmp.py"", line 31, in main
    a, b, c = line.strip().split("" -> "")
ValueError: not enough values to unpack (expected 3, got 1)
","
from collections import Counter

def apply_rule(template, rules):
    new_template = """"
    for i in range(len(template) - 1):
        pair = template[i:i+2]
        if pair in rules:
            new_template += pair[0] + rules[pair]
        else:
            new_template += pair[0]
    new_template += template[-1]
    return new_template

def polymerization(template, rules, steps):
    for _ in range(steps):
        template = apply_rule(template, rules)
    return template

def count_elements(template):
    element_counts = Counter(template)
    most_common = max(element_counts, key=element_counts.get)
    least_common = min(element_counts, key=element_counts.get)
    return element_counts[most_common] - element_counts[least_common]

def main():
    with open(""input.txt"", ""r"") as file:
        template = file.readline().strip()
        rules = {}
        for line in file:
            a, b, c = line.strip().split("" -> "")
            rules[a] = c

    polymer_template = polymerization(template, rules, 10)
    print(count_elements(polymer_template))

if __name__ == ""__main__"":
    main()
",0
164,2021,15,1,syntax_error,,423,"  File ""/tmp/tmp8s40a4rw/tmp.py"", line 12
    lowest_risk_path = sys.maxsize
    ^
SyntaxError: invalid syntax
","
import sys
from collections import deque

def is_valid_position(position, rows, columns):
    return position[0] >= 0 and position[0] < rows and position[1] >= 0 and position[1] < columns

def find_lowest_risk_path(cavern, rows, columns):
    visited = set()
    queue = deque()
    queue.append(((0,0,0)) # starting position with risk 0
    lowest_risk_path = sys.maxsize
    while queue:
        position, risk_level = queue.popleft()
        if position == (rows-1, columns-1):
            lowest_risk_path = min(lowest_risk_path, risk_level)
            continue
        for direction in [(1,0), (0,1), (-1,0), (0,-1)]:
            new_position = (position[0] + direction[0], position[1] + direction[1])
            if is_valid_position(new_position, rows, columns) and new_position not in visited:
                new_risk_level = risk_level + cavern[new_position[0]][new_position[1]]
                queue.append((new_position, new_risk_level))
                visited.add(new_position)
    return lowest_risk_path

def main():
    with open('input.txt', 'r') as file:
        cavern = [list(map(int, line.strip()) for line in file.readlines())]
    rows, columns = len(cavern), len(cavern[0])
    lowest_risk_path = find_lowest_risk_path(cavern, rows, columns)
    print(""Lowest risk path:"", lowest_risk_path)

if __name__ == ""__main__"":
    main()
",0
165,2021,16,1,runtime_error,,947,"Traceback (most recent call last):
  File ""/tmp/tmpilwyqqb9/tmp.py"", line 46, in <module>
    main()
  File ""/tmp/tmpilwyqqb9/tmp.py"", line 42, in main
    version, _, _ = parse_packet(bin_str)
  File ""/tmp/tmpilwyqqb9/tmp.py"", line 33, in parse_packet
    sub_version, sub_value, sub_length = parse_packet(sub_packets[total_length:])
  File ""/tmp/tmpilwyqqb9/tmp.py"", line 8, in parse_packet
    version = int(packet[:3], 2)
ValueError: invalid literal for int() with base 2: ''
","
import binascii

def hex_to_bin(hex_str):
    return bin(int(hex_str, 16))[2:].zfill(len(hex_str * 4) + (len(hex_str) % 2) * 4)

def parse_packet(packet):
    version = int(packet[:3], 2)
    type_id = int(packet[3:6], 2)
    if type_id == 4:
        # Literal value packet
        value_bin = """"
        i = 6
        while True:
            value_bin += packet[i + 1:i + 5]
            if packet[i] == ""0"":
                break
            i += 5
        value = int(value_bin, 2)
        return (version, value, i)
    else:
        # Operator packet
        length_type_id = packet[6]
        if length_type_id == ""0"":
            length = int(packet[7:22], 2)
            sub_packets = packet[22:22 + length]
            total_length = length
        else:
            num_sub_packets = int(packet[7:18], 2)
            sub_packets = packet[18:]
            total_length = 0
            for _ in range(num_sub_packets):
                sub_version, sub_value, sub_length = parse_packet(sub_packets[total_length:])
                version += sub_version
                total_length += sub_length
        return (version, 0, total_length)

def main():
    with open(""input.txt"", ""r"") as f:
        hex_str = f.read().strip()
    bin_str = hex_to_bin(hex_str)
    version, _, _ = parse_packet(bin_str)
    print(f""The sum of version numbers is: {version}"")

if __name__ == ""__main__"":
    main()
",0
166,2021,17,1,syntax_error,,8646,"  File ""/tmp/tmp999syvoh/tmp.py"", line 26
    max_y = find_trajectory(x_range, y_range)
    ^
SyntaxError: invalid syntax
","
import re

def find_trajectory(x_range, y_range):
    max_y = 0
    for x_velocity in range(x_range[0], x_range[1]+1):
        for y_velocity in range(y_range[0], -y_range[0]+1):
            x = 0
            y = 0
            temp_max_y = 0
            while x <= x_range[1] and y >= y_range[0]:
                x += x_velocity
                y += y_velocity
                temp_max_y = max(temp_max_y, y)
                if x_range[0] <= x <= x_range[1] and y_range[0] <= y <= y_range[1]:
                    max_y = max(max_y, temp_max_y)
                    return max_y
                if x_velocity > 0:
                    x_velocity -= 1
                y_velocity -= 1
    return max_y

with open('input.txt', 'r') as file:
    x_range, y_range = re.findall(r'x=(-?\d+)\.\.(-?\d+), y=(-?\d+)\.\.(-?\d+)', file.read().strip())
    x_range = list(map(int, x_range.split('..'))); y_range = list(map(int, y_range.split('..'))
    max_y = find_trajectory(x_range, y_range)
    print(max_y)
",0
167,2021,18,1,runtime_error,,4184,"Traceback (most recent call last):
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 91, in <module>
    main()
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 86, in main
    result = reduce(lambda num1, num2: add_snailfish(num1, num2), numbers)
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 86, in <lambda>
    result = reduce(lambda num1, num2: add_snailfish(num1, num2), numbers)
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 8, in add_snailfish
    reduce_snailfish(result)
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 57, in reduce_snailfish
    while explode(num) or split(num):
  File ""/tmp/tmpoepp5_o2/tmp.py"", line 18, in explode
    return explode(num[0], depth + 1) or explode(num[1], depth + 1)
IndexError: list index out of range
","
import re
import sys
from functools import reduce

def add_snailfish(num1, num2):
    result = ['[' + num1.replace(' ', '') + ',' + num2.replace(' ', '') + ']']
    reduce_snailfish(result)
    return result[0]

def explode(num, depth=0):
    if depth == 4:
        return True
    if not isinstance(num, list):
        return False
    if depth == 3 and isinstance(num[0], list) and isinstance(num[1], list):
        return True
    return explode(num[0], depth + 1) or explode(num[1], depth + 1)

def split(num):
    if isinstance(num, list):
        return split(num[0]) or split(num[1])
    elif num >= 10:
        return True
    return False

def find_explosion(num, depth=0):
    if isinstance(num, int):
        return None, depth, None, None
    if depth == 4 and isinstance(num[0], int) and isinstance(num[1], int):
        return num, depth, None, None
    left, d, i, right = find_explosion(num[0], depth + 1)
    if left:
        return left, d, [0, right]
    left, d, right = find_explosion(num[1], depth + 1)
    if left:
        return left, d, [right, 0]
    return None, None, None

def find_split(num):
    if isinstance(num, int):
        return None, None
    left, right = num
    if isinstance(left, int) and left >= 10:
        return [left // 2, left // 2 + left % 2], [0, right]
    elif isinstance(right, int) and right >= 10:
        return [left, right // 2, right // 2 + right % 2]
    left, right = find_split(left)
    if left:
        return [left, right]
    left, right = find_split(right)
    if left:
        return [left, right]
    return None

def reduce_snailfish(num):
    while explode(num) or split(num):
        while explode(num):
            left, depth, right_value = find_explosion(num)
            if left and right_value:
                i = 0
                while i < len(num):
                    if isinstance(num[i], list) and num[i][1] == 0:
                        num[i] = 0
                    if isinstance(num[i], int):
                        num[i] += left
                        break
                    i += 1
                if i > 0:
                    if isinstance(num[i - 1], int):
                        num[i - 1] += right_value
            num = ['[' + re.sub(r'\[(\d+),(\d+)\]', r'\1', num[0]) + ',' + re.sub(r'\[(\d+),(\d+)\]', r'\2', num[0]) + ']']
        if split(num):
            left, right = find_split(num)
            num = left + right
    return num

def magnitude(num):
    if isinstance(num, int):
        return num
    return 3 * magnitude(num[0]) + 2 * magnitude(num[1])

def main():
    with open('input.txt') as f:
        numbers = [line.strip() for line in f.readlines()]
    result = reduce(lambda num1, num2: add_snailfish(num1, num2), numbers)
    result = eval(result)
    print(magnitude(result))

if __name__ == '__main__':
    main()
",0
168,2021,19,1,syntax_error,,405,"  File ""/tmp/tmprkz29hab/tmp.py"", line 21
    else:
    ^
SyntaxError: invalid syntax
","
import re
import itertools
from collections import defaultdict
from math import sqrt

def read_input_file(file_name):
    with open(file_name, 'r') as file:
        return file.readlines()

def parse_scanners(input_data):
    scanners = []
    scanner_data = []
    for line in input_data:
        if line.startswith('---'):
            scanner_id = int(re.findall(r'\d+', line)[0])
            scanners.append(scanner_data)
            scanner_data = []
        elif line.strip():
            scanner_data.append(tuple(map(int, line.strip().split(',')))
        else:
            scanners.append(scanner_data)
    return scanners

def distance(a, b):
    return sqrt(sum((a[i] - b[i]) ** 2 for i in range(3))

def overlap(scanner1, scanner2):
    for p1 in scanner1:
        for p2 in scanner2:
            if sum(1 for d in range(3) if abs(p1[d] - p2[d]) <= 1000) >= 12:
                return True
    return False

def generate_rotations():
    for x_rot in range(4):
        for y_rot in range(4):
            for z_rot in range(4):
                yield lambda x, y, z: (
                    (+1 if x_rot & 0b1 else -1) * x,
                    (+1 if y_rot & 0b1 else -1) * y,
                    (+1 if z_rot & 0b1 else -1) * z,
                )(*(
                    ((-1 if x_rot & 0b10 else +1) * p,
                    (-1 if y_rot & 0b10 else +1) * q,
                    (-1 if x_rot & 0b100 else +1) * r)
                    for p, q, r in ((x, y, z), (z, x, y), (y, z, x))
                )
            )

def align_scanners(scanners):
    aligned = [scanners[0]]
    to_align = scanners[1:]
    while to_align:
        aligned_scanner_id, aligned_beacons = aligned[-1]
        for candidate_id, candidate_beacons in enumerate(to_align):
            for rotation in generate_rotations():
                offsets = defaultdict(int)
                for beacon1 in aligned_beacons:
                    for beacon2 in candidate_beacons:
                        offset = tuple(a - b for a, b in zip(beacon1, rotation(beacon2))
                        if all(abs(a - b) <= 1000 for a, b in offset))
                        if len(offset) == 3:
                            offsets[offset] += 1
                            if offsets[offset] == 12:
                                aligned.append((candidate_id, [tuple(a - b for a, b in zip(beacon2, offset)) for beacon2 in candidate_beacons]))
                                to_align.remove(candidate_beacons)
                                break
            if len(aligned) > len(scanners) - 1:
                return aligned
    return None

def part1(input_file):
    scanners = parse_scanners(read_input_file(input_file))
    aligned_scanners = align_scanners(scanners)
    if aligned_scanners:
        unique_beacons = set(p for beacons in aligned_scanners for p in beacons)
        return len(unique_beacons)
    return None

def main():
    input_file = 'input.txt'
    result = part1(input_file)
    print(f'The number of beacons is: {result}')

if __name__ == '__main__':
    main()
",0
169,2021,20,1,syntax_error,,5682,"  File ""/tmp/tmplqv36ycr/tmp.py"", line 17
    for i, j in product(range(-2, width + 2), range(-2, height + 2):
                                                                   ^
SyntaxError: invalid syntax
","
from collections import defaultdict
from itertools import product
import sys

def get_input(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
        algorithm = lines[0].strip()
        image = [line.strip() for line in lines[2:]]
        return algorithm, image

def enhance_image(image, algorithm, step):
    padding = '.' if algorithm[0] == '.' else '#'
    width, height = len(image[0]), len(image)
    new_image = defaultdict(lambda: padding)
    for i, j in product(range(-2, width + 2), range(-2, height + 2):
        index = 0
        for x, y in product([i - 1, i, i + 1], [j - 1, j, j + 1]):
            index = index * 2 + (1 if image[(y + 1) % height][x % width] == '#' else 0)
        new_image[(i, j + 1)] = algorithm[index]
    if step % 2 == 1 and padding == '.':
        padding = '.' if algorithm[511] == '.' else '#'
    else:
        padding = '.' if algorithm[0] == '.' else '#'
    for i in range(-2, width + 2):
        new_image[(i, -2)] = padding
        new_image[(i, height + 1)] = padding
    for j in range(-2, height + 2):
        new_image[(-2, j)], new_image[(width + 1, j)], new_image[(width + 2, j)], new_image[(width + 3, j)], new_image[(2 * width + 1, j)], = padding, padding, padding, padding
    return new_image

def count_lit_pixels(image):
    return sum(1 for x, y in image.items() if image[(x, y) == '#')

def main():
    algorithm, image = get_input('input.txt')
    image = defaultdict(lambda: '.', {(i, j): pixel for j, row in enumerate(image) for i, pixel in enumerate(row)})
    for step in range(2):
        image = enhance_image(image, algorithm, step)
    print(f""Part 1: {count_lit_pixels(image)}"")

if __name__ == ""__main__"":
    main()
",0
170,2021,21,1,syntax_error,,504972,"  File ""/tmp/tmpb427vix9/tmp.py"", line 110
    python game.py input.txt
           ^
SyntaxError: invalid syntax
","
import random

start_positions = [4, 8]

# Initialize players and scores
player_scores = [0, 0]
current_player = 0

# Initialize die and count number of rolls
deterministic_die = 1
num_rolls = 0

# Initialize a dictionary to keep track of positions of the pawns
pawns = {4: 0, 8: 0}

# Keep track of the last rolls to calculate the sum of the dice
last_rolls = [0, 0, 0]

# Keep track of the last position of each player
last_positions = [start_positions[0], start_positions[1]]

# Play the game
while max(player_scores) < 1000:
    # Roll the die
    current_roll = deterministic_die % 100 + 1
    deterministic_die += 1
    num_rolls += 1
    last_rolls.pop(0)
    last_rolls.append(current_roll)

    # Calculate the sum of the dice
    dice_sum = sum(last_rolls)

    # Move the pawn
    current_pos = (last_positions[current_player] + dice_sum) % 10
    pawns[current_pos] = current_pos

    # Increase the score
    player_scores[current_player] += current_pos

    # Switch the player
    current_player = (current_player + 1) % 2

    # Update the last position
    last_positions[current_player] = pawns[current_pos]

# Calculate the losing score and the number of rolls
losing_score = min(player_scores)
winning_score = max(player_scores)
total_rolls = num_rolls

# Print the result
print(losing_score * total_rolls)


start_positions = [4, 8]

# Initialize players and scores
player_scores = [0, 0]
current_player = 0

# Initialize die and count number of rolls
deterministic_die = 1
num_rolls = 0

# Initialize a dictionary to keep track of positions of the pawns
pawns = {4: 0, 8: 0}

# Keep track of the last rolls to calculate the sum of the dice
last_rolls = [0, 0, 0]

# Keep track of the last position of each player
last_positions = [start_positions[0], start_positions[1]]

# Play the game
while max(player_scores) < 100:
    # Roll the die
    current_roll = deterministic_die % 100 + 1
    deterministic_die += 1
    num_rolls += 1
    last_rolls.pop(0)
    last_rolls.append(current_roll)

    # Calculate the sum of the dice
    dice_sum = sum(last_rolls)

    # Move the pawn
    current_pos = (last_positions[current_player] + dice_sum) % 10
    pawns[current_pos] = current_pos

    # Increase the score
    player_scores[current_player] += current_pos

    # Switch the player
    current_player = (current_player + 1) % 2

    # Update the last position
    last_positions[current_player] = pawns[current_pos]

# Calculate the losing score and the number of rolls
losing_score = min(player_scores)
winning_score = max(player_scores)
total_rolls = num_rolls

# Print the result
print(losing_score * total_rolls)


python game.py input.txt
",0
171,2021,22,1,timeout_error,,600458,TIMEOUT,"
import re
from itertools import product

def parse_reboot_steps(input_file):
    with open(input_file) as file:
        lines = file.readlines()

    return [line.strip() for line in lines]

def get_cubes(step):
    on_off, xyz_range = step.split(' ')
    x_range, y_range, z_range = xyz_range.split(',')
    x_min, x_max = map(int, re.findall(r'-?\d+', x_range))
    y_min, y_max = map(int, re.findall(r'-?\d+', y_range))
    z_min, z_max = map(int, re.findall(r'-?\d+', z_range))
    return on_off, (x_min, x_max), (y_min, y_max), (z_min, z_max)

def reboot_reactor(reboot_steps):
    reactor_core = {}
    for step in reboot_steps:
        on_off, x_range, y_range, z_range = get_cubes(step)
        for x, y, z in product(range(x_range[0], x_range[1] + 1), range(y_range[0], y_range[1] + 1), range(z_range[0], z_range[1] + 1)):
            if -50 <= x <= 50 and -50 <= y <= 50 and -50 <= z <= 50:
                reactor_core[(x, y, z)] = on_off

    return reactor_core

def count_on_cubes(reactor_core):
    return sum(1 for cube in reactor_core.values() if cube == 'on')

def main():
    reboot_steps = parse_reboot_steps('input.txt')
    reactor_core = reboot_reactor(reboot_steps)
    count = count_on_cubes(reactor_core)
    print(f""Number of cubes on: {count}"")

if __name__ == '__main__':
    main()
",0
172,2021,23,1,syntax_error,,19019,"  File ""/tmp/tmp833tavnc/tmp.py"", line 47
    return moves
    ^
SyntaxError: invalid syntax
","
from collections import deque
from functools import lru_cache

class Amphipod:
    def __init__(self, type, x, y, energy):
        self.type = type
        self.x = x
        self.y = y
        self.energy = energy

    def __repr__(self):
        return f'{self.type} ({self.x}, {self.y})'

def parse_input(input_file):
    amphipods = []
    with open(input_file) as f:
        lines = [line.strip() for line in f.readlines()]
        for y, line in enumerate(lines):
            for x, char in enumerate(line):
                if char in {'A', 'B', 'C', 'D'}:
                    amphipods.append(Amphipod(char, x, y))
    return amphipods

@lru_cache(maxsize=None)
def get_possible_moves(amphipods, x, y):
    moves = []
    if amphipods[y][x] is not None:
        amphipod = amphipods[y][x]
        target_x = {'A': 2, 'B': 4, 'C': 6, 'D': 8}[amphipod.type]
        steps = abs(target_x - amphipod.x)
        energy = {'A': 1, 'B': 10, 'C': 100, 'D': 1000}[amphipod.type] * steps

        if amphipod.x < target_x:
            for i in range(amphipod.x + 1, target_x):
                if amphipods[y][i] is not None:
                    return []
        else:
            for i in range(amphipod.x - 1, target_x, -1):
                if amphipods[y][i] is not None:
                    return []

        for dy in range(len(amphipods)):
            if all(amphipods[dy][x] is None for x in range(amphipod.x, target_x, -1 if amphipod.x > target_x else 1)):
                moves.append((amphipod, (target_x, dy), energy * (abs(y - dy) + abs(target_x - amphipod.x)))

    return moves

def find_min_energy(amphipods):
    queue = deque([(amphipods, 0)])
    visited = set()
    while queue:
        current, energy = queue.popleft()
        hashed = tuple(tuple(tuple(row) for row in current) for row in current)
        if hashed in visited:
            continue
        visited.add(hashed)

        if all(amphipod.x == {'A': 2, 'B': 4, 'C': 6, 'D': 8}[amphipod.type] for amphipod in current if amphipod is not None):
            return energy

        for y, row in enumerate(current):
            for x, amphipod in enumerate(row):
                if amphipod is not None:
                    for amphipod, pos, move_energy in get_possible_moves(current, x, y):
                        new_amphipods = [list(row) for row in current]
                        new_amphipods[y][x] = None
                        new_amphipods[pos[1]][pos[0]] = amphipod
                        new_amphipods = tuple(tuple(row) for row in new_amphipods)
                        queue.append((new_amphipods, energy + move_energy))

    return None

def main():
    amphipods = parse_input('input.txt')
    min_energy = find_min_energy(amphipods)
    print(min_energy)

if __name__ == '__main__':
    main()
",0
173,2021,24,1,syntax_error,,49917929934999,"  File ""/tmp/tmp3i81_i3n/tmp.py"", line 2
    ```python
    ^
SyntaxError: invalid syntax
","
```python
import itertools

def is_valid_model_number(model_number):
    if '0' in str(model_number):
        return False
    if len(str(model_number)) != 14:
        return False
    w, x, y, z = 0, 0, 0, 0
    for instruction in program:
        if instruction[0] == 'inp':
            a = instruction[1]
            z = int(model_number[0])
            model_number = model_number[1:]
        elif instruction[0] == 'add':
            b = instruction[2]
            if b in 'wxyz':
                b = locals()[b]
            exec(f'{a} += {b}')
        elif instruction[0] == 'mul':
            b = instruction[2]
            if b in 'wxyz':
                b = locals()[b]
            exec(f'{a} *= {b}')
        elif instruction[0] == 'div':
            b = instruction[2]
            if b in 'wxyz':
                b = locals()[b]
            if b == 0 or z < 0:
                return False
            exec(f'{a} //= {b}')
        elif instruction[0] == 'mod':
            b = instruction[2]
            if b in 'wxyz':
                b = locals()[b]
            if z < 0 or b <= 0:
                return False
            exec(f'{a} %= {b}')
        elif instruction[0] == 'eql':
            b = instruction[2]
            if b in 'wxyz':
                b = locals()[b]
            exec(f'{a} = int({a} == {b})')
    return z == 0

program = [
    ['inp', 'w'], ['mul', 'x', '0'], ['add', 'x', 'z'], ['mod', 'x', '26'], ['div', 'z', '1'],
    ['add', 'x', '13'], ['eql', 'x', 'w'], ['eql', 'x', '0'], ['mul', 'y', '0'], ['add', 'y', '25'], ['mul', 'y', 'x'], ['add', 'y', '1'],
    ['mul', 'y', 'x'], ['add', 'y', '1'], ['mul', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '7'], ['mul', 'y', 'x'],
    ['mul', 'y', 'w'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '13'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '14'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '14'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '14'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul', 'y', '25'], ['add', 'y', '1'], ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'],
    ['mul', 'y', 'x'], ['add', 'z', 'y'], ['mul', 'y', '0'], ['add', 'y', 'w'], ['add', 'y', '11'], ['eql', 'y', '0'], ['eql', 'y', '0'],
    ['mul",0
174,2021,25,1,syntax_error,,489,"  File ""/tmp/tmphneehqvx/tmp.py"", line 6
    with open(input_file, 'r') as f:
    ^
SyntaxError: invalid syntax
","
from collections import defaultdict
from typing import List, Tuple

def parse_input(input_file: str) -> List[List[str]:
    with open(input_file, 'r') as f:
        return [list(line.strip()) for line in f.readlines()]

def move_cucumbers(east: List[List[str], south: List[str], rows: int, cols: int) -> Tuple[List[List[str], List[str], int]:
    moved = False
    for i in range(rows):
        for j in range(cols):
            if east[i][j] == '>' and east[(i+1) % rows][j] == '.':
                east[i][j], east[(i+1) % rows][j] = '.', '>'
                moved = True
            if south[i][j] == 'v' and south[i][(j+1) % cols] == '.':
                south[i][j], south[i][(j+1) % cols] = '.', 'v'
                moved = True
    return east, south, moved

def print_cucumbers(cucumbers: List[List[str]):
    for row in cucumbers:
        print(''.join(row))

def main():
    cucumbers = parse_input('input.txt')
    east = [['.' if c == '.' else '>' for c in row] for row in cucumbers]
    south = [['.' if c == '.' else 'v' for c in row] for row in cucumbers]
    rows, cols = len(cucumbers), len(cucumbers[0])
    steps = 0
    while True:
        east, south, moved = move_cucumbers(east, south, rows, cols)
        steps += 1
        if not moved:
            break
        # print_cucumbers(east)
        # print_cucumbers(south)
        # print()
    print(f""Safe to land on step {steps}"")

if __name__ == '__main__':
    main()
",0
175,2022,1,1,no_error,"70116
",70116,,"
import os

def get_total_calories():
    with open(""input.txt"", ""r"") as f:
        data = f.read().split(""\n\n"")
    data = [x.split(""\n"") for x in data]
    max_calories = 0
    for elf in data:
        calories = sum(map(int, elf))
        if calories > max_calories:
            max_calories = calories
    return max_calories

print(get_total_calories())
",0
176,2022,2,1,wrong_output,"Your total score: 9461
",12276,,"
# Importing the necessary libraries
import re

# Reading the input file
with open('input.txt', 'r') as file:
    data = file.read()

# Splitting the input data by newline
data = data.split('\n')

# Initializing variables
total_score = 0

# Dictionary to store the scores of the game
scores = {'A': 1, 'B': 2, 'C': 3, 'X': 1, 'Y': 2, 'Z': 3}

# Iterating through the data
for line in data:
    # Using regular expression to extract the input and output
    pattern = r'([ABC]) ([XYZ])'
    opponent, player = re.findall(pattern, line)[0]
    # Calculating the score for each round
    if opponent == 'A' and player == 'Y':
        total_score += 8
    elif opponent == 'B' and player == 'X':
        total_score += 1
    elif opponent == 'C' and player == 'Z':
        total_score += 6
    elif opponent == 'A' and player == 'Z':
        total_score += 8
    elif opponent == 'B' and player == 'Y':
        total_score += 1
    elif opponent == 'C' and player == 'X':
        total_score += 6
    elif opponent == 'A' and player == 'X':
        total_score += 3
    elif opponent == 'B' and player == 'Z':
        total_score += 8
    elif opponent == 'C' and player == 'Y':
        total_score += 1
    elif opponent == 'A' and player == 'Z':
        total_score += 6
    elif opponent == 'B' and player == 'X':
        total_score += 3
    elif opponent == 'C' and player == 'Y':
        total_score += 8
    elif opponent == 'A' and player == 'X':
        total_score += 1
    elif opponent == 'B' and player == 'Y':
        total_score += 6
    elif opponent == 'C' and player == 'Z':
        total_score += 3
    else:
        total_score += 0

# Printing the total score
print(""Your total score:"", total_score)
",0
177,2022,3,1,runtime_error,,8053,"Traceback (most recent call last):
  File ""/tmp/tmp_shkpwu6/tmp.py"", line 12, in <module>
    comp1, comp2 = rucksack.strip().split(rucksack[len(rucksack)//2])
ValueError: too many values to unpack (expected 2)
","
# Open the input file and read its contents
with open(""input.txt"", ""r"") as f:
    rucksacks = f.readlines()

# Initialize the total priority sum
total_priority = 0

# Iterate through each rucksack
for rucksack in rucksacks:
    # Split the rucksack into its two compartments
    comp1, comp2 = rucksack.strip().split(rucksack[len(rucksack)//2])

    # Find the common items between the two compartments
    common_items = set(comp1) & set(comp2)

    # Calculate the priority for each common item and add it to the total priority
    for item in common_items:
        if item.islower():
            total_priority += ord(item) - ord('a') + 1
        else:
            total_priority += ord(item) - ord('A') + 27

# Print the result
print(total_priority)
",0
178,2022,4,1,wrong_output,"790
",441,,"
import re

def count_overlaps(input_file):
    with open(input_file, 'r') as file:
        lines = file.readlines()
        overlaps = 0
        for line in lines:
            ranges = sorted(re.findall(r'\d+', line.strip()), key=int)
            if int(ranges[0]) <= int(ranges[1]) < int(ranges[2]) <= int(ranges[3]):
                overlaps += 1
        return overlaps

print(count_overlaps('input.txt'))
",0
179,2022,5,1,syntax_error,,FCVRLMVQP,"  File ""/tmp/tmpsg7gpn_r/tmp.py"", line 22
    result = ''.join([crate[0] for crate in [stack[-1] for stack in stacks])
                                                                           ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import re

def reorder_crates(steps, stacks):
    for step in steps:
        move, from_stack, to_stack = re.findall(r'(\d+)', step)
        from_stack, to_stack = int(from_stack), int(to_stack)
        crate = stacks[from_stack - 1].pop(int(move) - 1)
        stacks[to_stack - 1].insert(0, crate)
    return stacks

def read_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        stacks = [line.strip().split() for line in lines[:-2]]
        steps = lines[-2:]
    return stacks, steps

def main():
    stacks, steps = read_file('input.txt')
    stacks = reorder_crates(steps, stacks)
    result = ''.join([crate[0] for crate in [stack[-1] for stack in stacks])
    print(result)

if __name__ == '__main__':
    main()
",0
180,2022,6,1,runtime_error,,1109,"Traceback (most recent call last):
  File ""/tmp/tmprr9tw8os/tmp.py"", line 18, in <module>
    main()
  File ""/tmp/tmprr9tw8os/tmp.py"", line 14, in main
    result = find_first_packet_marker(buffer)
  File ""/tmp/tmprr9tw8os/tmp.py"", line 5, in find_first_packet_marker
    regex = re.compile(r'(.)(?=.*\1)(?=.*\2)(?=.*\3)(?=.*\4)')
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/re.py"", line 252, in compile
    return _compile(pattern, flags)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/re.py"", line 304, in _compile
    p = sre_compile.compile(pattern, flags)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_compile.py"", line 764, in compile
    p = sre_parse.parse(p, flags)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 948, in parse
    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 443, in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 754, in _parse
    p = _parse_sub(source, state, verbose, nested + 1)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 443, in _parse_sub
    itemsappend(_parse(source, state, verbose, nested + 1,
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 525, in _parse
    code = _escape(source, this, state)
  File ""/vol/home-vol2/ml/hallepat/.conda/envs/aoc/lib/python3.8/sre_parse.py"", line 423, in _escape
    raise source.error(""invalid group reference %d"" % group, len(escape) - 1)
re.error: invalid group reference 2 at position 17
","
import re

def find_first_packet_marker(buffer):
    regex = re.compile(r'(.)(?=.*\1)(?=.*\2)(?=.*\3)(?=.*\4)')
    for i in range(len(buffer) - 3):
        if regex.match(buffer[i:i+4]):
            return i + 4
    return None

def main():
    with open('input.txt', 'r') as file:
        buffer = file.read()
        result = find_first_packet_marker(buffer)
        print(f""The first start-of-packet marker appears after {result} characters."")

if __name__ == ""__main__"":
    main()
",0
181,2022,7,1,runtime_error,,1443806,"Traceback (most recent call last):
  File ""/tmp/tmpnuu_8oe6/tmp.py"", line 43, in <module>
    if line[2] == 'dir':
IndexError: list index out of range
","
import re
import os

# Function to find total size of a directory
def get_directory_size(start_path = '.'):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            if not os.path.islink(fp):
                total_size += os.path.getsize(fp)
        for dirname in dirnames:
            total_size += get_directory_size(os.path.join(dirpath, dirname))
    return total_size

# Read input file
with open('input.txt', 'r') as input_file:
    lines = input_file.readlines()

# Remove whitespace and split lines by space
lines = [line.strip().split() for line in lines]

# Initialize current directory and directory stack
current_directory = '/'
directory_stack = []

# Initialize dictionary to store directory names and sizes
directory = {}

# Process input lines
for line in lines:
    if line[0] == '$':
        if line[1] == 'cd':
            if line[2] == '..':
                current_directory = directory_stack.pop()
            elif line[2] == '/':
                current_directory = '/'
            else:
                directory_stack.append(current_directory)
                current_directory = os.path.join(current_directory, line[2])
        elif line[1] == 'ls':
            if line[2] == 'dir':
                directory[current_directory] = {}
                for i in range(3, len(line)):
                    directory[os.path.join(current_directory, line[i])] = {}
            else:
                directory[current_directory][line[2]] = int(line[1])

# Initialize list to store directories with total size <= 100000
directories = []

# Calculate total size of directories
for dir_name in directory:
    if dir_name != '/':
        size = get_directory_size(dir_name)
        if size <= 100000:
            directories.append(dir_name)

# Calculate sum of total sizes of directories
sum_size = 0
for dir_name in directories:
    sum_size += get_directory_size(dir_name)

print(sum_size)
",0
182,2022,8,1,wrong_output,"4909
",1807,,"
import sys

def count_visible_trees(grid):
    # Initialize variables
    visible_trees = 0
    rows = len(grid)
    cols = len(grid[0])

    # Count visible trees from left and right
    for row in grid:
        max_tree = 0
        for i in range(1, cols - 1):
            if row[i] > row[i - 1] and row[i] > row[i + 1]:
                visible_trees += 1
            if row[i] > max_tree:
                max_tree = row[i]
        visible_trees += 1 if max_tree > row[0] else 0
        visible_trees += 1 if max_tree > row[-1] else 0

    # Count visible trees from top and bottom
    for col in range(1, cols - 1):
        max_tree = 0
        for i in range(1, rows - 1):
            if grid[i][col] > grid[i - 1][col] and grid[i][col] > grid[i + 1][col]:
                visible_trees += 1
            if grid[i][col] > max_tree:
                max_tree = grid[i][col]
        visible_trees += 1 if max_tree > grid[0][col] else 0
        visible_trees += 1 if max_tree > grid[-1][col] else 0

    # Count visible trees in corners
    visible_trees += 1 if grid[0][0] > grid[0][1] and grid[0][0] > grid[1][0] else 0
    visible_trees += 1 if grid[0][-1] > grid[0][-2] and grid[0][-1] > grid[-1][-1] else 0
    visible_trees += 1 if grid[-1][0] > grid[-2][0] and grid[-1][0] > grid[-1][1] else 0
    visible_trees += 1 if grid[-1][-1] > grid[-2][-1] and grid[-1][-1] > grid[-1][-2] else 0

    return visible_trees

# Read input file
with open(""input.txt"", ""r"") as f:
    grid = [[int(x) for x in line.strip()] for line in f.readlines()]

# Count visible trees
print(count_visible_trees(grid))
",0
183,2022,9,1,runtime_error,,6087,"Traceback (most recent call last):
  File ""/tmp/tmp7_yhvxe6/tmp.py"", line 50, in <module>
    print(simulate_rope(movements))
  File ""/tmp/tmp7_yhvxe6/tmp.py"", line 13, in simulate_rope
    direction, steps = re.match(r'([RLUD])([0-9]+)', move).groups()
AttributeError: 'NoneType' object has no attribute 'groups'
","
import re
import collections

def simulate_rope(movements):
    head_x, head_y = 0, 0
    tail_x, tail_y = 0, 0
    visited = collections.defaultdict(int)
    visited[(head_x, head_y)] = 1
    visited[(tail_x, tail_y)] = 1

    for move in movements:
        direction, steps = re.match(r'([RLUD])([0-9]+)', move).groups()
        steps = int(steps)
        if direction == 'R':
            head_x += steps
            tail_x += steps
        elif direction == 'L':
            head_x -= steps
            tail_x -= steps
        elif direction == 'U':
            head_y -= steps
            tail_y -= steps
        elif direction == 'D':
            head_y += steps
            tail_y += steps

        if head_x - tail_x == 1 and head_y == tail_y or head_y - tail_y == 1 and head_x == tail_x:
            continue
        elif head_x == tail_x:
            for i in range(min(head_y, tail_y), max(head_y, tail_y)):
                visited[(head_x, i)] += 1
        elif head_y == tail_y:
            for i in range(min(head_x, tail_x), max(head_x, tail_x)):
                visited[(i, head_y)] += 1
        else:
            for i in range(min(head_x, tail_x), max(head_x, tail_x)):
                visited[(i, head_y)] += 1
            for i in range(min(head_y, tail_y), max(head_y, tail_y)):
                visited[(head_x, i)] += 1

        head_x, tail_x = head_x + (head_x - tail_x), head_x
        head_y, tail_y = head_y + (head_y - tail_y), head_y

    return sum(visited.values())

with open('input.txt', 'r') as f:
    movements = f.readlines()

print(simulate_rope(movements))
",0
184,2022,10,1,runtime_error,,15360,"Traceback (most recent call last):
  File ""/tmp/tmp53stiv6_/tmp.py"", line 13, in <module>
    value = int(re.search(r'addx\s*(\d+)', instruction).group(1))
AttributeError: 'NoneType' object has no attribute 'group'
","
import re

with open('input.txt', 'r') as f:
    instructions = [line.strip() for line in f.readlines()]

x = 1
cycle = 0
signal_strengths = []

for instruction in instructions:
    if 'addx' in instruction:
        value = int(re.search(r'addx\s*(\d+)', instruction).group(1))
        if cycle % 2 == 0:
            x += value
            cycle += 1
        else:
            x += value
            cycle += 2
    else:
        cycle += 1

    if cycle % 40 == 0:
        signal_strengths.append(cycle * x)

    if cycle >= 220:
        break

print(sum(signal_strengths))


instructions = []
with open('input.txt', 'r') as f:
    for line in f:
        instructions.append(line.strip())

x = 1
cycle = 0
signal_strengths = []

for instruction in instructions:
    if 'addx' in instruction:
        value = int(re.findall(r'\d+', instruction)[0])
        if cycle % 2 == 0:
            x += value
            cycle += 1
        else:
            x += value
            cycle += 2
    else:
        cycle += 1

    if cycle % 40 == 0:
        signal_strengths.append(cycle * x)

    if cycle >= 220:
        break

print(sum(signal_strengths))
",0
185,2022,11,1,runtime_error,,69918,"Traceback (most recent call last):
  File ""/tmp/tmpai6ju2ax/tmp.py"", line 12, in <module>
    monkey_id = int(line.strip().split()[1])
ValueError: invalid literal for int() with base 10: '0:'
","
import math

input_file = open('input.txt', 'r')

monkeys = {}
rounds = 20

# parse input file into a dictionary of monkeys with their properties
for line in input_file:
    if 'Monkey' in line:
        monkey_id = int(line.strip().split()[1])
        monkeys[monkey_id] = {'items': [], 'operation': '', 'test': '', 'mod': 0, 'target_true': -1, 'target_false': -1}
    elif 'Starting' in line:
        monkeys[monkey_id]['items'] = [int(item) for item in line.strip().split(':')[1].split(', ')]
    elif 'Operation' in line:
        monkeys[monkey_id]['operation'] = line.strip().split(':')[1].strip()
    elif 'new = old *' in line:
        monkeys[monkey_id]['operation'] = int(line.strip().split()[4])
    elif 'Test: divisible' in line:
        monkeys[monkey_id]['mod'] = int(line.strip().split()[4])
        if 'If true' in line:
            monkeys[monkey_id]['target_true'] = int(line.strip().split()[-1])
        else:
            monkeys[monkey_id]['target_false'] = int(line.strip().split()[-1])

# simulate the rounds
for i in range(rounds):
    for monkey_id, monkey in monkeys.items():
        for j, item_worry in enumerate(monkey['items']):
            new_worry = eval(monkey['operation'])
            monkeys[monkey_id]['items'][j] = new_worry // 3
            if new_worry % monkeys[monkey_id]['mod'] == 0:
                monkeys[monkey['target_true']]['items'].append(new_worry)
            else:
                monkeys[monkey['target_false']]['items'].append(new_worry)

# count the number of inspections for each monkey
inspections = {monkey_id: len(monkeys[monkey_id]['items']) * (rounds + 1) for monkey_id in monkeys}

# find the two most active monkeys and calculate their business level
most_active_monkeys = sorted(inspections, key=inspections.get, reverse=True)[:2]
business_level = inspections[most_active_monkeys[0]] * inspections[most_active_monkeys[1]]
print(business_level)
",0
186,2022,12,1,timeout_error,,504,TIMEOUT,"
import sys
from collections import deque

def find_path(heightmap, source, dest):
    def get_neighbors(x, y):
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < len(heightmap) and 0 <= ny < len(heightmap[0]) and heightmap[nx][ny] != 'X':
                yield nx, ny

    visited = set()
    queue = deque([(source, 0)])
    while queue:
        (x, y), steps = queue.popleft()
        if (x, y) == dest:
            return steps
        if (x, y) in visited:
            continue
        visited.add((x, y))
        height = ord(heightmap[x][y]) - ord('a')
        for nx, ny in get_neighbors(x, y):
            if heightmap[nx][ny] != 'X' and ord(heightmap[nx][ny]) - ord('a') <= height + 1:
                queue.append(((nx, ny), steps + 1))
        heightmap[x][y] = 'X'

    return -1

def main():
    heightmap = [list(line.strip()) for line in sys.stdin]
    source = (0, 0)
    dest = (-1, -1)
    for x, row in enumerate(heightmap):
        for y, cell in enumerate(row):
            if cell == 'S':
                source = (x, y)
            elif cell == 'E':
                dest = (x, y)
    heightmap[source[0]][source[1]] = 'S'
    heightmap[dest[0]][dest[1]] = 'E'
    print(find_path(heightmap, source, dest))

if __name__ == '__main__':
    main()
",0
187,2022,13,1,syntax_error,,5503,"  File ""/tmp/tmpz4edjhoa/tmp.py"", line 6
    return [eval(line) for line in input_str.split(""\n"") if line.strip()]
    ^
SyntaxError: invalid syntax
","
import re
from typing import List, Union, Tuple

def parse_input(input_str: str) -> List[List[Union[int, List[int]]]:
    return [eval(line) for line in input_str.split(""\n"") if line.strip()]

def compare(left: Union[int, List[int]], right: Union[int, List[int]]) -> bool:
    if isinstance(left, int) and isinstance(right, int):
        return left < right
    elif isinstance(left, list) and isinstance(right, list):
        for l, r in zip(left, right):
            if l != r:
                return compare(l, r)
        return len(left) < len(right)
    elif isinstance(left, int):
        return compare([left], right)
    elif isinstance(right, int):
        return compare(left, [right])
    else:
        raise ValueError(""Invalid input"")

def reorder_input(input_str: str) -> Tuple[List[int], List[int]]:
    inputs = parse_input(input_str)
    ordered_inputs = []
    for i in range(0, len(inputs), 2):
        if compare(inputs[i], inputs[i + 1]):
            ordered_inputs.append(i)
    return ordered_inputs

with open(""input.txt"", ""r"") as f:
    input_str = f.read()

ordered_indices = reorder_input(input_str)
print(sum(ordered_indices))
",0
188,2022,14,1,runtime_error,,825,"Traceback (most recent call last):
  File ""/tmp/tmpikiy54uo/tmp.py"", line 47, in <module>
    grid = set(generate_lines(lines))
  File ""/tmp/tmpikiy54uo/tmp.py"", line 18, in generate_lines
    x1, y1, x2, y2 = [int(n) for n in re.findall(r'\d+', line)]
ValueError: too many values to unpack (expected 4)
","
import re

def draw_grid(grid, max_x, max_y):
    for y in range(max_y+1):
        for x in range(max_x+1):
            if (x, y) in grid:
                print('#', end='')
            elif (x, y) == (500, 0):
                print('+', end='')
            else:
                print('.', end='')
        print()

def generate_lines(lines):
    result = []
    for line in lines:
        x1, y1, x2, y2 = [int(n) for n in re.findall(r'\d+', line)]
        if x1 == x2:
            result.extend([(x1, y) for y in range(min(y1, y2), max(y1, y2) + 1)])
        elif y1 == y2:
            result.extend([(x) for x in range(min(x1, x2), max(x1, x2) + 1)])
        else:
            print('Invalid input:', line)
    return result

def simulate(grid):
    x, y = 500, 0
    sand = set()
    while True:
        sand.add((x, y))
        down = (x, y + 1)
        left = (x - 1, y + 1)
        right = (x + 1, y + 1)
        if down not in grid and down not in sand and (down[1] <= max_y):
            x, y = down
        elif left not in grid and left not in sand and (left[1] <= max_y) and (left[0] >= 0):
            x, y = left
        elif right not in grid and right not in sand and (right[1] <= max_y) and (right[0] <= max_x):
            x, y = right
        else:
            break
    return len(sand) - 1

with open('input.txt', 'r') as f:
    lines = f.readlines()
    grid = set(generate_lines(lines))
    max_x = max(x for x, _ in grid)
    max_y = max(y for _, y in grid) + 1
    draw_grid(grid, max_x, max_y)
    print(simulate(grid))
",0
189,2022,15,1,runtime_error,,4861076,"Traceback (most recent call last):
  File ""/tmp/tmp1n92vz9d/tmp.py"", line 39, in <module>
    main()
  File ""/tmp/tmp1n92vz9d/tmp.py"", line 28, in main
    x, y = map(int, line.split(""="")[-1].strip()[1:-1].split("",""))
ValueError: not enough values to unpack (expected 2, got 1)
","
import math
from collections import defaultdict

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def count_beacon_free_positions(sensors, y_target, min_x, max_x):
    count = 0
    for x in range(min_x, max_x + 1):
        closest_sensor = None
        closest_distance = math.inf
        for sensor, beacon in sensors.items():
            distance = manhattan_distance(sensor, (x, y_target))
            if distance < closest_distance:
                closest_sensor = beacon
                closest_distance = distance
        if closest_sensor is None:
            count += 1
        else:
            count += 1 if y_target == closest_sensor[1] else 0
    return count

def main():
    sensors = defaultdict(tuple)
    with open(""input.txt"", ""r"") as f:
        for line in f:
            x, y = map(int, line.split(""="")[-1].strip()[1:-1].split("",""))
            sensor = tuple(map(int, line.split("":"")[0].split("",""))[:2])
            beacon = tuple(map(int, line.split(""="")[-1].strip()[1:-1].split("",""))[:2])
            sensors[sensor] = beacon

    min_x = min(map(lambda x: x[0], sensors.keys()))
    max_x = max(map(lambda x: x[0], sensors.keys()))
    y_target = 200000
    print(f""In the row where y={y_target}, there are {count_beacon_free_positions(sensors, y_target, min_x, max_x)} positions where a beacon cannot be present."")

if __name__ == ""__main__"":
    main()
",0
190,2022,16,1,runtime_error,,2080,"Traceback (most recent call last):
  File ""/tmp/tmpmz1zk6_b/tmp.py"", line 59, in <module>
    valves = generate_valves('input.txt')
  File ""/tmp/tmpmz1zk6_b/tmp.py"", line 32, in generate_valves
    name, flow_rate, tunnels = re.findall(r'([A-Z]{2}) has flow rate=(\d+); tunnels lead to (.*)', line.strip())[0]
IndexError: list index out of range
","
import heapq
import re

class Node:
    def __init__(self, name, flow_rate, tunnels):
        self.name = name
        self.flow_rate = flow_rate
        self.tunnels = tunnels
        self.total_flow = 0

    def add_tunnel(self, tunnel):
        self.tunnels.append(tunnel)

    def __lt__(self, other):
        return self.flow_rate < other.flow_rate

def open_valve(valves, opened, node, minutes):
    node.total_flow += node.flow_rate
    if node.name in opened:
        return
    opened.add(node.name)
    for tunnel in node.tunnels:
        if tunnel.name not in opened:
            tunnel.total_flow += node.flow_rate
            heapq.heappush(minutes, (minutes[0] + 1, tunnel))

def generate_valves(input_file):
    valves = {}
    with open(input_file, 'r') as f:
        for line in f.readlines():
            name, flow_rate, tunnels = re.findall(r'([A-Z]{2}) has flow rate=(\d+); tunnels lead to (.*)', line.strip())[0]
            flow_rate = int(flow_rate)
            tunnels = [t.strip() for t in tunnels.split(',')]
            node = Node(name, flow_rate, [])
            valves[name] = node
            for tunnel in tunnels:
                if tunnel in valves:
                    node.add_tunnel(valves[tunnel])
                else:
                    valves[tunnel] = Node(tunnel, 0, [node])
                    node.add_tunnel(valves[tunnel])
    return valves

def find_max_pressure(valves, start_valve):
    minutes = [(0, valves[start_valve])]
    opened = set()
    max_pressure = 0
    while minutes:
        current_minute, node = heapq.heappop(minutes)
        if current_minute >= 30:
            break
        for tunnel in node.tunnels:
            if tunnel.name not in opened:
                open_valve(valves, opened, tunnel, minutes)
        max_pressure = max(max_pressure, sum(node.total_flow for node in valves.values()))
    return max_pressure

valves = generate_valves('input.txt')
print(find_max_pressure(valves, 'AA'))
",0
191,2022,17,1,runtime_error,,3235,"Traceback (most recent call last):
  File ""/tmp/tmpdagtn90c/tmp.py"", line 152, in <module>
    main()
  File ""/tmp/tmpdagtn90c/tmp.py"", line 48, in main
    if grid[(i + direction, 1) + direction] == '#' or grid[(i + direction, 1) + direction] == '|':
TypeError: can only concatenate tuple (not ""int"") to tuple
","
import sys
from collections import defaultdict

def main():
    # Read input file
    with open('input.txt', 'r') as f:
        jet_pattern = f.readline().strip()

    # Initialize variables
    height = 7
    width = 5
    rocks = ['-', '+', '|', '\\', '/', 'X']
    jets = ['<', '>']
    grid = defaultdict(lambda: '.')
    # Fill the grid with the first rock
    for y in range(1, height+1):
        for x in range(2, 2+width):
            if y == 1:
                grid[(x, y)] = '-'
            else:
                grid[(x, y)] = '.'

    # Initialize jet pattern index and rock index
    jet_index = 0
    rock_index = 0

    # Iterate through the rock falling process
    while rock_index < 2022:
        # Determine the shape of the current rock
        rock_shape = rocks[rock_index % 5]

        # Determine the direction of the current jet
        if jet_pattern[jet_index % len(jet_pattern)] == '<':
            direction = -1
        else:
            direction = 1
        jet_index += 1

        # Move the rock
        if rock_shape == '-':
            for i in range(2, 2+width):
                if grid[(i, 1)] == '.':
                    rock_index += 1
                    break
                grid[(i, 1)] = rock_shape
                grid[(i + direction, 1)] = rock_shape
                if grid[(i + direction, 1) + direction] == '#' or grid[(i + direction, 1) + direction] == '|':
                    grid[(i, 2)] = '#'
                    break
                elif grid[(i + direction, 1) + direction] == '\\' or grid[(i + direction, 1) + direction] == '/':
                    grid[(i, 2)] = '\\'
                    break
                elif grid[(i + direction, 1) + direction] == 'X':
                    grid[(i, 2)] = 'X'
                    break
                else:
                    grid[(i, 1)] = '.'
                grid[(i, 1)] = '.'
                i += direction
        elif rock_shape == '+':
            for i in range(2, 2+width):
                if grid[(i, 2)] == '.':
                    rock_index += 1
                    break
                grid[(i, 2)] = rock_shape
                grid[(i, 1)] = rock_shape
                if grid[(i, 1 - direction) + direction] == '#' or grid[(i, 1 - direction) + direction] == '|':
                    grid[(i, 3)] = '#'
                    break
                elif grid[(i, 1 - direction) + direction] == '\\' or grid[(i, 1 - direction) + direction] == '/':
                    grid[(i, 3)] = '/'
                    break
                elif grid[(i, 1 - direction) + direction] == 'X':
                    grid[(i, 3)] = 'X'
                    break
                else:
                    grid[(i, 2)] = '.'
                grid[(i, 2)] = '.'
                i += 1
        elif rock_shape == '|':
            for y in range(2, height+1):
                if grid[(2, y)] == '.':
                    rock_index += 1
                    break
                grid[(2, y)] = rock_shape
                grid[(1, y + 1)] = rock_shape
                if grid[(1, y + 1) + direction] == '#' or grid[(1, y + 1) + direction] == '|':
                    grid[(3, y + 1)] = '#'
                    break
                elif grid[(1, y + 1) + direction] == '\\' or grid[(1, y + 1) + direction] == '/':
                    grid[(3, y + 1)] = '|'
                    break
                elif grid[(1, y + 1) + direction] == 'X':
                    grid[(3, y + 1)] = 'X'
                    break
                else:
                    grid[(2, y)] = '.'
                grid[(1, y)] = '.'
                y += 1
        elif rock_shape == '\\':
            for y in range(2, height+1):
                if grid[2, y] == '.':
                    rock_index += 1
                    break
                grid[2, y] = rock_shape
                grid[1, y - 1] = rock_shape
                if grid[1, y - 1] == '#' or grid[1, y - 1] == '\\':
                    grid[3, y - 1] = '#'
                    break
                elif grid[1, y - 1] == '|' or grid[1, y - 1] == '/':
                    grid[3, y - 1] = '\\'
                    break
                elif grid[1, y - 1] == 'X':
                    grid[3, y - 1] = 'X'
                    break
                else:
                    grid[2, y] = '.'
                grid[1, y] = '.'
                y -= 1
        else:
            for y in range(2, height+1):
                if grid[2, y] == '.':
                    rock_index += 1
                    break
                grid[2, y] = rock_shape
                grid[3, y + 1] = rock_shape
                if grid[3, y + 1] == '#' or grid[3, y + 1] == '/':
                    grid[1, y + 1] = '#'
                    break
                elif grid[3, y + 1] == '|' or grid[3, y + 1] == '\\':
                    grid[1, y + 1] = '/'
                    break
                elif grid[3, y + 1] == 'X':
                    grid[1, y + 1] = 'X'
                    break
                else:
                    grid[2, y] = '.'
                grid[3, y] = '.'
                y += 1

    # Calculate the height of the tower
    max_y = 0
    for x in range(2, 2+width):
        for y in range(1, height+1):
            if grid[(x, y)] != '.':
                max_y = max(max_y, y)

    print(max_y)

if __name__ == ""__main__"":
    main()
",0
192,2022,18,1,wrong_output,"44224
",4310,,"
import math

def surface_area(cubes):
    total_area = 0
    for x, y, z in cubes:
        connections = 0
        for i in range(-1, 2):
            for j in range(-1, 2):
                for k in range(-1, 2):
                    if (x + i, y + j, z + k) not in cubes:
                        connections += 1
        total_area += 2 * connections
    return total_area

def read_cubes(file_name):
    with open(file_name, 'r') as file:
        data = file.readlines()
    cubes = []
    for line in data:
        x, y, z = map(int, line.strip().split(','))
        cubes.append((x, y, z))
    return cubes

def main():
    cubes = read_cubes('input.txt')
    area = surface_area(cubes)
    print(area)

if __name__ == '__main__':
    main()
",0
193,2022,19,1,runtime_error,,1613,"Traceback (most recent call last):
  File ""/tmp/tmpxrwxf7l1/tmp.py"", line 59, in <module>
    main()
  File ""/tmp/tmpxrwxf7l1/tmp.py"", line 54, in main
    blueprints = parse_input('input.txt')
  File ""/tmp/tmpxrwxf7l1/tmp.py"", line 17, in parse_input
    blueprint_info[robot_type] = (int(costs[0]), 0)
IndexError: list index out of range
","
import re

def parse_input(input_file):
    blueprints = []
    with open(input_file, 'r') as f:
        for line in f.readlines():
            if line.startswith('Blueprint'):
                blueprint_id = int(re.findall(r'Blueprint (\d+)', line)[0])
                blueprint_info = {}
                robot_types = ['ore', 'clay', 'obsidian', 'geode']
                for robot_type in robot_types:
                    costs = re.findall(r'{}: (\d+) (ore|clay|obsidian)'.format(robot_type), line)
                    if len(costs) == 2:
                        blueprint_info[robot_type] = (int(costs[0][0]), int(costs[1][0]))
                    else:
                        blueprint_info[robot_type] = (int(costs[0]), 0)
                blueprints.append(blueprint_info)
    return blueprints

def calculate_max_geodes(blueprint, available_resources, robots):
    geodes_opened = 0
    for i in range(24):
        available_resources = update_resources(available_resources, robots)
        available_resources = build_robots(available_resources, blueprint, robots)
        geodes_opened += robots['geode']
    return geodes_opened

def update_resources(available_resources, robots):
    for key in robots:
        robots[key] = robots[key] * (robots[key] + 1)
    available_resources['ore'] -= robots['ore']
    available_resources['clay'] -= robots['clay']
    available_resources['obsidian'] -= robots['obsidian']
    return available_resources

def build_robots(available_resources, blueprint, robots):
    for robot_type, cost in blueprint.items():
        if available_resources[robot_type[0]] >= cost[1] and available_resources[robot_type[1]] >= cost[0]:
            available_resources[robot_type[0]] -= cost[1]
            available_resources[robot_type[1]] -= cost[0]
            robots[robot_type] += 1
    return robots

def calculate_quality_level(blueprints):
    quality_levels = []
    for blueprint in blueprints:
        available_resources = {'ore': 1, 'clay': 0, 'obsidian': 0, 'geode': 0}
        robots = {'ore': 1, 'clay': 0, 'obsidian': 0, 'geode': 0}
        quality_levels.append(calculate_max_geodes(blueprint, available_resources, robots) * blueprint['geode'][0])
    return sum(quality_levels)

def main():
    blueprints = parse_input('input.txt')
    quality_level_sum = calculate_quality_level(blueprints)
    print(f'The sum of the quality levels is: {quality_level_sum}')

if __name__ == '__main__':
    main()
",0
194,2022,20,1,runtime_error,,18257,"Traceback (most recent call last):
  File ""/tmp/tmpsc6prh2r/tmp.py"", line 19, in <module>
    result = part1(input_arr)
  File ""/tmp/tmpsc6prh2r/tmp.py"", line 14, in part1
    arr = mix(arr, 100)
  File ""/tmp/tmpsc6prh2r/tmp.py"", line 7, in mix
    for i, num in enumerate(num_list):
RuntimeError: deque mutated during iteration
","
from collections import deque

def mix(arr, steps):
    num_list = deque(arr)
    for _ in range(steps):
        for i, num in enumerate(num_list):
            index = (i + num + len(num_list)) % len(num_list)
            num_list.rotate(-num)
            num_list[i] = num
    return num_list

def part1(arr):
    arr = mix(arr, 100)
    return arr[0] + arr[1] + arr[2]

with open('input.txt') as f:
    input_arr = list(map(int, f.read().splitlines()))
    result = part1(input_arr)
    print(result)
",0
195,2022,21,1,runtime_error,,118565889858886,"Traceback (most recent call last):
  File ""/tmp/tmph1upzmfp/tmp.py"", line 48, in <module>
    main(""input.txt"")
  File ""/tmp/tmph1upzmfp/tmp.py"", line 43, in main
    root_number = find_root_number(monkeys)
  File ""/tmp/tmph1upzmfp/tmp.py"", line 23, in find_root_number
    dependencies[monkey] = get_dependencies(job)
  File ""/tmp/tmph1upzmfp/tmp.py"", line 7, in get_dependencies
    return job.split()[1].split('+') if '+' in job else job.split()[1].split('-') if '-' in job else job.split()[1].split('/') if '/' in job else [job.split()[1]]
IndexError: list index out of range
","
import re
import time
import collections

def get_dependencies(job):
    return job.split()[1].split('+') if '+' in job else job.split()[1].split('-') if '-' in job else job.split()[1].split('/') if '/' in job else [job.split()[1]]

def calculate_job(job, values):
    if '+' in job:
        return values[job.split()[0]] + values[job.split()[2]]
    elif '-' in job:
        return values[job.split()[0]] - values[job.split()[2]]
    elif '/' in job:
        return values[job.split()[0]] / values[job.split()[2]]
    else:
        return int(job.split()[0])

def find_root_number(monkeys):
    dependencies = {}
    values = {}
    for monkey, job in monkeys.items():
        dependencies[monkey] = get_dependencies(job)
        if monkey.isnumeric():
            values[monkey] = int(monkey)

    while len(values) < len(monkeys):
        for monkey, deps in dependencies.items():
            if all(dep in values for dep in deps) and monkey not in values:
                values[monkey] = calculate_job(monkeys[monkey], values)
                if isinstance(values[monkey], float):
                    values[monkey] = int(values[monkey])

    return values['root']

def main(input_file):
    monkeys = {}
    with open(input_file, 'r') as f:
        for line in f.readlines():
            monkey, job = line.strip().split(':')
            monkeys[monkey] = job.strip()

    root_number = find_root_number(monkeys)
    print(root_number)

if __name__ == ""__main__"":
    start_time = time.time()
    main(""input.txt"")
    print(""--- %s seconds ---"" % (time.time() - start_time))


def get_dependencies(job):
    return job.split()[1].split('+') if '+' in job else job.split()[1].split('-') if '-' in job else job.split()[1].split('/') if '/' in job else [job.split()[1]]

def calculate_job(job, values):
    if '+' in job:
        return values[job.split()[0]] + values[job.split()[2]]
    elif '-' in job:
        return values[job.split()[0]] - values[job.split()[2]]
    elif '/' in job:
        return values[job.split()[0]] / values[job.split()[2]]
    else:
        return int(job.split()[0])

def find_root_number(monkeys):
    dependencies = {}
    values = {}
    for monkey, job in monkeys.items():
        dependencies[monkey] = get_dependencies(job)
        if monkey.isnumeric():
            values[monkey] = int(monkey)

    while len(values) < len(monkeys):
        for monkey, deps in dependencies.items():
            if all(dep in values for dep in deps) and monkey not in values:
                values[monkey] = calculate_job(monkeys[monkey], values)
                if isinstance(values[monkey], float):
                    values[monkey] = int(values[monkey])

    return values['root']

def main(input_file):
    monkeys = {}
    with open(input_file, 'r') as f:
        for line in f.readlines():
            monkey, job = line.strip().split(':')
            monkeys[monkey] = job.strip()

    root_number = find_root_number(monkeys)
    print(root_number)

if __name__ == ""__main__"":
    start_time = time.time()
    main(""input.txt"")
    print(""--- %s seconds ---"" % (time.time() - start_time))
",0
196,2022,22,1,runtime_error,,93226,"Traceback (most recent call last):
  File ""/tmp/tmp49fl30ap/tmp.py"", line 54, in <module>
    print(solve(board, path))
  File ""/tmp/tmp49fl30ap/tmp.py"", line 35, in solve
    position, facing = trace_path(board, path)
  File ""/tmp/tmp49fl30ap/tmp.py"", line 31, in trace_path
    facing = (facing + (step == 'R') - step == 'L') % 4
TypeError: unsupported operand type(s) for -: 'int' and 'str'
","
import re

def move(position, direction, distance):
    x, y = position
    if direction == 0:
        return x, y + distance
    elif direction == 1:
        return x + distance, y
    elif direction == 2:
        return x, y - distance
    elif direction == 3:
        return x - distance, y

def wrap(position, board_size):
    x, y = position
    return (x % board_size, y % board_size)

def trace_path(board, path):
    position = (0, 0)
    facing = 0
    for step in re.findall(r'\d+|\D', path):
        if step.isdigit():
            distance = int(step)
            for _ in range(distance):
                position = move(position, facing, 1)
                position = wrap(position, len(board))
                if board[position[1]][position[0]] == '#':
                    break
            continue
        facing = (facing + (step == 'R') - step == 'L') % 4
    return position, facing

def solve(board, path):
    position, facing = trace_path(board, path)
    return 100 * position[1] + 4 * position[0] + facing

board = [
    ['#', '.', '#', '#', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
    ['.', '#', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['#', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#'],
    ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '#', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
]

path = ""10R5L5R10L4R5L5""

print(solve(board, path))
",0
197,2022,23,1,syntax_error,,4109,"  File ""/tmp/tmpsg388oxf/tmp.py"", line 59
    for col in range(len(grid[0]):
                                 ^
SyntaxError: invalid syntax
","
import sys
from collections import Counter

def process_input(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
        grid = []
        for line in lines:
            grid.append(list(line.strip()))
        return grid

def find_neighbors(grid, row, col):
    neighbors = []
    if row > 0:
        neighbors.append((row-1, col))
        if col > 0:
            neighbors.append((row-1, col-1) if grid[row-1][col-1] == '.' else None)
        if col < len(grid[0])-1:
            neighbors.append((row-1, col+1) if grid[row-1][col+1] == '.' else None)
    if col > 0:
        neighbors.append((row, col-1))
    if col < len(grid[0])-1:
        neighbors.append((row, col+1))
    if row < len(grid)-1:
        neighbors.append((row+1, col))
        if col > 0:
            neighbors.append((row+1, col-1) if grid[row+1][col-1] == '.' else None)
        if col < len(grid[0])-1:
            neighbors.append((row+1, col+1) if grid[row+1][col+1] == '.' else None)
    neighbors = [n for n in neighbors if n is not None]
    return neighbors

def move_elves(grid, elves):
    new_elves = {}
    for elf in elves:
        row, col = elf
        neighbors = find_neighbors(grid, row, col)
        valid_moves = [pos for pos in neighbors if pos not in elves]
        if valid_moves:
            for pos in valid_moves:
                if pos not in new_elves.values():
                    new_elves[elf] = pos
                    break
    return new_elves

def print_grid(grid, elves):
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if (row, col) in elves:
                print('#', end='')
            else:
                print(grid[row][col], end='')
        print()

def count_empty(grid, elves):
    counts = Counter()
    for row in range(len(grid)):
        for col in range(len(grid[0]):
            if (row, col) not in elves and grid[row][col] == '.':
                counts[(row, col)] = 1
    return sum(counts.values())

def simulate_elves(grid, elves, rounds=10):
    for i in range(rounds):
        elves = move_elves(grid, elves)
        # print_grid(grid, elves)
        # print()
    return count_empty(grid, elves)

def find_smallest_rectangle(grid, elves):
    min_row = min(row for row, _ in elves.values())
    max_row = max(row for row, _ in elves.values())
    min_col = min(col for _, col in elves.values())
    max_col = max(col for _, col in elves.values())
    return grid[min_row:max_row+1], [col for col in range(min_col, max_col+1)]

def main():
    grid = process_input(sys.argv[1])
    elves = {(row, col): None for row in range(len(grid)) for col in range(len(grid[0]) if grid[row][col] == '#'}
    print(simulate_elves(grid, elves))
    rect_grid, rect_cols = find_smallest_rectangle(grid, elves)
    for row in rect_grid:
        print(''.join(row[c] for c in rect_cols))

if __name__ == '__main__':
    main()
",0
198,2022,24,1,runtime_error,,279,"Traceback (most recent call last):
  File ""/tmp/tmpwdsuj6xm/tmp.py"", line 90, in <module>
    steps = move_expedition(start_position, end_position, map_data, width, height)
  File ""/tmp/tmpwdsuj6xm/tmp.py"", line 69, in move_expedition
    next_positions = [(current_position[0] + 1, current_position[1]), (current_position[0] - 1, current_position[1]), (current_position[0], current_position[1] + 1), (current_position[0], current_position[1] - 1)]
TypeError: 'NoneType' object is not subscriptable
","
import os

def get_input():
    with open(""input.txt"", ""r"") as f:
        map_data = f.readlines()
    return map_data

def parse_input(map_data):
    map_data = [line.strip() for line in map_data]
    width = len(map_data[0])
    height = len(map_data)
    return map_data, width, height

def is_safe_to_move_to(position, map_data, width, height):
    return position[0] >= 0 and position[0] < width and position[1] >= 0 and position[1] < height and map_data[position[1]][position[0]] == "".""

def find_start_and_end(map_data, width, height):
    start_position = None
    end_position = None
    for y in range(height):
        for x in range(width):
            if map_data[y][x] == ""E"":
                start_position = (x, y)
            elif map_data[y][x] == ""v"":
                end_position = (x, y)
    return start_position, end_position

def find_blizzards(map_data, width, height):
    blizzards = []
    for y in range(height):
        for x in range(width):
            if map_data[y][x] in ""^>v<"":
                blizzards.append((x, y, map_data[y][x]))
    return blizzards

def move_blizzards(blizzards, width, height):
    new_blizzards = []
    for blizzard in blizzards:
        x, y, direction = blizzard
        if direction == "">"":
            new_x = (x + 1) % width
            new_y = y
            new_direction = "">"" if is_safe_to_move_to((new_x, y), map_data, width, height) else ""<""
        elif direction == ""<"":
            new_x = (x - 1) % width
            new_y = y
            new_direction = ""<"" if is_safe_to_move_to((new_x, y), map_data, width, height) else "">""
        elif direction == ""^"":
            new_x = x
            new_y = (y - 1) % height
            new_direction = ""^"" if is_safe_to_move_to((x, new_y), map_data, width, height) else ""v""
        elif direction == ""v"":
            new_x = x
            new_y = (y + 1) % height
            new_direction = ""v"" if is_safe_to_move_to((x, new_y), map_data, width, height) else ""^""
        new_blizzards.append((new_x, new_y, new_direction))
    return new_blizzards

def count_blizzard_collisions(blizzards, position):
    return sum([1 for blizzard in blizzards if blizzard[0] == position[0] and blizzard[1] == position[1]])

def move_expedition(start_position, end_position, map_data, width, height):
    steps = 0
    current_position = start_position
    visited_positions = set()
    while current_position != end_position:
        blizzards = find_blizzards(map_data, width, height)
        next_positions = [(current_position[0] + 1, current_position[1]), (current_position[0] - 1, current_position[1]), (current_position[0], current_position[1] + 1), (current_position[0], current_position[1] - 1)]
        next_position = None
        for position in next_positions:
            if is_safe_to_move_to(position, map_data, width, height) and position not in visited_positions and count_blizzard_collisions(blizzards, position) == 0:
                next_position = position
                break
        if next_position is None:
            return -1
        map_data[current_position[1]][current_position[0]] = "".""
        map_data[next_position[1]][next_position[0]] = ""E""
        current_position = next_position
        visited_positions.add(current_position)
        steps += 1
        blizzards = move_blizzards(blizzards, width, height)
        for blizzard in blizzards:
            map_data[blizzard[1]][blizzard[0]] = blizzard[2]
    return steps

map_data = get_input()
map_data, width, height = parse_input(map_data)
start_position, end_position = find_start_and_end(map_data, width, height)
steps = move_expedition(start_position, end_position, map_data, width, height)
print(f""Fewest number of steps required to reach extraction point: {steps}"")
",0
199,2022,25,1,runtime_error,,2=0=02-0----2-=02-10,"Traceback (most recent call last):
  File ""/tmp/tmpc22s0nq5/tmp.py"", line 39, in <module>
    total_fuel_requirement += convert_from_snafu(re.sub('[*]', '', line.strip()))
  File ""/tmp/tmpc22s0nq5/tmp.py"", line 33, in convert_from_snafu
    decimal += snafu_map[digit] * 5**i
KeyError: '='
","
import re

def convert_to_snafu(num):
    snafu = ''
    for digit in str(num):
        if digit == '0':
            snafu += '0'
        elif digit == '1':
            snafu += '1'
        elif digit == '2':
            snafu += '2='
        elif digit == '3':
            snafu += '1='
        elif digit == '4':
            snafu += '1-'
        elif digit == '5':
            snafu += '20'
        elif digit == '6':
            snafu += '21'
        elif digit == '7':
            snafu += '22'
        elif digit == '8':
            snafu += '12'
        elif digit == '9':
            snafu += '221'
    return snafu

def convert_from_snafu(snafu):
    snafu_map = {'0': 0, '1': 1, '2=': 2, '1=': 3, '1-': 4, '20': 5, '21': 6, '22': 7, '12': 8, '2-': 9}
    decimal = 0
    for i, digit in enumerate(snafu[::-1]):
        decimal += snafu_map[digit] * 5**i
    return decimal

with open('input.txt', 'r') as f:
    total_fuel_requirement = 0
    for line in f.readlines():
        total_fuel_requirement += convert_from_snafu(re.sub('[*]', '', line.strip()))

snafu_total_fuel_requirement = convert_to_snafu(total_fuel_requirement)
print(snafu_total_fuel_requirement)
",0
