,year,day,part,status,output,expected_output,error,code,kpass
0,2015,1,1,no_error,"74
",74,,"
def get_floor(instructions):
    floor = 0
    for char in instructions:
        if char == ""("":
            floor += 1
        else:
            floor -= 1
    return floor

with open(""input.txt"", ""r"") as f:
    instructions = f.readline().strip()
    print(get_floor(instructions))
",0
1,2015,2,1,wrong_output,"Total wrapping paper needed: 1586300 square feet
",1586300,,"
import math

def get_input_file(file_name):
    with open(file_name, 'r') as file:
        return file.readlines()

def calculate_wrapping_paper(dimensions):
    l, w, h = [int(dim) for dim in dimensions.split('x')]
    sides = [l * w, w * h, h * l]
    area = sum(2 * sides) + min(sides)
    return area

def main():
    input_file = get_input_file('input.txt')
    wrapping_paper_needed = sum(calculate_wrapping_paper(dimensions) for dimensions in input_file)
    print(f""Total wrapping paper needed: {wrapping_paper_needed} square feet"")

if __name__ == ""__main__"":
    main()
",2
2,2015,3,1,no_error,"2565
",2565,,"
import re

def count_visited_houses(directions):
    x, y = 0, 0
    visited_houses = set()
    visited_houses.add((x, y))
    for direction in directions:
        if direction == '^':
            y += 1
        elif direction == 'v':
            y -= 1
        elif direction == '>':
            x += 1
        elif direction == '<':
            x -= 1
        visited_houses.add((x, y))
    return len(visited_houses)

with open('input.txt', 'r') as f:
    directions = re.findall('[><v^]', f.read())
    print(count_visited_houses(directions))
",0
3,2015,4,1,wrong_output,"3938038
",117946,,"
import hashlib

def generate_md5(key, num):
    return hashlib.md5((key + str(num)).encode()).hexdigest()

def find_number(key):
    num = 0
    while True:
        md5_hash = generate_md5(key, num)
        if md5_hash.startswith(""000000""):
            return num
        num += 1

with open(""input.txt"", ""r"") as file:
    key = file.read().strip()

print(find_number(key))
",2
4,2015,5,1,no_error,"236
",236,,"
import re

def is_nice(s):
    if not re.search(r'[aeiou].*[aeiou].*[aeiou]', s):
        return False
    if not re.search(r'(.)\1', s):
        return False
    if re.search(r'ab|cd|pq|xy', s):
        return False
    return True

def count_nice_strings():
    with open('input.txt', 'r') as f:
        count = 0
        for line in f:
            if is_nice(line.strip()):
                count += 1
    return count

print(count_nice_strings())
",1
5,2015,6,1,no_error,"400410
",400410,,"
import re

# Open input.txt file for reading
with open(""input.txt"", ""r"") as input_file:
    # read all lines and store it in a list
    lines = input_file.readlines()

# Initialize a 2D array with all elements as False (off)
lights = [[False for x in range(1000)] for y in range(1000)]

# Loop through each line in the input file
for line in lines:
    # Use regex to match the pattern in the line
    match = re.match(r""(.*) (\d+),(\d+) through (\d+),(\d+)"", line.strip())
    action, x1, y1, x2, y2 = match.groups()
    x1, y1, x2, y2 = int(x1), int(y1), int(x2), int(y2)
    # Perform the action on the lights
    if action == ""turn on"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = True
    elif action == ""turn off"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = False
    elif action == ""toggle"":
        for i in range(x1, x2+1):
            for j in range(y1, y2+1):
                lights[i][j] = not lights[i][j]

# Count the number of turned on lights
count = 0
for i in range(1000):
    for j in range(1000):
        if lights[i][j]:
            count += 1

# Print the count of turned on lights
print(count)
",0
6,2015,7,1,runtime_error,,46065,"Traceback (most recent call last):
  File ""/tmp/tmpfidomh0g/tmp.py"", line 57, in <module>
    main()
  File ""/tmp/tmpfidomh0g/tmp.py"", line 52, in main
    eval_line(line, wires)
  File ""/tmp/tmpfidomh0g/tmp.py"", line 33, in eval_line
    x, _, shift, _, dest = re.findall(r'(\w+) | (\d+)', line)
ValueError: not enough values to unpack (expected 5, got 3)
","
import re

def bitwise_not(x):
    return 65535 - x

def bitwise_and(x, y):
    return x & y

def bitwise_or(x, y):
    return x | y

def bitwise_lshift(x, y):
    return x << y

def bitwise_rshift(x, y):
    return x >> y

def eval_line(line, wires):
    if 'AND' in line:
        x, _, y, _, dest = re.findall(r'(\w+)', line)
        wires[dest] = bitwise_and(wires[x], wires[y])
        return
    elif 'OR' in line:
        x, _, y, _, dest = re.findall(r'(\w+)', line)
        wires[dest] = bitwise_or(wires[x], wires[y])
        return
    elif 'LSHIFT' in line:
        x, _, shift, _, dest = re.findall(r'(\w+) | (\d+)', line)
        wires[dest] = bitwise_lshift(wires[x], int(shift))
        return
    elif 'RSHIFT' in line:
        x, _, shift, _, dest = re.findall(r'(\w+) | (\d+)', line)
        wires[dest] = bitwise_rshift(wires[x], int(shift))
        return
    elif 'NOT' in line:
        x, _, dest = re.findall(r'(\w+)', line)
        wires[dest] = bitwise_not(wires[x])
        return
    else:
        x, _, dest = re.findall(r'(\d+) -> (\w+)', line)
        wires[dest] = int(x)
        return

def main():
    with open('input.txt', 'r') as file:
        circuit_lines = file.readlines()

    wires = {}
    for line in circuit_lines:
        line = line.strip()
        eval_line(line, wires)

    print(wires['a'])

if __name__ == '__main__':
    main()
",2
7,2015,8,1,no_error,"1371
",1371,,"
import re

def count_string_literals(file_path):
    with open(file_path) as f:
        lines = f.readlines()
        total_code = 0
        total_memory = 0

        for line in lines:
            line = line.strip()
            code = len(line)
            line = line[1:-1] # Remove the opening and closing quotes
            line = re.sub(r'\\\\', '-', line) # Replace \ with - to avoid counting it as an escape character
            line = re.sub(r'\\""', '-', line) # Replace \"" with - to avoid counting it as an escape character
            line = re.sub(r'\\x[0-9a-fA-F]{2}', '-', line) # Replace hexadecimal escape sequences with - to avoid counting it as an escape character
            memory = len(line)
            total_code += code
            total_memory += memory

        return total_code - total_memory

result = count_string_literals('input.txt')
print(result)
",2
8,2015,9,1,syntax_error,,251,"  File ""/tmp/tmp_8vd14wy/tmp.py"", line 18
    return None
    ^
SyntaxError: invalid syntax
","
import itertools
from collections import defaultdict
from heapq import heappop, heapify

def dijkstra(graph, start, end):
    queue = [(0, start, [])]
    visited = set()
    while queue:
        (cost, current, path) = heappop(queue)
        if current not in visited:
            visited.add(current)
            path = path + [current]
            if current == end:
                return (cost, path)
            for neighbor, distance in graph[current]:
                heapq.heappush(queue, (cost + distance, neighbor, path + [neighbor])
    return None

def read_input(filename):
    graph = defaultdict(list)
    with open(filename, 'r') as file:
        for line in file:
            city1, city2, dist = line.strip().split(' = ')
            dist = int(dist)
            graph[city1].append((city2, dist))
            graph[city2].append((city1, dist))
    return graph

def shortest_path(graph):
    cities = list(graph.keys())
    min_cost = float('inf')
    for perm in itertools.permutations(cities, len(cities)):
        start, *cities_to_visit, end = perm
        cost, path = dijkstra(graph, start, end)
        for city in cities_to_visit:
            cost += graph[path[-1]][cities.index(city)][1]
            path.append(city)
        if cost < min_cost:
            min_cost = cost
    return min_cost

# Read input file
graph = read_input('input.txt')

# Find shortest path
shortest = shortest_path(graph)

# Print answer
print(f""The shortest distance Santa can travel is {shortest} km."")
",2
9,2015,10,1,no_error,"329356
",329356,,"
def look_and_say(sequence):
    result = ''
    count = 1
    digit = sequence[0]
    for i in range(1, len(sequence)):
        if sequence[i] == digit:
            count += 1
        else:
            result += str(count) + digit
            count = 1
            digit = sequence[i]
    result += str(count) + digit
    return result

with open('input.txt', 'r') as f:
    input_seq = f.read().strip()

for _ in range(40):
    input_seq = look_and_say(input_seq)

print(len(input_seq))
",0
10,2015,11,1,wrong_output,"abcdffaa
",vzbxxyzz,,"
import re

def is_valid_password(password):
    if 'i' in password or 'o' in password or 'l' in password:
        return False
    if not re.search(r'abc|bcd|cde|def|efg|fgh|ghi|pqr|pqr|xyz', password):
        return False
    if len(re.findall(r'([a-z])\1', password)) < 2:
        return False
    return True

def increment_password(password):
    password = list(password)
    for i in range(len(password) - 1, -1, -1):
        if password[i] == 'z':
            password[i] = 'a'
        else:
            password[i] = chr(ord(password[i]) + 1)
            return ''.join(password)
    return 'a' * len(password)

def find_next_password(current_password):
    next_password = increment_password(current_password)
    while not is_valid_password(next_password):
        next_password = increment_password(next_password)
    return next_password

current_password = 'abcdefgh' # replace with the current password from input.txt
next_password = find_next_password(current_password)
print(next_password)
",2
11,2015,12,1,no_error,"111754
",111754,,"
import json

def sum_numbers(doc):
    if isinstance(doc, int):
        return doc
    elif isinstance(doc, list):
        return sum(sum_numbers(item) for item in doc)
    elif isinstance(doc, dict):
        return sum(sum_numbers(item) for item in doc.values())
    else:
        return 0

with open('input.txt', 'r') as f:
    data = json.load(f)
    print(sum_numbers(data))
",0
12,2015,13,1,no_error,"733
",733,,"
import itertools

def get_happiness_change(arrangement, happiness_dict):
    total_change = 0
    for i in range(len(arrangement)):
        total_change += happiness_dict[arrangement[i]][arrangement[(i+1)%len(arrangement)]] + happiness_dict[arrangement[(i+1)%len(arrangement)]][arrangement[i]]
    return total_change

def generate_all_arrangements(names):
    return list(itertools.permutations(names))

def find_optimal_arrangement(happiness_dict):
    all_arrangements = generate_all_arrangements(happiness_dict.keys())
    max_change = float('-inf')
    optimal_arrangement = None
    for arrangement in all_arrangements:
        change = get_happiness_change(arrangement, happiness_dict)
        if change > max_change:
            max_change = change
            optimal_arrangement = arrangement
    return max_change

with open('input.txt', 'r') as f:
    happiness_dict = {}
    lines = f.readlines()
    for line in lines:
        line = line.strip().split()
        person1, gain_lose, units, neighbor = line[0], line[2], int(line[3]), line[-1][:-1]
        if gain_lose == 'gain':
            if person1 in happiness_dict:
                happiness_dict[person1][neighbor] = units
            else:
                happiness_dict[person1] = {neighbor: units}
        else:
            if person1 in happiness_dict:
                happiness_dict[person1][neighbor] = -units
            else:
                happiness_dict[person1] = {neighbor: -units}

    max_change = find_optimal_arrangement(happiness_dict)
    print(max_change)
",2
13,2015,14,1,syntax_error,,2655,"  File ""/tmp/tmpo045qo5k/tmp.py"", line 35
    if i % (int(reindeer[2]) + int(reindeer[3]) < int(reindeer[2]):
                                                                  ^
SyntaxError: invalid syntax
","
import re
import time

reindeer_data = []
with open('input.txt', 'r') as f:
    for line in f:
        reindeer_data.append(re.findall(r'(\w+) can fly (\d+) km/s for (\d+) seconds, but then must rest for (\d+) seconds.', line))

reindeer_distances = {}
for reindeer in reindeer_data:
    reindeer_distances[reindeer[0]] = 0

for i in range(2503):
    for reindeer in reindeer_data:
        if i % (int(reindeer[2]) + int(reindeer[3])) < int(reindeer[2]):
            reindeer_distances[reindeer[0]] += int(reindeer[1])

    max_distance = max(reindeer_distances.values())

print(max_distance)


reindeer_data = []
with open('input.txt', 'r') as f:
    for line in f:
        reindeer_data.append(re.findall(r'(\w+) can fly (\d+) km/s for (\d+) seconds, but then must rest for (\d+) seconds.', line))

reindeer_distances = {}
for reindeer in reindeer_data:
    reindeer_distances[reindeer[0]] = 0

for i in range(2503):
    for reindeer in reindeer_data:
        if i % (int(reindeer[2]) + int(reindeer[3]) < int(reindeer[2]):
            reindeer_distances[reindeer[0]] += int(reindeer[1])

    max_distance = max(reindeer_distances.values())

print(max_distance)
",2
14,2015,15,1,wrong_output,"1766400
",21367368,,"
import itertools
import math

def get_max_score(ingredients, total_teaspoons):
    max_score = 0
    for comb in itertools.combinations_with_replacement(ingredients, total_teaspoons):
        capacity_sum = 0
        durability_sum = 0
        flavor_sum = 0
        texture_sum = 0
        calories_sum = 0
        for ingredient in comb:
            capacity_sum += ingredient[0]
            durability_sum += ingredient[1]
            flavor_sum += ingredient[2]
            texture_sum += ingredient[3]
            calories_sum += ingredient[4]
        if calories_sum != 500:
            continue
        score = math.prod([max(0, capacity_sum), max(0, durability_sum), max(0, flavor_sum), max(0, texture_sum)])
        max_score = max(max_score, score)
    return max_score

input_file = open(""input.txt"", ""r"")
ingredients = []
for line in input_file:
    name, properties = line.split("":"")
    properties = properties.strip().split("","")
    capacity, durability, flavor, texture, calories = [int(prop.split()[-1]) for prop in properties]
    ingredients.append((capacity, durability, flavor, texture, calories))
input_file.close()

print(get_max_score(ingredients, 100))
",2
15,2015,16,1,syntax_error,,40,"  File ""/tmp/tmpon2h7vur/tmp.py"", line 45
    if aunt_sue_details.items() <= {f'Aunt {i}': aunt_sue_details.get(f'Aunt {i}', 0) for f'Aunt {i}' in aunt_sue_details.keys()}.items():
                                                                                          ^
SyntaxError: cannot assign to f-string expression
","
import re

# Sample Input
input_str = """"""children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1""""""

# Dictionary to store the Aunt Sue details
aunt_sue_details = {
    'children': 3,
    'cats': 7,
    'samoyeds': 2,
    'pomeranians': 3,
    'akitas': 0,
    'vizslas': 0,
    'goldfish': 5,
    'trees': 3,
    'cars': 2,
    'perfumes': 1
}

# Dictionary to store the Aunt Sue details with the number
aunt_sue = {}

# Reading the input from file
with open('input.txt', 'r') as file:
    input_str = file.read()

# Creating a dictionary for the Aunt Sue details
for line in input_str.split('\n'):
    key, value = re.findall(r'(\w+): (\d+)', line)[0]
    aunt_sue_details[key] = int(value)

# Looping through the Aunts
for i in range(1, 501):
    # Checking if the Aunt Sue has the same details as the input
    if aunt_sue_details.items() <= {f'Aunt {i}': aunt_sue_details.get(f'Aunt {i}', 0) for f'Aunt {i}' in aunt_sue_details.keys()}.items():
        aunt_sue[i] = aunt_sue_details

# Printing the Aunt Sue number
print(list(aunt_sue.keys())[0])
",2
16,2015,17,1,runtime_error,,1638,"Traceback (most recent call last):
  File ""/tmp/tmprth49itk/tmp.py"", line 9, in <module>
    print(count_combinations(eggnog, containers))
  File ""/tmp/tmprth49itk/tmp.py"", line 5, in count_combinations
    return sum(1 for i in range(len(containers)) if sum(combinations(containers, i)) == eggnog)
  File ""/tmp/tmprth49itk/tmp.py"", line 5, in <genexpr>
    return sum(1 for i in range(len(containers)) if sum(combinations(containers, i)) == eggnog)
TypeError: unsupported operand type(s) for +: 'int' and 'tuple'
","
from itertools import combinations

def count_combinations(eggnog, containers):
    return sum(1 for i in range(len(containers)) if sum(combinations(containers, i)) == eggnog)

containers = [20, 15, 10, 5, 5]
eggnog = 150
print(count_combinations(eggnog, containers))
",2
17,2015,18,1,no_error,"814
",814,,"
import os

# Read the input file
with open(""input.txt"", ""r"") as file:
    data = file.readlines()

# Initialize the grid
grid = [list(line.strip()) for line in data]

# Function to count the number of neighbors that are on
def count_neighbors(x, y, grid):
    count = 0
    for dx in range(-1, 2):
        for dy in range(-1, 2):
            if dx == 0 and dy == 0:
                continue
            nx = x + dx
            ny = y + dy
            if 0 <= nx < 100 and 0 <= ny < 100:
                if grid[ny][nx] == '#':
                    count += 1
    return count

# Function to generate the next state of the grid
def next_state(grid):
    new_grid = [['.' for _ in range(100)] for _ in range(100)]
    for x in range(100):
        for y in range(100):
            neighbors_on = count_neighbors(x, y, grid)
            if grid[y][x] == '#' and 2 <= neighbors_on <= 3:
                new_grid[y][x] = '#'
            elif grid[y][x] == '.' and neighbors_on == 3:
                new_grid[y][x] = '#'
    return new_grid

# Run the animation for 100 steps
for _ in range(100):
    grid = next_state(grid)

# Count the number of lights on
count = sum(row.count('#') for row in grid)

print(count)
",2
18,2015,19,1,wrong_output,"5246
",518,,"
import re

def replace_molecules(molecule, replacements):
    new_molecules = set()
    for old, new in replacements:
        for match in re.finditer(old, molecule):
            start, end = match.span()
            new_molecules.add(molecule[:start] + new + molecule[end:])
    return new_molecules

def count_distinct_molecules(molecule, replacements, steps=10):
    distinct_molecules = set()
    for _ in range(steps):
        molecules = replace_molecules(molecule, replacements)
        for mol in molecules:
            distinct_molecules.add(mol)
        molecule = list(molecules)[0]
    return len(distinct_molecules)

if __name__ == ""__main__"":
    with open(""input.txt"") as f:
        lines = f.readlines()
        replacements = [line.strip().split(' => ') for line in lines[:-2]]
        medicine = lines[-1].strip()
        print(count_distinct_molecules(medicine, replacements))
",2
19,2015,20,1,wrong_output,"The lowest house number to get at least 33100000 presents is 3638.
",776160,,"
def get_lowest_house_number(target_presents):
    elves = {}
    house = 1
    presents_at_house = 0
    while presents_at_house < target_presents:
        for i in range(1, house + 1):
            if i not in elves:
                elves[i] = 0
            elves[i] += i * 10
            if elves[i] >= target_presents:
                return house
        house += 1

def main():
    input_file = open(""input.txt"", ""r"")
    target_presents = int(input_file.readline().strip())
    result = get_lowest_house_number(target_presents)
    print(f""The lowest house number to get at least {target_presents} presents is {result}."")

if __name__ == ""__main__"":
    main()
",2
20,2015,21,1,runtime_error,,78,"Traceback (most recent call last):
  File ""/tmp/tmpevf_rxju/tmp.py"", line 27, in <module>
    boss_stats = list(map(int, f.read().split()))
ValueError: invalid literal for int() with base 10: 'Hit'
","
import sys
from itertools import combinations

def win_fight(player_hp, player_damage, player_armor, boss_hp, boss_damage, boss_armor, weapons, armor, rings):
    for weapon in weapons:
        for arm in armor:
            for ring1, ring2 in combinations(rings, 2):
                total_cost = weapon[0] + arm[0] + ring1[0] + ring2[0]
                total_damage = player_damage + weapon[1] + ring1[1] + ring2[1]
                total_armor = player_armor + arm[1] + ring1[2] + ring2[2]
                player_turns_to_win = math.ceil(boss_hp / (total_damage - boss_armor))
                boss_turns_to_win = math.ceil(player_hp / (boss_damage - total_armor))
                if player_turns_to_win <= boss_turns_to_win:
                    return total_cost
    return -1

weapons = [(8, 4, 0), (10, 5, 0), (25, 6, 0), (40, 7, 0), (74, 8, 0)]
armor = [(0, 0, 0), (13, 0, 1), (31, 0, 2), (53, 0, 3), (75, 0, 4), (102, 0, 5)]
rings = [(0, 0, 0), (25, 1, 0), (50, 2, 0), (100, 3, 0), (20, 0, 1), (40, 0, 2), (80, 0, 3)]

player_hp = 100
player_damage = 0
player_armor = 0

with open('input.txt', 'r') as f:
    boss_stats = list(map(int, f.read().split()))

boss_hp, boss_damage, boss_armor = boss_stats

min_cost = float('inf')

for weapon in weapons:
    for arm in armor:
        for ring1, ring2 in combinations(rings, 2):
            total_cost = weapon[0] + arm[0] + ring1[0] + ring2[0]
            total_damage = player_damage + weapon[1] + ring1[1] + ring2[1]
            total_armor = player_armor + arm[1] + ring1[2] + ring2[2]
            player_turns_to_win = math.ceil(boss_hp / (total_damage - boss_armor))
            boss_turns_to_win = math.ceil(player_hp / (boss_damage - total_armor))
            if player_turns_to_win <= boss_turns_to_win:
                min_cost = min(min_cost, total_cost)

print(min_cost)
",2
21,2015,22,1,runtime_error,,953,"Traceback (most recent call last):
  File ""/tmp/tmp73qy_c3f/tmp.py"", line 43, in <module>
    boss_stats = [int(line.strip()) for line in open('input.txt').readlines()]
  File ""/tmp/tmp73qy_c3f/tmp.py"", line 43, in <listcomp>
    boss_stats = [int(line.strip()) for line in open('input.txt').readlines()]
ValueError: invalid literal for int() with base 10: 'Hit Points: 55'
","
import sys

def calculate_least_mana_spent(boss_hp, boss_damage):
    def run_combat(player_hp, player_mana, player_armor, player_shield_timer, player_poison_timer, player_recharge_timer, mana_spent, player_turn):
        if player_turn:
            if player_shield_timer > 0:
                player_armor = 7
            if player_poison_timer > 0:
                boss_hp -= 3
            if player_recharge_timer > 0:
                player_mana += 101
            if mana_spent >= 229 and player_recharge_timer <= 0:
                player_mana += 101
                player_recharge_timer = 5
                mana_spent += 229
            if mana_spent >= 173 and player_poison_timer <= 0:
                player_poison_timer = 6
                mana_spent += 173
            if mana_spent >= 113 and player_shield_timer <= 0:
                player_shield_timer = 6
                player_armor = 7
                mana_spent += 113
            if mana_spent >= 53:
                if boss_hp <= 4:
                    return mana_spent
                player_hp -= 4
                boss_hp -= 2 if player_shield_timer > 0 else 1
                mana_spent += 53
        else:
            if player_shield_timer > 0:
                player_armor = 0
            if player_poison_timer > 0:
                boss_hp -= 3
            if boss_hp <= 0:
                return mana_spent
            player_hp -= max(1, boss_damage - player_armor)
        return run_combat(boss_hp, player_mana, player_armor, max(0, player_shield_timer - 1), max(0, player_poison_timer - 1), max(0, player_recharge_timer - 1), mana_spent, not player_turn)

    return run_combat(50, 500, 0, 0, 0, 0, True)


boss_stats = [int(line.strip()) for line in open('input.txt').readlines()]
print(calculate_least_mana_spent(boss_stats[0], boss_stats[1]))


def calculate_least_mana_spent(boss_hp, boss_damage):
    def run_combat(player_hp, player_mana, player_armor, player_shield_timer, player_poison_timer, player_recharge_timer, mana_spent, player_turn):
        if player_turn:
            if player_shield_timer > 0:
                player_armor = 7
            if player_poison_timer > 0:
                boss_hp -= 3
            if player_recharge_timer > 0:
                player_mana += 101
            if mana_spent >= 229 and player_recharge_timer <= 0:
                player_mana += 101
                player_recharge_timer = 5
                mana_spent += 229
            if mana_spent >= 173 and player_poison_timer <= 0:
                player_poison_timer = 6
                mana_spent += 173
            if mana_spent >= 113 and player_shield_timer <= 0:
                player_shield_timer = 6
                player_armor = 7
                mana_spent += 113
            if mana_spent >= 53:
                if boss_hp <= 4:
                    return mana_spent
                player_hp -= 4
                boss_hp -= 2 if player_shield_timer > 0 else 1
                mana_spent += 53
        else:
            if player_shield_timer > 0:
                player_armor = 0
            if player_poison_timer > 0:
                boss_hp -= 3
            if boss_hp <= 0:
                return mana_spent
            player_hp -= max(1, boss_damage - player_armor)
        return run_combat(boss_hp, player_mana, player_armor, max(0, player_shield_timer - 1), max(0, player_poison_timer - 1), max(0, player_recharge_timer - 1), mana_spent, not player_turn)

    with open('input.txt') as f:
        boss_stats = [int(line.strip()) for line in f]
    print(calculate_least_mana_spent(boss_stats[0], boss_stats[1]))
",2
22,2015,23,1,runtime_error,,307,"Traceback (most recent call last):
  File ""/tmp/tmprvyetsag/tmp.py"", line 33, in <module>
    process_program(program)
  File ""/tmp/tmprvyetsag/tmp.py"", line 25, in process_program
    offset = execute_instruction(instruction, registers)
  File ""/tmp/tmprvyetsag/tmp.py"", line 17, in execute_instruction
    if register[instruction[1]] == 1:
NameError: name 'register' is not defined
","
import sys

def execute_instruction(instruction, registers):
    if instruction[0] == ""hlf"":
        registers[instruction[1]] //= 2
    elif instruction[0] == ""tpl"":
        registers[instruction[1]] *= 3
    elif instruction[0] == ""inc"":
        registers[instruction[1]] += 1
    elif instruction[0] == ""jmp"":
        return int(instruction[1])
    elif instruction[0] == ""jie"":
        if register[instruction[1]] % 2 == 0:
            return int(instruction[2])
    elif instruction[0] == ""jio"":
        if register[instruction[1]] == 1:
            return int(instruction[2])
    return 1

def process_program(program):
    i = 0
    while i < len(program):
        instruction = program[i].split()
        offset = execute_instruction(instruction, registers)
        if offset is not None:
            i += offset
        else:
            i += 1

registers = {""a"": 0, ""b"": 0}
program = [line.strip() for line in open(""input.txt"", ""r"").readlines()]
process_program(program)
print(registers[""b""])


def execute_instruction(instruction, registers):
    if instruction[0] == ""hlf"":
        registers[instruction[1]] //= 2
    elif instruction[0] == ""tpl"":
        registers[instruction[1]] *= 3
    elif instruction[0] == ""inc"":
        registers[instruction[1]] += 1
    elif instruction[0] == ""jmp"":
        return int(instruction[1])
    elif instruction[0] == ""jie"":
        if register[instruction[1]] % 2 == 0:
            return int(instruction[2])
    elif instruction[0] == ""jio"":
        if register[instruction[1]] == 1:
            return int(instruction[2])
    return 1

def process_program(program):
    i = 0
    while i < len(program):
        instruction = program[i].split()
        offset = execute_instruction(instruction, registers)
        if offset is not None:
            i += offset
        else:
            i += 1

registers = {""a"": 0, ""b"": 0}
with open(""input.txt"", ""r"") as f:
    program = [line.strip() for line in f.readlines()]
process_program(program)
print(registers[""b""])
",2
23,2015,24,1,no_error,"10439961859
",10439961859,,"
from itertools import combinations
from math import prod

# Read the input from the file
with open('input.txt', 'r') as f:
    data = [int(x) for x in f.read().split()]

# Sort the packages in descending order
data.sort(reverse=True)

# Iterate over all possible combinations of the first group and find the one with the smallest quantum entanglement
min_qe = float('inf')
min_first_group = None
for i in range(1, len(data) // 3):
    for combo in combinations(data, i):
        if sum(combo) <= sum(data) // 3:
            first_group = combo
            second_group = [x for x in data if x not in first_group]
            if sum(first_group) == sum(second_group) // 2:
                qe = prod(first_group)
                if qe < min_qe:
                    min_qe = qe
                    min_first_group = first_group

print(min_qe)
",1
24,2015,25,1,timeout_error,,9132360,TIMEOUT,"
import math

def generate_code(row, col):
    code = 20151125
    for i in range(1, max(row, col)+1):
        code = (code * 252533) % 3354393
    return code

def find_row_col(n):
    row = math.ceil((math.sqrt(8 * n + 1) - 1) / 2)
    col = n - (row * (row - 1)) // 2
    return int(row), int(col)

def main():
    puzzle_input = input(""Enter the puzzle input: "")
    row, col = find_row_col(int(puzzle_input))
    code = generate_code(row, col)
    print(""The code is:"", code)

if __name__ == ""__main__"":
    main()
",2
25,2016,1,1,wrong_output,"913
",287,,"
import re

def calculate_distance(directions):
    x = 0
    y = 0
    for direction in directions:
        if direction[0] == ""R"":
            if direction[1] == ""L"":
                x += int(direction[1:])
            else:
                y -= int(direction[1:])
        else:
            if direction[1] == ""L"":
                y += int(direction[1:])
            else:
                x -= int(direction[1:])
    return abs(x) + abs(y)

with open(""input.txt"", ""r"") as file:
    input_directions = file.read().strip().split("", "")

distance = calculate_distance(input_directions)
print(distance)
",2
26,2016,2,1,no_error,"12578
",12578,,"
def get_position(pos, direction):
    if direction == 'U':
        return (pos[0] - 1, pos[1]) if pos[0] > 0 else pos
    elif direction == 'D':
        return (pos[0] + 1, pos[1]) if pos[0] < 2 else pos
    elif direction == 'L':
        return (pos[0], pos[1] - 1) if pos[1] > 0 else pos
    elif direction == 'R':
        return (pos[0], pos[1] + 1) if pos[1] < 2 else pos
    else:
        return pos

def get_code(instructions):
    pos = (1, 1)
    code = []
    for line in instructions:
        for d in line:
            pos = get_position(pos, d)
        code.append(str(pos[0] * 3 + pos[1] + 1))
    return ''.join(code)

with open('input.txt', 'r') as f:
    instructions = f.readlines()
    print(get_code(instructions))
",0
27,2016,3,1,no_error,"993
",993,,"
import os

# Opening the file containing the input data
with open(""input.txt"", ""r"") as f:
    data = f.readlines()

# Initializing a counter for valid triangles
valid_triangles = 0

# Looping through each line in the file
for line in data:
    # Splitting the line into a list of integers
    sides = list(map(int, line.split()))

    # Sorting the sides in ascending order
    sides.sort()

    # Checking if the sum of the first two sides is greater than the third side
    if sides[0] + sides[1] > sides[2]:
        valid_triangles += 1

# Printing the count of valid triangles
print(valid_triangles)
",0
28,2016,4,1,syntax_error,,245102,"  File ""/tmp/tmpjt6o3un7/tmp.py"", line 15
    checksum = ''.join([k for k, v in sorted_letters[:5])
    ^
SyntaxError: invalid syntax
","import re

def is_real_room(room):
    encrypted_name, sector_id = room.split('[')
    encrypted_name = encrypted_name[:-1]
    sector_id = int(sector_id[:-1])
    letter_counts = {}
    for letter in encrypted_name:
        if letter != '-':
            if letter in letter_counts:
                letter_counts[letter] += 1
            else:
                letter_counts[letter] = 1
    sorted_letters = sorted(letter_counts.items(), key=lambda x: (-x[1], x[0])
    checksum = ''.join([k for k, v in sorted_letters[:5])
    if checksum == room[-6:-1]:
        return sector_id
    return None

def main():
    with open('input.txt', 'r') as f:
        lines = f.readlines()
        sector_sum = 0
        for line in lines:
            sector_id = is_real_room(line.strip())
            if sector_id:
                sector_sum += sector_id
    print(sector_sum)

if __name__ == '__main__':
    main() 

# Solution:
#1. We start by importing the 're' module for regular expressions which we will use to split the lines of text into encrypted names and sector IDs.
#2. We define a function 'is_real_room' that takes in a single parameter 'room'.
#3. In the function, we split the room into its encrypted name and sector ID using the 'split' method.
#4. We create a dictionary to store the count of each letter in the encrypted name.
#5. We loop through each letter in the encrypted name, excluding the dashes.
#6. We update the count of each letter in the dictionary.
#7. We sort the dictionary items by count and then by letter in descending order and extract the top 5 letters.
#8. We join the top 5 letters into a string called 'checksum' and compare it to the checksum in the input.
#9. If the checksum matches, we return the sector ID, otherwise we return None.
#10. In the main function, we open the input file, initialize a variable 'sector_sum' to 0, loop through each line in the file, and add the sector ID to the sum if it is not None (i.e. if it is a real room).
#11. Finally, we print the sector sum.

# Note: The input file containing the list of rooms should be in the same directory as the python script. ",2
29,2016,5,1,timeout_error,,1a3099aa,TIMEOUT,"
import hashlib

def generate_password(door_id):
    password = """"
    index = 0
    while len(password) < 8:
        md5_hash = hashlib.md5((door_id + str(index)).encode()).hexdigest()
        if md5_hash[:5] == ""000000"":
            password += md5_hash[5]
        index += 1
    return password

with open(""input.txt"", ""r"") as f:
    door_id = f.read().strip()
    print(generate_password(door_id))
",2
30,2016,6,1,no_error,"ygjzvzib
",ygjzvzib,,"
import operator

def error_correction(file_name):
    with open(file_name, 'r') as file:
        messages = [line.strip() for line in file.readlines()]

    message_length = len(messages[0])
    corrected_message = ''

    for i in range(message_length):
        char_count = {}
        for message in messages:
            char = message[i]
            char_count[char] = char_count.get(char, 0) + 1

        corrected_message += max(char_count.items(), key=operator.itemgetter(1))[0]

    return corrected_message

print(error_correction('input.txt'))
",0
31,2016,7,1,wrong_output,"0
",115,,"
import re

def supports_tls(ip):
    # Function to check if an IP supports TLS
    abba_pattern = re.compile(r'(?<!\[)([a-z])([a-z])\1(?!\1)([a-z])\2(?!\2)')
    hypernet_pattern = re.compile(r'\[([a-z]+)\]')
    abba_match = abba_pattern.findall(ip)
    hypernet_match = hypernet_pattern.findall(ip)
    for match in abba_match:
        if match[::-1] in abba_match:
            return True
    for match in hypernet_match:
        if match[::-1] in match:
            return False
    return False

# Open input file and count IPs that support TLS
with open('input.txt', 'r') as f:
    ips = f.readlines()
    tls_count = sum(1 for ip in ips if supports_tls(ip.strip()))

print(tls_count)
",2
32,2016,8,1,no_error,"115
",115,,"
import re

def process_instructions(instructions, width, height):
    screen = [['.' for _ in range(width)] for _ in range(height)]
    for instruction in instructions:
        if instruction.startswith('rect'):
            A, B = map(int, re.findall(r'\d+', instruction))
            for y in range(B):
                for x in range(A):
                    screen[y][x] = '#'
        elif instruction.startswith('rotate column'):
            x, B = map(int, re.findall(r'\d+', instruction))
            screen_column = [screen[y][x] for y in range(height)]
            for y in range(height):
                screen[y][x] = screen_column[(y - B) % height]
        elif instruction.startswith('rotate row'):
            y, B = map(int, re.findall(r'\d+', instruction))
            screen_row = screen[y]
            screen[y] = screen_row[-B:] + screen_row[:-B]
        else:
            raise ValueError('Invalid instruction: ' + instruction)
    return sum(1 for row in screen for pixel in row if pixel == '#')

with open('input.txt') as f:
    instructions = f.readlines()
    width, height = 50, 6
    lit_pixels = process_instructions(instructions, width, height)
    print(lit_pixels)
",1
33,2016,9,1,runtime_error,,102239,"Traceback (most recent call last):
  File ""/tmp/tmpvmkqg5tq/tmp.py"", line 25, in <module>
    length = decompress(line)
  File ""/tmp/tmpvmkqg5tq/tmp.py"", line 14, in decompress
    length, multiplier = int(line[start+1:start_marker]), int(line[start_marker+1:end])
ValueError: invalid literal for int() with base 10: ''
","import re

def decompress(line):
    decompressed_length = 0
    while True:
        match = re.search(r'\((\d+)x(\d+)\)', line)
        if not match:
            decompressed_length += len(line)
            break
        else:
            start, end = match.span()
            start_marker, end_marker = line.find('(', start), line.find(')', end)
            decompressed_length += start_marker
            length, multiplier = int(line[start+1:start_marker]), int(line[start_marker+1:end])
            decompressed_length += length * multiplier
            line = line[end_marker+1:]
            decompress_length = decompress(line[:length]) * multiplier
            line = line[length:]
            decompressed_length += decompress_length
    return decompressed_length

with open('input.txt', 'r') as file:
    for line in file:
        line = line.strip()
        length = decompress(line)
        print(length) ",2
34,2016,10,1,wrong_output,"None
",118,,"
import re

def find_bot(instructions, target1, target2):
    bot_dict = {}
    output_dict = {}
    for line in instructions.split('\n'):
        if line.startswith('value'):
            value, bot_id = map(int, re.findall(r'\d+', line))
            if bot_id in bot_dict:
                bot_dict[bot_id].append(value)
            else:
                bot_dict[bot_id] = [value]
        elif line.startswith('bot'):
            source_bot, low_recipient, high_recipient = re.findall(r'\d+', line)
            low_recipient = 'output' if low_recipient == 'output' else int(low_recipient)
            high_recipient = 'output' if high_recipient == 'output' else int(high_recipient)
            if source_bot in bot_dict:
                low, high = sorted(bot_dict[source_bot])
                if low == target1 and high == target2:
                    return source_bot
                bot_dict[source_bot] = []
                if low_recipient != 'output':
                    if low in bot_dict[low_recipient]:
                        bot_dict[low_recipient].append(low)
                    else:
                        bot_dict[low_recipient] = [low]
                else:
                    if low not in output_dict:
                        output_dict[low_recipient] = [low]
                    else:
                        output_dict[low_recipient].append(low)
                if high_recipient != 'output':
                    if high in bot_dict[high_recipient]:
                        bot_dict[high_recipient].append(high)
                    else:
                        bot_dict[high_recipient] = [high]
                else:
                    if high not in output_dict:
                        output_dict[high_recipient] = [high]
                    else:
                        output_dict[high_recipient].append(high)
    return None

instructions = '''value 5 goes to bot 2
bot 2 gives low to bot 1 and high to bot 0
value 3 goes to bot 1
bot 1 gives low to output 1 and high to bot 0
bot 0 gives low to output 2 and high to output 0
value 2 goes to bot 2'''

print(find_bot(instructions, 61, 17))
",2
35,2016,11,1,runtime_error,,37,"Traceback (most recent call last):
  File ""/tmp/tmptpck7a6l/tmp.py"", line 61, in <module>
    main(sys.argv[1])
IndexError: list index out of range
","
import itertools
import re
import sys
from collections import defaultdict

def get_data(input_file):
    with open(input_file, ""r"") as file:
        data = file.readlines()
    items = {}
    for line in data:
        floor, item = re.findall(r""(\d+) (H|L)(\w+)"", line)
        items[int(floor)] = (item[0], item[1])
    return items

def is_safe(item1, item2):
    return item1[0] != item2[0] and item1[1] != item2[1]

def get_steps(items):
    floors = defaultdict(set)
    for floor, item in items.items():
        floors[floor].add(item)

    for floor in floors.keys():
        if len(floors[floor]) > 1:
            floors[floor] = set(sorted(floors[floor], key=lambda x: x[1]))

    steps = 0
    elevator = set()
    current_floor = 1
    while any(floors.values()):
        if current_floor == 4:
            current_floor = 1

        if elevator and (current_floor == 4 or len(elevator) == 2 or any(is_safe(elevator, item) for item in floors[current_floor] | elevator)):
            if len(elevator) == 2:
                steps += 1
            elif len(elevator) == 1:
                steps += 2
            elevator.clear()

        if floors[current_floor]:
            for item in floors[current_floor]:
                if is_safe(item, elevator):
                    elevator.add(item)
                    floors[current_floor].remove(item)

        if current_floor == 4:
            break

        current_floor += 1

    return steps

def main(input_file):
    items = get_data(input_file)
    steps = get_steps(items)
    print(f""Minimum steps required: {steps}"")

if __name__ == ""__main__"":
    main(sys.argv[1])
",2
36,2016,12,1,runtime_error,,318083,"Traceback (most recent call last):
  File ""/tmp/tmpg4mxiy_b/tmp.py"", line 53, in <module>
    print(generate_code('input.txt'))
  File ""/tmp/tmpg4mxiy_b/tmp.py"", line 48, in generate_code
    jump = execute_instruction(lines[i], registers)
  File ""/tmp/tmpg4mxiy_b/tmp.py"", line 28, in execute_instruction
    cpy(params[0], params[1], registers)
TypeError: cpy() takes 2 positional arguments but 3 were given
","
import re
import sys

def cpy(params, registers):
    value, dest = params.split()
    if not value.isalpha():
        registers[dest] = int(value)
    else:
        registers[dest] = registers[value]

def inc(params, registers):
    registers[params] += 1

def dec(params, registers):
    registers[params] -= 1

def jnz(params, registers):
    value, jump = params.split()
    if (not value.isalpha() and int(value) != 0) or (value.isalpha() and registers[value] != 0):
        return int(jump)
    else:
        return 1

def execute_instruction(instruction, registers):
    opcode, params = instruction.split()[0], instruction.split()[1:]
    if opcode == 'cpy':
        cpy(params[0], params[1], registers)
    elif opcode == 'inc':
        inc(params[0], registers)
    elif opcode == 'dec':
        dec(params[0], registers)
    elif opcode == 'jnz':
        return jnz(params[0], params[1], registers)
    else:
        print(""Invalid instruction"")
        sys.exit(1)

    return 1

def generate_code(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
    i = 0
    while i < len(lines):
        jump = execute_instruction(lines[i], registers)
        i += jump

    return registers['a']

print(generate_code('input.txt'))


def cpy(params, registers):
    value, dest = params.split()
    if not value.isalpha():
        registers[dest] = int(value)
    else:
        registers[dest] = registers[value]

def inc(params, registers):
    registers[params] += 1

def dec(params, registers):
    registers[params] -= 1

def jnz(params, registers):
    value, jump = params.split()
    if (not value.isalpha() and int(value) != 0) or (value.isalpha() and registers[value] != 0):
        return int(jump)
    else:
        return 1

def execute_instruction(instruction, registers):
    opcode, params = instruction.split()[0], instruction.split()[1:]
    if opcode == 'cpy':
        cpy(params[0], params[1], registers)
    elif opcode == 'inc':
        inc(params[0], registers)
    elif opcode == 'dec':
        dec(params[0], registers)
    elif opcode == 'jnz':
        return jnz(params[0], params[1], registers)
    else:
        print(""Invalid instruction"")
        sys.exit(1)

    return 1

def generate_code(input_file):
    with open(input_file, 'r') as f:
        lines = f.readlines()

    registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
    i = 0
    while i < len(lines):
        jump = execute_instruction(lines[i], registers)
        i += jump

    return registers['a']

print(generate_code('input.txt'))
",2
37,2016,13,1,wrong_output,"90
",92,,"
import math

def count_bits(num):
    """"""
    Counts the number of 1's in the binary representation of a number
    """"""
    return bin(num).count('1')

def is_open_space(x, y, fav_num):
    """"""
    Determines whether a given coordinate is an open space or a wall
    """"""
    return count_bits(x*x + 3*x + 2*x*y + y + y*y + fav_num) % 2 == 0

def generate_maze(fav_num):
    """"""
    Generates the maze as a dictionary of coordinates
    """"""
    maze = {(x, y): is_open_space(x, y, fav_num) for x in range(50) for y in range(50)}
    return maze

def get_neighbors(x, y, maze):
    """"""
    Returns the open neighboring coordinates for a given coordinate
    """"""
    neighbors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if (nx, ny) in maze and maze[(nx, ny)]:
            neighbors.append((nx, ny))
    return neighbors

def bfs(start, end, maze):
    """"""
    Breadth-first search to find the shortest path from start to end in the maze
    """"""
    queue = [(start, 0)]
    visited = set()
    while queue:
        (x, y), steps = queue.pop(0)
        if (x, y) == end:
            return steps
        if (x, y) not in visited:
            visited.add((x, y))
            for nx, ny in get_neighbors(x, y, maze):
                queue.append(((nx, ny), steps + 1))
    return None

fav_num = 1352
maze = generate_maze(fav_num)
print(bfs((1, 1), (31, 39), maze))
",2
38,2016,14,1,wrong_output,"23629
",23890,,"
import hashlib

def find_keys(salt):
    index = 0
    keys = 0
    key_index = None
    while keys < 64:
        md5_hash = hashlib.md5(salt.encode('utf-8') + str(index).encode('utf-8')).hexdigest()
        if len(set(md5_hash)) != len(md5_hash):
            for char in set(md5_hash):
                if md5_hash.count(char * 3) >= 1:
                    for i in range(index + 1, index + 1000):
                        new_hash = hashlib.md5(salt.encode('utf-8') + str(i).encode('utf-8')).hexdigest()
                        if new_hash.count(char * 5) >= 1:
                            keys += 1
                            key_index = index
                            break
        index += 1
    return key_index

input_file = open('input.txt', 'r')
salt = input_file.readline().strip()
print(find_keys(salt))
",2
39,2016,15,1,runtime_error,,400589,"Traceback (most recent call last):
  File ""/tmp/tmp5hmo8b65/tmp.py"", line 17, in <module>
    disc_positions = [int(d[1]) for d in discs]
  File ""/tmp/tmp5hmo8b65/tmp.py"", line 17, in <listcomp>
    disc_positions = [int(d[1]) for d in discs]
ValueError: invalid literal for int() with base 10: '#1'
","
import math

def find_first_valid_time(disc_positions, disc_sizes):
    time = 0
    while True:
        for i in range(len(disc_positions)):
            time += 1
            if (disc_positions[i] + time + i + 1) % disc_sizes[i] != 0:
                break
        else:
            return time

# Read the input from the file
with open('input.txt', 'r') as file:
    discs = [line.strip().split(' ') for line in file.readlines()]
    disc_positions = [int(d[1]) for d in discs]
    disc_sizes = [int(d[3]) for d in discs]

# Find the first valid time to push the button
first_valid_time = find_first_valid_time(disc_positions, disc_sizes)

print(""The first valid time to push the button is:"", first_valid_time)
",2
40,2016,16,1,no_error,"10100011010101011
",10100011010101011,,"
import hashlib

def dragon_curve(a, n):
    """"""
    Generates the modified dragon curve for the given input a of length n.
    """"""
    b = a[::-1]
    b = b.replace('0', '2').replace('1', '0').replace('2', '1')
    return a + '0' + b

def generate_data(a, n):
    """"""
    Generates the random data for the given initial state a of length n.
    """"""
    data = a
    while len(data) < n:
        data = dragon_curve(data, n)
    return data[:n]

def generate_checksum(data):
    """"""
    Generates the checksum for the given data.
    """"""
    checksum = ''
    for i in range(0, len(data), 2):
        if data[i] == data[i+1]:
            checksum += '1'
        else:
            checksum += '0'
    if len(checksum) % 2 == 0:
        checksum = generate_checksum(checksum)
    return checksum

def solve(initial_state, length):
    """"""
    Generates the correct checksum for the given initial state and disk length.
    """"""
    data = generate_data(initial_state, length)
    return generate_checksum(data)

# Read the initial state from the input file
with open('input.txt', 'r') as f:
    initial_state = f.read().strip()

# Set the desired disk length
disk_length = 272

# Get the correct checksum
checksum = solve(initial_state, disk_length)
print(checksum)
",2
41,2016,17,1,wrong_output,"None
",RDDRULDDRR,,"
import hashlib

def get_doors(passcode, path):
    m = hashlib.md5((passcode + path).encode('utf-8')).hexdigest()[:4]
    return [m[i] in ""bcdef"" for i in range(4)]

def solve_maze(passcode, path='', x=0, y=0, target=(3,3)):
    if (x, y) == target:
        return path
    if y < target[1]:
        if get_doors(passcode, path+'D')[0]:
            return solve_maze(passcode, path+'D', x, y+1, target)
    if x < target[0]:
        if get_doors(passcode, path+'R')[1]:
            return solve_maze(passcode, path+'R', x+1, y, target)
    if y > 0:
        if get_doors(passcode, path+'U')[2]:
            return solve_maze(passcode, path+'U', x, y-1, target)
    if x > 0:
        if get_doors(passcode, path+'L')[3]:
            return solve_maze(passcode, path+'L', x-1, y, target)

passcode = open('input.txt').read().strip()
print(solve_maze(passcode))
",2
42,2016,18,1,wrong_output,"The number of safe tiles in 40 rows of traps is: 2006
",1913,,"
import os

def get_input():
    with open(os.path.join(os.getcwd(), 'input.txt'), 'r') as f:
        return [line.strip() for line in f.readlines()]

def get_next_row(row):
    next_row = []
    for i in range(len(row)):
        prev_left, prev_center, prev_right = '^' if i == 0 else row[i-1], row[i], '^' if i == len(row) - 1 else row[i+1]
        if (prev_left == '^' and prev_center == '^' and prev_right != '^') or (prev_center == '^' and prev_right == '^' and prev_left != '^') or (prev_left == '^' and prev_center != '^' and prev_right != '^') or (prev_right == '^' and prev_center != '^' and prev_left != '^'):
            next_row.append('^')
        else:
            next_row.append('.')
    return ''.join(next_row)

def count_safe_tiles(rows):
    safe_count = 0
    for row in rows:
        safe_count += row.count('.')
    return safe_count

def main():
    input_rows = get_input()
    rows = [input_rows[0]]
    for _ in range(40):
        rows.append(get_next_row(rows[-1]))
    safe_count = count_safe_tiles(rows)
    print(f""The number of safe tiles in 40 rows of traps is: {safe_count}"")
    
if __name__ == '__main__':
    main()
",2
43,2016,19,1,timeout_error,,1808357,TIMEOUT,"
import math

def steal_presents(num_elves):
    """"""
    Returns the position of the elf who gets all the presents.
    """"""
    # Initialize variables
    elves = list(range(1, num_elves + 1))
    current_elf = 0
    while len(elves) > 1:
        # Calculate the position of the elf to steal from
        steal_from = (current_elf + (num_elves // 2) + (num_elves // 2) % 2) % num_elves
        # Remove the elf who is being stolen from and add their presents to the current elf
        elves.pop(steal_from)
        # Move to the next elf
        current_elf = (current_elf + 1) % len(elves)
        num_elves -= 1
    return elves[0]

def main():
    # Read input from file
    with open('input.txt', 'r') as file:
        num_elves = int(file.readline().strip())
    # Calculate the position of the elf who gets all the presents
    elf_with_presents = steal_presents(num_elves)
    print(f""Elf {elf_with_presents} gets all the presents."")

if __name__ == ""__main__"":
    main()


def steal_presents(num_elves):
    """"""
    Returns the position of the elf who gets all the presents.
    """"""
    # Initialize variables
    elves = list(range(1, num_elves + 1))
    current_elf = 0
    while len(elves) > 1:
        # Calculate the position of the elf to steal from
        steal_from = (current_elf + (num_elves // 2) + (num_elves // 2) % 2) % num_elves
        # Remove the elf who is being stolen from and add their presents to the current elf
        elves.pop(steal_from)
        # Move to the next elf
        current_elf = (current_elf + 1) % len(elves)
        num_elves -= 1
    return elves[0]

def main():
    # Read input from file
    with open('input.txt', 'r') as file:
        num_elves = int(file.readline().strip())
    # Calculate the position of the elf who gets all the presents
    elf_with_presents = steal_presents(num_elves)
    print(f""Elf {elf_with_presents} gets all the presents."")

if __name__ == ""__main__"":
    main()
",2
44,2016,20,1,wrong_output,"The lowest valid IP is 32259706.
",32259706,,"
import re

def lowest_valid_ip(blacklist):
    blocked_ranges = []
    for line in blacklist:
        start, end = map(int, re.findall(r'\d+', line))
        blocked_ranges.append((start, end))

    blocked_ranges.sort()

    lowest_valid = 0
    for start, end in blocked_ranges:
        if start > lowest_valid:
            return lowest_valid
        lowest_valid = end + 1

    return lowest_valid

with open('input.txt') as f:
    blacklist = f.readlines()
    lowest_ip = lowest_valid_ip(blacklist)
    print(f""The lowest valid IP is {lowest_ip}."")
",2
45,2016,21,1,runtime_error,,gbhafcde,"Traceback (most recent call last):
  File ""/tmp/tmpkszxfyj9/tmp.py"", line 41, in <module>
    print(scramble_password(""abcdefgh"", operations))
  File ""/tmp/tmpkszxfyj9/tmp.py"", line 16, in scramble_password
    password.rotate(steps)
AttributeError: 'str' object has no attribute 'rotate'
","
from collections import deque

def scramble_password(password, operations):
    password = deque(list(password))
    for operation in operations:
        if operation.startswith(""swap position""):
            x, y = map(int, operation.split()[-2:])
            password[x], password[y] = password[y], password[x]
        elif operation.startswith(""swap letter""):
            x, y = operation.split()[-2:]
            password = ''.join(password).replace(x, ""_"").replace(y, x).replace(""_"", y)
        elif operation.startswith(""rotate""):
            if ""left"" in operation:
                steps = int(operation.split()[-2])
                password.rotate(steps)
            elif ""right"" in operation:
                steps = int(operation.split()[-2])
                password.rotate(-steps)
            elif ""position"" in operation:
                x = operation.split()[-1]
                i = password.index(x)
                steps = (i + 2) % len(password)
                if i >= 4:
                    steps += 1
                password.rotate(steps)
        elif operation.startswith(""reverse""):
            x, y = map(int, operation.split()[-2:])
            password = list(password)
            password[x:y+1] = password[x:y+1][::-1]
            password = deque(password)
        elif operation.startswith(""move""):
            x, y = map(int, operation.split()[-2:])
            password.remove(password[x])
            password.insert(y, password.popleft())
    return ''.join(password)

with open(""input.txt"", ""r"") as f:
    operations = [line.strip() for line in f.readlines()]

print(scramble_password(""abcdefgh"", operations))


class deque:
    def __init__(self, iterable=(), maxlen=None):
        self.items = list(iterable)
        self.maxlen = maxlen

    def append(self, x):
        self.items.append(x)
        if self.maxlen is not None and len(self) > self.maxlen:
            self.popleft()

    def appendleft(self, x):
        self.items.insert(0, x)
        if self.maxlen is not None and len(self) > self.maxlen:
            self.pop()

    def pop(self):
        return self.items.pop()

    def popleft(self):
        return self.items.pop(0)

    def rotate(self, n=1):
        self.items = self.items[-n:] + self.items[:-n]

    def __len__(self):
        return len(self.items)

    def __getitem__(self, i):
        return self.items[i]

    def __setitem__(self, i, x):
        self.items[i] = x

    def __iter__(self):
        return iter(self.items)

    def __repr__(self):
        return ""deque({!r})"".format(self.items)

def scramble_password(password, operations):
    password = deque(list(password))
    for operation in operations:
        if operation.startswith(""swap position""):
            x, y = map(int, operation.split()[-2:])
            password[x], password[y] = password[y], password[x]
        elif operation.startswith(""swap letter""):
            x, y = operation.split()[-2:]
            password = ''.join(password).replace(x, ""_"").replace(y, x).replace(""_"", y)
        elif operation.startswith(""rotate""):
            if ""left"" in operation:
                steps = int(operation.split()[-2])
                password.rotate(steps)
            elif ""right"" in operation:
                steps = int(operation.split()[-2])
                password.rotate(-steps)
            elif ""position"" in operation:
                x = operation.split()[-1]
                i = password.index(x)
                steps = (i + 2) % len(password)
                if i >= 4:
                    steps += 1
                password.rotate(steps)
        elif operation.startswith(""reverse""):
            x, y = map(int, operation.split()[-2:])
            password = list(password)
            password[x:y+1] = password[x:y+1][::-1]
            password = deque(password)
        elif operation.startswith(""move""):
            x, y = map(int, operation.split()[-2:])
            password.remove(password[x])
            password.insert(y, password.popleft())
    return ''.join(password)

with open(""input.txt"", ""r"") as f:
    operations = [line.strip() for line in f.readlines()]

print(scramble_password(""abcdefgh"", operations))
",2
46,2016,22,1,syntax_error,,901,"  File ""/tmp/tmpfmlf6qq5/tmp.py"", line 9
    for l in range(len(nodes[k]):
                                ^
SyntaxError: invalid syntax
","
import re

def count_viable_pairs(nodes):
    viable_pairs = 0
    for i in range(len(nodes)):
        for j in range(len(nodes[i])):
            for k in range(len(nodes)):
                for l in range(len(nodes[k]):
                    if nodes[i][j]['Used'] != 0 and nodes[i][j]['Used'] <= nodes[k][l]['Avail'] and (i,j) != (k,l):
                        viable_pairs += 1
    return viable_pairs

with open('input.txt', 'r') as file:
    lines = file.readlines()
    nodes = []
    for line in lines:
        node, size, used, avail, use = re.findall(r'node-x(\d+)-y(\d+)\s+(.*?)\s+(\d+)T\s+(\d+)T\s+(\d+)T', line)[0]
        node = (int(node[4:]), int(node[6:])), int(used), int(avail), int(use)
        nodes.append(node)

    count = count_viable_pairs(nodes)
    print(count)
",2
47,2016,23,1,wrong_output,"7
",12516,,"
import re

with open('input.txt', 'r') as f:
    data = f.readlines()

registers = {'a': 7, 'b': 0, 'c': 0, 'd': 0}

def cpy(x, y):
    try:
        registers[y] = int(x) if not x.isalpha() else registers[x]
    except ValueError:
        return

def inc(x):
    registers[x] += 1

def dec(x):
    registers[x] -= 1

def jnz(x, y):
    try:
        x = int(x)
    except ValueError:
        x = registers[x]
    try:
        y = int(y)
    except ValueError:
        y = registers[y]
    if x:
        return y
    else:
        return None

instructions = [re.findall(r'(\w+)\s+([-\w]+)\s*([-\w]*)?', line.strip()) for line in data]
toggled = set()

for i, (cmd, *args) in enumerate(instructions):
    if cmd == 'tgl':
        try:
            index = i + int(args[0])
            if 0 <= index < len(instructions):
                instruction, *arguments = instructions[index]
                if len(arguments) == 1:
                    instructions[index] = ('dec' if instruction == 'inc' else 'inc', *arguments)
                else:
                    instructions[index] = ('cpy' if instruction == 'jnz' else 'jnz', *arguments)
                toggled.add(index)
        except ValueError:
            pass

i = 0
while i < len(instructions):
    cmd, *args = instructions[i]
    if i in toggled:
        cmd = 'inc' if cmd == 'dec' else 'dec' if cmd == 'inc' else 'jnz' if cmd == 'cpy' else 'cpy'
    if cmd == 'inc':
        inc(args[0])
    elif cmd == 'dec':
        dec(args[0])
    elif cmd == 'cpy':
        cpy(args[0], args[1])
    elif cmd == 'jnz':
        try:
            jnz(args[0], int(args[1]) - 1)
        except ValueError:
            pass
    elif cmd == 'tgl':
        pass
    i += 1 if i not in toggled else jnz(args[0], args[1]) or 1

print(registers['a'])
",2
48,2016,24,1,syntax_error,,498,"  File ""/tmp/tmp2e_o20kz/tmp.py"", line 47
    distances[start] = 0
    ^
SyntaxError: invalid syntax
","
import numpy as np
import heapq
from collections import defaultdict

# Load the input.txt file
with open('input.txt', 'r') as f:
    data = f.read().splitlines()

# Define the maze with walls and corridors
maze = np.array([list(line) for line in data])

# Define the starting point
start = np.where(maze == '0')
start = (start[0][0], start[1][0])

# Define the goal points
goals = set(map(int, ''.join(maze[maze != '#'])) - set('0'))

# Define the four directions (up, down, left, right)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# Define the distance function
def distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

# Define the heuristic function
def heuristic(p1, p2):
    return distance(p1, p2)

# Define the neighbors function
def get_neighbors(position):
    i, j = position
    neighbors = []
    for direction in directions:
        x, y = direction
        if maze[i + x, j + y] != '#':
            neighbors.append((i + x, j + y))
    return neighbors

# A* search algorithm
def a_star_search(start, goal, heuristic):
    queue = [(0, start)]
    visited = set()
    visited.add(start)
    distances = defaultdict(lambda: float('inf')
    distances[start] = 0
    parents = {}
    while queue:
        current_distance, current_position = heapq.heappop(queue)
        if current_position == goal:
            return distances[goal]
        for neighbor in get_neighbors(current_position):
            new_distance = current_distance + distance(current_position, neighbor)
            if new_distance < distances[neighbor]:
                distances[neighbor] = new_distance
                parents[neighbor] = current_position
                priority = new_distance + heuristic(neighbor, goal)
                heapq.heappush(queue, (priority, neighbor))
    return distances[goal]

# Execute the search for each goal
total_distance = 0
for goal in goals:
    total_distance += a_star_search(start, (np.where(maze == str(goal))[0][0], np.where(maze == str(goal))[1][0]), heuristic)

print(total_distance)
",2
49,2016,25,1,runtime_error,,196,"Traceback (most recent call last):
  File ""/tmp/tmppw3n17ln/tmp.py"", line 69, in <module>
    main()
  File ""/tmp/tmppw3n17ln/tmp.py"", line 38, in main
    instructions, _ = parse_input(input_data)
  File ""/tmp/tmppw3n17ln/tmp.py"", line 13, in parse_input
    op, arg1, arg2 = re.findall(r""(\w{3}) ([a-z])(?: ([a-z])?)?"", line.strip())[0]
IndexError: list index out of range
","
import re
import sys
from typing import Tuple

filename = ""input.txt""
with open(filename) as f:
    input_data = f.readlines()

def parse_input(data: list) -> Tuple[dict, int]:
    instructions = {}
    for line in data:
        op, arg1, arg2 = re.findall(r""(\w{3}) ([a-z])(?: ([a-z])?)?"", line.strip())[0]
        instructions[len(instructions)] = (op, arg1, arg2)
    return instructions, 0

def execute_instruction(instructions: dict, registers: dict, pointer: int, a, b, c, d) -> Tuple[int, int, int, int, int]:
    op, arg1, arg2 = instructions[pointer]

    if op == ""cpy"":
        registers[arg2] = registers[arg1] if arg1.isdigit() else registers.get(arg1, 0)
        pointer += 1
    elif op == ""inc"":
        registers[arg1] += 1
        pointer += 1
    elif op == ""dec"":
        registers[arg1] -= 1
        pointer += 1
    elif op == ""jnz"":
        pointer += int(arg2) if arg1.isdigit() and int(arg1) != 0 else (registers.get(arg1, 0) != 0) * int(arg2)
    elif op == ""out"":
        registers[""output""] = registers[arg1] if arg1.isdigit() else registers.get(arg1, 0)
        pointer += 1

    return a, b, c, d

def main():
    instructions, _ = parse_input(input_data)
    a, b, c, d = 0, 0, 0, 0
    pointer = 0

    while pointer < len(instructions):
        a, b, c, d = execute_instruction(instructions, {""a"": a, ""b"": b, ""c"": c, ""d"": d}, pointer)
        if ""output"" in locals():
            print(locals()[""output""], end="""")
            del locals()[""output""]
        if pointer >= len(instructions):
            break
    
    print()
    pattern = re.compile(r""0101"")
    lowest_integer = 0
    while True:
        a, b, c, d = 0, 0, 0, 0
        output = """"
        pointer = 0
        while pointer < len(instructions):
            a, b, c, d = execute_instruction(instructions, {""a"": a, ""b"": b, ""c"": c, ""d"": d}, pointer)
            if ""output"" in locals():
                output += str(locals()[""output""])
                del locals()[""output""]
            pointer += 1
        if pattern.match(output):
            print(f""The lowest positive integer to initialize register 'a' to produce a clock signal of 0, 1, 0, 1, ... is {lowest_integer}"")
            break
        lowest_integer += 1

if __name__ == ""__main__"":
    main()
",2
50,2017,1,1,runtime_error,,1177,"Traceback (most recent call last):
  File ""/tmp/tmpaxxs8b25/tmp.py"", line 15, in <module>
    for digit in input_deque:
RuntimeError: deque mutated during iteration
","
import os
from collections import deque

input_file = open('input.txt', 'r')
input_lines = input_file.readlines()
input_line = input_lines[0].strip()

# Convert the input string to a deque (so we can use circular indexing)
input_deque = deque(input_line)

total_sum = 0

# Iterate through the deque, comparing each digit to the next
for digit in input_deque:
    if input_deque[1] == digit:
        total_sum += int(digit)
    
    # Rotate the deque one step to the right
    input_deque.rotate(-1)

print(total_sum)
",2
51,2017,2,1,wrong_output,"45158
45158
",45158,,"
import sys

def checksum(spreadsheet):
    checksum_total = 0
    for row in spreadsheet:
        row = [int(x) for x in row.split()]
        row_diff = max(row) - min(row)
        checksum_total += row_diff
    return checksum_total

input_file = open(""input.txt"", ""r"")
spreadsheet = input_file.readlines()
print(checksum(spreadsheet))


def checksum(spreadsheet):
    checksum_total = 0
    for row in spreadsheet:
        row = list(map(int, row.split()))
        row_diff = max(row) - min(row)
        checksum_total += row_diff
    return checksum_total

with open(""input.txt"", ""r"") as input_file:
    spreadsheet = input_file.readlines()
print(checksum(spreadsheet))
",2
52,2017,3,1,wrong_output,"711
",438,,"
import math

def distance_to_access_port(num):
    # calculate the distance to the closest layer
    layer = int(math.ceil((math.sqrt(num-1) / 2)) + 1)
    last_square_in_layer = layer ** 2
    # calculate the start and end points of the layer
    start_of_layer = last_square_in_layer - (layer-1) ** 2
    end_of_layer = last_square_in_layer
    # calculate the position of the number in the layer
    position_in_layer = num - start_of_layer
    
    # calculate the distance to center of layer
    if position_in_layer <= layer:
        distance = position_in_layer
    else:
        distance = layer + (position_in_layer % layer)
    
    # add the distance to the center of the layer and the distance to the access port
    return distance + layer

# read input from file
with open('input.txt', 'r') as file:
    num = int(file.read().strip())

# calculate distance to access port
print(distance_to_access_port(num))
",2
53,2017,4,1,no_error,"383
",383,,"
import re

def is_valid_passphrase(passphrase):
    words = passphrase.split()
    return len(words) == len(set(words))

def count_valid_passphrases(input_file):
    valid_count = 0
    with open(input_file, 'r') as f:
        for line in f:
            if is_valid_passphrase(line.strip()):
                valid_count += 1
    return valid_count

input_file = 'input.txt'
valid_count = count_valid_passphrases(input_file)
print(valid_count)
",0
54,2017,5,1,no_error,"391540
",391540,,"
def main():
    with open('input.txt', 'r') as f:
        offsets = [int(x) for x in f.read().split()]
    jumps = 0
    i = 0
    while i >= 0 and i < len(offsets):
        offset = offsets[i]
        offsets[i] += 1
        i += offset
        jumps += 1
    print(jumps)

if __name__ == ""__main__"":
    main()
",2
55,2017,6,1,no_error,"6681
",6681,,"
def reallocate(banks):
    max_value = max(banks)
    max_index = banks.index(max_value)
    banks[max_index] = 0
    for i in range(max_index + 1, max_index + max_value + 1):
        index = i % len(banks)
        banks[index] += 1
    return banks

def check_for_cycle(banks, seen_configs):
    key = tuple(banks)
    if key in seen_configs:
        return True
    else:
        seen_configs.add(key)
        return False

def main():
    with open('input.txt', 'r') as f:
        banks = list(map(int, f.read().strip().split()))
    seen_configs = set()
    cycles = 0
    while True:
        if check_for_cycle(banks, seen_configs):
            break
        reallocate(banks)
        cycles += 1
    print(cycles)

if __name__ == '__main__':
    main()
",0
56,2017,7,1,runtime_error,,cyrupz,"Traceback (most recent call last):
  File ""/tmp/tmpfl8j1usu/tmp.py"", line 32, in <module>
    tower = create_tower(data)
  File ""/tmp/tmpfl8j1usu/tmp.py"", line 15, in create_tower
    program, _, above_programs = re.findall(r'(.+) \(.*\)', line.split('->')[0].strip())
ValueError: not enough values to unpack (expected 3, got 1)
","
import re
from collections import defaultdict

def parse_input(input_file):
    with open(input_file, 'r') as f:
        data = f.readlines()
    return data

def create_tower(data):
    tower = defaultdict(dict)
    for line in data:
        line = line.strip()
        if '->' in line:
            program, _, above_programs = re.findall(r'(.+) \(.*\)', line.split('->')[0].strip())
            above_programs = re.findall(r'\b\w+\b', line.split('->')[1].strip())
            tower[program]['above'] = above_programs
        else:
            program, weight = re.findall(r'(\w+) \((.*)\)$', line)[0]
            tower[program]['weight'] = int(weight)
    return tower

def find_bottom_program(tower):
    bottom_program = None
    for program, program_info in tower.items():
        if 'above' not in program_info:
            bottom_program = program
            break
    return bottom_program

data = parse_input('input.txt')
tower = create_tower(data)
bottom_program = find_bottom_program(tower)
print(f""The bottom program is: {bottom_program}"")
",2
57,2017,8,1,no_error,"4448
",4448,,"
import re

with open(""input.txt"") as f:
    lines = f.readlines()

registers = {}

# Initialize registers with value 0
for line in lines:
    for match in re.finditer(r""[a-z]+"", line):
        register = match.group(0)
        if register not in registers:
            registers[register] = 0

# Process instructions
for line in lines:
    match = re.match(r""(?P<register>[a-z]+) (?P<operation>inc|dec) (?P<amount>-?\d+) if (?P<condition>[a-z]+) (?P<condition_op>!=|<=|==|>|<|>=) (?P<condition_value>-?\d+)"", line.strip())
    if match:
        register, operation, amount, condition, condition_op, condition_value = match.groups()
        condition_value = int(condition_value)
        amount = int(amount)

        if eval(f""registers.get('{condition}', 0) {condition_op} {condition_value}""):
            if operation == ""inc"":
                registers[register] += amount
            elif operation == ""dec"":
                registers[register] -= amount

        max_value = max(registers.values())

print(max_value)
",1
58,2017,9,1,timeout_error,,7640,TIMEOUT,"
import re

def parse_stream(stream):
    """"""
    Parses the stream and returns the score and the remaining characters
    """"""
    score = 0
    while stream:
        # Remove any ignored characters
        if stream.startswith('!'):
            stream = stream[2:]

        # Check if the group starts
        if stream.startswith('{'):
            score += 1
            stream = stream[1:]
            score, stream = parse_stream(stream)

        # Check if the group ends
        if stream.startswith('}'):
            return (score, stream[1:])

        # Check for garbage
        if stream.startswith('<'):
            stream = stream[1:]
            while not stream.startswith('>'):
                if stream.startswith('!'):
                    stream = stream[2:]
                else:
                    stream = stream[1:]
            stream = stream[1:]

    return (score, stream)

def calculate_score(stream):
    """"""
    Calculates the score of the stream
    """"""
    # Remove all garbage from the stream
    stream = re.sub(r'<[^>]*>', '', stream)

    # Parse the remaining stream
    score, remaining = parse_stream(stream)
    return score

# Read the input file
with open('input.txt', 'r') as f:
    stream = f.read().strip()

# Calculate the score
print(calculate_score(stream))
",2
59,2017,10,1,no_error,"46600
",46600,,"
import functools

def circular_list(lst, current_pos, length):
    """"""
    Reverse the order of a slice of the given list starting at current_pos and wrapping around if necessary
    """"""
    if current_pos + length > len(lst):
        # wrap around if we need to
        reverse_slice = lst[current_pos:] + lst[:current_pos+length-len(lst)]
    else:
        reverse_slice = lst[current_pos:current_pos+length]
    reversed_slice = list(reversed(reverse_slice))
    if current_pos + length > len(lst):
        lst[current_pos:] = reversed_slice[:len(lst)-current_pos]
        lst[:current_pos+length-len(lst)] = reversed_slice[len(lst)-current_pos:]
    else:
        lst[current_pos:current_pos+length] = reversed_slice

def knot_hash(lengths, rounds=1, size=256):
    """"""
    Implement the knot-tying hash function with the given lengths and rounds
    """"""
    lst = list(range(size))
    current_pos = skip_size = 0
    for length in lengths:
        circular_list(lst, current_pos, length)
        current_pos = (current_pos + length + skip_size) % size
        skip_size += 1
    return lst

def knot_hash_part1(lengths):
    """"""
    Part 1 of the puzzle: multiply the first two elements of the knot hash
    """"""
    hashed = knot_hash(lengths)
    return hashed[0] * hashed[1]

# Part 1 solution
lengths = [int(x) for x in open('input.txt').read().split(',')]
print(knot_hash_part1(lengths))
",0
60,2017,11,1,no_error,"696
",696,,"
def hex_distance(path):
    import re
    moves = re.findall(r'[ns][ew]', path)
    x, y = 0, 0
    for move in moves:
        dx, dy = {'n': (0, -1), 'ne': (1, -1), 'se': (1, 0), 's': (0, 1), 'sw': (-1, 1), 'nw': (-1, 0)}[move]
        x += dx
        y += dy
    return max(abs(x), abs(y))

with open('input.txt', 'r') as f:
    path = f.read().strip()
    print(hex_distance(path))
",0
61,2017,12,1,no_error,"288
",288,,"
import sys
from collections import deque

def build_graph(input_file):
    with open(input_file, 'r') as f:
        data = f.readlines()
    graph = {}
    for line in data:
        node, neighbors = line.strip().split(' <-> ')
        graph[int(node)] = [int(n) for n in neighbors.split(', ')]
    return graph

def search_group(graph, start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.add(node)
            queue.extend(n for n in graph[node] if n not in visited)
    return visited

def main():
    input_file = 'input.txt'
    graph = build_graph(input_file)
    group = search_group(graph, 0)
    print(len(group))

if __name__ == '__main__':
    main()
",0
62,2017,13,1,wrong_output,"0
",1624,,"
import re

def severity(filename):
    with open(filename, 'r') as f:
        layers = re.findall(r'(\d+): (\d+)', f.read())
    layers = {int(depth): int(range_) for depth, range_ in layers}

    total_severity = 0
    for picosecond, layer in enumerate(sorted(layers.keys())):
        scanner_position = (picosecond // (2 * (layers[layer] - 1)) + 1) * layers[layer] - 1
        if scanner_position == 0:
            total_severity += layer * layers[layer]

    return total_severity

print(severity('input.txt'))
",2
63,2017,14,1,wrong_output,"8186
",8148,,"
import hashlib
import binascii

key = ""flqrgnkx""

def knot_hash(key, rounds=64, size=256):
    lengths = [ord(char) for char in key] + [17, 31, 73, 47, 23]
    sparse_hash = list(range(size))
    current_position = skip_size = 0
    for _ in range(rounds):
        for length in lengths:
            if current_position + length < size:
                sparse_hash = sparse_hash[current_position:current_position+length][::-1] + sparse_hash[:current_position] + sparse_hash[current_position+length:]
            else:
                wrap_amount = current_position + length - size
                sparse_hash = sparse_hash[-wrap_amount:] + sparse_hash[:current_position+length-size][::-1] + sparse_hash[current_position+length-size:-wrap_amount][::-1] + sparse_hash[:current_position]
            current_position = (current_position + length + skip_size) % size
            skip_size += 1
    dense_hash = [0] * 16
    for i in range(16):
        dense_hash[i] = 0
        for j in range(16):
            dense_hash[i] ^= sparse_hash[i*16+j]
    return binascii.hexlify(bytes(dense_hash))

def generate_grid(key):
    grid = []
    for i in range(128):
        grid.append(list(bin(int(knot_hash(key+'-'+str(i)), 16))[2:].zfill(128))[:128])
    return grid

def count_used_squares(grid):
    count = 0
    for row in grid:
        count += row.count('1')
    return count

grid = generate_grid(key)
print(count_used_squares(grid))
",2
64,2017,15,1,runtime_error,,650,"Traceback (most recent call last):
  File ""/tmp/tmpom3x4qkf/tmp.py"", line 34, in <module>
    main()
  File ""/tmp/tmpom3x4qkf/tmp.py"", line 16, in main
    starting_values = [int(line.strip()) for line in f.readlines()]
  File ""/tmp/tmpom3x4qkf/tmp.py"", line 16, in <listcomp>
    starting_values = [int(line.strip()) for line in f.readlines()]
ValueError: invalid literal for int() with base 10: 'Generator A starts with 783'
","
def generate_value(prev_value, factor):
    """"""
    Generate the next value based on the given factor and previous value using the formula: (prev_value * factor) % 2147483647
    """"""
    return (prev_value * factor) % 2147483647

def check_matching_bits(value_a, value_b):
    """"""
    Check if the lowest 16 bits of the given values match.
    """"""
    return bin(value_a & 0xFFFF)[2:] == bin(value_b & 0xFFFF)[2:]

def main():
    with open('input.txt') as f:
        starting_values = [int(line.strip()) for line in f.readlines()]

    judge_count = 0
    max_pairs_to_generate = 4000000000
    factor_a = 16807
    factor_b = 48271
    value_a = starting_values[0]
    value_b = starting_values[1]

    for _ in range(max_pairs_to_generate):
        value_a = generate_value(value_a, factor_a)
        value_b = generate_value(value_b, factor_b)
        if check_matching_bits(value_a, value_b):
            judge_count += 1

    print(judge_count)

if __name__ == '__main__':
    main()
",2
65,2017,16,1,no_error,"nlciboghjmfdapek
",nlciboghjmfdapek,,"
import re

# Input data
dance_moves = ""s1,x3/4,pe/b""
programs = ""abcde""
program_count = 16

# Function to perform spin move
def spin(dance_moves, programs):
    move = re.findall(r""s(\d+)"", dance_moves)[0]
    move = int(move)
    spin_programs = programs[-move:] + programs[:-move]
    return spin_programs

# Function to perform exchange move
def exchange(dance_moves, programs):
    move = re.findall(r""x(\d+)/(\d+)"", dance_moves)[0]
    move = list(map(int, move))
    exchange_programs = list(programs)
    exchange_programs[move[0]], exchange_programs[move[1]] = exchange_programs[move[1]], exchange_programs[move[0]]
    return """".join(exchange_programs)

# Function to perform partner move
def partner(dance_moves, programs):
    move = re.findall(r""p(\w)/(\w)"", dance_moves)[0]
    a_index = programs.index(move[0])
    b_index = programs.index(move[1])
    exchange_programs = list(programs)
    exchange_programs[a_index], exchange_programs[b_index] = exchange_programs[b_index], exchange_programs[a_index]
    return """".join(exchange_programs)

# Function to perform the dance
def perform_dance(dance_moves, programs):
    for move in dance_moves.split("",""):
        if move[0] == ""s"":
            programs = spin(move, programs)
        elif move[0] == ""x"":
            programs = exchange(move, programs)
        elif move[0] == ""p"":
            programs = partner(move, programs)
    return programs

# Read input file
with open(""input.txt"", ""r"") as f:
    dance_moves = f.readline().strip()

# Initialize programs
programs = [chr(97 + i) for i in range(program_count)]
programs = """".join(programs)

# Perform the dance
programs = perform_dance(dance_moves, programs)

# Print the final order of the programs
print("""".join(programs))
",1
66,2017,17,1,no_error,"640
",640,,"
import sys

def spinlock(step, iterations):
    buffer = [0]
    current_position = 0
    value = 1
    for i in range(1, iterations+1):
        current_position = (current_position + step) % len(buffer)
        buffer.insert(current_position + 1, value)
        current_position = (current_position + 1) % len(buffer)
        value += 1
    return buffer[buffer.index(2017) + 1]

with open('input.txt', 'r') as f:
    input_step = int(f.read().strip())

print(spinlock(input_step, 2017))
",0
67,2017,18,1,runtime_error,,4601,"Traceback (most recent call last):
  File ""/tmp/tmpv84t0d12/tmp.py"", line 81, in <module>
    process_instructions(instructions, registers, last_sound)
  File ""/tmp/tmpv84t0d12/tmp.py"", line 65, in process_instructions
    last_sound, registers, jump = execute_instruction(instructions[i], registers, last_sound)
  File ""/tmp/tmpv84t0d12/tmp.py"", line 9, in execute_instruction
    x, y = re.findall('[a-z]+|\d+', instruction)
ValueError: too many values to unpack (expected 2)
","
import re

def execute_instruction(instruction, registers, last_sound):
    if instruction.startswith('snd'):
        last_sound = int(re.findall('[a-z]+', instruction.split()[1])[0])
        return last_sound, registers, None
    elif instruction.startswith('set'):
        x, y = re.findall('[a-z]+|\d+', instruction)
        if y.isalpha():
            y = registers[y]
        else:
            y = int(y)
        registers[x] = y
        return last_sound, registers, None
    elif instruction.startswith('add'):
        x, y = re.findall('[a-z]+|\d+', instruction)
        if y.isalpha():
            y = registers[y]
        else:
            y = int(y)
        registers[x] += y
        return last_sound, registers, None
    elif instruction.startswith('mul'):
        x, y = re.findall('[a-z]+|\d+', instruction)
        if y.isalpha():
            y = registers[y]
        else:
            y = int(y)
        registers[x] *= y
        return last_sound, registers, None
    elif instruction.startswith('mod'):
        x, y = re.findall('[a-z]+|\d+', instruction)
        if y.isalpha():
            y = registers[y]
        else:
            y = int(y)
        registers[x] = registers[x] % y
        return last_sound, registers, None
    elif instruction.startswith('rcv'):
        x = re.findall('[a-z]+|\d+', instruction)[0]
        if registers[x] != 0:
            return last_sound, registers, 'recover'
        else:
            return last_sound, registers, None
    elif instruction.startswith('jgz'):
        x, y = re.findall('[a-z]+|\d+', instruction)
        if x.isalpha():
            x = registers[x]
        else:
            x = int(x)
        if y.isalpha():
            y = registers[y]
        else:
            y = int(y)
        if x > 0:
            return last_sound, registers, y
        else:
            return last_sound, registers, None
    return last_sound, registers, None

def process_instructions(instructions, registers, last_sound):
    i = 0
    while i < len(instructions):
        last_sound, registers, jump = execute_instruction(instructions[i], registers, last_sound)
        if jump is None:
            i += 1
        elif jump == 'recover':
            return last_sound
        else:
            i += jump
    return last_sound

registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0}

with open('input.txt', 'r') as f:
    instructions = f.read().split('\n')

last_sound = None

process_instructions(instructions, registers, last_sound)
",2
68,2017,19,1,wrong_output,"

",GSXDIPWTU,,"
import re

def find_path(diagram):
    path = ''
    x, y = 0, diagram.index('\n')
    direction = 'D' # Down
    while True:
        if diagram[y][x] == '+':
            if direction in ['N', 'S']:
                if diagram[y][x-1] != ' ':
                    direction = 'L'
                else:
                    direction = 'R'
            elif direction in ['L', 'R']:
                if diagram[y-1][x] != ' ':
                    direction = 'U'
                else:
                    direction = 'D'
            elif direction == 'U':
                if diagram[y][x-1] != ' ' and diagram[y][x+1] != ' ':
                    direction = 'R'
                elif diagram[y][x+1] != ' ':
                    direction = 'D'
                else:
                    direction = 'L'
            elif direction == 'D':
                if diagram[y][x-1] != ' ' and diagram[y][x+1] != ' ':
                    direction = 'L'
                elif diagram[y][x+1] != ' ':
                    direction = 'U'
                else:
                    direction = 'R'
        elif re.match(r'[A-Za-z]', diagram[y][x]):
            path += diagram[y][x]
            
        if direction == 'D':
            y += 1
        elif direction == 'U':
            y -= 1
        elif direction == 'L':
            x -= 1
        elif direction == 'R':
            x += 1

        if x < 0 or y < 0 or x >= len(diagram[0]) or y >= len(diagram) or diagram[y][x] == ' ':
            break

    return path

with open('input.txt', 'r') as file:
    diagram = file.read()
    print(find_path(diagram))


def find_path(diagram):
    path = ''
    x, y = 0, diagram.index('\n')
    direction = 'D' # Down
    while True:
        if diagram[y][x] == '+':
            if direction in ['N', 'S']:
                if diagram[y][x-1] != ' ':
                    direction = 'L'
                else:
                    direction = 'R'
            elif direction in ['L', 'R']:
                if diagram[y-1][x] != ' ':
                    direction = 'U'
                else:
                    direction = 'D'
            elif direction == 'U':
                if diagram[y][x-1] != ' ' and diagram[y][x+1] != ' ':
                    direction = 'R'
                elif diagram[y][x+1] != ' ':
                    direction = 'D'
                else:
                    direction = 'L'
            elif direction == 'D':
                if diagram[y][x-1] != ' ' and diagram[y][x+1] != ' ':
                    direction = 'L'
                elif diagram[y][x+1] != ' ':
                    direction = 'U'
                else:
                    direction = 'R'
        elif re.match(r'[A-Za-z]', diagram[y][x]):
            path += diagram[y][x]
            
        if direction == 'D':
            y += 1
        elif direction == 'U':
            y -= 1
        elif direction == 'L':
            x -= 1
        elif direction == 'R':
            x += 1

        if x < 0 or y < 0 or x >= len(diagram[0]) or y >= len(diagram) or diagram[y][x] == ' ':
            break

    return path

with open('input.txt', 'r') as file:
    diagram = file.read()
    print(find_path(diagram))
",2
69,2017,20,1,timeout_error,,344,TIMEOUT,"
import re
import sys

def manhattan_distance(x, y, z):
    return abs(x) + abs(y) + abs(z)

particles = []
for line in sys.stdin:
    m = re.match(r'p=<(-?\d+),(-?\d+),(-?\d+)>, v=<(-?\d+),(-?\d+),(-?\d+)>, a=<(-?\d+),(-?\d+),(-?\d+)>', line.strip())
    p = [int(m.group(1)), int(m.group(2)), int(m.group(3))]
    v = [int(m.group(4)), int(m.group(5)), int(m.group(6))]
    a = [int(m.group(7)), int(m.group(8)), int(m.group(9))]
    particles.append((p, v, a))

t = 10000
while t > 0:
    for i, (p, v, a) in enumerate(particles):
        p = [sum(x) for x in zip(p, v)]
        v = [sum(x) for x in zip(v, a)]
        particles[i] = (p, v, a)
    t -= 1

distances = [manhattan_distance(*p) for p, v, a in particles]
closest = distances.index(min(distances))
print(closest)
",2
70,2017,21,1,syntax_error,,179,"  File ""/tmp/tmp74uqs90h/tmp.py"", line 27
    sub_grid = [''.join(sub_grid[r] for r in range(2)] for _ in range(3)]
                                                     ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import os
from itertools import product

def read_input(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
        rules = {}
        for line in lines:
            key, value = line.strip().split(' => ')
            key = key.split('/')
            value = value.split('/')
            for i in range(4):
                if i % 2 == 1:
                    key[i] = key[i][::-1]
            for i in range(4):
                key[i] = list(key[i])
            rules[tuple(key)] = value
        return rules

def enhance(grid, rules, size):
    new_grid = []
    if size % 2 == 0:
        for i in range(0, len(grid), 2):
            for j in range(0, len(grid), 2):
                sub_grid = [[grid[x][y] for y in range(j, j+2)] for x in range(i, i+2)]
                sub_grid = [''.join(sub_grid[r] for r in range(2)] for _ in range(3)]
                new_grid.extend(rules[tuple(sub_grid)])
            new_grid.append('.' * (len(sub_grid) + 2))
        new_grid = new_grid[:-1]
    else:
        for i in range(0, len(grid), 3):
            for j in range(0, len(grid), 3):
                sub_grid = [[grid[x][y] for y in range(j, j+3)] for x in range(i, i+3)]
                sub_grid = [''.join(sub_grid[r] for r in range(3)) for _ in range(4)]
                new_grid.extend(rules[tuple(sub_grid)])
            new_grid.append('.' * (len(sub_grid) + 1))
        new_grid = new_grid[:-1]
    return new_grid

def count_on(grid):
    return sum(1 for row in grid for pixel in row if pixel == '#')

def main():
    file_name = 'input.txt'
    rules = read_input(file_name)
    grid = ['.#.', '..#', '###']
    size = 3
    for _ in range(5):
        grid = enhance(grid, rules, size)
        size = len(grid)

    print(count_on(grid))

main()
",2
71,2017,22,1,wrong_output,"15
",5280,,"
import sys
import re
from collections import Counter

# Read input file
with open('input.txt', 'r') as f:
    grid = f.readlines()

infected_nodes = Counter()

# Get center of grid
center = len(grid) // 2
current_node = (center, center)
current_dir = 0 # up

# Initially infect center node
infected_nodes[current_node] += 1

# Number of bursts
bursts = 10000

# Direction vectors
directions = [(0, -1), (1, 0), (0, 1), (-1, 0)]

# Turn left
def turn_left(dir):
    return (dir - 1) % 4

# Turn right
def turn_right(dir):
    return (dir + 1) % 4

# Move one step in direction
def move_one_step(node, direction):
    return (node[0] + directions[direction][0], node[1] + directions[direction][1])

# Count infected nodes
def count_infected(nodes):
    return sum(1 for v in nodes.values() if v % 2 == 1)

for i in range(bursts):
    # Check current node status
    if current_node in infected_nodes:
        current_dir = turn_right(current_dir)
        infected_nodes[current_node] -= 1
    else:
        current_dir = turn_left(current_dir)
        infected_nodes[current_node] += 1

    # Move one step forward
    current_node = move_one_step(current_node, current_dir)

# Count infected nodes
print(count_infected(infected_nodes))
",2
72,2017,23,1,runtime_error,,6724,"Traceback (most recent call last):
  File ""/tmp/tmp_afi6d5n/tmp.py"", line 32, in <module>
    print(execute_program(program))
  File ""/tmp/tmp_afi6d5n/tmp.py"", line 25, in execute_program
    offset = process_instruction(program[i], registers)
  File ""/tmp/tmp_afi6d5n/tmp.py"", line 6, in process_instruction
    x, y = re.findall(r'\w+', instruction)
ValueError: too many values to unpack (expected 2)
","
import re

def process_instruction(instruction, registers):
    if instruction.startswith('set'):
        x, y = re.findall(r'\w+', instruction)
        registers[x] = int(y) if y.isnumeric() else registers[y]
    elif instruction.startswith('sub'):
        x, y = re.findall(r'\w+', instruction)
        registers[x] -= int(y) if y.isnumeric() else registers[y]
    elif instruction.startswith('mul'):
        registers['mul'] += 1
        x, y = re.findall(r'\w+', instruction)
        registers[x] *= int(y) if y.isnumeric() else registers[y]
    elif instruction.startswith('jnz'):
        x, y = re.findall(r'\w+', instruction)
        if int(x) if x.isnumeric() else registers[x] != 0:
            return int(y) if y.isnumeric() else registers[y]
    return 1

def execute_program(program):
    registers = {'a': 0, 'b': 0, 'c': 0, 'd': 0, 'e': 0, 'f': 0, 'g': 0, 'h': 0, 'mul': 0}
    i = 0
    while i < len(program):
        offset = process_instruction(program[i], registers)
        i += offset if offset else 1
    return registers['mul']

with open('input.txt', 'r') as f:
    program = [line.strip() for line in f.readlines()]

print(execute_program(program))
",2
73,2017,24,1,timeout_error,,2006,TIMEOUT,"
import itertools
import re

def load_components(filename):
    with open(filename, 'r') as file:
        components = file.readlines()
        return [tuple(map(int, re.findall(r'\d+', component.strip())) for component in components) for component in components]

def find_strongest_bridge(components, start_port=0):
    max_strength = 0
    for combination in itertools.permutations(components):
        strength = 0
        port = start_port
        for component in combination:
            if component[0] == port:
                strength += component[0] + component[1]
                port = component[1]
            elif component[1] == port:
                strength += component[1] + component[0]
                port = component[0]
        max_strength = max(max_strength, strength)
    return max_strength

def main():
    components = load_components('input.txt')
    print(find_strongest_bridge(components))

if __name__ == '__main__':
    main()
",2
74,2017,25,1,runtime_error,,2846,"Traceback (most recent call last):
  File ""/tmp/tmpxrchtce3/tmp.py"", line 40, in <module>
    diagnostic_checksum = execute_turing_machine(blueprint, diagnostic_checksum_steps)
  File ""/tmp/tmpxrchtce3/tmp.py"", line 22, in execute_turing_machine
    write_value, move_direction, next_state = states[state][value].values()
KeyError: 'A'
","
import re

def execute_turing_machine(blueprint, diagnostic_checksum_steps):
    # parse blueprint
    state_pattern = r""In state ([\w]):\s*If the current value is (\d):\s*- Write the value (\d).\s*- Move ([a-z]+) one slot.\s*- Continue with state ([\w]).""
    states = {}
    for state, value, write, direction, next_state in re.findall(state_pattern, blueprint):
        states[state] = {
            int(value): {
                'write': int(write),
                'direction': 1 if direction == 'right' else -1,
                'next_state': next_state
            }
        }

    cursor = 0
    tape = [0]
    state = 'A'
    for _ in range(diagnostic_checksum_steps):
        value = tape[cursor]
        write_value, move_direction, next_state = states[state][value].values()
        tape[cursor] = write_value
        cursor += move_direction
        if cursor < 0:
            tape.insert(0, 0)
            cursor = 0
        elif cursor >= len(tape):
            tape.append(0)
        state = next_state

    return tape.count(1)

# read input file
with open('input.txt', 'r') as f:
    blueprint = f.read()

diagnostic_checksum_steps = int(re.search(r""Perform a diagnostic checksum after (\d+) steps."", blueprint).group(1))

diagnostic_checksum = execute_turing_machine(blueprint, diagnostic_checksum_steps)
print(diagnostic_checksum)
",2
75,2018,1,1,no_error,"490
",490,,"
def calculate_frequency(filename):
    frequency = 0
    with open(filename, 'r') as file:
        for line in file:
            if line.startswith('+'):
                frequency += int(line[1:])
            elif line.startswith('-'):
                frequency -= int(line[1:])
    return frequency

filename = 'input.txt'
print(calculate_frequency(filename))
",2
76,2018,2,1,no_error,"7163
",7163,,"import re

# Read input file
with open(""input.txt"", ""r"") as file:
    input_data = file.readlines()

def checksum(ids):
    # Initialize counts
    two_count = 0
    three_count = 0

    # Iterate over each box ID
    for box_id in ids:
        # Find all unique letters and their counts
        letter_counts = {}
        for letter in box_id:
            if letter in letter_counts:
                letter_counts[letter] += 1
            else:
                letter_counts[letter] = 1

        # Check for any letters that appear exactly two or three times
        if 2 in letter_counts.values():
            two_count += 1
        if 3 in letter_counts.values():
            three_count += 1

    return two_count * three_count

# Count the checksum
print(checksum(input_data)) ",1
77,2018,3,1,wrong_output,"Number of overlapping inches: 109716
",109716,,"
import re
from collections import defaultdict

def count_overlapping_inches(claims):
    fabric = defaultdict(int)
    for claim in claims:
        claim_id, left, top, width, height = map(int, re.findall(r'\d+', claim))
        for x in range(left, left + width):
            for y in range(top, top + height):
                fabric[(x, y)] += 1

    count = 0
    for inches in fabric.values():
        if inches > 1:
            count += 1

    return count

def main():
    with open('input.txt', 'r') as f:
        claims = f.readlines()
    overlapping_inches = count_overlapping_inches(claims)
    print(""Number of overlapping inches:"", overlapping_inches)

if __name__ == ""__main__"":
    main()
",2
78,2018,4,1,no_error,"73646
",73646,,"
import re
from collections import defaultdict

# read input file
with open('input.txt', 'r') as file:
    lines = file.readlines()

# sort the lines by time
lines.sort(key=lambda x: x[:17])

# regex pattern to match the guard id
id_pattern = re.compile(r'#(\d+)')

# regex pattern to match the minute
minute_pattern = re.compile(r':(\d+)')

# store the sleeping time of each guard
guard_sleeping_time = defaultdict(int)

# store the minute at which the guard slept the most
guard_sleeping_minute = defaultdict(lambda: [0]*60)

# loop through the lines
for line in lines:
    # match the guard id
    id_match = id_pattern.search(line)
    if id_match:
        guard_id = int(id_match.group(1))

    # match the minute
    minute_match = minute_pattern.search(line)
    if minute_match:
        minute = int(minute_match.group(1))

    # check if the guard fell asleep
    if 'falls asleep' in line:
        start_sleep = minute

    # check if the guard woke up
    if 'wakes up' in line:
        end_sleep = minute
        # add the sleeping time of the guard
        guard_sleeping_time[guard_id] += end_sleep - start_sleep

        # update the minute the guard slept the most
        for i in range(start_sleep, end_sleep):
            guard_sleeping_minute[guard_id][i] += 1

# find guard with the most sleeping time
max_guard = max(guard_sleeping_time, key=guard_sleeping_time.get)

# find the minute the guard slept the most
max_minute = guard_sleeping_minute[max_guard].index(max(guard_sleeping_minute[max_guard]))

# print the result
print(max_guard * max_minute)
",1
79,2018,5,1,runtime_error,,9686,"Traceback (most recent call last):
  File ""/tmp/tmp40gri52k/tmp.py"", line 12, in <module>
    input_file = open(sys.argv[1], 'r')
IndexError: list index out of range
","
import re
import sys

def react_polymer(polymer):
    while True:
        polymer = re.sub(r'aA|Aa|bB|Bb|cC|Cc|dD|Dd|eE|Ee|fF|Ff|gG|Gg|hH|Hh|iI|Ii|jJ|Jj|kK|Kk|lL|Ll|mM|Mm|nN|Nn|oO|Oo|pP|Pp|qQ|Qq|rR|Rr|sS|Ss|tT|Tt|uU|Uu|vV|Vv|wW|Ww|xX|Xx|yY|Yy|zZ|Zz', '', polymer, flags=re.IGNORECASE)
        if len(polymer) == len(re.sub(r'aA|Aa|bB|Bb|cC|Cc|dD|Dd|eE|Ee|fF|Ff|gG|Gg|hH|Hh|iI|Ii|jJ|Jj|kK|Kk|lL|Ll|mM|Mm|nN|Nn|oO|Oo|pP|Pp|qQ|Qq|rR|Rr|sS|Ss|tT|Tt|uU|Uu|vV|Vv|wW|Ww|xX|Xx|yY|Yy|zZ|Zz', '', polymer, flags=re.IGNORECASE)):
            break
    return len(polymer)

input_file = open(sys.argv[1], 'r')
input_polymer = input_file.readline().strip()
input_file.close()

num_units = react_polymer(input_polymer)
print(num_units)
",2
80,2018,6,1,syntax_error,,3909,"  File ""/tmp/tmpgmg38yca/tmp.py"", line 32
    for x, y in itertools.product(range(min(c[0] for c in coords), max(c[0] for c in coords)), range(min(c[1] for c in coords), max(c[1] for c in coords)):
                                                                                                                                                          ^
SyntaxError: invalid syntax
","
import math
import itertools
import sys

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def generate_grid(coords):
    min_x = min(c[0] for c in coords)
    max_x = max(c[0] for c in coords)
    min_y = min(c[1] for c in coords)
    max_y = max(c[1] for c in coords)
    grid = {}
    for x in range(min_x, max_x + 1):
        for y in range(min_y, max_y + 1):
            closest = None
            min_dist = sys.maxsize
            for coord in coords:
                dist = manhattan_distance((x, y), coord)
                if dist < min_dist:
                    min_dist = dist
                    closest = coord
                elif dist == min_dist:
                    closest = None
            if closest:
                grid[(x, y)] = closest
    return grid

def calculate_area(grid, coords, coord):
    area = 0
    for x, y in itertools.product(range(min(c[0] for c in coords), max(c[0] for c in coords)), range(min(c[1] for c in coords), max(c[1] for c in coords)):
        if grid.get((x, y) == coord):
            area += 1
    return area

def largest_area(coords):
    grid = generate_grid(coords)
    areas = {coord: calculate_area(grid, coords, coord) for coord in coords}
    return max(areas.values())

def main():
    with open('input.txt', 'r') as f:
        coords = [tuple(map(int, line.strip().split(',')) for line in f.readlines())]
    print(""Largest area:"", largest_area(coords))

if __name__ == '__main__':
    main()
",2
81,2018,7,1,wrong_output,"ABCDEFGHIJKK LMNPP QRSL TUC F VS V WB E U XO YA H J M Y ZD I N Q T X Z 
",GKRVWBESYAMZDPTIUCFXQJLHNO,,"
import re
from collections import defaultdict

with open('input.txt', 'r') as f:
    data = f.readlines()

# create empty dependency dictionaries
depends_on = defaultdict(set)
depends_by = defaultdict(set)

# parse the input to populate the dictionaries
for line in data:
    match = re.match(r'Step\s([A-Z])\smust\sbe\sfinished\sbefore\sstep\s([A-Z]\s)*can\sbegin\.', line.strip())
    if match:
        before, after = match.groups()
        depends_on[after].add(before)
        depends_by[before].add(after)

# find the first steps
first_steps = set(depends_by.keys()) - set(depends_on.keys())
current_steps = sorted(first_steps)
completed_steps = set()

# create the order list
order = []

while first_steps:
    next_step = sorted(first_steps)[0]
    order.append(next_step)
    completed_steps.add(next_step)
    first_steps.remove(next_step)
    for step in depends_by[next_step]:
        if depends_on[step].issubset(completed_steps):
            first_steps.add(step)
    first_steps -= completed_steps

print(''.join(order))
",2
82,2018,8,1,runtime_error,,47244,"Traceback (most recent call last):
  File ""/tmp/tmpafiomfqh/tmp.py"", line 22, in <module>
    main()
  File ""/tmp/tmpafiomfqh/tmp.py"", line 17, in main
    input_data = list(map(int, open(sys.argv[1]).read().strip().split()))
IndexError: list index out of range
","
import sys

def process_node(data):
    num_children = data.pop(0)
    num_metadata = data.pop(0)
    metadata_sum = 0
    child_sum = 0
    for _ in range(num_children):
        child_sum, data = process_node(data)
        metadata_sum += child_sum
    for _ in range(num_metadata):
        metadata_sum += data.pop(0)
    return metadata_sum, data

def main():
    input_data = list(map(int, open(sys.argv[1]).read().strip().split()))
    metadata_sum, _ = process_node(input_data)
    print(f""Sum of all metadata entries: {metadata_sum}"")

if __name__ == ""__main__"":
    main()
",2
83,2018,9,1,runtime_error,,384288,"Traceback (most recent call last):
  File ""/tmp/tmpvwyib5oq/tmp.py"", line 21, in <module>
    players = int(f.readline().strip())
ValueError: invalid literal for int() with base 10: '455 players; last marble is worth 71223 points'
","
import sys
from collections import defaultdict

def game(players, last_marble):
    scores = defaultdict(int)
    circle = [0]
    current_marble = 0
    player = 0
    for marble in range(1, last_marble + 1):
        if marble % 23 == 0:
            current_marble = (current_marble - 7) % len(circle)
            scores[player] += marble + circle.pop(current_marble)
        else:
            current_marble = (current_marble + 2) % len(circle)
            circle.insert(current_marble, marble)
        player = (player + 1) % players
    return max(scores.values())

with open('input.txt', 'r') as f:
    players = int(f.readline().strip())
    last_marble = int(f.readline().strip())

print(game(players, last_marble))
",2
84,2018,10,1,wrong_output,"Seconds to wait:  10274
............#.......#..................................#....................#.....
..........................................#..##..............................#....
.......#.........#..##....#.......#.#............##.........................#.....
........#.........#......................................#........................
............#.......#......##..#......#......................#..###...............
...#.................#.#....#.....#.........#.............#.........#.............
......##.........#......#..#..#.#..##..#..#........#............#........###......
#...............................##..#...#....#..#.......#...#......#.#.....#.#....
..........#...................#.....##.#....#.#..#.......#........................
..............#.#.....##...........###..##....#....#....#.....#.....#.............
..................#..##.....#.#..#..........#.............#.##..#.#......###.#....
.......#....#.#.#....#......##...........#..#...##................................
............#...#....#..#...##.#............#...................#...#.............
........##..#...#.......#......#....#........#..#...#........#.......#....#.......
......#.........#.#...#..........#...#.#..#.........#..#...#..#.#............#....
...........#.#..........#......##........#....#.#....#...#....#....#......#..#....
#......#.#..#......#......#...##....#..#........#...........#..............#......
.................##......#.#....#.#...#......#.##...#........#.....#.#............
..#........#.#.#..#...............#.##..#.........#...#.......#....#..............
..........#.......#......#......###.......#.......#....#.....##...#.#.............
........#...#........#.##.....#...#.....###......#...#...#.......#.............#..
.......#........#...#..#.............#....#.#....#..........###......#.....#......
#..................###.#.....##......#..#...........#...##...............#....#...
.#..............#.....................#.#.......#....#.##........##..#....##.....#
..................##...#..#.....................#.........#.#....................#
.........................................#...#.......#........##...#........#.....
.....................#................#.........#.................................
.......#..........................................................................
..............#.....#...........#...#............##.................#.#...........
........#....#.....................#.....#........................................
",GFNKCGGH,,"
import re
import time

# Input file reading
with open('input.txt') as f:
    lines = f.readlines()

# Point class
class Point:
    def __init__(self, x, y, vx, vy):
        self.x = x
        self.y = y
        self.vx = vx
        self.vy = vy

    def move(self):
        self.x += self.vx
        self.y += self.vy

    def __str__(self):
        return f""position=<{self.x}, {self.y}> velocity=<{self.vx}, {self.vy}>""

# List of points initialization
points = []
for line in lines:
    x, y, vx, vy = map(int, re.findall(r'-?\d+', line))
    points.append(Point(x, y, vx, vy))

# Function to calculate the boundaries of the points
def boundaries(points):
    min_x = min(p.x for p in points)
    max_x = max(p.x for p in points)
    min_y = min(p.y for p in points)
    max_y = max(p.y for p in points)
    return min_x, max_x, min_y, max_y

# Function to print the points in a grid
def print_points(points):
    min_x, max_x, min_y, max_y = boundaries(points)
    grid = [['.' for _ in range(min_x, max_x+1)] for _ in range(min_y, max_y+1)]
    for p in points:
        grid[p.y-min_y][p.x-min_x] = '#'
    for row in grid:
        print(''.join(row))

# Function to find the message
def find_message(points):
    min_x, max_x, min_y, max_y = boundaries(points)
    prev_area = (max_x - min_x) * (max_y - min_y)
    seconds = 0
    while True:
        for p in points:
            p.move()
        new_min_x, new_max_x, new_min_y, new_max_y = boundaries(points)
        new_area = (new_max_x - new_min_x) * (new_max_y - new_min_y)
        if new_area > prev_area:
            for p in points:
                p.move()
            break
        prev_area = new_area
        seconds += 1
    return seconds

# Main code
print(""Seconds to wait: "", find_message(points))
print_points(points)
",2
85,2018,11,1,timeout_error,,"235,63",TIMEOUT,"
from itertools import product

def get_power_level(x, y, serial):
    rack_id = x + 10
    power = (rack_id * y + serial) * rack_id
    power = (power // 100 % 10) - 5
    return power

def get_square_power(grid, x, y):
    return sum(grid[y + i][x:x+3] + grid[y + i + 1][x:x+3] + grid[y + i + 2][x:x+3] for i in range(3))

def generate_grid(serial):
    return [[get_power_level(i, j, serial) for i in range(1, 301)] for j in range(1, 301)]

def max_square_power(grid):
    max_power = float('-inf')
    max_coords = None
    for x, y in product(range(1, 298), range(1, 298)):
        square_power = get_square_power(grid, x, y)
        if square_power > max_power:
            max_power = square_power
            max_coords = (x, y)
    return max_power, max_coords

serial = int(input())
grid = generate_grid(serial)
max_power, max_coords = max_square_power(grid)
print(f""{max_coords[0] - 1},{max_coords[1] - 1}"")
",2
86,2018,12,1,timeout_error,,4110,TIMEOUT,"
import re
import sys

# initialize patterns and pots
def initialize(initial_state):
    pots = initial_state.split("":"")[1].strip()
    patterns = {}
    for line in sys.stdin:
        pattern, outcome = re.findall(r""^([#.]{5}) => (#|.)"", line)
        patterns[pattern] = outcome
    return pots, patterns


def next_generation(pots, patterns):
    next_gen = """"
    for i in range(-2, len(pots) + 2):
        if i == -2:
            next_gen += "".""
        elif i == len(pots) + 1:
            next_gen += "".""
        elif i == -1:
            next_gen += pots[0]
        elif i == len(pots):
            next_gen += pots[-1]
        else:
            next_gen += patterns[pots[i-2:i+3]]
    return next_gen

def sum_pots(pots):
    pot_sum = 0
    for i, pot in enumerate(pots):
        if pot == ""#"":
            pot_sum += i
    return pot_sum

def main():
    initial_state = """"
    for line in sys.stdin:
        if ""initial state"" in line:
            initial_state = line.strip()
            break

    pots, patterns = initialize(initial_state)
    for _ in range(20):
        pots = next_generation(pots, patterns)

    print(sum_pots(pots))

if __name__ == ""__main__"":
    main()


def initialize(initial_state):
    pots = initial_state.split("":"")[1].strip()
    patterns = {}
    for line in sys.stdin:
        pattern, outcome = re.findall(r""^([#.]{5}) => (#|.)"", line)
        patterns[pattern] = outcome
    return pots, patterns

def next_generation(pots, patterns):
    next_gen = """"
    for i in range(-2, len(pots) + 2):
        if i == -2:
            next_gen += "".""
        elif i == len(pots) + 1:
            next_gen += "".""
        elif i == -1:
            next_gen += pots[0]
        elif i == len(pots):
            next_gen += pots[-1]
        else:
            next_gen += patterns[pots[i-2:i+3]]
    return next_gen

def sum_pots(pots):
    pot_sum = 0
    for i, pot in enumerate(pots):
        if pot == ""#"":
            pot_sum += i
    return pot_sum

def main():
    initial_state = """"
    for line in sys.stdin:
        if ""initial state"" in line:
            initial_state = line.strip()
            break

    pots, patterns = initialize(initial_state)
    for _ in range(20):
        pots = next_generation(pots, patterns)

    print(sum_pots(pots))

if __name__ == ""__main__"":
    main()
",2
87,2018,13,1,syntax_error,,"79,128","  File ""/tmp/tmp8y88n7ld/tmp.py"", line 54
    if cart[3] == 0:
    ^
SyntaxError: invalid syntax
","
import sys
import time
from collections import defaultdict

# Read input file
with open('input.txt', 'r') as file:
    input_data = file.read()

# Function to check if two carts are in the same position
def collision(cart1, cart2):
    return cart1[0] == cart2[0] and cart1[1] == cart2[1]

# Function to update cart direction
def update_dir(cart):
    if cart[2] == '^':
        return (cart[0], cart[1] - 1, '<' if cart[3] == 0 else '^' if cart[3] == 1 else '>' if cart[3] == 2 else 'v')
    elif cart[2] == 'v':
        return (cart[0], cart[1] + 1, '<' if cart[3] == 0 else 'v' if cart[3] == 1 else '>' if cart[3] == 2 else '^')
    elif cart[2] == '<':
        return (cart[0] - 1, cart[1], 'v' if cart[3] == 0 else '>' if cart[3] == 1 else '^' if cart[3] == 2 else '<')
    else:
        return (cart[0] + 1, cart[1], '^' if cart[3] == 0 else '<' if cart[3] == 1 else 'v' if cart[3] == 2 else '>')

# Function to update cart turn
def update_turn(cart):
    if cart[3] == 0:
        return cart[2], 1
    elif cart[3] == 1:
        return cart[2], 2
    elif cart[3] == 2:
        return cart[2], 0
    else:
        return cart[2], 1

# Function to move a cart
def move_cart(cart, track):
    if cart[2] == '^':
        if track[cart[1]-1][cart[0]] == '/':
            return (cart[0]-1, cart[1], '>', cart[3])
        elif track[cart[1]-1][cart[0]] == '\\':
            return (cart[0]+1, cart[1], '<', cart[3])
        else:
            return (cart[0], cart[1]-1, cart[2], cart[3] + 1)
    elif cart[2] == 'v':
        if track[cart[1]+1][cart[0]] == '/':
            return (cart[0]+1, cart[1], '<', cart[3])
        elif track[cart[1]+1][cart[0]] == '\\':
            return (cart[0]-1, cart[1], '>', cart[3])
        else:
            return (cart[0], cart[1]+1, cart[2], cart[3] + 1)
    elif cart[2] == '<':
        if track[cart[1][cart[0]-1] == '+':
            if cart[3] == 0:
                return (cart[0], cart[1], '^', 1)
            elif cart[3] == 1:
                return (cart[0]-1, cart[1], '-', 2)
            else:
                return (cart[0], cart[1], 'v', 0)
        else:
            return (cart[0]-1, cart[1], cart[2], cart[3])
    else:
        if track[cart[1][cart[0]+1] == '+':
            if cart[3] == 0:
                return (cart[0], cart[1], 'v', 1)
            elif cart[3] == 1:
                return (cart[0]+1, cart[1], '|', 2)
            else:
                return (cart[0], cart[1], '^', 0)
        else:
            return (cart[0]+1, cart[1], cart[2], cart[3])

# Function to check if a cart has crashed
def check_crash(carts):
    for i in range(len(carts)):
        for j in range(i+1, len(carts)):
            if collision(carts[i], carts[j]):
                return True, (carts[i][0], carts[i][1])
    return False, None

# Create dictionary to store tracks
tracks = defaultdict(str)

# Parse input to create track grid and carts
carts = []
for y, line in enumerate(input_data.split('\n')):
    for x, char in enumerate(line):
        if char in 'v<^>':
            carts.append((x, y, char, 0))
            if char == '^':
                tracks[y][x] = '|'
            elif char == 'v':
                tracks[y][x] = '|'
            elif char == '<':
                tracks[y][x] = '-'
            else:
                tracks[y][x] = '-'
        elif char in '|-/\\':
            tracks[y][x] = char

# Run simulation
tick = 0
while True:
    tick += 1
    for i in range(len(carts)):
        carts[i] = move_cart(carts[i], tracks)
        carts[i] = update_dir(carts[i])
        carts[i] = update_turn(carts[i])

        crash, pos = check_crash(carts)
        if crash:
            print(f""The first crash happened at {pos[0]},{pos[1]} on tick {tick}"")
            sys.exit(0)

    carts.sort()
",2
88,2018,14,1,no_error,"9411137133
",9411137133,,"
from typing import List
import re
from collections import deque

def generate_recipes(n: int) -> List[int]:
    scoreboard = [3, 7]
    elf1 = 0
    elf2 = 1
    while len(scoreboard) < n + 10:
        new_recipe_sum = int(scoreboard[elf1]) + int(scoreboard[elf2])
        for digit in str(new_recipe_sum):
            scoreboard.append(int(digit))
        elf1 = (elf1 + 1 + int(scoreboard[elf1])) % len(scoreboard)
        elf2 = (elf2 + 1 + int(scoreboard[elf2])) % len(scoreboard)
    return scoreboard[-10:]

def main():
    with open('input.txt', 'r') as file:
        n = int(file.read().strip())
    result = generate_recipes(n)
    print("""".join(map(str, result))[:10])

if __name__ == ""__main__"":
    main()
",2
89,2018,15,1,syntax_error,,201638,"  File ""/tmp/tmpx12g5q75/tmp.py"", line 56
    min_hp = min([int(board[target[0]) for target in targets_in_range])
                                     ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys
from queue import PriorityQueue

def read_input(file_name):
    with open(file_name, ""r"") as f:
        lines = f.readlines()
    return [line.strip() for line in lines]

def find_targets(board, unit_pos, targets, unit_type):
    targets_in_range = []
    adjacent_squares = [(unit_pos[0]-1, unit_pos[1]), (unit_pos[0]+1, unit_pos[1]), (unit_pos[0], unit_pos[1]-1), (unit_pos[0], unit_pos[1]+1)]
    for square in adjacent_squares:
        if 0 <= square[0] < len(board) and 0 <= square[1] < len(board[0]) and board[square[0]][square[1]] in targets:
            if board[square[0]][square[1]].isupper() != board[unit_pos[0]][unit_pos[1]].isupper():
                targets_in_range.append(square)
    return targets_in_range

def find_reachable_squares(board, unit_pos, targets_in_range):
    reachable_squares = []
    for target in targets_in_range:
        if board[target[0]][target[1]] == ""."":
            reachable_squares.append(target)
    return reachable_squares

def find_nearest_square(board, unit_pos, reachable_squares):
    visited = set()
    queue = PriorityQueue()
    queue.put((0, unit_pos))
    while not queue.empty():
        dist, curr_pos = queue.get()
        if curr_pos in visited:
            continue
        visited.add(curr_pos)
        if curr_pos in reachable_squares:
            return curr_pos
        for adj_square in [(curr_pos[0]-1, curr_pos[1]), (curr_pos[0]+1, curr_pos[1]), (curr_pos[0], curr_pos[1]-1), (curr_pos[0], curr_pos[1]+1)]:
            if 0 <= adj_square[0] < len(board) and 0 <= adj_square[1] < len(board[0]) and board[adj_square[0]][adj_square[1]] == ""."" and adj_square not in visited:
                queue.put((dist+1, adj_square))

def move_unit(board, unit_pos, targets_in_range, reachable_squares, nearest_square):
    board[unit_pos[0]][unit_pos[1]] = "".""
    board[nearest_square[0]][nearest_square[1]] = board[unit_pos[0]][unit_pos[1]]
    unit_pos = nearest_square
    return unit_pos

def attack(board, unit_pos, targets, unit_type):
    adjacent_squares = [(unit_pos[0]-1, unit_pos[1]), (unit_pos[0]+1, unit_pos[1]), (unit_pos[0], unit_pos[1]-1), (unit_pos[0], unit_pos[1]+1)]
    targets_in_range = []
    for square in adjacent_squares:
        if 0 <= square[0] < len(board) and 0 <= square[1] < len(board[0]) and board[square[0]][square[1]] in targets:
            if board[square[0]][square[1]].isupper() != board[unit_pos[0]][unit_pos[1]].isupper():
                targets_in_range.append(square)
    if not targets_in_range:
        return None
    min_hp = min([int(board[target[0]) for target in targets_in_range])
    targets_with_min_hp = [target for target in targets_in_range if int(board[target[0]) == min_hp] and int(board[target[1]) == min(int(board[target[1]) for target in targets_in_range if int(board[target[0]) == min_hp)]]
    target_to_attack = sorted(targets_with_min_hp)[0]
    if unit_type == ""E"":
        board[target_to_attack[0]][target_to_attack[1]] = ""E("" + str(int(board[target_to_attack[0][1:]) - 3)
    else:
        board[target_to_attack[0]][target_to_attack[1]] = ""G("" + str(int(board[target_to_attack[0][1:]) - 3)
    if int(board[target_to_attack[0][1:]) <= 0:
        board[target_to_attack[0]][target_to_attack[1]] = "".""
    return target_to_attack

def count_elves(board):
    return sum(1 for row in board for square in row if square.isupper() and square == ""E"")

def count_goblins(board):
    return sum(1 for row in board for square in row if square.isupper() and square == ""G"")

def combat(board, elf_attack_power=3):
    rounds = 0
    elf_count = count_elves(board)
    while count_elves(board) > 0 and count_goblins(board) > 0:
        units = sorted([(i, j) for i in range(len(board)) for j in range(len(board[0]) if board[i][j].isupper()])
        for unit_pos in units:
            if board[unit_pos[0]][unit_pos[1]].isupper():
                targets = ""GE"" if board[unit_pos[0]][unit_pos[1]] == ""E"" else ""EG""
                targets_in_range = find_targets(board, unit_pos, targets)
                if not targets_in_range:
                    continue
                reachable_squares = find_reachable_squares(board, unit_pos, targets_in_range)
                if not reachable_squares:
                    continue
                nearest_square = find_nearest_square(board, unit_pos, reachable_squares)
                if nearest_square:
                    unit_pos = move_unit(board, unit_pos, targets_in_range, reachable_squares, nearest_square)
                target_attacked = attack(board, unit_pos, targets, board[unit_pos[0]][unit_pos[1]])
                if target_attacked:
                    if board[target_attacked[0]][target_attacked[1]] == ""."":
                        break
        rounds += 1
    return rounds * sum(int(square[1:]) for row in board for square in row if square.isnumeric())

def main():
    file_name = ""input.txt""
    input_board = read_input(file_name)
    elf_attack_power = 3
    while True:
        outcome = combat(input_board, elf_attack_power)
        elf_count = count_elves(input_board)
        if elf_count == elf_count:
            break
        else:
            elf_attack_power += 1
    print(outcome)

if __name__ == ""__main__"":
    main()
",2
90,2018,16,1,no_error,"642
",642,,"
import re
from collections import defaultdict

# Sample Input
# Before: [1, 2, 3, 4]
# 9 2 3 4
# After:  [1, 2, 3, 4]

# 9 3 4 5
# After: [1, 2, 3, 5]

# 9 1 2 3
# After: [1, 3, 4, 3]

# 9 1 1 3
# After: [2, 3, 4, 3]

# 9 3 1 4
# After: [1, 2, 4, 3]

# 9 1 4 3
# After: [1, 2, 5, 3]

# 9 1 5 3
# After: [1, 3, 3, 3]

# 9 2 4 3
# After: [1, 2, 3, 4]

# 9 1 3 4
# After: [2, 3, 4, 3]

# 9 4 2 4
# After: [1, 2, 3, 4]

samples = []
with open('input.txt') as file:
    for line in file:
        line = line.strip()
        if line.startswith('Before'):
            match = re.search(r'\[(\d+), (\d+), (\d+), (\d+)\]', line)
            before = [int(match.group(1)), int(match.group(2)), int(match.group(3)), int(match.group(4))]
            line = file.readline().strip()
            match = re.search(r'(\d+) (\d+) (\d+) (\d+)', line)
            op, a, b, c = map(int, match.groups())
            line = file.readline().strip()
            match = re.search(r'\[(\d+), (\d+), (\d+), (\d+)\]', line)
            after = [int(match.group(1)), int(match.group(2)), int(match.group(3)), int(match.group(4))]
            samples.append((before, op, a, b, c, after))

def addr(a, b, c, reg):
    reg[c] = reg[a] + reg[b]

def addi(a, b, c, reg):
    reg[c] = reg[a] + b

def mulr(a, b, c, reg):
    reg[c] = reg[a] * reg[b]

def muli(a, b, c, reg):
    reg[c] = reg[a] * b

def banr(a, b, c, reg):
    reg[c] = reg[a] & reg[b]

def bani(a, b, c, reg):
    reg[c] = reg[a] & b

def borr(a, b, c, reg):
    reg[c] = reg[a] | reg[b]

def bori(a, b, c, reg):
    reg[c] = reg[a] | b

def setr(a, b, c, reg):
    reg[c] = reg[a]

def seti(a, b, c, reg):
    reg[c] = a

def gtir(a, b, c, reg):
    reg[c] = int(a > reg[b])

def gtri(a, b, c, reg):
    reg[c] = int(reg[a] > b)

def gtrr(a, b, c, reg):
    reg[c] = int(reg[a] > reg[b])

def eqir(a, b, c, reg):
    reg[c] = int(a == reg[b])

def eqri(a, b, c, reg):
    reg[c] = int(reg[a] == b)

def eqrr(a, b, c, reg):
    reg[c] = int(reg[a] == reg[b])

def execute(op, a, b, c, reg):
    if op == 0:
        addr(a, b, c, reg)
    elif op == 1:
        addi(a, b, c, reg)
    elif op == 2:
        mulr(a, b, c, reg)
    elif op == 3:
        muli(a, b, c, reg)
    elif op == 4:
        banr(a, b, c, reg)
    elif op == 5:
        bani(a, b, c, reg)
    elif op == 6:
        borr(a, b, c, reg)
    elif op == 7:
        bori(a, b, c, reg)
    elif op == 8:
        setr(a, b, c, reg)
    elif op == 9:
        seti(a, b, c, reg)
    elif op == 10:
        gtir(a, b, c, reg)
    elif op == 11:
        gtri(a, b, c, reg)
    elif op == 12:
        gtrr(a, b, c, reg)
    elif op == 13:
        eqir(a, b, c, reg)
    elif op == 14:
        eqri(a, b, c, reg)
    elif op == 15:
        eqrr(a, b, c, reg)

count = 0
for before, op, a, b, c, after in samples:
    matches = 0
    for i in range(16):
        reg = before.copy()
        execute(i, a, b, c, reg)
        if reg == after:
            matches += 1
    if matches >= 3:
        count += 1

print(count)
",0
91,2018,17,1,runtime_error,,31788,"Traceback (most recent call last):
  File ""/tmp/tmpy59k99yv/tmp.py"", line 101, in <module>
    main()
  File ""/tmp/tmpy59k99yv/tmp.py"", line 96, in main
    clay = parse_input('input.txt')
  File ""/tmp/tmpy59k99yv/tmp.py"", line 88, in parse_input
    x_range, y_range = re.findall(r'(\d+)\D+(\d+)\D+(\d+)\D+(\d+)', line)
ValueError: not enough values to unpack (expected 2, got 0)
","
import re

# Helper function to check if a point is inside the clay
def is_inside_clay(x, y, clay):
    return (x, y) in clay

# Helper function to check if a point is sand
def is_sand(x, y, sand):
    return (x, y) in sand

# Helper function to check if a point is below the bottom row of clay
def below_bottom_row(y, bottom_row):
    return y > bottom_row

# Helper function to check if a point is above the top row of clay
def above_top_row(y, top_row):
    return y < top_row

# Helper function to check if a point is outside the leftmost and rightmost columns of clay
def outside_columns(x, leftmost_col, rightmost_col):
    return x < leftmost_col or x > rightmost_col

# Function to simulate the water flow
def simulate_water_flow(clay, x, y):
    sand = set()
    settled_water = set()
    moving_water = set()
    bottom_row = min(clay, key=lambda x: x[1])[1]
    top_row = max(clay, key=lambda x: x[1])[1]
    leftmost_col = min(clay, key=lambda x: x[0])[0]
    rightmost_col = max(clay, key=lambda x: x[0])[0]
    
    # Add water spring
    moving_water.add((500, 0))
    
    while moving_water:
        moving_water_cpy = set(moving_water)
        for (x, y) in moving_water_cpy:
            moving_water.remove((x, y))
            
            # Check if the point is below the bottom row of clay
            if not below_bottom_row(y, bottom_row):
                continue
            
            # Check if the point is above the top row of clay
            if not above_top_row(y, top_row):
                continue
            
            # Check if the point is outside the leftmost and rightmost columns of clay
            if outside_columns(x, leftmost_col, rightmost_col):
                continue
            
            # Check if the point is sand
            if is_sand(x, y, sand):
                sand.add((x, y))
                continue
            
            # Check if the point is clay
            if is_inside_clay(x, y, clay):
                # Check if the point is already settled
                if (x, y) in settled_water:
                    continue
                
                # If the point is not settled, add it to settled_water
                settled_water.add((x, y))
                
                # Check if the point is at the edge of the clay
                if not is_inside_clay(x+1, y, clay) and is_sand(x+1, y, sand):
                    moving_water.add((x+1, y))
                
                if not is_inside_clay(x-1, y, clay) and is_sand(x-1, y):
                    moving_water.add((x-1, y))
                
                if not is_inside_clay(x, y+1, clay) and is_sand(x, y+1):
                    moving_water.add((x, y+1))
            else:
                # Add the point to sand
                sand.add((x, y))
    
    return sand, settled_water

# Function to parse the input file
def parse_input(filename):
    clay = set()
    with open(filename, 'r') as f:
        for line in f:
            x_range, y_range = re.findall(r'(\d+)\D+(\d+)\D+(\d+)\D+(\d+)', line)
            for x in range(int(x_range[0]), int(x_range[1])+1):
                for y in range(int(y_range[0]), int(y_range[1])+1):
                    clay.add((x, y))
    return clay

# Main function
def main():
    clay = parse_input('input.txt')
    sand, settled_water = simulate_water_flow(clay, 500, 0)
    print(len(settled_water) + len(sand))

if __name__ == '__main__':
    main()
",2
92,2018,18,1,syntax_error,,653184,"  File ""/tmp/tmpao9rjk9u/tmp.py"", line 22
    new_acre_map = [['.' for _ in range(len(acre_map[0])] for _ in range(len(acre_map))]
                                                        ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
from collections import Counter

def next_state(acre):
    if acre == '.':
        return '|' if Counter([neighbor for neighbor in get_neighbors(acre_map, x, y)]).get('|', 0) >= 3 else '.'
    elif acre == '|':
        return '#' if Counter([neighbor for neighbor in get_neighbors(acre_map, x, y)].values()).get('#', 0) >= 3 else '|'
    else:
        return '#' if Counter([neighbor for neighbor in get_neighbors(acre_map, x, y)].values()).get('#', 0) >= 1 and Counter([neighbor for neighbor in get_neighbors(acre_map, x, y)].values()).get('|', 0) >= 1 else '.'

def get_neighbors(acre_map, x, y):
    directions = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1)]
    neighbors = []
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(acre_map) and 0 <= ny < len(acre_map[0]):
            neighbors.append(acre_map[nx][ny])
    return neighbors

def simulate(acre_map):
    new_acre_map = [['.' for _ in range(len(acre_map[0])] for _ in range(len(acre_map))]
    for y in range(len(acre_map)):
        for x in range(len(acre_map[0]):
            new_acre_map[y][x] = next_state(acre_map[y][x])
    return new_acre_map

def count_acres(acre_map):
    return Counter(acre for row in acre_map for acre in row).get('|', 0), Counter(acre for row in acre_map for acre in row).get('#', 0)

def main():
    with open('input.txt') as f:
        acre_map = [list(line.strip()) for line in f.readlines()]
    for minute in range(1, 11):
        acre_map = simulate(acre_map)
        wooded, lumberyards = count_acres(acre_map)
        print(f'After {minute} minutes: {wooded} wooded acres, {lumberyards} lumberyards')
    print(f'Total resource value after 10 minutes: {wooded * lumberyards}')

if __name__ == '__main__':
    main()
",2
93,2018,19,1,syntax_error,,2520,"  File ""/tmp/tmpz6t1ct06/tmp.py"", line 35
    registers[int(instruction[3])] = 1 if registers[int(instruction[1]) == int(instruction[2]) else 0
                                                                                               ^
SyntaxError: invalid syntax
","
import re

# Function to execute instructions
def execute_instruction(instruction, registers):
    if instruction[0] == 'addr':
        registers[int(instruction[3])] = registers[int(instruction[1])] + registers[int(instruction[2])]
    elif instruction[0] == 'addi':
        registers[int(instruction[3])] = registers[int(instruction[1])] + int(instruction[2])
    elif instruction[0] == 'mulr':
        registers[int(instruction[3])] = registers[int(instruction[1])] * registers[int(instruction[2])]
    elif instruction[0] == 'muli':
        registers[int(instruction[3])] = registers[int(instruction[1])] * int(instruction[2])
    elif instruction[0] == 'banr':
        registers[int(instruction[3])] = registers[int(instruction[1])] & registers[int(instruction[2])]
    elif instruction[0] == 'bani':
        registers[int(instruction[3])] = registers[int(instruction[1])] & int(instruction[2])
    elif instruction[0] == 'borr':
        registers[int(instruction[3])] = registers[int(instruction[1])] | registers[int(instruction[2])]
    elif instruction[0] == 'bori':
        registers[int(instruction[3])] = registers[int(instruction[1])] | int(instruction[2])
    elif instruction[0] == 'setr':
        registers[int(instruction[3])] = registers[int(instruction[1])]
    elif instruction[0] == 'seti':
        registers[int(instruction[3])] = int(instruction[1])
    elif instruction[0] == 'gtir':
        registers[int(instruction[3])] = 1 if int(instruction[1]) > registers[int(instruction[2])] else 0
    elif instruction[0] == 'gtri':
        registers[int(instruction[3])] = 1 if registers[int(instruction[1])] > int(instruction[2]) else 0
    elif instruction[0] == 'gtrr':
        registers[int(instruction[3])] = 1 if registers[int(instruction[1])] > registers[int(instruction[2])] else 0
    elif instruction[0] == 'eqir':
        registers[int(instruction[3])] = 1 if int(instruction[1]) == registers[int(instruction[2])] else 0
    elif instruction[0] == 'eqri':
        registers[int(instruction[3])] = 1 if registers[int(instruction[1]) == int(instruction[2]) else 0
    elif instruction[0] == 'eqrr':
        registers[int(instruction[3])] = 1 if registers[int(instruction[1])] == registers[int(instruction[2])] else 0

# Read input file
with open('input.txt', 'r') as f:
    lines = f.readlines()

# Initialize registers and IP register
registers = [0, 0, 0, 0, 0, 0, 0]
ip_register = int(re.search(r'#ip (\d)', lines[0]).group(1))

# Iterate through the instructions
line_number = 0
while line_number < len(lines):
    # Parse instruction
    instruction = lines[line_number + 1].strip().split()
    # Update IP register
    registers[ip_register] = line_number
    # Execute instruction
    execute_instruction(instruction, registers)
    # Print the current state of registers
    print(f""ip={line_number} [{registers[0], registers[1], registers[2], registers[3], registers[4], registers[5]} {instruction} {registers}"")
    # Update line number
    line_number = registers[ip_register] + 1

# What value is left in register 0 when the background process halts?
print(f""Register 0: {registers[0]}"")
",2
94,2018,20,1,runtime_error,,4432,"Traceback (most recent call last):
  File ""/tmp/tmpg800o5v7/tmp.py"", line 71, in <module>
    print(f""Furthest room requires passing {process_branch(regex)} doors"")
NameError: name 'process_branch' is not defined
","
import re
import math

def generate_map(regex):
    def process_regex(regex):
        map_list = [['.|.' for _ in range(len(regex))] for _ in range(len(regex))]
        x, y = 0, 0
        facing = 0
        for i, char in enumerate(regex):
            if char in 'NSEW':
                if char == 'N':
                    map_list[y - 1][x] = '#'
                    y -= 1
                elif char == 'S':
                    map_list[y + 1][x] = '#'
                    y += 1
                elif char == 'E':
                    map_list[y][x + 1] = '#'
                    x += 1
                elif char == 'W':
                    map_list[y][x - 1] = '#'
                    x -= 1
                map_list[y][x] = 'X'
            elif char == '(':
                pass
            elif char == '|':
                pass
            elif char == ')':
                pass
            elif char == '^':
                pass
            elif char == '$':
                pass
            elif char == '|':
                pass
            else:
                return None, None, None
        return map_list, x, y

    def find_furthest_room(map_list, x, y):
        max_distance = 0
        for i in range(len(map_list)):
            for j in range(len(map_list[0])):
                if map_list[i][j] == '.|.':
                    distance = abs(x - i) + abs(y - j)
                    max_distance = max(max_distance, distance)
        return max_distance

    def process_branch(regex):
        if '(' not in regex:
            map_list, x, y = process_regex(regex)
            return find_furthest_room(map_list, x, y)
        else:
            stack = []
            for i, char in enumerate(regex):
                if char == '(':
                    stack.append(i)
                elif char == ')':
                    start = stack.pop()
                    if not stack:
                        branch_regex = regex[start + 1:i]
                        map_list, x, y = process_regex(branch_regex)
                        max_distance = find_furthest_room(map_list, x, y)
                        return max(max_distance, process_branch(regex[:start] + '|' + regex[i + 1:]))

    return process_branch(regex[1:-1])

with open('input.txt', 'r') as f:
    regex = f.read().strip()
    print(f""Furthest room requires passing {process_branch(regex)} doors"")
",2
95,2018,21,1,wrong_output,,2159153,,"
import re

def bani(reg, a, b):
    reg[a] = reg[a] & b

def bori(reg, a, b, c):
    reg[a] = reg[a] | b

def borr(reg, a, b, c):
    reg[a] = reg[a] | reg[b]

def eqrr(reg, a, b, c):
    reg[c] = 1 if reg[a] == reg[b] else 0

def gtir(reg, a, b, c):
    reg[c] = 1 if a > reg[b] else 0

def gtri(reg, a, b, c):
    reg[c] = 1 if reg[a] > b else 0

def gtrr(reg, a, b, c):
    reg[c] = 1 if reg[a] > reg[b] else 0

def setr(reg, a, b, c):
    reg[c] = reg[a]

def seti(reg, a, b, c):
    reg[c] = a

def mulr(reg, a, b, c):
    reg[c] = reg[a] * reg[b]

def muli(reg, a, b, c):
    reg[c] = reg[a] * b

def addr(reg, a, b, c):
    reg[c] = reg[a] + reg[b]

def addi(reg, a, b, c):
    reg[c] = reg[a] + b
",2
96,2018,22,1,wrong_output,"116
",11972,,"
import math
import sys

depth = 510
target = [10, 10]

def geologic_index(x, y):
    if x == y == 0:
        return 0
    elif x == 0:
        return y * 48271
    elif y == 0:
        return x * 16807
    else:
        return erosion_level(x-1, y) * erosion_level(x, y-1)

def erosion_level(x, y):
    return (geologic_index(x, y) + depth) % 20183

def risk_level(x, y):
    return erosion_level(x, y) % 3

def main():
    risk = 0
    for x in range(target[0] + 1):
        for y in range(target[1] + 1):
            risk += risk_level(x, y)
    print(risk)

if __name__ == ""__main__"":
    main()
",2
97,2018,23,1,runtime_error,,270,"Traceback (most recent call last):
  File ""/tmp/tmp58qlqpt6/tmp.py"", line 11, in <module>
    pos, r = re.findall(r'pos=<(-?\d+),(-?\d+),(-?\d+)>, r=(\d+)', line.strip())
ValueError: not enough values to unpack (expected 2, got 1)
","
import re
import math

def manhattan_distance(p1, p2):
    return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1]) + abs(p1[2]-p2[2])

nanobots = []
with open('input.txt', 'r') as file:
    for line in file:
        pos, r = re.findall(r'pos=<(-?\d+),(-?\d+),(-?\d+)>, r=(\d+)', line.strip())
        pos = (int(pos[0]), int(pos[1]), int(pos[2]))
        r = int(r)
        nanobots.append((pos, r))

strongest_nanobot = max(nanobots, key=lambda x: x[1])

in_range_count = 0
for bot in nanobots:
    if manhattan_distance(strongest_nanobot[0], bot[0]) <= strongest_nanobot[1]:
        in_range_count += 1

print(in_range_count)
",2
98,2018,24,1,runtime_error,,14377,"Traceback (most recent call last):
  File ""/tmp/tmp7q7ua4yn/tmp.py"", line 28, in <module>
    main()
  File ""/tmp/tmp7q7ua4yn/tmp.py"", line 23, in main
    immune, infect = parse_input(sys.argv[1])
IndexError: list index out of range
","
import re
import sys
from typing import List, Tuple

def parse_input(filename: str) -> Tuple[List[str], List[str]]:
    immune, infect = [], []
    current_army = immune
    with open(filename, 'r') as f:
        for line in f:
            if line.startswith('Immune'):
                current_army = immune
            elif line.startswith('Infection'):
                current_army = infect
            else:
                current_army.append(line.strip())
    return immune, infect

def process_input(immune: List[str], infect: List[str]) -> Tuple[int, int]:
    pass

def main():
    immune, infect = parse_input(sys.argv[1])
    immune_units, infect_units = process_input(immune, infect)
    print(f""The winning army has {immune_units + infect_units} units"")

if __name__ == ""__main__"":
    main()
",2
99,2018,25,1,syntax_error,,363,"  File ""/tmp/tmpk56wsoh9/tmp.py"", line 25
    fixed_points = [tuple(map(int, line.strip().split(',')) for line in open('input.txt').readlines()]
                                                                                                     ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
from itertools import combinations
from math import sqrt

def is_close(p1, p2):
    return sqrt(sum([(a - b) ** 2 for a, b in zip(p1, p2)])) <= 3

def merge_constellations(constellations, p):
    for constellation in constellations:
        if any(is_close(p, point) for point in constellation):
            constellation.add(p)
            return True
    return False

def find_constellations(fixed_points):
    constellations = []
    for point in fixed_points:
        if not merge_constellations(constellations, point):
            constellations.append({point})
    return constellations

def count_constellations(fixed_points):
    return len(find_constellations(fixed_points))

fixed_points = [tuple(map(int, line.strip().split(',')) for line in open('input.txt').readlines()]
print(count_constellations(fixed_points))
",2
100,2019,1,1,no_error,"3336439
",3336439,,"import math

def calculate_fuel(mass):
    """"""
    This function calculates the fuel required for a given mass.

    Args:
    mass (int): The mass of a module.

    Returns:
    int: The required fuel for the given mass.

    """"""
    return math.floor(mass / 3) - 2

def total_fuel(filename):
    """"""
    This function calculates the total fuel required for all the modules on the spacecraft.

    Args:
    filename (str): The name of the file containing the input data.

    Returns:
    int: The total fuel required for all the modules.

    """"""
    total_fuel_required = 0
    with open(filename, 'r') as file:
        for line in file:
            mass = int(line.strip())
            fuel = calculate_fuel(mass)
            total_fuel_required += fuel
    return total_fuel_required

# Replace 'input.txt' with the filename containing the input data
print(total_fuel('input.txt')) ",1
101,2019,2,1,syntax_error,,4138658,"  File ""/tmp/tmpa6sa41mu/tmp.py"", line 13
    index += 4
    ^
SyntaxError: invalid syntax
","
import sys

def intcode_computer(intcode):
    index = 0
    while True:
        opcode = intcode[index]
        if opcode == 1:
            intcode[intcode[index+3]] = intcode[intcode[index+1]] + intcode[intcode[index+2]]
            index += 4
        elif opcode == 2:
            intcode[intcode[index+3]] = intcode[intcode[index+1] * intcode[index+2]
            index += 4
        elif opcode == 99:
            break
        else:
            sys.exit(""Invalid opcode"")
    return intcode[0]

with open(""input.txt"", ""r"") as file:
    input_file = file.readline().strip().split("","")
    intcode = [int(num) for num in input_file]
    intcode[1] = 12
    intcode[2] = 2
    result = intcode_computer(intcode)
    print(result)
",2
102,2019,3,1,no_error,"248
",248,,"
import re
from collections import defaultdict

# Read the input file
with open('input.txt', 'r') as file:
    wires = [line.strip() for line in file.readlines()]

# Define a function to convert the wire instructions to a set of coordinates
def get_coords(instructions):
    x, y, coords = 0, 0, set()
    for instruction in instructions.split(','):
        direction = instruction[0]
        distance = int(instruction[1:])
        for _ in range(distance):
            if direction == 'R':
                x += 1
            elif direction == 'L':
                x -= 1
            elif direction == 'U':
                y += 1
            elif direction == 'D':
                y -= 1
            coords.add((x, y))
    return coords

# Convert the instructions to sets of coordinates for each wire
wire_coords = [get_coords(wire) for wire in wires]

# Find the intersection points and calculate their Manhattan distance
intersections = wire_coords[0].intersection(wire_coords[1])
distances = [abs(x) + abs(y) for x, y in intersections]

# Print the shortest distance
print(min(distances))
",1
103,2019,4,1,timeout_error,,454,TIMEOUT,"
def check_password_criteria(password):
    if len(password) != 6:
        return False
    for i in range(len(password)-1):
        if int(password[i+1]) < int(password[i]):
            return False
        if password[i] == password[i+1] and i != len(password)-2:
            return True
        elif password[i] != password[i+1] and i == len(password)-2:
            return False
    return password[0] != password[1]

def find_passwords(range_start, range_end):
    valid_passwords = []
    for i in range(range_start, range_end+1):
        password = str(i)
        if check_password_criteria(password):
            valid_passwords.append(password)
    return valid_passwords

def main():
    # Read input from file
    with open('input.txt', 'r') as file:
        input_range = file.read().strip().split('-')
        range_start = int(input_range[0])
        range_end = int(input_range[1])

    # Find valid passwords in the given range
    valid_passwords = find_passwords(range_start, range_end)
    print(f""There are {len(valid_passwords)} valid passwords in the range {range_start} - {range_end}."")
    print(""Valid passwords are:"", valid_passwords)

if __name__ == ""__main__"":
    main()
",2
104,2019,5,1,runtime_error,,6069343,"Traceback (most recent call last):
  File ""/tmp/tmpj6yhzt4s/tmp.py"", line 78, in <module>
    run_program(memory, input_val)
  File ""/tmp/tmpj6yhzt4s/tmp.py"", line 73, in run_program
    ip = process_instruction(memory, ip, input_val)
  File ""/tmp/tmpj6yhzt4s/tmp.py"", line 18, in process_instruction
    a, b, c = memory[ip+1:ip+4]
TypeError: unhashable type: 'slice'
","
import sys
from collections import defaultdict

def parse_input(input_file):
    with open(input_file, 'r') as f:
        data = [int(n) for n in f.read().strip().split(',')]
    return defaultdict(int, enumerate(data))

def process_instruction(memory, ip, input_val):
    opcode = memory[ip] % 100
    modes = [0, 0, 0]
    
    for i in range(3):
        modes[i] = (memory[ip] // (10 ** (i + 1)) % 10)
    
    if opcode == 1:
        a, b, c = memory[ip+1:ip+4]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        memory[c] = a + b
        ip += 4
    elif opcode == 2:
        a, b, c = memory[ip+1:ip+4]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        memory[c] = a * b
        ip += 4
    elif opcode == 3:
        memory[memory[ip+1]] = input_val
        ip += 2
    elif opcode == 4:
        a = memory[ip+1] if modes[0] else memory[memory[ip+1]]
        print(a, end='')
        ip += 2
    elif opcode == 5:
        a, b = memory[ip+1:ip+3]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        if a != 0:
            ip = b
        else:
            ip += 3
    elif opcode == 6:
        a, b = memory[ip+1:ip+3]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        if a == 0:
            ip = b
        else:
            ip += 3
    elif opcode == 7:
        a, b, c = memory[ip+1:ip+4]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        memory[c] = 1 if a < b else 0
        ip += 4
    elif opcode == 8:
        a, b, c = memory[ip+1:ip+4]
        a = a if modes[0] else memory[a]
        b = b if modes[1] else memory[b]
        memory[c] = 1 if a == b else 0
        ip += 4
    elif opcode == 99:
        return None
    else:
        raise ValueError('Invalid opcode')
    return ip

def run_program(memory, input_val):
    ip = 0
    while ip is not None:
        ip = process_instruction(memory, ip, input_val)
    return memory

memory = parse_input('input.txt')
input_val = 1
run_program(memory, input_val)
",2
105,2019,6,1,no_error,"142497
",142497,,"
import re


# Read the input file and store it in a list
with open('input.txt', 'r') as file:
    orbits = file.readlines()

# Create a dictionary to store the orbits
orbit_dict = {}

# Create a set to store unique objects
objects = set()

# Loop through each orbit line and add them to the dictionary
for orbit in orbits:
    center, satellite = re.findall(r'(.+)\)(.+)', orbit.strip())[0]
    orbit_dict[satellite] = center
    objects.add(center)
    objects.add(satellite)

# Initialize the count of orbits
total_orbits = 0

# For each object, find its indirect orbits and add it to the total count
for obj in objects:
    temp_obj = obj
    while temp_obj in orbit_dict:
        temp_obj = orbit_dict[temp_obj]
        total_orbits += 1

print(total_orbits)
",0
106,2019,7,1,runtime_error,,77500,"Traceback (most recent call last):
  File ""/tmp/tmp3vu0lzk_/tmp.py"", line 26, in <module>
    main()
  File ""/tmp/tmp3vu0lzk_/tmp.py"", line 19, in main
    if output_signal > max_output_signal:
TypeError: '>' not supported between instances of 'NoneType' and 'int'
","
import itertools

def intcode_computer(program, input_signal):
    # Function to run the intcode program and return the output signal
    # This function is already provided in the previous puzzle
    pass

def main():
    with open(""input.txt"", ""r"") as file:
        program = list(map(int, file.read().strip().split(',')))

    max_output_signal = 0
    for phase_settings in itertools.permutations(range(5)):
        output_signal = 0
        for i in range(5):
            output_signal = intcode_computer(program.copy(), phase_settings[i])
            input_signal = output_signal
        if output_signal > max_output_signal:
            max_output_signal = output_signal
            best_phase_settings = phase_settings

    print(f""Maximum output signal: {max_output_signal} (Phase settings: {best_phase_settings})"")

if __name__ == ""__main__"":
    main()
",2
107,2019,8,1,no_error,"1742
",1742,,"
import math

# Open the file and read the input
with open('input.txt', 'r') as file:
    data = file.read().strip()

# Calculate the number of layers and pixels per layer
layer_size = 25 * 6
num_layers = len(data) // layer_size

# Initialize variables
fewest_zeros = math.inf
ones = 0
twos = 0

# Loop through each layer
for i in range(num_layers):
    start = i * layer_size
    end = (i + 1) * layer_size
    layer = data[start:end]
    zeros = layer.count('0')
    if zeros < fewest_zeros:
        fewest_zeros = zeros
        ones = layer.count('1')
        twos = layer.count('2')

# Print the result
print(ones * twos)
",1
108,2019,9,1,no_error,"3780860499
",3780860499,,"
import math
from collections import defaultdict

def get_input():
    with open(""input.txt"", ""r"") as file:
        data = file.read()
        return [int(i) for i in data.split(',')]

def get_mode(opcode):
    return str(opcode // 100).zfill(3)

def parse_instruction(opcode):
    return (opcode % 100, int(get_mode(opcode)[2]), int(get_mode(opcode)[1]), int(get_mode(opcode)[0]))

def get_param(memory, position, mode, relative_base):
    if mode == 0:
        return memory[memory[position]]
    elif mode == 1:
        return memory[position]
    else:
        return memory[relative_base + memory[position]]

def set_param(memory, value, position, mode, relative_base):
    if mode == 2:
        memory[relative_base + position] = value
    else:
        memory[position] = value

def run_intcode(memory, input_code):
    input_index = 0
    relative_base = 0
    instruction_pointer = 0
    while True:
        opcode, param1_mode, param2_mode, param3_mode = parse_instruction(memory[instruction_pointer])
        if opcode == 1:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            param2 = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            set_param(memory, param1 + param2, memory[instruction_pointer + 3], param3_mode, relative_base)
            instruction_pointer += 4
        elif opcode == 2:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            param2 = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            set_param(memory, param1 * param2, memory[instruction_pointer + 3], param3_mode, relative_base)
            instruction_pointer += 4
        elif opcode == 3:
            set_param(memory, input_code[input_index], memory[instruction_pointer + 1], param1_mode, relative_base)
            input_index += 1
            instruction_pointer += 2
        elif opcode == 4:
            print(get_param(memory, instruction_pointer + 1, param1_mode, relative_base))
            instruction_pointer += 2
        elif opcode == 5:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            if param1 != 0:
                instruction_pointer = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            else:
                instruction_pointer += 3
        elif opcode == 6:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            if param1 == 0:
                instruction_pointer = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            else:
                instruction_pointer += 3
        elif opcode == 7:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            param2 = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            set_param(memory, 1 if param1 < param2 else 0, memory[instruction_pointer + 3], param3_mode, relative_base)
            instruction_pointer += 4
        elif opcode == 8:
            param1 = get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            param2 = get_param(memory, instruction_pointer + 2, param2_mode, relative_base)
            set_param(memory, 1 if param1 == param2 else 0, memory[instruction_pointer + 3], param3_mode, relative_base)
            instruction_pointer += 4
        elif opcode == 9:
            relative_base += get_param(memory, instruction_pointer + 1, param1_mode, relative_base)
            instruction_pointer += 2
        elif opcode == 99:
            break
        else:
            print(""Unknown opcode:"", opcode)
            break

memory = defaultdict(int)
input_code = get_input()
for i, value in enumerate(input_code):
    memory[i] = value
run_intcode(memory, [1])
",1
109,2019,10,1,timeout_error,,309,TIMEOUT,"
from itertools import combinations
from math import atan2, pi

def angle(a, b):
    return atan2(b[1]-a[1], b[0]-a[0]) % (2*pi)

def visible_asteroids(asteroids):
    visible = {}
    for a, b in combinations(asteroids, 2):
        if a != b:
            if a[0] == b[0]:
                p1, p2 = sorted([a, b], key=lambda x: x[1])
                visible[a] = visible.get(a, []) + [(p2, angle(a, b))]
                visible[b] = visible.get(b, []) + [(p1, angle(b, a))]
            elif a[1] == b[1]:
                p1, p2 = sorted([a, b], key=lambda x: x[0])
                visible[a] = visible.get(a, []) + [(p2, angle(a, b))]
                visible[b] = visible.get(b, []) + [(p1, angle(b, a))]
            else:
                m = (b[1]-a[1]) / (b[0]-a[0])
                p1, p2 = a, b
                if m > 0:
                    if a[0] > b[0]:
                        p1, p2 = b, a
                else:
                    if a[0] < b[0]:
                        p1, p2 = b, a
                visible[p1] = visible.get(p1, []) + [(p2, angle(p1, p2))]
                visible[p2] = visible.get(p2, []) + [(p1, angle(p2, p1))]
    return visible

def solve(asteroids):
    visibility = {a: len(set(visible_asteroids(asteroids-{a})) | {angle(a, b) for b in asteroids - {a} if b not in visible_asteroids(asteroids-{a})}) for a in asteroids}
    return max(visibility, key=visibility.get)

with open('input.txt', 'r') as f:
    grid = [list(l.strip()) for l in f]
    asteroids = {(x, y) for y, row in enumerate(grid) for x, val in enumerate(row) if val == '#'}
    station = solve(asteroids)
    print(f""Best location: {station}, can detect {visibility[station]} other asteroids"")


with open('input.txt', 'r') as f:
    grid = [list(l.strip()) for l in f]
    asteroids = {(x, y) for y, row in enumerate(grid) for x, val in enumerate(row) if val == '#'}
    station = solve(asteroids)
    print(f""Best location: {station}, can detect {visibility[station]} other asteroids"")
",2
110,2019,11,1,syntax_error,,2336,"  File ""/tmp/tmplr37ayjl/tmp.py"", line 91
    print(process_painting_robot(program))
    ^
SyntaxError: invalid syntax
","
from collections import defaultdict
from queue import Queue

def run_program(program, input_queue):
    ip = 0
    relative_base = 0
    while ip < len(program):
        opcode = program[ip] % 100
        mode_p1, mode_p2, mode_p3 = program[ip] // 100 % 10, program[ip] // 1000 % 10, program[ip] // 10000 % 10
        if opcode == 1:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            p3 = program[ip+3]
            program[p3] = p1 + p2
            ip += 4
        elif opcode == 2:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            p3 = program[ip+3]
            program[p3] = p1 * p2
            ip += 4
        elif opcode == 3:
            p1 = program[ip+1]
            program[p1] = input_queue.get()
            ip += 2
        elif opcode == 4:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            print(p1)
            ip += 2
        elif opcode == 5:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            if p1 != 0:
                ip = p2
            else:
                ip += 3
        elif opcode == 6:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            if p1 == 0:
                ip = p2
            else:
                ip += 3
        elif opcode == 7:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            p3 = program[ip+3]
            program[p3] = 1 if p1 < p2 else 0
            ip += 4
        elif opcode == 8:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            p2 = program[ip+2] if mode_p2 else program[program[ip+2]]
            p3 = program[ip+3]
            program[p3] = 1 if p1 == p2 else 0
            ip += 4
        elif opcode == 9:
            p1 = program[ip+1] if mode_p1 else program[program[ip+1]]
            relative_base += p1
            ip += 2
        else:
            break

def process_painting_robot(program):
    grid = defaultdict(lambda: 0)
    x, y = 0, 0
    dx, dy = 0, 1
    painted = set()
    input_queue = Queue()
    input_queue.put(0)
    while True:
        output_color = run_program(program, input_queue)
        if output_color is None:
            break
        input_queue.put(grid[(x, y)] if (x, y) in grid else 0)
        output_direction = run_program(program, input_queue)
        if output_direction is None:
            break
        grid[(x, y)] = output_color
        painted.add((x, y))
        if output_direction == 0:
            dx, dy = -dy, 0
        elif output_direction == 1:
            dx, dy = 0, -dx
        x += dx
        y += dy
    return len(painted)

with open('input.txt') as f:
    program = list(map(int, f.read().strip().split(','))
    print(process_painting_robot(program))
",2
111,2019,12,1,syntax_error,,6220,"  File ""/tmp/tmpijz3_25e/tmp.py"", line 28
    def total_energy(moons):
    ^
SyntaxError: invalid syntax
","
import re
from itertools import combinations
from collections import namedtuple

class Moon:
    def __init__(self, x, y, z):
        self.pos = (x, y, z)
        self.vel = (0, 0, 0)

def parse_input(input_str):
    pos_pattern = r'<x=(-?\d+), y=(-?\d+), z=(-?\d+)>'
    positions = re.findall(pos_pattern, input_str)
    return [Moon(int(x), int(y), int(z)) for x, y, z in positions]

def simulate_step(moons):
    for m1, m2 in combinations(moons, 2):
        dx = m2.pos[0] - m1.pos[0]
        dy = m2.pos[1] - m1.pos[1]
        dz = m2.pos[2] - m1.pos[2]
        vx, vy, vz = m1.vel
        m1.vel = (vx + int(dx < 0) * 2 - int(dx > 0), vy + int(dy < 0) * 2 - int(dy > 0), vz + int(dz < 0) * 2 - int(dz > 0))
        m2.vel = (m2.vel[0] - dx, m2.vel[1] - dy, m2.vel[2] - dz)

    for m in moons:
        m.pos = tuple(map(sum, zip(m.pos, m.vel))

def total_energy(moons):
    return sum(sum(abs(p) for p in m.pos) * sum(abs(v) for v in m.vel) for m in moons)

def simulate(moons, steps):
    for _ in range(steps):
        simulate_step(moons)
    return total_energy(moons)

input_str = '''
<x=-1, y=0, z=2>
<x=2, y=-10, z=-7>
<x=4, y=-8, z=8>
<x=3, y=5, z=-1>
'''

moons = parse_input(input_str)
print(simulate(moons, 100))
",2
112,2019,13,1,syntax_error,,270,"  File ""/tmp/tmp2_ka2b11/tmp.py"", line 13
    elif opcode == 2:
    ^
SyntaxError: invalid syntax
","
import os

def read_input(file_name):
    with open(file_name, 'r') as file:
        return file.readline().strip().split(',')

def parse_intcode(intcode):
    for i in range(0, len(intcode), 4):
        opcode = int(intcode[i])
        if opcode == 1:
            intcode[intcode[i+3]] = intcode[intcode[i+1]] + intcode[intcode[i+2]
        elif opcode == 2:
            intcode[intcode[i+3]] = intcode[intcode[i+1] * intcode[i+2]
        elif opcode == 99:
            return intcode
        else:
            raise ValueError('Invalid opcode')

def run_intcode(intcode):
    while True:
        try:
            parse_intcode(intcode)
        except ValueError:
            break
    return intcode

def main():
    input_file = 'input.txt'
    intcode = read_input(input_file)
    intcode = list(map(int, intcode))
    intcode[0] = 2
    result = run_intcode(intcode)
    block_tiles = sum(1 for x in result if x == 2)
    print('Number of block tiles on the screen:', block_tiles)

if __name__ == '__main__':
    main()
",2
113,2019,14,1,runtime_error,,532506,"Traceback (most recent call last):
  File ""/tmp/tmpxyeud7r2/tmp.py"", line 36, in <module>
    reactions = parse_input('input.txt')
  File ""/tmp/tmpxyeud7r2/tmp.py"", line 13, in parse_input
    output_qty, output_name = map(int, re.findall(r'(\d+) ([A-Z]+)', right)[0])
ValueError: invalid literal for int() with base 10: 'LMCRF'
","
import re
from collections import defaultdict

def parse_input(input_file):
    reactions = {}
    with open(input_file, 'r') as f:
        for line in f:
            # Split line into input and output
            left, right = line.strip().split(' => ')
            # Split input and output into lists of tuples of form (quantity, name)
            inputs = [(int(qty), name) for qty, name in re.findall(r'(\d+) ([A-Z]+)', left)]
            output_qty, output_name = map(int, re.findall(r'(\d+) ([A-Z]+)', right)[0])
            # Store the reaction in the dictionary
            reactions[output_name] = (output_qty, inputs)
    return reactions

def get_ore_required(reactions, fuel=1):
    surplus = defaultdict(int)
    def get_next_reaction(needed, chemical):
        if chemical == 'ORE':
            return needed
        # Use the surplus if available
        needed_amount = max(0, needed - surplus[chemical])
        surplus[chemical] -= needed_amount
        # Calculate the number of reactions required
        qty, inputs = reactions[chemical]
        n = (needed_amount // qty) + 1
        # Update the surplus
        surplus[chemical] += n * qty - needed_amount
        # Recurse for each input
        ore = sum(get_next_reaction(ni, inp_name) * q for ni, inp_name in inputs)
        return ore
    return get_next_reaction(fuel, 'FUEL')

reactions = parse_input('input.txt')
ore_required = get_ore_required(reactions)
print(f'Minimum ORE required: {ore_required}')
",2
114,2019,15,1,syntax_error,,300,"  File ""/tmp/tmph98afxwk/tmp.py"", line 103
    output = inputs.get()
    ^
SyntaxError: invalid syntax
","
import sys
from queue import Queue

def intcode_computer(intcode, inputs):
    relative_base = 0
    pointer = 0
    while pointer < len(intcode):
        instruction = str(intcode[pointer]).zfill(5)
        opcode = int(instruction[-2:])
        parameter_modes = list(map(int, instruction[2::-1]))
        if opcode == 99:
            break
        elif opcode in (1, 2, 5, 6, 7, 8):
            a, b, c = intcode[pointer+1 : pointer+4]
            a, b, c = a, b, c if parameter_modes[2] == 0 else c, a, b if parameter_modes[1] == 0 else c, intcode[c]
            if parameter_modes[0] == 0:
                a = intcode[a]
                b = intcode[b]
            else:
                a = a
                b = intcode[b]
            if opcode == 1:
                intcode[c] = a + b
            elif opcode == 2:
                intcode[c] = a * b
            elif opcode == 5:
                if a != 0:
                    pointer = b
                    continue
            elif opcode == 6:
                if a == 0:
                    pointer = b
                    continue
            elif opcode == 7:
                intcode[c] = int(a < b)
            elif opcode == 8:
                intcode[c] = int(a == b)
            pointer += 4
        elif opcode in (3, 4):
            a = intcode[pointer+1]
            if opcode == 3:
                intcode[a] = inputs.get()
            else:
                inputs.put(intcode[a])
            pointer += 2
        elif opcode in (9, 99):
            if opcode == 9:
                relative_base += intcode[a]
            pointer += 2
        else:
            a, b, c = intcode[pointer+1 : pointer+4]
            a, b, c = a, b, c if parameter_modes[2] == 0 else c, a, b if parameter_modes[1] == 0 else c, intcode[c] + relative_base if parameter_modes[1] == 2 else c
            if parameter_modes[0] == 0:
                a = intcode[a]
                b = intcode[b]
            else:
                a = a
                b = intcode[b]
            if opcode == 99:
                return intcode, inputs
            elif opcode == 4:
                print(a)
            elif opcode == 9:
                pointer += 2
                continue
            elif opcode == 5:
                if a != 0:
                    pointer = b
                    continue
            elif opcode == 6:
                if a == 0:
                    pointer = b
                    continue
            elif opcode == 7:
                intcode[c] = int(a < b)
            elif opcode == 8:
                intcode[c] = int(a == b)
            elif opcode == 9:
                relative_base += intcode[a]
            pointer += 4
        if pointer < 0:
            break

def solve_maze(intcode):
    maze = [list('##D##')]
    droid = [2, 1]
    moves = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    dirs = {'1': 0, '2': 2, '3': 1, '4': 3}
    min_moves = float('inf')
    queue = Queue()
    queue.put((droid[0], droid[1], 0, 0))
    while not queue.empty():
        x, y, depth, moves_count = queue.get()
        for i, (dx, dy) in enumerate(moves):
            nx, ny = x + dx, y + dy
            if maze[ny][nx] == ' ':
                queue.put((nx, ny, depth + 1, moves_count + 1) if maze[ny][nx-1] != '#' and maze[ny][nx+1] != '#' else (droid[0], droid[1], depth, moves_count))
                maze[ny][nx] = '.'
            elif maze[ny][nx] == '#':
                intcode[0] = dirs[str(i+1)]
                intcode, inputs = intcode_computer(intcode, inputs=Queue([dirs[str(i+1)]])
                output = inputs.get()
                if output == 0:
                    maze[ny][nx] = '#'
                elif output == 1:
                    droid = [nx, ny]
                    maze[y][x] = '.'
                    queue.put((droid[0], droid[1], depth + 1, moves_count + 1) if maze[ny][nx-1] != '#' and maze[ny][nx+1] != '#' else (droid[0], droid[1], depth, moves_count))
                elif output == 2:
                    droid = [nx, ny]
                    maze[y][x] = '.'
                    min_moves = min(min_moves, moves_count + 1)
                    return min_moves
    return min_moves

def main():
    with open('input.txt', 'r') as f:
        intcode = list(map(int, f.read().split(','))
    intcode[0] = 2
    min_moves = solve_maze(intcode)
    print(min_moves)

if __name__ == '__main__':
    main()
",2
115,2019,16,1,wrong_output,"[8, 0, 8, 0, 8, 0, 8, 0]
",68317988,,"
def fft(signal, phases=100):
    input_list = [int(d) for d in signal]
    output_list = input_list
    pattern = [0, 1, 0, -1]
    for phase in range(phases):
        new_output_list = []
        for i in range(len(output_list)):
            pattern_start = i + 1
            pattern_repeat = i + 1
            result = 0
            for j in range(len(output_list)):
                result += output_list[j] * pattern[(pattern_start + j) % len(pattern)]
            new_output_list.append(abs(result) % 10)
        output_list = new_output_list
    return output_list[:8]

with open('input.txt', 'r') as f:
    signal = f.read().strip()

result = fft(signal)
print(result)
",2
116,2019,17,1,syntax_error,,9876,"  File ""/tmp/tmpraqbmqr3/tmp.py"", line 14
    elif opcode == 2:
    ^
SyntaxError: invalid syntax
","
import re
import itertools

with open('input.txt', 'r') as file:
    data = file.read().split(',')
    data = list(map(int, data))

def intcode(index, inputs):
    while index < len(data):
        opcode = data[index]
        if opcode == 1:
            data[data[index + 3]] = data[data[index + 1]] + data[data[index + 2]
        elif opcode == 2:
            data[data[index + 3]] = data[data[index + 1] * data[index + 2]
        elif opcode == 3:
            data[data[index + 1]] = inputs.pop(0)
        elif opcode == 4:
            output = data[data[index + 1]]
        elif opcode == 5:
            if data[data[index + 1] != 0:
                index = data[index + 2]
            else:
                index += 3
        elif opcode == 6:
            if data[data[index + 1] == 0:
                index = data[index + 2]
            else:
                index += 3
        elif opcode == 7:
            if data[data[index + 1] < data[data[index + 2]:
                data[data[index + 3] = 1
            else:
                data[data[index + 3] = 0
        elif opcode == 8:
            if data[data[index + 1] == data[index + 2]:
                data[data[index + 3] = 1
            else:
                data[data[index + 3] = 0
        elif opcode == 99:
            break
        index += 4
    return data, output

def get_scaffold_grid():
    grid = []
    row = []
    for i in intcode(0, [])[1]:
        if i == 10:
            grid.append(row)
            row = []
        else:
            row.append(chr(i))
    return grid

def get_intersections(grid):
    intersections = []
    for x, y in itertools.product(range(1, len(grid[0] - 2), len(grid) - 2):
        if (grid[x][y] == '#' and
            grid[x - 1][y] == '#' and
            grid[x + 1][y] == '#' and
            grid[x][y - 1] == '#' and
            grid[x][y + 1] == '#' and
            grid[x][y - 1] == '#' and
            grid[x][y + 1] == '#'):
            intersections.append((x, y))
    return intersections

def alignment_parameter(x, y):
    return x * y

def main():
    grid = get_scaffold_grid()
    intersections = get_intersections(grid)
    total_sum = sum(alignment_parameter(x, y) for x, y in intersections)
    print(total_sum)

if __name__ == '__main__':
    main()
",2
117,2019,18,1,timeout_error,,6316,TIMEOUT,"
import re
import heapq
from collections import defaultdict
from itertools import product
import sys

def get_neighbors(x, y, maze):
    for dx, dy in product((-1, 0, 1), (-1, 0, 1)):
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(maze) and 0 <= ny < len(maze[0]) and maze[nx][ny] != '#':
            yield nx, ny

def search(maze, keys, x, y):
    visited = set()
    queue = [(0, x, y, frozenset())]
    while queue:
        steps, x, y, key_set = heapq.heappop(queue)
        if (x, y, key_set) in visited:
            continue
        visited.add((x, y, key_set))
        if (x, y) not in keys:
            continue
        key, door = keys.pop((x, y))
        key_set = key_set | {key}
        if not keys:
            return steps + 1
        for nx, ny in get_neighbors(x, y, maze):
            if maze[nx][ny].islower() and maze[nx][ny] not in key_set:
                heapq.heappush(queue, (steps + 1, nx, ny, key_set))
            elif maze[nx][ny].isupper() and key in key_set:
                heapq.heappush(queue, (steps + 1, nx, ny, key_set))

def find_all_keys(maze):
    keys = {}
    for y, row in enumerate(maze):
        for x, cell in enumerate(row):
            if cell.islower():
                keys[(x, y)] = cell
            elif cell.isupper():
                for nx, ny in get_neighbors(x, y, maze):
                    if maze[nx][ny].islower():
                        keys[(nx, ny)] = cell.lower()
                        break
    return keys

def min_steps(maze):
    keys = find_all_keys(maze)
    x, y = next((x, y) for y, row in enumerate(maze) for x, cell in enumerate(row) if cell == '@')
    return search(maze, keys, x, y)

maze = [list(line.strip()) for line in sys.stdin.readlines()]
print(min_steps(maze))
",2
118,2019,19,1,runtime_error,,150,"Traceback (most recent call last):
  File ""/tmp/tmp9ptjjjqy/tmp.py"", line 152, in <module>
    main()
  File ""/tmp/tmp9ptjjjqy/tmp.py"", line 147, in main
    output, _, _ = intcode(code_list.copy(), [x, y])
  File ""/tmp/tmp9ptjjjqy/tmp.py"", line 21, in intcode
    a, b, c, d = code_list[index+1:index+4]
TypeError: unhashable type: 'slice'
","
import re
from collections import defaultdict

def intcode(code_list, input_list):
    index = 0
    input_index = 0
    output = []
    relative_base = 0
    while True:
        instruction = str(code_list[index]).zfill(5)
        opcode = int(instruction[-2:])
        parameter_mode = [int(x) for x in instruction[2::-1]]
        if opcode == 99:
            break
        elif opcode == 1:
            a, b, c, d = code_list[index+1:index+4]
            code_list[d] = add(a, b, c, code_list, parameter_mode)
            index += 4
        elif opcode == 2:
            a, b, c, d = code_list[index+1:index+4]
            code_list[d] = multiply(a, b, c, code_list, parameter_mode)
            index += 4
        elif opcode == 3:
            a = code_list[index+1]
            if input_index < len(input_list):
                code_list[a] = input_list[input_index]
                input_index += 1
            else:
                return (code_list[a], output, False)
            index += 2
        elif opcode == 4:
            a = code_list[index+1]
            output.append(code_list[a])
            index += 2
        elif opcode == 5:
            a, b, c = code_list[index+1:index+3]
            if conditional_jump(a, b, code_list, parameter_mode):
                index = c
            else:
                index += 3
        elif opcode == 6:
            a, b, c = code_list[index+1:index+3]
            if not conditional_jump(a, b, code_list, parameter_mode):
                index = c
            else:
                index += 3
        elif opcode == 7:
            a, b, c, d = code_list[index+1:index+4]
            code_list[d] = less_than(a, b, code_list, parameter_mode)
            index += 4
        elif opcode == 8:
            a, b, c, d = code_list[index+1:index+4]
            code_list[d] = equals(a, b, code_list, parameter_mode)
            index += 4
        elif opcode == 9:
            a = code_list[index+1]
            relative_base += code_list[a]
            index += 2
        else:
            print(""Error: Incorrect opcode '{}'"".format(opcode))
            return False, output, False
    return (code_list[0], output, True)

def add(a, b, c, code_list, parameter_mode):
    if parameter_mode[2] == 0:
        code_list[c] = code_list[a] + code_list[b]
    elif parameter_mode[2] == 1:
        code_list[c] = a + b
    elif parameter_mode[2] == 2:
        code_list[c] = code_list[a] + relative_base + b
    else:
        print(""Error: Invalid parameter mode for add opcode '{}'"".format(parameter_mode[2]))
        return False
    return code_list

def multiply(a, b, c, code_list, parameter_mode):
    if parameter_mode[2] == 0:
        code_list[c] = code_list[a] * code_list[b]
    elif parameter_mode[2] == 1:
        code_list[c] = a * b
    elif parameter_mode[2] == 2:
        code_list[c] = code_list[a] * (relative_base + b)
    else:
        print(""Error: Invalid parameter mode for multiply opcode '{}'"".format(parameter_mode[2]))
        return False
    return code_list

def conditional_jump(a, b, code_list, parameter_mode):
    if parameter_mode[0] == 0:
        a = code_list[a]
    elif parameter_mode[0] == 1:
        a = a
    elif parameter_mode[0] == 2:
        a = code_list[a] + relative_base
    if parameter_mode[1] == 0:
        b = code_list[b]
    elif parameter_mode[1] == 1:
        b = b
    elif parameter_mode[1] == 2:
        b = code_list[b] + relative_base
    return a != 0

def less_than(a, b, code_list, parameter_mode):
    if parameter_mode[0] == 0:
        a = code_list[a]
    elif parameter_mode[0] == 1:
        a = a
    elif parameter_mode[0] == 2:
        a = code_list[a] + relative_base
    if parameter_mode[1] == 0:
        b = code_list[b]
    elif parameter_mode[1] == 1:
        b = b
    elif parameter_mode[1] == 2:
        b = code_list[b] + relative_base
    if a < b:
        return 1
    else:
        return 0

def equals(a, b, code_list, parameter_mode):
    if parameter_mode[0] == 0:
        a = code_list[a]
    elif parameter_mode[0] == 1:
        a = a
    elif parameter_mode[0] == 2:
        a = code_list[a] + relative_base
    if parameter_mode[1] == 0:
        b = code_list[b]
    elif parameter_mode[1] == 1:
        b = b
    elif parameter_mode[1] == 2:
        b = code_list[b] + relative_base
    if a == b:
        return 1
    else:
        return 0

def main():
    with open('input.txt') as f:
        code_list = [int(x) for x in f.readline().split(',')]
        code_list = defaultdict(int, enumerate(code_list))
        grid = defaultdict(int)
        for x in range(50):
            for y in range(50):
                output, _, _ = intcode(code_list.copy(), [x, y])
                grid[(x, y)] = output[-1]
        print(sum(grid.values()))

if __name__ == '__main__':
    main()
",2
119,2019,20,1,runtime_error,,608,"Traceback (most recent call last):
  File ""/tmp/tmpvxje9ers/tmp.py"", line 79, in <module>
    portals = find_portals()
  File ""/tmp/tmpvxje9ers/tmp.py"", line 23, in find_portals
    elif maze[y][x+1] == '.':
IndexError: list index out of range
","
import re
from collections import defaultdict
from heapq import heappush, heappop

# Read input file
with open('input.txt') as f:
    maze = [list(line.strip()) for line in f.readlines()]

# Get maze dimensions
rows = len(maze)
cols = len(maze[0])

# Function to find portals
def find_portals():
    labels = {}
    for y in range(rows):
        for x in range(cols):
            if maze[y][x].isalpha():
                if maze[y][x-1] == '.':
                    label = maze[y][x-2] + maze[y][x-1]
                    labels[label] = labels.get(label, []) + [(x-2, y)]
                elif maze[y][x+1] == '.':
                    label = maze[y][x] + maze[y][x+1]
                    labels[label] = labels.get(label, []) + [(x, y)]
                elif maze[y-1][x] == '.':
                    label = maze[y-2][x] + maze[y-1][x]
                    labels[label] = labels.get(label, []) + [(x, y-2)]
                elif maze[y+1][x] == '.':
                    label = maze[y][x] + maze[y+1][x]
                    labels[label] = labels.get(label, []) + [(x, y)]
    return labels

# Function to find start and end points
def get_start_end():
    for y in range(rows):
        for x in range(cols):
            if maze[y][x] == 'A':
                start = (x, y)
            if maze[y][x] == 'Z':
                end = (x, y)
    return start, end

# Function to find neighbors of a cell
def get_neighbors(x, y):
    neighbors = []
    if maze[y][x-1] == '.':
        neighbors.append((x-1, y))
    if maze[y][x+1] == '.':
        neighbors.append((x+1, y))
    if maze[y-1][x] == '.':
        neighbors.append((x, y-1))
    if maze[y+1][x] == '.':
        neighbors.append((x, y+1))
    return neighbors

# Function to get all possible destinations from a portal
def get_destinations(x, y):
    destinations = []
    if maze[y][x-1] == '.':
        destinations.append((x-1, y))
    if maze[y][x+1] == '.':
        destinations.append((x+1, y))
    if maze[y-1][x] == '.':
        destinations.append((x, y-1))
    if maze[y+1][x] == '.':
        destinations.append((x, y+1))
    if (x, y-1) in portals:
        destinations.extend(portals[(x, y-1)])
    if (x, y+1) in portals:
        destinations.extend(portals[(x, y+1)])
    if (x-1, y) in portals:
        destinations.extend(portals[(x-1, y)])
    if (x+1, y) in portals:
        destinations.extend(portals[(x+1, y)])
    return destinations

# Find portals and start and end points
portals = find_portals()
start, end = get_start_end()

# Initialize queue
queue = [(0, start)]
visited = set()

# Dijkstra's algorithm
while queue:
    steps, position = heappop(queue)
    if position == end:
        print(steps)
        break
    if position in visited:
        continue
    visited.add(position)
    for neighbor in get_destinations(*position):
        if neighbor not in visited:
            heappush(queue, (steps+1, neighbor))

",2
120,2019,21,1,syntax_error,,19358688,"  File ""/tmp/tmp0bdsdm9l/tmp.py"", line 2
    ```python
    ^
SyntaxError: invalid syntax
","
```python
import os

def run_program(program, input_list):
    with open('input.txt', 'r') as f:
        data = f.read()
    data = list(map(int, data.split(','))+[0]*10000)
    i = 0
    relative_base = 0
    while i < len(program):
        opcode = data[i]
        inst = opcode % 100
        mode_p1 = (opcode // 100) % 10
        mode_p2 = (opcode // 1000) % 10
        mode_p3 = (opcode // 10000) % 10
        
        if inst == 1:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if mode_p3 == 0:
                p3 = data[i+3]
            elif p3 == 2:
                p3 = data[i+3] + relative_base
            data[p3] = p1 + p2
            i += 4
        elif inst == 2:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if mode_p3 == 0:
                p3 = data[i+3]
            elif p3 == 2:
                p3 = data[i+3] + relative_base
            data[p3] = p1 * p2
            i += 4
        elif inst == 3:
            if mode_p1 == 0:
                p1 = data[i+1]
            elif mode_p1 == 1:
                p1 = i+1
            elif mode_p1 == 2:
                p1 = data[i+1] + relative_base
            data[p1] = input_list.pop(0)
            i += 2
        elif inst == 4:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            print(p1)
            i += 2
        elif inst == 5:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if p1 != 0:
                i = p2
            else:
                i += 3
        elif inst == 6:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if p1 == 0:
                i = p2
            else:
                i += 3
        elif inst == 7:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if mode_p3 == 0:
                p3 = data[i+3]
            elif p3 == 2:
                p3 = data[i+3] + relative_base
            if p1 < p2:
                data[p3] = 1
            else:
                data[p3] = 0
            i += 4
        elif inst == 8:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            if mode_p2 == 0:
                p2 = data[data[i+2]]
            elif mode_p2 == 1:
                p2 = data[i+2]
            elif mode_p2 == 2:
                p2 = data[data[i+2] + relative_base]
            if mode_p3 == 0:
                p3 = data[i+3]
            elif p3 == 2:
                p3 = data[i+3] + relative_base
            if p1 == p2:
                data[p3] = 1
            else:
                data[p3] = 0
            i += 4
        elif inst == 9:
            if mode_p1 == 0:
                p1 = data[data[i+1]]
            elif mode_p1 == 1:
                p1 = data[i+1]
            elif mode_p1 == 2:
                p1 = data[data[i+1] + relative_base]
            relative_base += p1
            i += 2
        else:
            print(""Error!"")
            return None, None
    return data, i

program = list(map(int, open('input.txt').read().split(','))+[0]*10000)

input_list = []
input_list.append(ord('N'))
input_list.append(ord('O'))
input_list.append(ord('T'))
input_list.append(ord(' '))
input_list.append(ord('A'))
input_list.append(ord(' '))
input_list.append(ord('J'))
input_list.append(ord('U'))
input_list.append(ord('M'))
input_list.append(ord('P'))
input_list.append(10)
input_list.append(ord('W'))
input_list.append(ord('A'))
input_list.append(ord('L'))
input_list.append(ord('K'))
input_list.append(10)

print(""Enter springscript commands:"")

while True:
    cmd = input()
    if cmd == 'WALK':
        input_list.append(10)
        break
   ",2
121,2019,22,1,runtime_error,,1252,"Traceback (most recent call last):
  File ""/tmp/tmp0azebo_8/tmp.py"", line 40, in <module>
    main()
  File ""/tmp/tmp0azebo_8/tmp.py"", line 35, in main
    deck = process_line(line.strip(), deck)
  File ""/tmp/tmp0azebo_8/tmp.py"", line 23, in process_line
    return deal_into_new_stack(deck)
  File ""/tmp/tmp0azebo_8/tmp.py"", line 5, in deal_into_new_stack
    return deque(deck[::-1])
TypeError: sequence index must be integer, not 'slice'
","
from collections import deque

def deal_into_new_stack(deck):
    return deque(deck[::-1])

def cut(deck, n):
    if n > 0:
        return deque(list(deck)[n:]) + deque(list(deck)[:n])
    else:
        return deque(list(deck)[-n:]) + deque(list(deck)[:-n])

def deal_with_increment(deck, n):
    table = [None] * len(deck)
    pos = 0
    for card in deck:
        table[pos] = card
        pos = (pos + n) % len(deck)
    return deque([card for card in table if card is not None])

def process_line(line, deck):
    if line.startswith('deal into new stack'):
        return deal_into_new_stack(deck)
    elif line.startswith('cut'):
        return cut(deck, int(line.split()[-1])).copy()
    elif line.startswith('deal with increment'):
        return deal_with_increment(deck, int(line.split()[-1])).copy()

def main():
    with open('input.txt') as f:
        lines = f.readlines()

    deck = deque(range(1007))
    for line in lines:
        deck = process_line(line.strip(), deck)

    print(deck.index(2019))

if __name__ == '__main__':
    main()


def deal_into_new_stack(deck):
    return deck[::-1]

def cut(deck, n):
    if n > 0:
        return deck[n:] + deck[:n]
    else:
        return deck[-n:] + deck[:-n]

def deal_with_increment(deck, n):
    table = [None] * len(deck)
    pos = 0
    for card in deck:
        table[pos] = card
        pos = (pos + n) % len(deck)
    return [card for card in table if card is not None]

def process_line(line, deck):
    if line.startswith('deal into new stack'):
        return deal_into_new_stack(deck)
    elif line.startswith('cut'):
        return cut(deck, int(line.split()[-1])).copy()
    elif line.startswith('deal with increment'):
        return deal_with_increment(deck, int(line.split()[-1])).copy()

def main():
    with open('input.txt') as f:
        lines = f.readlines()

    deck = list(range(1007))
    for line in lines:
        deck = process_line(line.strip(), deck)

    print(deck.index(2019))

if __name__ == '__main__':
    main()
",2
122,2019,23,1,syntax_error,,24922,"  File ""/tmp/tmpsqcmtbha/tmp.py"", line 15
    elif opcode == 2:
    ^
SyntaxError: invalid syntax
","
import os
import itertools

def run_intcode(program, input_values):
    # Initialize the Intcode computer
    intcode = program.copy()
    input_index = 0
    output = []
    for i in range(len(intcode)):
        if i % 4 == 0:
            opcode = intcode[i]
            if opcode == 1:
                intcode[intcode[i+3]] = intcode[intcode[i+1]] + intcode[intcode[i+2]
            elif opcode == 2:
                intcode[intcode[i+3]] = intcode[intcode[i+1] * intcode[i+2]
            elif opcode == 3:
                intcode[intcode[i+1]] = input_values[input_index]
                input_index += 1
            elif opcode == 4:
                output.append(intcode[intcode[i+1])
            elif opcode == 5:
                if intcode[intcode[i+1] != 0:
                    i = intcode[intcode[i+2]
            elif opcode == 6:
                if intcode[intcode[i+1] == 0:
                    i = intcode[intcode[i+2]
            elif opcode == 7:
                if intcode[intcode[intcode[i+1] < intcode[intcode[i+2]:
                    intcode[intcode[i+3] = 1
                else:
                    intcode[intcode[i+3] = 0
            elif opcode == 8:
                if intcode[intcode[intcode[i+1] == intcode[intcode[i+2]:
                    intcode[intcode[i+3] = 1
                else:
                    intcode[intcode[i+3] = 0
            elif opcode == 99:
                break
    return output

# Read the input file
with open('input.txt', 'r') as f:
    program = list(map(int, f.read().split(','))

# Initialize network
class Network:
    def __init__(self, num_computers):
        self.computers = []
        for i in range(num_computers):
            computer = run_intcode(program, [i])
            self.computers.append(computer)
        self.queues = {i: [] for i in range(num_computers)}

    def send_packet(self, address, x, y):
        if address == 255:
            return y
        self.queues[address].append((x, y))

    def receive_packet(self, address):
        if self.queues[address]:
            x, y = self.queues[address].pop(0)
            return x, y
        else:
            return -1, -1

    def run_network(self):
        for computer, address in itertools.product(self.computers, range(50)):
            while True:
                x, y = self.receive_packet(address)
                output = run_intcode(computer, [x, y])
                if not output:
                    break
                dest_address, packet_x, packet_y = output
                self.send_packet(dest_address, packet_x, packet_y)

# Initialize the network and run it
network = Network(50)
network.run_network()

# Find the first packet to address 255
first_packet_to_255 = network.queues[255][0][1]
print(first_packet_to_255)
",2
123,2019,24,1,syntax_error,,1151290,"  File ""/tmp/tmpbhyyx6uo/tmp.py"", line 46
    for y in range(len(grid[0]):
                               ^
SyntaxError: invalid syntax
","
import re
from collections import Counter

def get_adjacent_bugs(x, y, grid):
    adjacent_bugs = 0
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x+dx, y+dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):
            if grid[nx][ny] == '#':
                adjacent_bugs += 1
    return adjacent_bugs

def get_next_grid(grid):
    next_grid = []
    for x in range(len(grid)):
        row = ''
        for y in range(len(grid[0])):
            if grid[x][y] == '#':
                if get_adjacent_bugs(x, y, grid) != 1:
                    row += '.'
                else:
                    row += '#'
            else:
                if 1 <= get_adjacent_bugs(x, y, grid) <= 2:
                    row += '#'
                else:
                    row += '.'
        next_grid.append(row)
    return next_grid

def main():
    with open('input.txt') as f:
        grid = [line.strip() for line in f.readlines()]

    seen = set()
    seen.add(''.join(grid))
    for i in range(200):
        grid = get_next_grid(grid)
        if ''.join(grid) in seen:
            break
        seen.add(''.join(grid))

    biodiversity_rating = 0
    for x in range(len(grid)):
        for y in range(len(grid[0]):
            if grid[x][y] == '#':
                biodiversity_rating += 2**(x*len(grid[0]) + y)

    print(biodiversity_rating)

if __name__ == '__main__':
    main()
",2
124,2019,25,1,timeout_error,,25166400,TIMEOUT,"
import sys
import time
import asyncio
import threading

def intcode_computer(input_values):
    # Your code here
    return output_values

def communicate_with_droid():
    while True:
        droid_input = input(""Command? "")
        input_values.append(droid_input)
        output_values = intcode_computer(input_values)
        print(output_values)
        if ""Command?"" not in output_values:
            break

input_file = open('input.txt').read().strip().split(',')
input_values = [int(val) for val in input_file]
input_values.append(10) # ASCII code for newline

# Set up the droid's environment
droid_env = {
    ""internal_temp"": -40,
    ""life_signature_location"": ""somewhere"",
    ""hull_damage"": False,
    ""items_carrying"": [],
    ""items_in_environment"": [""red ball"", ""green ball"", ""keycard""]
}

input_values.append(""inv"") # Check the droid's inventory
communicate_with_droid()

# Move to the life signature's location
input_values.append(""north"")
communicate_with_droid()

# Pick up the red ball
input_values.append(""take red ball"")
communicate_with_droid()

# Move to the airlock
input_values.append(""east"")
communicate_with_droid()

# Drop the green ball
input_values.append(""drop green ball"")
communicate_with_droid()

# Check inventory again
input_values.append(""inv"")
communicate_with_droid()

# Use the keycard to open the airlock
input_values.append(""east"")
communicate_with_droid()

# Check the password in the terminal
input_values.append(""west"")
communicate_with_droid()
",2
125,2020,1,1,runtime_error,"928896
",928896,"Traceback (most recent call last):
  File ""/tmp/tmp9e8wkriw/tmp.py"", line 25, in <module>
    print(pair[0] * pair[1])
IndexError: list index out of range
","
import itertools

def find_two_numbers_sum(numbers):
    for pair in itertools.combinations(numbers, 2):
        if sum(pair) == 2020:
            return pair

def multiply_numbers(pair):
    return pair[0] * pair[1]

def main():
    with open('input.txt') as f:
        numbers = [int(line.strip()) for line in f]
        pair = find_two_numbers_sum(numbers)
        result = multiply_numbers(pair)
        print(result)

if __name__ == '__main__':
    main()


numbers = [int(line.strip()) for line in open('input.txt')]
pair = [x for x, y in itertools.combinations(numbers, 2) if x + y == 2020]
print(pair[0] * pair[1])
",2
126,2020,2,1,no_error,"434
",434,,"
import re

def is_valid_password(line):
    pattern = r""(\d+)-(\d+) ([a-z]): ([a-z]+)""
    match = re.match(pattern, line)
    if match:
        min_count, max_count, char, password = match.groups()
        min_count = int(min_count)
        max_count = int(max_count)
        count = password.count(char)
        if min_count <= count <= max_count:
            return True
    return False

def process_input(input_file):
    with open(input_file, ""r"") as f:
        valid_passwords = 0
        for line in f.readlines():
            if is_valid_password(line):
                valid_passwords += 1
        return valid_passwords

print(process_input(""input.txt""))
",1
127,2020,3,1,wrong_output,"Product of trees encountered: 9354744432
",292,,"
import re

def count_trees(map, slope):
    trees = 0
    pos_x, pos_y = 0, 0
    width = len(map[0])
    height = len(map)
    while pos_y < height:
        if map[pos_y][pos_x % width] == '#':
            trees += 1
        pos_x += slope[0]
        pos_y += slope[1]
    return trees

def count_trees_multiple_slopes(map, slopes):
    product = 1
    for slope in slopes:
        product *= count_trees(map, slope)
    return product

def read_map(file_path):
    map = []
    with open(file_path, 'r') as file:
        for line in file:
            map.append(line.strip())
    return map

if __name__ == ""__main__"":
    map = read_map(""input.txt"")
    slopes = [(1, 1), (3, 1), (5, 1), (7, 1), (1, 2)]
    product = count_trees_multiple_slopes(map, slopes)
    print(f""Product of trees encountered: {product}"")
",2
128,2020,4,1,wrong_output,"Valid passports: 233
Valid passports: 233
",233,,"
import re

def is_valid_passport(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

def process_passport_data(passport_data):
    passport = {}
    for line in passport_data:
        for field in line.split():
            key, value = field.split(':')
            passport[key] = value
    return passport

def is_north_pole_credential(passport):
    if 'cid' not in passport:
        return True
    return False

def main():
    with open('input.txt', 'r') as f:
        data = f.read()
    passport_data = data.split('\n\n')
    valid_passports = 0
    for passport in passport_data:
        passport = passport.replace('\n', ' ')
        passport = re.sub(r'\s+', ' ', passport).strip()
        passport = process_passport_data(passport.split())
        if is_valid_passport(passport) or (is_north_pole_credential(passport) and len(passport) == 7):
            valid_passports += 1
    print(f""Valid passports: {valid_passports}"")

if __name__ == ""__main__"":
    main()


def is_valid_passport(passport):
    required_fields = ['byr', 'iyr', 'eyr', 'hgt', 'hcl', 'ecl', 'pid']
    for field in required_fields:
        if field not in passport:
            return False
    return True

def process_passport_data(passport_data):
    passport = {}
    for line in passport_data:
        for field in line.split():
            key, value = field.split(':')
            passport[key] = value
    return passport

def is_north_pole_credential(passport):
    if 'cid' not in passport:
        return True
    return False

def main():
    with open('input.txt', 'r') as f:
        data = f.read()
    passport_data = data.split('\n\n')
    valid_passports = 0
    for passport in passport_data:
        passport = passport.replace('\n', ' ')
        passport = re.sub(r'\s+', ' ', passport).strip()
        passport = process_passport_data(passport.split())
        if is_valid_passport(passport) or (is_north_pole_credential(passport) and len(passport) == 7):
            valid_passports += 1
    print(f""Valid passports: {valid_passports}"")

if __name__ == ""__main__"":
    main()
",2
129,2020,5,1,wrong_output,"986
",987,,"
import re

def get_seat_id(boarding_pass):
    row_range = [0, 127]
    col_range = [0, 7]
    for i in range(7):
        if boarding_pass[i] == 'F':
            row_range[1] = (row_range[0] + row_range[1]) // 2
        else:
            row_range[0] = (row_range[0] + row_range[1]) // 2 + 1
    row = row_range[0]
    for i in range(7, 9):
        if boarding_pass[i] == 'L':
            col_range[1] = (col_range[0] + col_range[1]) // 2
        else:
            col_range[0] = (col_range[0] + col_range[1]) // 2 + 1
    col = col_range[0]
    return row * 8 + col

with open('input.txt') as f:
    seat_ids = [get_seat_id(line.strip()) for line in f]
    print(max(seat_ids))
",2
130,2020,6,1,wrong_output,"6775
6775
",6775,,"
import os

# Read the input file
with open(""input.txt"", ""r"") as f:
    data = f.read().split(""\n\n"")

# Process each group's answers
total_count = 0
for group in data:
    group_count = 0
    yes_answers = set()
    people = group.split(""\n"")
    for person in people:
        for answer in person:
            if answer not in yes_answers:
                yes_answers.add(answer)
                group_count += 1
    total_count += group_count

print(total_count)


# Read the input file
with open(""input.txt"", ""r"") as f:
    data = f.read().split(""\n\n"")

# Process each group's answers
total_count = 0
for group in data:
    group_count = 0
    yes_answers = set()
    people = group.split(""\n"")
    for person in people:
        for answer in person:
            if answer not in yes_answers:
                yes_answers.add(answer)
                group_count += 1
    total_count += group_count

print(total_count)
",2
131,2020,7,1,runtime_error,,226,"Traceback (most recent call last):
  File ""/tmp/tmpi12nx9ra/tmp.py"", line 30, in <module>
    for outer_bag in rules:
RuntimeError: dictionary changed size during iteration
","
import re
from collections import defaultdict

# Open and read the input file
with open('input.txt', 'r') as file:
    data = file.read().split('\n')

# Create a dictionary to store the rules
rules = defaultdict(list)

# Parse the rules and store them in the dictionary
for line in data:
    outer_bag, inner_bags = re.match(r'(.+) bags contain (.+)', line).groups()
    for bag in re.findall(r'\d+ (.+?) bag', inner_bags):
        rules[outer_bag.replace(' bags', '').strip()].append(bag.replace(' bags', '').strip())

# Initialize the set of valid bags
valid_bags = set()

# Recursive function to check valid bags
def find_valid_bags(bag):
    if 'shiny gold' in rules[bag]:
        valid_bags.add(bag)
    else:
        for inner_bag in rules[bag]:
            find_valid_bags(inner_bag)

# Iterate through the rules and find all valid bags
for outer_bag in rules:
    find_valid_bags(outer_bag)

# Print the result
print(len(valid_bags))
",2
132,2020,8,1,no_error,"1384
",1384,,"
def get_accumulator_value():
    with open(""input.txt"", ""r"") as file:
        instructions = [line.strip().split() for line in file.readlines()]
        accumulator = 0
        visited = set()
        current_line = 0
        while current_line not in visited:
            visited.add(current_line)
            if instructions[current_line][0] == ""acc"":
                accumulator += int(instructions[current_line][1])
                current_line += 1
            elif instructions[current_line][0] == ""jmp"":
                current_line += int(instructions[current_line][1])
            else:
                current_line += 1
            if current_line >= len(instructions):
                break
        return accumulator

print(get_accumulator_value())
",2
133,2020,9,1,timeout_error,,258585477,TIMEOUT,"
import fileinput

preamble_length = 25

def is_valid(numbers, target):
    for i in range(len(numbers) - preamble_length):
        for j in range(i + 1, len(numbers) - preamble_length):
            if numbers[i] == target or numbers[j] == target:
                continue
            if numbers[i] + numbers[j] == target:
                return True
    return False

data = [int(line.strip()) for line in fileinput.input()]

for i in range(preamble_length, len(data)):
    if not is_valid(data[:i], data[i]):
        print(data[i])
        break
",2
134,2020,10,1,no_error,"2263
",2263,,"
import os

def count_jolt_differences(adapters):
    adapters.append(0)
    adapters.append(max(adapters) + 3)
    adapters.sort()
    diff_counts = [0, 0, 0]
    for i in range(len(adapters) - 1):
        diff = adapters[i+1] - adapters[i]
        diff_counts[diff-1] += 1
    return diff_counts[0] * diff_counts[2]

if __name__ == ""__main__"":
    with open('input.txt', 'r') as file:
        input_adapters = [int(line.strip()) for line in file.readlines()]
        print(count_jolt_differences(input_adapters))
",1
135,2020,11,1,syntax_error,,2368,"  File ""/tmp/tmpmvyw3v2s/tmp.py"", line 11
    for i in range(max(0, row-1), min(row+2, len(grid)):
                                                       ^
SyntaxError: invalid syntax
","
import os

def read_input_file(file_name):
    with open(file_name, 'r') as file:
        data = file.readlines()
    return [line.strip() for line in data]

def get_adjacent_seats(grid, row, col):
    adjacent_seats = []
    for i in range(max(0, row-1), min(row+2, len(grid)):
        for j in range(max(0, col-1), min(col+2, len(grid[0])):
            if not (i == row and j == col):
                adjacent_seats.append(grid[i][j])
    return adjacent_seats

def update_grid(grid):
    new_grid = []
    for i, row in enumerate(grid):
        new_row = []
        for j, seat in enumerate(row):
            if seat == '.':
                new_row.append('.')
            elif seat == 'L' and sum(1 for s in get_adjacent_seats(grid, i, j) if s == '#') == 0:
                new_row.append('#')
            elif seat == '#' and sum(1 for s in get_adjacent_seats(grid, i, j) if s == '#') >= 4:
                new_row.append('L')
            else:
                new_row.append(seat)
        new_grid.append(new_row)
    return new_grid

def count_occupied_seats(grid):
    return sum(sum(1 for row in grid for seat in row if seat == '#')

def main():
    grid = read_input_file('input.txt')
    while True:
        new_grid = update_grid(grid)
        if new_grid == grid:
            break
        grid = new_grid
    print(count_occupied_seats(grid))

if __name__ == ""__main__"":
    main()
",2
136,2020,12,1,no_error,"962
",962,,"
import math
import re

def navigate(instructions):
    position = [0, 0]
    direction = 0

    for i in instructions:
        action, value = i[0], int(i[1:])
        if action == 'N':
            position[1] += value
        elif action == 'S':
            position[1] -= value
        elif action == 'E':
            position[0] += value
        elif action == 'W':
            position[0] -= value
        elif action == 'L':
            direction += value
        elif action == 'R':
            direction -= value
        elif action == 'F':
            position[0] += round(math.cos(math.radians(direction)) * value)
            position[1] += round(math.sin(math.radians(direction)) * value)
        direction = (direction + 360) % 360

    return sum(map(abs, position))

with open('input.txt') as f:
    instructions = [line.strip() for line in f]

print(navigate(instructions))
",0
137,2020,13,1,no_error,"2095
",2095,,"
import math

def earliest_bus(earliest_timestamp, bus_ids):
    earliest_bus_id = 0
    min_wait_time = math.inf
    for bus_id in bus_ids:
        wait_time = bus_id - (earliest_timestamp % bus_id)
        if wait_time < min_wait_time:
            min_wait_time = wait_time
            earliest_bus_id = bus_id
    return earliest_bus_id * min_wait_time

with open('input.txt', 'r') as file:
    earliest_timestamp = int(file.readline().strip())
    bus_ids = [int(bus_id) for bus_id in file.readline().strip().split(',') if bus_id != 'x']
    print(earliest_bus(earliest_timestamp, bus_ids))
",0
138,2020,14,1,no_error,"14553106347726
",14553106347726,,"
import re

# Initialize memory and mask
memory = {}
mask = '0' * 36

# Read input from file
with open('input.txt', 'r') as file:
    for line in file:
        line = line.strip()

        # If line starts with 'mask', update mask
        if line.startswith('mask'):
            mask = line.split('=')[1].strip()

        # If line starts with 'mem', update memory
        elif line.startswith('mem'):
            addr, value = map(int, re.findall(r'\d+', line))
            value_binary = format(value, '036b')
            masked_value = ''.join([bit if mask_bit == 'X' else mask_bit for bit, mask_bit in zip(value_binary, mask)])
            masked_value = int(masked_value, 2)
            memory[addr] = masked_value

# Calculate sum of all memory values
total_sum = sum(memory.values())

print(total_sum)
",1
139,2020,15,1,wrong_output,"The 2020th number spoken is: 468
",468,,"
from typing import Dict, List

def generate_sequence(starting_numbers: List[int], num_turns: int) -> List[int]:
    """"""
    Given the starting numbers and the number of turns, generates the sequence according to the game rules.
    :param starting_numbers: List[int]
    :param num_turns: int
    :return: List[int]
    """"""
    sequence = [0] * (num_turns + 1)
    sequence[0:len(starting_numbers)] = starting_numbers
    last_spoken_number = starting_numbers[-1]
    last_spoken_indices: Dict[int, List[int]] = {}
    for i, num in enumerate(starting_numbers):
        last_spoken_indices[num] = [i + 1]

    for i in range(len(starting_numbers) + 1, num_turns + 1):
        if len(last_spoken_indices[last_spoken_number]) == 1:
            next_number = 0
        else:
            next_number = last_spoken_indices[last_spoken_number][-1] - last_spoken_indices[last_spoken_number][-2]
        sequence[i] = next_number
        if next_number in last_spoken_indices:
            last_spoken_indices[next_number].append(i)
        else:
            last_spoken_indices[next_number] = [i]
        last_spoken_number = next_number

    return sequence

def find_nth_number_spoken(starting_numbers: List[int], n: int) -> int:
    """"""
    Given the starting numbers and the nth position, finds the nth number spoken.
    :param starting_numbers: List[int]
    :param n: int
    :return: int
    """"""
    sequence = generate_sequence(starting_numbers, n)
    return sequence[n]

if __name__ == ""__main__"":
    with open(""input.txt"", ""r"") as file:
        starting_numbers = [int(num) for num in file.read().strip().split("","")]
    n = 2020
    print(f""The {n}th number spoken is: {find_nth_number_spoken(starting_numbers, n)}"")
",2
140,2020,16,1,syntax_error,,26026,"  File ""/tmp/tmp_2bge50a/tmp.py"", line 33
    fields['class'] = [list(map(int, re.findall(r'\d+', line))]
                                                              ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import re

def validate_range(value, ranges):
    for r in ranges:
        if value in range(r[0], r[1] + 1):
            return True
    return False

def find_invalid_values(ticket, fields):
    invalid_values = []
    for value in ticket:
        valid = False
        for field, ranges in fields.items():
            if validate_range(value, ranges):
                valid = True
                break
        if not valid:
            invalid_values.append(value)
    return invalid_values

def main():
    input_file = open('input.txt', 'r')
    lines = input_file.readlines()
    
    fields = {}
    tickets = []
    for line in lines:
        line = line.strip()
        if line.startswith('your'):
            break
        if line.startswith('class'):
            fields['class'] = [list(map(int, re.findall(r'\d+', line))]
        elif line.startswith('row'):
            fields['row'] = [list(map(int, re.findall(r'\d+', line))]
        elif line.startswith('seat'):
            fields['seat'] = [list(map(int, re.findall(r'\d+', line))]
        elif line:
            tickets.append(list(map(int, line.split(',')))
    
    error_rate = 0
    for ticket in tickets:
        invalid_values = find_invalid_values(ticket, fields)
        error_rate += sum(invalid_values)
    
    print(error_rate)

if __name__ == '__main__':
    main()


def validate_range(value, ranges):
    for r in ranges:
        if value in range(r[0], r[1] + 1):
            return True
    return False

def find_invalid_values(ticket, fields):
    invalid_values = []
    for value in ticket:
        valid = False
        for field, ranges in fields.items():
            if validate_range(value, ranges):
                valid = True
                break
        if not valid:
            invalid_values.append(value)
    return invalid_values

def main():
    input_file = open('input.txt', 'r')
    lines = input_file.readlines()
    
    fields = {}
    tickets = []
    for line in lines:
        line = line.strip()
        if line.startswith('your'):
            break
        if line.startswith('class'):
            fields['class'] = [list(map(int, re.findall(r'\d+', line))]
        elif line.startswith('row'):
            fields['row'] = [list(map(int, re.findall(r'\d+', line))]
        elif line.startswith('seat'):
            fields['seat'] = [list(map(int, re.findall(r'\d+', line))]
        elif line:
            tickets.append(list(map(int, line.split(',')))
    
    error_rate = 0
    for ticket in tickets:
        invalid_values = find_invalid_values(ticket, fields)
        error_rate += sum(invalid_values)
    
    print(error_rate)

if __name__ == '__main__':
    main()
",2
141,2020,17,1,runtime_error,,263,"Traceback (most recent call last):
  File ""/tmp/tmphxuf6yus/tmp.py"", line 45, in <module>
    main()
  File ""/tmp/tmphxuf6yus/tmp.py"", line 39, in main
    cubes = parse_input(input_data)
  File ""/tmp/tmphxuf6yus/tmp.py"", line 18, in parse_input
    cubes[(x, y, 0) - (len(input_data) // 2, len(input_data[0]) // 2, 0)] = 1
TypeError: unsupported operand type(s) for -: 'tuple' and 'tuple'
","
import re
import sys
from collections import defaultdict
from itertools import product
import os

def read_input():
    with open(""input.txt"", ""r"") as file:
        input_data = file.read().strip()
    return input_data

def parse_input(input_data):
    cubes = defaultdict(int)
    for y, line in enumerate(input_data.split(""\n"")):
        for x, char in enumerate(line):
            if char == ""#"":
                cubes[(x, y, 0) - (len(input_data) // 2, len(input_data[0]) // 2, 0)] = 1
    return cubes

def get_neighbors(cube):
    x, y, z = cube
    for dx, dy, dz in product(range(-1, 2), repeat=3):
        if (dx, dy, dz) != (0, 0, 0):
            yield (x + dx, y + dy, z + dz)

def simulate_cycle(cubes):
    new_cubes = defaultdict(int)
    for cube in set(cubes) | set(n for c in cubes for n in get_neighbors(cube)):
        count = sum(cubes[n] for n in get_neighbors(cube))
        if cubes[cube] and count in {2, 3}:
            new_cubes[cube] = 1
        elif count == 3:
            new_cubes[cube] = 1
    return new_cubes

def main():
    input_data = read_input()
    cubes = parse_input(input_data)
    for _ in range(6):
        cubes = simulate_cycle(cubes)
    print(sum(cubes.values()))

if __name__ == ""__main__"":
    main()


def read_input():
    with open(""input.txt"", ""r"") as file:
        input_data = file.read().strip()
    return input_data

def parse_input(input_data):
    cubes = {}
    for y, line in enumerate(input_data.split(""\n"")):
        for x, char in enumerate(line):
            if char == ""#"":
                cubes[(x, y, 0) - (len(input_data) // 2, len(input_data[0]) // 2, 0)] = 1
    return cubes

def get_neighbors(cube):
    x, y, z = cube
    for dx, dy, dz in ((-1, -1, -1), (-1, -1, 0), (-1, -1, 1), (-1, 0, -1), (-1, 0, 0), (-1, 0, 1), (-1, 1, -1), (-1, 1, 0), (-1, 1, 1), (0, -1, -1), (0, -1, 0), (0, -1, 1), (0, 0, -1), (0, 0, 1), (0, 1, -1), (0, 1, 0), (0, 1, 1), (1, -1, -1), (1, -1, 0), (1, -1, 1), (1, 0, -1), (1, 0, 0), (1, 0, 1), (1, 1, -1), (1, 1, 0), (1, 1, 1)):
        yield (x + dx, y + dy, z + dz)

def simulate_cycle(cubes):
    new_cubes = {}
    for cube in set(cubes) | set(n for c in cubes for n in get_neighbors(cube)):
        count = sum(cubes.get(n, 0) for n in get_neighbors(cube))
        if cubes.get(cube, 0) and count in {2, 3}:
            new_cubes[cube] = 1
        elif count == 3:
            new_cubes[cube] = 1
    return new_cubes

def main():
    input_data = read_input()
    cubes = parse_input(input_data)
    for _ in range(6):
        cubes = simulate_cycle(cubes)
    print(sum(cubes.values()))

if __name__ == ""__main__"":
    main()
",2
142,2020,18,1,runtime_error,,31142189909908,"Traceback (most recent call last):
  File ""/tmp/tmpf65a_r_4/tmp.py"", line 30, in <module>
    result += evaluate_expression(line)
  File ""/tmp/tmpf65a_r_4/tmp.py"", line 8, in evaluate_expression
    result = evaluate_expression(sub_expression)
  File ""/tmp/tmpf65a_r_4/tmp.py"", line 8, in evaluate_expression
    result = evaluate_expression(sub_expression)
  File ""/tmp/tmpf65a_r_4/tmp.py"", line 8, in evaluate_expression
    result = evaluate_expression(sub_expression)
  File ""/tmp/tmpf65a_r_4/tmp.py"", line 19, in evaluate_expression
    part = int(part)
ValueError: invalid literal for int() with base 10: ' '
","import re

def evaluate_expression(expression):
    while '(' in expression:
        start_index = expression.find('(')
        end_index = expression.rfind(')')
        sub_expression = expression[start_index+1:end_index]
        result = evaluate_expression(sub_expression)
        expression = expression[:start_index] + str(result) + expression[end_index+1:]
    parts = re.split('(\+|\*)', expression)
    result = int(parts[0])
    operator = '+'
    for part in parts[1:]:
        if part == '+':
            operator = '+'
        elif part == '*':
            operator = '*'
        else:
            part = int(part)
            if operator == '+':
                result += part
            elif operator == '*':
                result *= part
    return result

with open('input.txt', 'r') as file:
    result = 0
    for line in file:
        line = line.strip()
        result += evaluate_expression(line)
    print(result) ",2
143,2020,19,1,wrong_output,"0
",173,,"
import re

def generate_pattern(rules, current_rule):
    pattern = ""(""
    for rule in rules[current_rule]:
        if rule.isnumeric():
            pattern += generate_pattern(rules, rule)
        else:
            pattern += rule
    pattern += "")""
    return pattern

def part1(rules, messages):
    pattern = ""^"" + generate_pattern(rules, ""0"") + ""$""
    regex = re.compile(pattern)
    valid_messages = 0
    for message in messages:
        if regex.match(message):
            valid_messages += 1
    return valid_messages

with open(""input.txt"", ""r"") as f:
    lines = f.readlines()
    rules = {}
    messages = []

    parsing_rules = True
    for line in lines:
        line = line.strip()
        if line == """":
            parsing_rules = False
            continue
        if parsing_rules:
            number, rule = line.split("": "")
            if '""' in rule:
                rules[number] = rule.replace('""', """")
            else:
                rules[number] = [sub_rule.strip() for sub_rule in rule.split(""|"")]
        else:
            messages.append(line)

    valid_messages = part1(rules, messages)
    print(valid_messages)
",2
144,2020,20,1,syntax_error,,15003787688423,"  File ""/tmp/tmp22s5nmw7/tmp.py"", line 30
    def generate_orientations(tile):
    ^
SyntaxError: invalid syntax
","
import re
from collections import defaultdict

# Read input.txt and store tiles in a dictionary
with open(""input.txt"", ""r"") as file:
    lines = file.readlines()
    tiles = {}
    tile_id = None
    tile = []
    for line in lines:
        line = line.strip()
        if line.startswith(""Tile""):
            tile_id = int(re.search(r""\d+"", line).group())
            tile = []
        elif line == """":
            tiles[tile_id] = tile
        else:
            tile.append(line)

# Function to rotate a tile
def rotate(tile):
    return [''.join(row[::-1] for row in [''.join(tile)[i] for i in range(len(tile[0])-1, -1, -1)])]

# Function to flip a tile
def flip_horizontal(tile):
    return [''.join(row[::-1] for row in tile)

# Function to generate all possible orientations of a tile
def generate_orientations(tile):
    for _ in range(4):
        yield tile
        tile = rotate(tile)
    tile = flip_horizontal(tile)
    for _ in range(4):
        yield tile
        tile = rotate(tile)

# Create a dictionary of borders for each tile
borders = defaultdict(set)
for tile_id, tile in tiles.items():
    for orientation in generate_orientations(tile):
        borders[tile_id].add(''.join(orientation[0]))
        borders[tile_id].add(''.join(orientation[-1]))
        borders[tile_id].add(''.join(row[0] for row in orientation))
        borders[tile_id].add(''.join(row[-1] for row in orientation))

# Create a graph of tile neighbors based on border matching
neighbors = defaultdict(set)
for tile_id, border_set in borders.items():
    for other_id, other_border_set in borders.items():
        if tile_id != other_id and bool(border_set & other_border_set):
            neighbors[tile_id].add(other_id)

# Determine which tile is in the top-left corner by counting the number of neighbors
corner_tile_ids = [tile_id for tile_id, neighbor_set in neighbors.items() if len(neighbor_set) == 2]

# Assemble the image
image = []
row_size = int(len(tiles) ** 0.5)
for y in range(row_size):
    for x in range(row_size):
        if x == 0 and y == 0:
            tile_id = corner_tile_ids[0]
        else:
            for neighbor_id in neighbors[tile_id]:
                for orientation in generate_orientations(tiles[neighbor_id]):
                    if any(border in borders[tile_id] for border in [''.join(orientation[0]), ''.join(orientation[-1]), ''.join(row[0] for row in orientation), ''.join(row[-1] for row in orientation)]):
                        tiles[neighbor_id] = orientation
                        tile_id = neighbor_id
                        break
                else:
                    continue
                break
        image.append(tiles[tile_id][1:-1])
        if x == 0:
            tiles[tile_id] = rotate(tiles[tile_id])
        else:
            tiles[tile_id] = rotate(rotate(rotate(flip_horizontal(tiles[tile_id])))
        neighbors[tile_id].remove(prev_tile_id)
        prev_tile_id = tile_id

# Calculate the result
result = 1
for tile_id in corner_tile_ids:
    result *= tile_id
print(result)
",2
145,2020,21,1,wrong_output,"0
",2542,,"
from collections import Counter

# initialize a dictionary to store the allergens and their corresponding ingredients
allergen_dict = {}
# initialize a set to store the ingredients that are potential allergens
potential_allergens = set()
# initialize a list to store the foods
foods = []

# read the input file
with open(""input.txt"", ""r"") as file:
    for line in file:
        # extract the ingredients and their potential allergens
        ingredients, allergens = line.strip().split(""(contains"")
        ingredients = ingredients.strip().split()
        allergens = allergens[1:-1].strip().split("", "") if ""contains"" in line else []
        
        # add the allergens and their corresponding ingredients to the allergen_dict
        for allergen in allergens:
            if allergen in allergen_dict:
                allergen_dict[allergen] &= set(ingredients)
            else:
                allergen_dict[allergen] = set(ingredients)
        
        # add all the ingredients to the potential_allergens set
        potential_allergens |= set(ingredients)
        
        # add the food to the foods list
        foods.append(ingredients)

# find the ingredients that don't contain any allergens
non_allergen_ingredients = set(foods[0])
for ingredient_list in foods:
    for ingredient in ingredient_list:
        if ingredient in potential_allergens:
            non_allergen_ingredients -= set([ingredient])

# count the frequency of non-allergen ingredients
count = Counter()
for ingredient_list in foods:
    for ingredient in ingredient_list:
        if ingredient in non_allergen_ingredients:
            count[ingredient] += 1

# print the total count
print(sum(count.values()))
",2
146,2020,22,1,syntax_error,,34255,"  File ""/tmp/tmp_taa2l_m/tmp.py"", line 21
    round_number = 0
    ^
SyntaxError: invalid syntax
","
import os

# Open and read the input file
with open(""input.txt"", ""r"") as f:
    data = f.readlines()

# Create two empty lists for each player's cards
player1_cards = []
player2_cards = []

# Load the cards into the appropriate lists
for line in data:
    line = line.strip()
    if line.startswith(""Player 1""):
        player1_cards.append(int(line.split("":"")[1]))
    elif line.startswith(""Player 2""):
        player2_cards.append(int(line.split("":"")[1])

# Initialize the game variables
round_number = 0
total_rounds = 1
winner = None

# Play the game until a winner is determined
while not winner:
    round_number += 1
    print(f""-- Round {round_number} --"")
    print(f""Player 1's deck: {player1_cards}"")
    print(f""Player 2's deck: {player2_cards}"")

    # Draw the top cards
    card1 = player1_cards.pop(0)
    card2 = player2_cards.pop(0)

    # Determine the winner of the round
    if card1 > card2:
        print(f""Player 1 wins the round!"")
        player1_cards.append(card1)
        player1_cards.append(card2)
    else:
        print(f""Player 2 wins the round!"")
        player2_cards.append(card2)
        player2_cards.append(card1)

    # Check if a player has won
    if not player1_cards:
        winner = 2
    elif not player2_cards:
        winner = 1

    print()

# Calculate the winning player's score
if winner == 1:
    winning_deck = player1_cards
else:
    winning_deck = player2_cards

score = 0
for i, card in enumerate(winning_deck[::-1]):
    score += (i+1) * card

print(f""== Post-game results =="")
print(f""Winning player's deck: {winning_deck}"")
print(f""Winning player's score: {score}"")
",2
147,2020,23,1,wrong_output,"27483951
27483951
",49576328,,"
from collections import deque

def simulate_game(cups, num_moves=100):
    cups = deque(cups)
    current_cup = cups[0]
    for _ in range(num_moves):
        # Pick up three cups clockwise
        picked_cups = [cups.popleft(), cups.popleft(), cups.popleft()]
        destination_cup = current_cup - 1
        if destination_cup < min(cups):
            destination_cup = max(cups)
        while destination_cup in picked_cups:
            destination_cup -= 1
            if destination_cup < min(cups):
                destination_cup = max(cups)
        # Find the destination cup index
        destination_index = cups.index(destination_cup)
        # Place the picked up cups immediately clockwise of the destination cup
        cups.insert(destination_index+1, picked_cups[2])
        cups.insert(destination_index+1, picked_cups[1])
        cups.insert(destination_index+1, picked_cups[0])
        # Select new current cup
        current_index = cups.index(current_cup)
        current_cup = cups[(current_index + 1) % len(cups)]
    return cups

# Read the input
with open('input.txt', 'r') as f:
    initial_cups = [int(c) for c in f.read().strip()]

# Simulate 100 moves
final_cups = simulate_game(initial_cups, 100)

# Get the labeling after cup 1
labeling = ''.join(str(c) for c in list(final_cups)[1:])
print(labeling)


def simulate_game(cups, num_moves=100):
    cups = deque(cups)
    current_cup = cups[0]
    for _ in range(num_moves):
        # Pick up three cups clockwise
        picked_cups = [cups.popleft(), cups.popleft(), cups.popleft()]
        destination_cup = current_cup - 1
        if destination_cup < min(cups):
            destination_cup = max(cups)
        while destination_cup in picked_cups:
            destination_cup -= 1
            if destination_cup < min(cups):
                destination_cup = max(cups)
        # Find the destination cup index
        destination_index = cups.index(destination_cup)
        # Place the picked up cups immediately clockwise of the destination cup
        cups.insert(destination_index+1, picked_cups[2])
        cups.insert(destination_index+1, picked_cups[1])
        cups.insert(destination_index+1, picked_cups[0])
        # Select new current cup
        current_index = cups.index(current_cup)
        current_cup = cups[(current_index + 1) % len(cups)]
    return cups

# Read the input
with open('input.txt', 'r') as f:
    initial_cups = [int(c) for c in f.read().strip()]

# Simulate 100 moves
final_cups = simulate_game(initial_cups, 100)

# Get the labeling after cup 1
labeling = ''.join(str(c) for c in list(final_cups)[1:])
print(labeling)
",2
148,2020,24,1,runtime_error,,356,"Traceback (most recent call last):
  File ""/tmp/tmp_z6nsv9y/tmp.py"", line 46, in <module>
    flipped_tiles = process_input(sys.argv[1])
IndexError: list index out of range
","
import sys
from collections import defaultdict

def hex_direction(direction, current_hex):
    if direction == 'e':
        return (current_hex[0] + 1, current_hex[1])
    elif direction == 'w':
        return (current_hex[0] - 1, current_hex[1])
    elif direction == 'ne':
        if current_hex[1] % 2 == 0:
            return (current_hex[0] - 1, current_hex[1] + 1)
        else:
            return (current_hex[0], current_hex[1] + 1)
    elif direction == 'nw':
        if current_hex[1] % 2 == 0:
            return (current_hex[0], current_hex[1] + 1)
        else:
            return (current_hex[0] - 1, current_hex[1])
    elif direction == 'se':
        if current_hex[1] % 2 == 0:
            return (current_hex[0] + 1, current_hex[1] - 1)
        else:
            return (current_hex[0], current_hex[1] - 1)
    elif direction == 'sw':
        if current_hex[1] % 2 == 0:
            return (current_hex[0] + 1, current_hex[1])
        else:
            return (current_hex[0], current_hex[1] - 1)

def process_input(filename):
    flipped_tiles = defaultdict(bool)
    with open(filename, 'r') as f:
        for line in f.readlines():
            current_hex = (0, 0)
            directions = line.strip()
            for direction in directions:
                current_hex = hex_direction(direction, current_hex)
            flipped_tiles[current_hex] = not flipped_tiles[current_hex]
    return flipped_tiles

def count_black_tiles(flipped_tiles):
    return sum(1 for tile in flipped_tiles.values() if tile)

if __name__ == ""__main__"":
    flipped_tiles = process_input(sys.argv[1])
    black_tiles = count_black_tiles(flipped_tiles)
    print(f""The number of tiles with the black side up is: {black_tiles}"")
",2
149,2020,25,1,timeout_error,,711945,TIMEOUT,"
import math

def transform_subject_number(subject_number, loop_size):
    value = 1
    for _ in range(loop_size):
        value *= subject_number
        value %= 2020127
    return value

def find_loop_size(public_key, subject_number=7):
    value = 1
    loop_size = 0
    while value != public_key:
        loop_size += 1
        value *= subject_number
        value %= 2020127
    return loop_size

def find_encryption_key(card_public_key, door_public_key, subject_number=7):
    card_loop_size = find_loop_size(card_public_key, subject_number)
    door_loop_size = find_loop_size(door_public_key, subject_number)
    encryption_key = transform_subject_number(door_public_key, card_loop_size)
    return encryption_key

def main():
    with open('input.txt', 'r') as file:
        card_public_key, door_public_key = [int(line.strip()) for line in file.readlines()]
    encryption_key = find_encryption_key(card_public_key, door_public_key)
    print(f""The encryption key is: {encryption_key}"")

if __name__ == ""__main__"":
    main()
",2
150,2021,1,1,no_error,"1532
",1532,,"
import os

file_path = 'input.txt'

if os.path.exists(file_path):
    with open(file_path, 'r') as file:
        depths = [int(line.strip()) for line in file.readlines()]
        increases = 0
        for i in range(1, len(depths)):
            if depths[i] > depths[i-1]:
                increases += 1
        print(increases)
else:
    print(""File not found"")
",0
151,2021,2,1,no_error,"1990000
",1990000,,"
import os

horizontal_position = 0
depth = 0

with open('input.txt', 'r') as file:
    for line in file:
        command, value = line.split()
        if command == 'forward':
            horizontal_position += int(value)
        elif command == 'down':
            depth += int(value)
        elif command == 'up':
            depth -= int(value)

print(horizontal_position * depth)
",1
152,2021,3,1,wrong_output,"Gamma rate: 101100100001, Epsilon rate: 010011011110, Power consumption: 3549854
",3549854,,"
def read_input_file():
    with open('input.txt', 'r') as file:
        data = file.readlines()
    return data

def most_common_bit(bit_list):
    return '1' if bit_list.count('1') >= bit_list.count('0') else '0'

def least_common_bit(bit_list):
    return '0' if bit_list.count('0') <= bit_list.count('1') else '1'

def calculate_gamma_rate(diagnostic_report):
    gamma_rate = ''
    for i in range(len(diagnostic_report[0].strip())):
        column_bits = [report[i] for report in diagnostic_report]
        gamma_rate += most_common_bit(column_bits)
    return gamma_rate

def calculate_epsilon_rate(diagnostic_report):
    epsilon_rate = ''
    for i in range(len(diagnostic_report[0].strip())):
        column_bits = [report[i] for report in diagnostic_report]
        epsilon_rate += least_common_bit(column_bits)
    return epsilon_rate

def main():
    diagnostic_report = read_input_file()
    gamma_rate = calculate_gamma_rate(diagnostic_report)
    epsilon_rate = calculate_epsilon_rate(diagnostic_report)
    power_consumption = int(gamma_rate, 2) * int(epsilon_rate, 2)
    print(f""Gamma rate: {gamma_rate}, Epsilon rate: {epsilon_rate}, Power consumption: {power_consumption}"")

if __name__ == '__main__':
    main()
",2
153,2021,4,1,runtime_error,,49860,"Traceback (most recent call last):
  File ""/tmp/tmp2z4c6j01/tmp.py"", line 3, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import sys
import numpy as np

# Read input file
with open('input.txt', 'r') as f:
    data = f.readlines()

# Get bingo numbers and boards
bingo_numbers = [int(num) for num in data[0].strip().split(',')]
num_boards = int((len(data) - 1) / 6)
boards = np.array([[list(map(int, line.strip().split())) for line in data[i*6+1:i*6+6]] for i in range(num_boards)])

# Play bingo
for num in bingo_numbers:
    boards[boards == num] = -1
    for i in range(num_boards):
        if np.max(np.sum(boards[i], axis=0)) == -5 or np.max(np.sum(boards[i], axis=1)) == -5:
            board_sum = np.sum(boards[i][boards[i] != -1])
            final_score = board_sum * num
            print(final_score)
            sys.exit()
        if np.max(np.sum(boards, axis=0)[i]) == -5 or np.max(np.sum(boards, axis=1)[i]) == -5:
            board_sum = np.sum(boards[i][boards[i] != -1])
            final_score = board_sum * num
            print(final_score)
            sys.exit()
",2
154,2021,5,1,syntax_error,,6710,"  File ""/tmp/tmpxo3b8gsv/tmp.py"", line 10
    vents.append([[x1, y1, x2, y2])
                                  ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys

def main():
    with open('input.txt', 'r') as file:
        lines = file.readlines()
        vents = []
        for line in lines:
            x1, y1, x2, y2 = map(int, line.strip().replace(' -> ', ',').split(','))
            vents.append([[x1, y1, x2, y2])

        max_x = max([max(x1, x2) for x1, y1, x2, y2 in vents]) + 1
        max_y = max([max(y1, y2) for x1, y1, x2, y2 in vents]) + 1

        grid = [[0] * max_x for _ in range(max_y)]

        for x1, y1, x2, y2 in vents:
            if x1 == x2:
                for y in range(min(y1, y2), max(y1, y2) + 1):
                    grid[y][x1] += 1
            elif y1 == y2:
                for x in range(min(x1, x2), max(x1, x2) + 1):
                    grid[y1][x] += 1

        overlaps = sum(sum(1 for row in grid for cell in row if cell > 1)
        print(overlaps)

if __name__ == ""__main__"":
    main()
",2
155,2021,6,1,syntax_error,,380243,"  File ""/tmp/tmpydvjhb8j/tmp.py"", line 7
    state = initial_state.copy()
    ^
SyntaxError: invalid syntax
","
import sys

def simulate_lanternfish(input_file, days):
    with open(input_file, 'r') as file:
        initial_state = list(map(int, file.readline().strip().split(','))
    state = initial_state.copy()
    for _ in range(days):
        new_fish = state.count(0)
        state = [timer - 1 if timer > 0 else 6 for timer in state] + [8] * new_fish
        state = [timer for timer in state if timer != 0]
    return len(state)

input_file = sys.argv[1]
days = int(sys.argv[2])
result = simulate_lanternfish(input_file, days)
print(f""After {days} days, there will be {result} lanternfish."")
",2
156,2021,7,1,no_error,"344297
",344297,,"
import math

def align_crabs(crabs):
    # Define a list to store the fuel costs for each possible position
    fuel_costs = []

    # Determine the range of horizontal positions
    min_pos = min(crabs)
    max_pos = max(crabs)

    # Iterate over each possible position
    for pos in range(min_pos, max_pos + 1):
        # Calculate the fuel cost for this position
        fuel_cost = sum([abs(crab - pos) for crab in crabs])

        # Add the fuel cost to the list
        fuel_costs.append(fuel_cost)

    # Return the minimum fuel cost
    return min(fuel_costs)

# Read input from file
with open(""input.txt"", ""r"") as f:
    crabs = [int(x) for x in f.readline().strip().split("","")]

# Align the crabs and print the minimum fuel cost
print(align_crabs(crabs))
",0
157,2021,8,1,no_error,"440
",440,,"
import re

def count_easy_digits(filename):
    count = 0
    with open(filename, 'r') as f:
        for line in f:
            output_values = line.split('|')[-1].strip().split()
            for value in output_values:
                if len(value) in [2, 3, 4, 7]:
                    count += 1
    return count

print(count_easy_digits('input.txt'))
",0
158,2021,9,1,syntax_error,,462,"  File ""/tmp/tmpegihim7m/tmp.py"", line 36
    else:
    ^
SyntaxError: invalid syntax
","
import os
from functools import reduce

def find_low_points(heightmap):
    low_points = []
    for i in range(len(heightmap)):
        for j in range(len(heightmap[i])):
            if i == 0:
                if j == 0:
                    if heightmap[i][j] < heightmap[i][j+1] and heightmap[i][j] < heightmap[i+1][j]:
                        low_points.append((i, j))
                elif j == len(heightmap[i]) - 1:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i+1][j]:
                        low_points.append((i, j))
                else:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i+1][j] and heightmap[i][j] < heightmap[i][j+1]:
                        low_points.append((i, j))
            elif i == len(heightmap) - 1:
                if j == 0:
                    if heightmap[i][j] < heightmap[i][j+1] and heightmap[i][j] < heightmap[i-1][j]:
                        low_points.append((i, j))
                elif j == len(heightmap[i]) - 1:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i-1][j]:
                        low_points.append((i, j))
                else:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i-1][j] and heightmap[i][j] < heightmap[i][j+1]:
                        low_points.append((i, j))
            else:
                if j == 0:
                    if heightmap[i][j] < heightmap[i][j+1] and heightmap[i][j] < heightmap[i-1][j] and heightmap[i][j] < heightmap[i+1][j]:
                        low_points.append((i, j))
                elif j == len(heightmap[i]) - 1:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i-1][j] and heightmap[i][j] < heightmap[i+1][j]:
                        low_points.append((i, j)
                else:
                    if heightmap[i][j] < heightmap[i][j-1] and heightmap[i][j] < heightmap[i-1][j] and heightmap[i][j] < heightmap[i][j+1] and heightmap[i][j] < heightmap[i+1][j]:
                        low_points.append((i, j)
    return low_points

def risk_level(heightmap, low_points):
    risk = 0
    for point in low_points:
        risk += heightmap[point[0]][point[1]] + 1
    return risk

def main():
    with open(""input.txt"", ""r"") as f:
        heightmap = [list(map(int, line.strip()) for line in f.readlines())]
    low_points = find_low_points(heightmap)
    risk = risk_level(heightmap, low_points)
    print(risk)

if __name__ == ""__main__"":
    main()
",2
159,2021,10,1,wrong_output,"Total syntax error score: 299793
",299793,,"
def read_input_file(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
    return [line.strip() for line in lines]

def find_corrupted_chunks(line):
    opening_chars = ['(', '[', '{', '<']
    closing_chars = [')', ']', '}', '>']
    matching_chars = [')', ']', '}', '>']
    corrupted_chunks = []
    for line in lines:
        stack = []
        for char in line:
            if char in opening_chars:
                stack.append(char)
            elif char in closing_chars:
                if not stack or closing_chars[opening_chars.index(stack[-1])] != char:
                    corrupted_chunks.append(char)
                    break
                else:
                    stack.pop()
    return corrupted_chunks

def calculate_score(corrupted_chunks):
    score = 0
    for char in corrupted_chunks:
        if char == ')':
            score += 3
        elif char == ']':
            score += 57
        elif char == '}':
            score += 1197
        elif char == '>':
            score += 25137
    return score

lines = read_input_file('input.txt')
corrupted_chunks = find_corrupted_chunks(lines)
score = calculate_score(corrupted_chunks)
print(""Total syntax error score:"", score)
",2
160,2021,11,1,syntax_error,,1793,"  File ""/tmp/tmp9zmsvuq6/tmp.py"", line 38
    def simulate_steps(octopuses: List[List[int], steps: int) -> int:
                                                            ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List

def get_adjacent_indices(i: int, j: int, max_i: int, max_j: int) -> List[tuple]:
    adjacent_indices = []
    for di in [-1, 0, 1]:
        for dj in [-1, 0, 1]:
            if di == 0 and dj == 0:
                continue
            new_i = i + di
            new_j = j + dj
            if 0 <= new_i < max_i and 0 <= new_j < max_j:
                adjacent_indices.append((new_i, new_j))
    return adjacent_indices

def simulate_step(octopuses: List[List[int]]) -> int:
    flashed_indices = set()
    flashes = 0
    for i in range(len(octopuses)):
        for j in range(len(octopuses[0])):
            octopuses[i][j] += 1
            if octopuses[i][j] > 9:
                flashed_indices.add((i, j))
                flashes += 1
    while flashed_indices:
        new_flashed_indices = set()
        for i, j in flashed_indices:
            for adjacent_i, adjacent_j in get_adjacent_indices(i, j, len(octopuses), len(octopuses[0])):
                octopuses[adjacent_i][adjacent_j] += 1
                if octopuses[adjacent_i][adjacent_j] > 9 and (adjacent_i, adjacent_j) not in flashed_indices and (adjacent_i, adjacent_j) not in new_flashed_indices:
                    new_flashed_indices.add((adjacent_i, adjacent_j))
                    flashes += 1
        for i, j in flashed_indices:
            octopuses[i][j] = 0
        flashed_indices = new_flashed_indices
    return flashes

def simulate_steps(octopuses: List[List[int], steps: int) -> int:
    total_flashes = 0
    for _ in range(steps):
        total_flashes += simulate_step(octopuses)
    return total_flashes

def read_input(file_name: str) -> List[List[int]]:
    with open(file_name, 'r') as file:
        return [[int(char) for char in line.strip()] for line in file.readlines()]

if __name__ == ""__main__"":
    octopuses = read_input(""input.txt"")
    total_flashes = simulate_steps(octopuses, 100)
    print(total_flashes)
",2
161,2021,12,1,wrong_output,"21953
",3887,,"
import re
from collections import defaultdict
from itertools import permutations

def find_paths(graph, path=None, small_cave_visited=None):
    if path is None:
        path = ['start']
    if small_cave_visited is None:
        small_cave_visited = defaultdict(int)

    if path[-1] == 'end':
        return [path]

    paths = []
    for node in graph[path[-1]]:
        if node.isupper() or node not in small_cave_visited:
            new_path = path.copy()
            new_path.append(node)
            new_small_cave_visited = small_cave_visited.copy()
            if node.islower():
                new_small_cave_visited[node] += 1
            paths.extend(find_paths(graph, new_path, new_small_cave_visited))
        elif node != 'start' and small_cave_visited[node] == 0:
            new_path = path.copy()
            new_path.append(node)
            new_small_cave_visited = small_cave_visited.copy()
            new_small_cave_visited[node] += 1
            paths.extend(find_paths(graph, new_path, new_small_cave_visited))
    return paths

def create_graph(connections):
    graph = defaultdict(list)
    for connection in connections:
        node1, node2 = re.findall('[a-zA-Z]+', connection)
        graph[node1].append(node2)
        graph[node2].append(node1)
    return graph

def main():
    with open('input.txt', 'r') as file:
        connections = file.readlines()
        graph = create_graph(connections)
        paths = find_paths(graph)
        print(len(paths))

if __name__ == '__main__':
    main()
",2
162,2021,13,1,wrong_output,"After the first fold, there are 712 visible dots.
###..#....#..#.####...##.###....##.####
#..#.#....#..#.#.......#.#..#....#.#...
###..#....####.###.....#.#..#....#.###.
#..#.#....#..#.#.......#.###.....#.#...
#..#.#....#..#.#....#..#.#....#..#.#...
###..####.#..#.#.....##..#.....##..#...
",712,,"
import re
from collections import defaultdict

def fold_paper(dots, instruction):
    axis, value = instruction.split('=')
    value = int(value)
    new_dots = set()
    if axis == 'x':
        for x, y in dots:
            if x < value:
                new_dots.add((x, y))
            else:
                new_dots.add((2*value - x, y))
    elif axis == 'y':
        for x, y in dots:
            if y < value:
                new_dots.add((x, y))
            else:
                new_dots.add((x, 2*value - y))
    return new_dots

def print_paper(dots):
    max_x = max(x for x, _ in dots)
    max_y = max(y for _, y in dots)
    for y in range(max_y+1):
        for x in range(max_x+1):
            print('#' if (x, y) in dots else '.', end='')
        print()

input_file = open('input.txt', 'r')
dots = []
folds = []
for line in input_file:
    line = line.strip()
    if not line:
        continue
    if ',' in line:
        x, y = [int(i) for i in line.split(',')]
        dots.append((x, y))
    elif 'fold' in line:
        folds.append(line.split()[-1])

dots = set(dots)
for i, fold in enumerate(folds):
    dots = fold_paper(dots, fold)
    if i == 0:
        print(f'After the first fold, there are {len(dots)} visible dots.')

print_paper(dots)
",2
163,2021,14,1,no_error,"2233
",2233,,"
from collections import Counter

def react_polymer(template, rules, num_steps):
    for _ in range(num_steps):
        new_template = template[0]
        for i in range(len(template) - 1):
            pair = template[i:i+2]
            if pair in rules:
                new_template += rules[pair] + pair[1]
            else:
                new_template += pair[1]
        template = new_template
    return template

def count_elements(polymer):
    element_count = Counter(polymer)
    return max(element_count.values()) - min(element_count.values())

def main():
    with open('input.txt', 'r') as file:
        polymer_template = file.readline().strip()
        file.readline()
        rules = {}
        for line in file:
            pair, element = line.strip().split(' -> ')
            rules[pair] = element

    polymer = react_polymer(polymer_template, rules, 10)
    print(count_elements(polymer))

if __name__ == '__main__':
    main()
",1
164,2021,15,1,syntax_error,,423,"  File ""/tmp/tmp2t3mdiic/tmp.py"", line 16
    def dijkstra(cave: List[List[int], start: Tuple[int, int], end: Tuple[int, int]) -> int:
                                                                                   ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import heapq
from collections import defaultdict
from typing import List, Tuple

def get_neighbors(x: int, y: int, max_x: int, max_y: int) -> List[Tuple[int, int]]:
    if x > 0:
        yield x - 1, y
    if x < max_x:
        yield x + 1, y
    if y > 0:
        yield x, y - 1
    if y < max_y:
        yield x, y + 1

def dijkstra(cave: List[List[int], start: Tuple[int, int], end: Tuple[int, int]) -> int:
    queue = [(0, *start)]
    visited = set()
    while queue:
        risk, x, y = heapq.heappop(queue)
        if (x, y) == end:
            return risk
        if (x, y) in visited:
            continue
        visited.add((x, y))
        for neighbor_x, neighbor_y in get_neighbors(x, y, len(cave[0]) - 1, len(cave) - 1):
            new_risk = risk + cave[neighbor_y][neighbor_x]
            heapq.heappush(queue, (new_risk, neighbor_x, neighbor_y))
    return -1

def generate_cave(filename: str) -> List[List[int]]:
    with open(filename, 'r') as file:
        return [[int(num) for num in line.strip()] for line in file.readlines()]

def expand_cave(cave: List[List[int]) -> List[List[int]]:
    expanded_cave = []
    for i in range(5):
        for row in cave:
            new_row = [((num + i + j) % 9) or 9 for num in row]
            expanded_cave.append(new_row)
    for row in expanded_cave:
        new_row = []
        for j in range(5):
            new_row += [(num + j) % 9 or 9 for num in row]
        expanded_cave.append(new_row)
    return expanded_cave

def main():
    cave = generate_cave('input.txt')
    print(""Part 1:"", dijkstra(cave, (0, 0), (len(cave) - 1, len(cave[0]) - 1)))

    expanded_cave = expand_cave(cave)
    print(""Part 2:"", dijkstra(expanded_cave, (0, 0), (len(expanded_cave) - 1, len(expanded_cave[0]) - 1))

if __name__ == ""__main__"":
    main()
",2
165,2021,16,1,runtime_error,,947,"Traceback (most recent call last):
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 55, in <module>
    main()
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 51, in main
    total_version, _, _ = parse_packet(binary_string)
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  [Previous line repeated 4 more times]
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 42, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
  [Previous line repeated 1 more time]
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 31, in parse_packet
    sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
  File ""/tmp/tmpy8n04kc6/tmp.py"", line 12, in parse_packet
    version = int(binary_string[:3], 2)
ValueError: invalid literal for int() with base 2: ''
","
import sys

def hex_to_binary(hex_string):
    binary_representation = {
        '0': '00000', '1': '0001', '2': '0010', '3': '0011', '4': '0100', '5': '0101', '6': '0110', '7': '0111', '8': '1000', '9': '1001',
        'A': '1010', 'B': '1011', 'C': '1100', 'D': '1101', 'E': '1110', 'F': '1111'
    }
    return ''.join([binary_representation[char] for char in hex_string])

def parse_packet(binary_string):
    version = int(binary_string[:3], 2)
    type_id = int(binary_string[3:6], 2)
    if type_id == 4:
        # Literal value packet
        literal_value = ''
        for i in range(6, len(binary_string), 5):
            if binary_string[i] == '0':
                literal_value += binary_string[i+1:i+5]
                return version, i + 5, int(literal_value, 2)
            else:
                literal_value += binary_string[i+1:i+5]
        return version, i + 5, int(literal_value, 2)
    else:
        length_type_id = binary_string[6]
        if length_type_id == '0':
            total_length = int(binary_string[7:22], 2)
            sub_packets_end = 22 + total_length
            sub_packets = []
            while True:
                sub_version, sub_packets_end, sub_value = parse_packet(binary_string[22:sub_packets_end])
                version += sub_version
                sub_packets.append(sub_value)
                if sub_packets_end == len(binary_string):
                    break
            return version, sub_packets_end, sub_packets
        else:
            num_sub_packets = int(binary_string[7:18], 2)
            sub_packets = []
            sub_packets_end = 18
            for _ in range(num_sub_packets):
                sub_version, sub_packets_end, sub_value = parse_packet(binary_string[sub_packets_end:])
                version += sub_version
                sub_packets.append(sub_value)
            return version, sub_packets_end, sub_packets

def main():
    with open('input.txt', 'r') as file:
        hex_string = file.read().strip()
        binary_string = hex_to_binary(hex_string)
        total_version, _, _ = parse_packet(binary_string)
        print(f'Total version sum: {total_version}')

if __name__ == '__main__':
    main()
",2
166,2021,17,1,no_error,"8646
",8646,,"
import re

def find_highest_y_position(x_min, x_max, y_min, y_max):
    highest_y = 0
    for x_velocity in range(1, x_max + 1):
        for y_velocity in range(y_min, -y_min):
            x = 0
            y = 0
            max_y = 0
            velocity_x = x_velocity
            velocity_y = y_velocity
            while x <= x_max and y >= y_min:
                x += velocity_x
                y += velocity_y
                if velocity_x > 0:
                    velocity_x -= 1
                velocity_y -= 1
                max_y = max(max_y, y)
                if x_min <= x <= x_max and y_min <= y <= y_max:
                    highest_y = max(highest_y, max_y)
                    break
            if x_min <= x <= x_max and y_min <= y <= y_max:
                highest_y = max(highest_y, max_y)
    return highest_y

with open('input.txt', 'r') as file:
    input_data = file.readline().strip()
    x_min, x_max, y_min, y_max = map(int, re.findall(r'-?\d+', input_data))
    print(find_highest_y_position(x_min, x_max, y_min, y_max))
",1
167,2021,18,1,syntax_error,,4184,"  File ""/tmp/tmpwq_nh9uq/tmp.py"", line 54
    def snailfish_sum(numbers: List[List[List]) -> List[List]:
                                              ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def add_snailfish(num1: List[List], num2: List[List]) -> List[List]:
    return ['[' + str(num1) + ',' + str(num2) + ']']

def reduce_snailfish(num: List[List]) -> Tuple[List, bool]:
    exploded, num = explode(num)
    if exploded:
        return num, True
    splitted, num = split(num)
    return num, splitted

def explode(num: List[List], depth: int = 0) -> Tuple[bool, List[List]]:
    if isinstance(num[0], int) and isinstance(num[1], int):
        return False, num
    
    if depth == 4:
        return True, [0, 0]

    if isinstance(num[0], list):
        exploded, num[0] = explode(num[0], depth + 1)
        if exploded:
            return True, num

    if isinstance(num[1], list):
        exploded, num[1] = explode(num[1], depth + 1)
        if exploded:
            return True, num

    return False, num

def split(num: List[List]) -> Tuple[bool, List[List]]:
    if isinstance(num, int):
        return num >= 10, [num // 2, num - num // 2]
    
    if isinstance(num[0], list):
        splitted, num[0] = split(num[0])
        if splitted:
            return True, num

    if isinstance(num[1], list):
        splitted, num[1] = split(num[1])
        if splitted:
            return True, num

    return False, num

def magnitude(num: List[List]) -> int:
    if isinstance(num, int):
        return num
    return 3 * magnitude(num[0]) + 2 * magnitude(num[1])

def snailfish_sum(numbers: List[List[List]) -> List[List]:
    result = numbers[0]
    for num in numbers[1:]:
        result = add_snailfish(result, num)
        while True:
            _, result = reduce_snailfish(result)
    return result

input_numbers = []
with open('input.txt', 'r') as file:
    for line in file:
        input_numbers.append(eval(line.strip()))

result = snailfish_sum(input_numbers)
print(magnitude(eval(result))
",2
168,2021,19,1,syntax_error,,405,"  File ""/tmp/tmpqkxnvnma/tmp.py"", line 34
    if len(overlapping_beacons) >= threshold:
                                            ^
SyntaxError: invalid syntax
","
from itertools import combinations
import numpy as np
import re

def read_input(filename):
    scanners = []
    with open(filename, 'r') as file:
        lines = file.readlines()
        scanner = []
        for line in lines:
            if line.startswith('--- scanner'):
                if scanner:
                    scanners.append(scanner)
                    scanner = []
            elif line.strip():
                scanner.append(list(map(int, line.strip().split(','))) + [line.strip().split(',')[3]])
        scanners.append(scanner)
    return scanners

def find_overlapping_beacons(scanner1, scanner2, threshold=12):
    for i in range(24):
        for j in range(24):
            rotated = np.rot90(np.array(scanner2[:-1]), i)
            for k in range(24):
                rotated = np.rot90(rotated, 1, axis=1)
                for x, y in combinations(range(len(scanner1)), 2):
                    x_coords, y_coords = scanner1[x][:3], scanner1[y][:3]
                    for x_shift, y_shift in combinations(range(len(scanner2)-1), 2):
                        x_shift_coords, y_shift_coords = np.array(scanner2[x_shift][:3]), np.array(scanner2[y_shift][:3])
                        shift = x_shift_coords - y_shift_coords
                        translated = rotated + shift
                        overlapping_beacons = set(map(tuple, translated)) & set(map(tuple, np.array(scanner1[:-1]))).union(set(map(tuple, np.array(scanner1[:x] + scanner1[x+1:]))).union(set(map(tuple, np.array(scanner1[:y] + scanner1[y+1:])))
                        if len(overlapping_beacons) >= threshold:
                            return x_coords - x_shift_coords, y_coords - y_shift_coords, rotated, np.array(scanner2[:-1])
    return None

def generate_beacon_map(scanners):
    # initialize the beacon map with the first scanner
    beacon_map = set(map(tuple, scanners[0][:-1]))
    scanner_positions = [(0, 0, 0)]
    while len(scanner_positions) < len(scanners):
        for i, scanner in enumerate(scanners):
            if i in scanner_positions:
                continue
            for j in scanner_positions:
                result = find_overlapping_beacons(scanners[j], scanner)
                if result:
                    x_coords, y_coords, rotated, relative_scanner = result
                    scanner_positions.append(i)
                    scanners[i] = list(map(list, rotated))
                    for beacon in scanners[i]:
                        beacon[:3] = [beacon[:3] + x_coords + y_coords]
                        beacon_map.add(tuple(beacon[:3]))
                    break
    return beacon_map, scanners

def manhattan_distance(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2])

def max_distance(scanners):
    return max(manhattan_distance(a, b) for a, b in combinations(scanners, 2))

def main():
    scanners = read_input('input.txt')
    beacon_map, scanners = generate_beacon_map(scanners)
    print(""Part 1:"", len(beacon_map))
    print(""Part 2:"", max_distance(scanners))

if __name__ == ""__main__"":
    main()
",2
169,2021,20,1,runtime_error,,5682,"Traceback (most recent call last):
  File ""/tmp/tmpw0rjk_r_/tmp.py"", line 2, in <module>
    import numpy as np
ModuleNotFoundError: No module named 'numpy'
","
import numpy as np
from PIL import Image, ImageEnhance

def enhance_image(image, algorithm, background='.'):
    if algorithm[0] == '.':
        background = '.'
    else:
        background = '#'
    height, width = image.shape
    padded_image = np.pad(image, 1, mode='constant', constant_values=background)
    enhanced_image = np.empty((height, width), dtype=str)
    for i in range(1, height - 1):
        for j in range(1, width - 1):
            neighbors = padded_image[i - 1:i + 2, j - 1:j + 2].flatten()
            index = int(''.join(neighbors), 2)
            enhanced_image[i - 1][j - 1] = algorithm[index]
    return enhanced_image

def count_lit_pixels(image):
    return np.count_nonzero(image == '#')

def main():
    with open('input.txt', 'r') as file:
        algorithm = file.readline().strip()
        image = file.read().splitlines()
    
    np_image = np.array([[pixel for pixel in row] for row in image])
    for i in range(50):
        np_image = enhance_image(np_image, algorithm)

    print(f""Part 1: {count_lit_pixels(np_image)}"")

if __name__ == ""__main__"":
    main()
",2
170,2021,21,1,wrong_output,"8208
",504972,,"
import random

def dirac_dice(p1_start, p2_start):
    p1_score, p2_score = 0, 0
    p1_position, p2_position = p1_start, p2_start
    die_roll = 1
    die_rolls = 0
    while p1_score < 1000 and p2_score < 100:
        # Player 1's turn
        p1_move = sum(range(die_roll, die_roll + 3)) % 10
        p1_position += p1_move
        p1_position %= 10
        p1_score += p1_position
        die_rolls += 3
        die_roll = (die_roll + 3) % 100
        if p1_score >= 100:
            return p2_score * die_rolls
        # Player 2's turn
        p2_move = sum(range(die_roll, die_roll + 3)) % 10
        p2_position += p2_move
        p2_position %= 10
        p2_score += p2_position
        die_rolls += 3
        die_roll = (die_roll + 3) % 100
    return p1_score * die_rolls

# Read the starting positions from the input file
with open('input.txt', 'r') as f:
    content = f.readlines()
    p1_start = int(content[0].split(':')[1])
    p2_start = int(content[1].split(':')[1])

# Play the game and print the result
result = dirac_dice(p1_start, p2_start)
print(result)
",2
171,2021,22,1,syntax_error,,600458,"  File ""/tmp/tmpb4wvviab/tmp.py"", line 16
    def apply_instructions(instructions: List[Tuple[int, int, int, int, int, int, str]) -> int:
                                                                                      ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List, Tuple

def parse_input(input_file: str) -> List[Tuple[int, int, int, int, int, int, int, int, int, int, str]]:
    with open(input_file, 'r') as f:
        lines = f.readlines()
    instructions = []
    for line in lines:
        mode, x_range, y_range, z_range = line.strip().split(',')
        x1, x2 = [int(i) for i in x_range[2:].split('..')]
        y1, y2 = [int(i) for i in y_range[2:].split('..')]
        z1, z2 = [int(i) for i in z_range[2:].split('..')]
        instructions.append((x1, x2, y1, y2, z1, z2, mode))
    return instructions

def apply_instructions(instructions: List[Tuple[int, int, int, int, int, int, str]) -> int:
    cubes = set()
    for x1, x2, y1, y2, z1, z2, mode in instructions:
        for x in range(max(-50, x1), min(50, x2)+1):
            for y in range(max(-50, y1), min(50, y2)+1):
                for z in range(max(-50, z1), min(50, z2)+1):
                    if mode == 'on':
                        cubes.add((x, y, z))
                    elif (x, y, z) in cubes:
                        cubes.remove((x, y, z))
    return len(cubes)

def main():
    instructions = parse_input('input.txt')
    on_cubes = apply_instructions(instructions)
    print(f""There are {on_cubes} cubes that are on."")

if __name__ == '__main__':
    main()
",2
172,2021,23,1,syntax_error,,19019,"  File ""/tmp/tmpts1fr57v/tmp.py"", line 26
    for x in range(len(board[0]):
                                ^
SyntaxError: invalid syntax
","
import sys
from collections import defaultdict

def is_valid_move(board, start, end):
    x1, y1 = start
    x2, y2 = end
    if x1 == x2 and y1 == y2:
        return False
    if board[y2][x2] != '.':
        return False
    if y1 < y2:
        return all(board[y][x1][x2] == '#' for y in range(y1+1, y2))
    else:
        return all(board[y][x1][x2] == '#' for y in range(y2+1, y1))

def is_final_state(board):
    for y in range(1, len(board)-1):
        for x in range(len(board[0])):
            if board[y][x] != board[0][x]:
                return False
    return True

def is_organized(board):
    for y in range(1, len(board)-1):
        for x in range(len(board[0]):
            if board[y][x] != '.':
                if board[0][x] != board[y][x]:
                    return False
    return True

def can_move(board, amphipod, start_x, start_y):
    if start_y == 1:
        return False
    if board[start_y-1][start_x] != '.':
        return False
    dest_y = 1
    if board[dest_y][start_x] == '.':
        return True
    return all(board[y][start_x] == amphipod for y in range(1, dest_y))

def move_cost(amphipod, dist):
    if amphipod == 'A':
        return dist
    elif amphipod == 'B':
        return 10 * dist
    elif amphipod == 'C':
        return 100 * dist
    elif amphipod == 'D':
        return 1000 * dist
    else:
        return 0

def find_best_move(board, energy):
    best_cost = float('inf')
    for y in range(1, len(board)-1):
        for x in range(len(board[0])):
            amphipod = board[y][x]
            if board[y][x] == '.':
                continue
            if all(board[y-1][i] == amphipod for i in range(x, len(board[0]))):
                continue
            if not can_move(board, amphipod, x, y):
                continue
            for end_x in range(len(board[0])):
                if board[1][end_x] != '.':
                    continue
                if is_valid_move(board, (x, y), (1, end_x)):
                    new_board = [row[:] for row in board]
                    new_board[y][x] = '.'
                    new_board[1][end_x] = amphipod
                    new_energy = energy + move_cost(amphipod, y - 1 + abs(end_x - x))
                    if new_energy < best_cost:
                        best_cost = new_energy
                        best_move = (y, x, 1, end_x)
    return best_move, best_cost

def organize_amphipods(board, energy=0):
    if is_final_state(board):
        return energy

    best_move, cost = find_best_move(board, energy)
    if best_move is None:
        return float('inf')

    y1, x1, y2, x2 = best_move
    new_board = [row[:] for row in board]
    new_board[y1][x1] = '.'
    new_board[y2][x2] = board[y1][x1]
    return organize_amphipods(new_board, energy + cost)

def main():
    board = []
    with open('input.txt') as f:
        for line in f:
            board.append(list(line.strip()))

    min_energy = organize_amphipods(board)
    print(f""The least energy required to organize the amphipods is {min_energy} units."")

if __name__ == '__main__':
    main()
",2
173,2021,24,1,syntax_error,,49917929934999,"  File ""/tmp/tmpo64c7ogx/tmp.py"", line 2
    ```python
    ^
SyntaxError: invalid syntax
","
```python
import sys

def run_alu(program, input_number):
    variables = {'w': 0, 'x': 0, 'y': 0, 'z': 0}
    for line in program:
        operation, *args = line.split()
        if operation == 'inp':
            variables[args[0]] = int(input_number.pop(0))
        elif operation == 'add':
            variables[args[0]] += variables[args[1]] if args[1].isalpha() else int(args[1])
        elif operation == 'mul':
            variables[args[0]] *= variables[args[1]] if args[1].isalpha() else int(args[1])
        elif operation == 'div':
            if variables[args[1]] == 0:
                raise ValueError('Division by zero is not allowed')
            variables[args[0]] //= variables[args[1]] if args[1].isalpha() else int(args[1])
        elif operation == 'mod':
            if variables[args[1]] <= 0:
                raise ValueError('Modulo with non-positive divisor is not allowed')
            variables[args[0]] %= variables[args[1]] if args[1].isalpha() else int(args[1])
        elif operation == 'eql':
            variables[args[0]] = int(variables[args[0]] == variables[args[1]) if args[1].isalpha() else int(args[1])
    return variables

def find_largest_valid_model_number():
    program = '''
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 14
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 25
        mul y x
        add z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 12
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 18
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -4
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 13
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 11
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 2
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -15
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 16
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 10
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 1
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 15
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 14
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 15
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 13
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -13
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 16
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -12
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 13
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -15
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 16
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -11
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 11
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -15
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 12
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -10
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 14
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -14
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 13
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 26
        add x -5
        eql x w
        eql x 0
        mul y 0
        add y 25
        mul y x
        add y 1
        mul z y
        mul y 0
        add y w
        add y 11
        mul z y
        inp w
        mul x 0
        add x z
        mod x 26
        div z 1
        add x 15
        eql x w
",2
174,2021,25,1,syntax_error,,489,"  File ""/tmp/tmpc6gvng96/tmp.py"", line 5
    with open(filename, 'r') as f:
    ^
SyntaxError: invalid syntax
","
from typing import List, Tuple

def parse_input(filename: str) -> List[List[str]:
    with open(filename, 'r') as f:
        return [list(line.strip()) for line in f.readlines()]

def move_cucumbers(cucumbers: List[List[str]) -> Tuple[List[List[str], bool]:
    height = len(cucumbers)
    width = len(cucumbers[0])
    moved = False

    for step in range(1000000000000):
        next_step = [['.' for _ in range(width)] for _ in range(height)]
        moved = False

        for y in range(height):
            for x in range(width):
                if cucumbers[y][x] == '>':
                    next_x = (x + 1) % width
                    if cucumbers[y][next_x] == '.':
                        next_step[y][next_x] = '>'
                        moved = True
                    else:
                        next_step[y][x] = '>'
                elif cucumbers[y][x] == 'v':
                    next_y = (y + 1) % height
                    if cucumbers[next_y][x] == '.':
                        next_step[next_y][x] = 'v'
                        moved = True
                    else:
                        next_step[y][x] = 'v'
                else:
                    next_step[y][x] = '.'

        cucumbers = next_step

        if not moved:
            return cucumbers, step

    return cucumbers, -1

def main():
    cucumbers = parse_input('input.txt')
    final_cucumbers, step = move_cucumbers(cucumbers)
    if step == -1:
        print(""Sea cucumbers stopped moving after step 100000000000"")
    else:
        print(f""First step without movement: {step}"")

if __name__ == ""__main__"":
    main()
",2
175,2022,1,1,no_error,"70116
",70116,,"
import os

def get_total_calories():
    with open(""input.txt"", ""r"") as f:
        data = f.read().split(""\n\n"")
    data = [x.split(""\n"") for x in data]
    max_calories = 0
    for elf in data:
        calories = sum(map(int, elf))
        if calories > max_calories:
            max_calories = calories
    return max_calories

print(get_total_calories())
",0
176,2022,2,1,runtime_error,,12276,"Traceback (most recent call last):
  File ""/tmp/tmpj5b4ku_b/tmp.py"", line 48, in <module>
    print(calculate_score('input.txt'))
  File ""/tmp/tmpj5b4ku_b/tmp.py"", line 16, in calculate_score
    elf_strategy = re.sub('\s+', '', line).strip().split('')
ValueError: empty separator
","
import re

def calculate_score(strategy):
    # Read the input file
    with open('input.txt', 'r') as file:
        data = file.readlines()

    # Initialize variables
    total_score = 0
    score_map = {'R': 1, 'P': 2, 'S': 3}

    # Iterate over each line in the file
    for line in data:
        # Remove any whitespace and split the line by the space character
        elf_strategy = re.sub('\s+', '', line).strip().split('')

        # Check if the opponent's move is Rock, Paper, or Scissors
        if elf_strategy[0] == 'A':
            opponent_move = 'R'
        elif elf_strategy[0] == 'B':
            opponent_move = 'P'
        else:
            opponent_move = 'S'

        # Check if your move is Rock, Paper, or Scissors
        if elf_strategy[1] == 'X':
            your_move = 'R'
        elif elf_strategy[1] == 'Y':
            your_move = 'P'
        else:
            your_move = 'S'

        # Calculate the score for the round
        if opponent_move == your_move:
            round_score = 3
        elif (opponent_move == 'R' and your_move == 'S') or (opponent_move == 'P' and your_move == 'R') or (opponent_move == 'S' and your_move == 'P'):
            round_score = 6
        else:
            round_score = 0

        # Calculate the total score
        total_score += score_map[your_move] + round_score

    return total_score

# Call the function and print the result
print(calculate_score('input.txt'))
",2
177,2022,3,1,no_error,"8053
",8053,,"
from functools import reduce
from collections import Counter

def find_common_items(sack):
    first_half, second_half = sack[:len(sack)//2], sack[len(sack)//2:]
    return set(first_half).intersection(second_half)

def calculate_priority(common_items):
    result = 0
    for item in common_items:
        if item.islower():
            result += ord(item) - ord('a') + 1
        else:
            result += ord(item) - ord('A') + 27
    return result

def sum_of_priorities(sacks):
    with open('input.txt') as f:
        return sum(calculate_priority(find_common_items(sack)) for sack in f.readlines())

print(sum_of_priorities('input.txt'))
",1
178,2022,4,1,wrong_output,"497
",441,,"
import re

def count_overlapping_pairs(pairs):
    count = 0
    for pair in pairs:
        r1, r2 = pair.split(',')
        s1, e1 = [int(x) for x in r1.split('-')]
        s2, e2 = [int(x) for x in r2.split('-')]
        if s1 <= s2 <= e1 <= e2 or s2 <= s1 <= e1 <= e2:
            count += 1
    return count

input_file = open(""input.txt"", ""r"")
pairs = input_file.readlines()
print(count_overlapping_pairs(pairs))
",2
179,2022,5,1,runtime_error,,FCVRLMVQP,"Traceback (most recent call last):
  File ""/tmp/tmpkyp9u0qx/tmp.py"", line 27, in <module>
    main()
  File ""/tmp/tmpkyp9u0qx/tmp.py"", line 23, in main
    top_crates = ''.join(stack[-1][0] for stack in stacks)
  File ""/tmp/tmpkyp9u0qx/tmp.py"", line 23, in <genexpr>
    top_crates = ''.join(stack[-1][0] for stack in stacks)
IndexError: list index out of range
","
import re

def reorder_crates(starting_stacks, rearrangement_instructions):
    stacks = starting_stacks.copy()
    for instruction in rearrangement_instructions:
        match = re.match(r'move (\d+) from (\d+) to (\d+)', instruction)
        quantity, source_stack, target_stack = map(int, match.groups())
        source_stack -= 1
        target_stack -= 1
        crate = stacks[source_stack].pop(-quantity)
        stacks[target_stack].append(crate)

    return stacks

def main():
    with open('input.txt', 'r') as f:
        lines = f.read().splitlines()
        starting_stacks = [line.strip().split() for line in lines[:-1]]
        rearrangement_instructions = lines[-1:]

    stacks = reorder_crates(starting_stacks, rearrangement_instructions)
    top_crates = ''.join(stack[-1][0] for stack in stacks)
    print(top_crates)

if __name__ == '__main__':
    main()
",2
180,2022,6,1,wrong_output,"No start-of-packet marker found.
",1109,,"
import re

def find_marker(buffer):
    pattern = re.compile(r'(?=([a-zA-Z0-9])\1{3})')
    match = re.search(pattern, buffer)
    if match:
        return match.start() + 1
    else:
        return -1

def main():
    with open('input.txt', 'r') as f:
        input_buffer = f.read().strip()
        result = find_marker(input_buffer)
        if result != -1:
            print(f""The first start-of-packet marker appears after {result} characters."")
        else:
            print(""No start-of-packet marker found."")

if __name__ == ""__main__"":
    main()
",2
181,2022,7,1,runtime_error,,1443806,"Traceback (most recent call last):
  File ""/tmp/tmp66fds7w_/tmp.py"", line 54, in <module>
    main()
  File ""/tmp/tmp66fds7w_/tmp.py"", line 47, in main
    dir_size, file_size = parse_input(lines)
  File ""/tmp/tmp66fds7w_/tmp.py"", line 23, in parse_input
    dir_size[current_dir] += int(line.split()[-1])
ValueError: invalid literal for int() with base 10: 'jssbn'
","
import os
import sys
import re
from collections import defaultdict

def process_input(input_file):
    with open(input_file, 'r') as f:
        lines = [line.strip() for line in f.readlines()]
    return lines

def parse_input(lines):
    current_dir = '/'
    dir_size = defaultdict(int)
    file_size = {}
    for line in lines:
        if line.startswith('cd'):
            if line == 'cd ..':
                current_dir = os.path.dirname(current_dir)
            else:
                current_dir = os.path.join(current_dir, line.split()[1])
        elif line.startswith('dir'):
            dir_size[current_dir] += int(line.split()[-1])
        elif line.startswith('ls'):
            for file_info in line.split()[1:]:
                if '.' in file_info:
                    file_size[os.path.join(current_dir, file_info)] = int(file_info.split('.')[0])
                else:
                    dir_size[os.path.join(current_dir, file_info)] = 0
    return dir_size, file_size

def calculate_total_size(dir_size, file_size, target_dir, target_size):
    total_size = 0
    for directory, size in dir_size.items():
        if size <= target_size:
            if target_dir in directory:
                total_size += size
            else:
                for file_path, file_size in file_size.items():
                    if file_path.startswith(directory + '/'):
                        total_size += file_size
    return total_size

def main():
    input_file = 'input.txt'
    lines = process_input(input_file)
    dir_size, file_size = parse_input(lines)
    target_dir = '/'
    target_size = 100000
    total_size = calculate_total_size(dir_size, file_size, target_dir, target_size)
    print(f""The sum of the total sizes of directories with a total size of at most {target_size} is {total_size}"")

if __name__ == ""__main__"":
    main()
",2
182,2022,8,1,syntax_error,,1807,"  File ""/tmp/tmps7pjklv6/tmp.py"", line 4
    def count_visible_trees(grid: List[List[int]):
                                                ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
from typing import List

def count_visible_trees(grid: List[List[int]):
    visible_count = 0
    num_rows = len(grid)
    num_cols = len(grid[0])

    for r in range(num_rows):
        for c in range(num_cols):
            if r == 0 or c == 0 or r == num_rows - 1 or c == num_cols - 1:
                # Trees on the edge are always visible
                visible_count += 1
                continue

            # Check up, down, left, and right
            if grid[r][c] > grid[r - 1][c] and grid[r][c] > grid[r + 1][c] and grid[r][c] > grid[r][c - 1] and grid[r][c] > grid[r][c + 1]:
                visible_count += 1

    return visible_count

def main():
    with open(""input.txt"", ""r"") as f:
        grid = [[int(x) for x in line.strip()] for line in f.readlines()]

    visible_count = count_visible_trees(grid)
    print(f""The total number of visible trees is {visible_count}"")

if __name__ == ""__main__"":
    main()
",2
183,2022,9,1,wrong_output,"3866
",6087,,"
from collections import defaultdict

def main():
    directions = {'R': (0, 1), 'L': (0, -1), 'U': (-1, 0), 'D': (1, 0)}
    head = [0, 0]
    tail = head.copy()
    visited = defaultdict(int)
    visited[tuple(head)] += 1
    visited[tuple(tail)] += 1
    
    with open('input.txt', 'r') as file:
        for line in file:
            direction, steps = line.strip().split()
            steps = int(steps)
            for _ in range(steps):
                dx, dy = directions[direction]
                head[0] += dx
                head[1] += dy
                visited[tuple(head)] += 1
                if head[0] != tail[0] and head[1] != tail[1]:
                    tail[0] = head[0] + (head[0] - tail[0]) // abs(head[0] - tail[0])
                    tail[1] = head[1] + (head[1] - tail[1]) // abs(head[1] - tail[1])
                    visited[tuple(tail)] += 1

    print(sum(1 for v in visited.values() if v >= 2))

if __name__ == '__main__':
    main()
",2
184,2022,10,1,wrong_output,"180
",15360,,"
import re

def get_signal_strength(program):
    cycles = [20, 60, 100, 140, 180, 220]
    X = 1
    signal_strengths = []
    i = 0
    for line in program:
        if line.startswith(""addx""):
            X += int(line.split()[1])
        i += 1
        if i in cycles:
            signal_strengths.append(i * X)
    return sum(signal_strengths)

program = []
with open(""input.txt"", ""r"") as f:
    program = re.findall(r""addx\s+(\d+)|noop"", f.read())
    total_signal_strength = get_signal_strength(program)
    print(total_signal_strength)
",2
185,2022,11,1,runtime_error,,69918,"Traceback (most recent call last):
  File ""/tmp/tmpcd45pqm8/tmp.py"", line 84, in <module>
    print(monkey_business('input.txt'))
  File ""/tmp/tmpcd45pqm8/tmp.py"", line 54, in monkey_business
    monkey_id = int(line.split()[1])
ValueError: invalid literal for int() with base 10: '0:'
","
import math

def generate_worry_level(item, operation):
    if operation == 'old * 19':
        return item * 19
    elif operation == 'old + 6':
        return item + 6
    elif operation == 'old * old':
        return item * item
    elif operation == 'old + 3':
        return item + 3

def check_test(worry_level, test):
    if test == 'divisible by 23':
        return worry_level % 23 == 0
    elif test == 'divisible by 19':
        return worry_level % 19 == 0
    elif test == 'divisible by 13':
        return worry_level % 13 == 0
    elif test == 'divisible by 17':
        return worry_level % 17 == 0

def monkey_turn(monkey_id, items, operations, tests, monkeys):
    for i, item in enumerate(items):
        new_worry_level = generate_worry_level(item, operations[monkey_id])
        items[i] = math.floor(new_worry_level / 3)
        if check_test(new_worry_level, tests[monkey_id]):
            throw_to = 2
        else:
            throw_to = 3
        monkeys[throw_to].append(new_worry_level)
        items.remove(item)

def simulate_round(monkeys, operations, tests):
    for monkey_id in range(len(monkeys)):
        if monkeys[monkey_id]:
            monkey_turn(monkey_id, monkeys[monkey_id], operations, tests, monkeys)

def count_inspections(monkeys, operations, tests):
    inspections = [0] * len(monkeys)
    for _ in range(20):
        for i, items in enumerate(monkeys):
            if items:
                inspections[i] += len(items)
        simulate_round(monkeys, operations, tests)
    return inspections

def monkey_business(input_file):
    monkey_data = []
    with open(input_file, 'r') as f:
        for line in f:
            if 'Monkey' in line:
                monkey_id = int(line.split()[1])
                items = []
                operation = None
                test = None
                for line in f:
                    line = line.strip()
                    if 'Starting items' in line:
                        items = [int(x) for x in line.split(':')[1].split(',')]
                    elif 'Operation' in line:
                        operation = line.split(':')[1].strip()
                    elif 'Test' in line:
                        test = line.split('If true:')[1].split()[0].strip()
                    elif 'If false' in line:
                        test = line.split('If false:')[1].split()[0].strip()
                    elif line:
                        monkey_data.append((monkey_id, items, operation, test))
                        break
    
    monkeys = [[] for _ in range(len(monkey_data))]
    for monkey_id, items, operation, test in monkey_data:
        monkeys[monkey_id] = items
        operations = [''] * len(monkeys)
        tests = [''] * len(monkeys)
        operations[monkey_id] = operation
        tests[monkey_id] = test
        
    inspections = count_inspections(monkeys, operations, tests)
    return math.prod(sorted(inspections, reverse=True)[:2])

if __name__ == ""__main__"":
    print(monkey_business('input.txt'))
",2
186,2022,12,1,syntax_error,,504,"  File ""/tmp/tmpqn1oqmfc/tmp.py"", line 13
    height = ord(grid[end[0]) - ord(grid[start[0])
                            ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
","
import sys

def get_neighbors(grid, x, y):
    neighbors = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] != '#':
            neighbors.append((nx, ny))
    return neighbors

def get_best_path(grid, start, end):
    height = ord(grid[end[0]) - ord(grid[start[0])
    if height <= 0:
        return -1
    visited = set()
    queue = [(start, 0)]
    while queue:
        pos, steps = queue.pop(0)
        if pos == end:
            return steps
        if pos in visited:
            continue
        visited.add(pos)
        for n in get_neighbors(grid, pos[0], pos[1]):
            if ord(grid[n[0]) - ord(grid[pos[0]) <= height:
                queue.append((n, steps + 1))
    return -1

def main():
    grid = []
    for line in sys.stdin:
        grid.append(list(line.strip()))
    start = (0, 0)
    end = (0, 0)
    for y, row in enumerate(grid):
        for x, val in enumerate(row):
            if val == 'S':
                start = (y, x)
            elif val == 'E':
                end = (y, x)
    print(get_best_path(grid, start, end))

if __name__ == '__main__':
    main()
",2
187,2022,13,1,wrong_output,"5424
",5503,,"
import re

def compare(left, right):
    if isinstance(left, int) and isinstance(right, int):
        return left - right
    elif isinstance(left, list) and isinstance(right, list):
        for i in range(min(len(left), len(right))):
            comparison = compare(left[i], right[i])
            if comparison != 0:
                return comparison
        return len(left) - len(right)
    elif isinstance(left, int):
        return compare([left], right)
    else:
        return compare(left, [right])

def is_ordered(packet1, packet2):
    return compare(packet1, packet2) <= 0

input_file = open(""input.txt"", ""r"")
pairs = input_file.read().split(""\n\n"")

ordered_pairs = []
for i, pair in enumerate(pairs):
    packets = [eval(line) for line in pair.split(""\n"")]
    if is_ordered(packets[0], packets[1]):
        ordered_pairs.append(i)

print(sum(ordered_pairs))
",2
188,2022,14,1,syntax_error,,825,"  File ""/tmp/tmp7pqaz6ee/tmp.py"", line 14
    sand = defaultdict(lambda: '.')
    ^
SyntaxError: invalid syntax
","
import re
from collections import defaultdict
from itertools import product

# Read input file
with open('input.txt', 'r') as f:
    lines = [line.strip() for line in f.readlines()]

# Parse input to get coordinates
coordinates = list(map(lambda x: tuple(map(int, re.findall(r'\d+', x)), lines))

# Create a dictionary to store the sand
sand = defaultdict(lambda: '.')

# Set source of sand
sand[500, 0] = '+'

# Function to check if a coordinate is open
def is_open(x, y):
    return sand[x, y] == '.'

# Function to check if a coordinate is a wall
def is_wall(x, y):
    return sand[x, y] == '#'

# Function to check if a coordinate is sand
def is_sand(x, y):
    return sand[x, y] == 'o'

# Function to check if a coordinate is free-falling sand
def is_falling_sand(x, y):
    return sand[x, y] == 'o'

# Function to check if a coordinate is settled sand
def is_settled_sand(x, y):
    return sand[x, y] == '#'

# Function to check if a coordinate is already sand
def is_sand_or_settled(x, y):
    return is_sand(x, y) or is_settled_sand(x, y)

# Function to place sand at a coordinate
def place_sand(x, y):
    sand[x, y] = 'o'

# Function to place settled sand at a coordinate
def place_settled_sand(x, y):
    sand[x, y] = '#'

# Function to place rock at a coordinate
def place_rock(x, y):
    sand[x, y] = '#'

# Function to simulate sand fall
def fall_sand(x, y):
    while True:
        if is_open(x, y+1):
            place_sand(x, y+1)
            return x, y+1
        elif is_open(x-1, y+1) and is_falling_sand(x+1, y+1):
            place_sand(x-1, y+1)
            return x-1, y+1
        elif is_open(x+1, y+1) and is_falling_sand(x-1, y+1):
            place_sand(x+1, y+1)
            return x+1, y+1
        elif is_open(x, y+1) and is_settled_sand(x-1, y+1) and is_settled_sand(x+1, y+1):
            return None, None
        else:
            place_settled_sand(x, y)
            return None, None

# Initialize sand at the source
place_sand(500, 0)

# Loop through all coordinates
for x, y in product(range(1001), range(101)):
    if is_falling_sand(x, y):
        x_new, y_new = fall_sand(x, y)
        while x_new is not None and y_new is not None:
            x, y = x_new, y_new
            x_new, y_new = fall_sand(x, y)

# Count the number of settled sand
count = sum(1 for x, y in sand.keys() if is_settled_sand(x, y))
print(count)
",2
189,2022,15,1,runtime_error,,4861076,"Traceback (most recent call last):
  File ""/tmp/tmpml1iv7q4/tmp.py"", line 36, in <module>
    sensor, beacon = re.findall(r'\d+,\d+', line)
ValueError: not enough values to unpack (expected 2, got 0)
","
import math
import re

def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

def closest_beacon(beacons, sensors):
    min_distance = math.inf
    closest_beacon = None
    for beacon in beacons:
        distance = manhattan_distance(beacon, sensor)
        if distance < min_distance:
            min_distance = distance
            closest_beacon = beacon
    return closest_beacon

def infeasible_positions(beacons, sensors):
    positions = set()
    for beacon in beacons:
        for sensor in sensors:
            if manhattan_distance(beacon, sensor) == 0:
                positions.add(beacon)
    for sensor in sensors:
        closest_beacon = closest_beacon(beacons, sensor)
        for x in range(min(sensor[0] - closest_beacon[0], 1), max(sensor[0] - closest_beacon[0], 1) + 1):
            for y in range(min(sensor[1] - closest_beacon[1], 1), max(sensor[1] - closest_beacon[1], 1) + 1):
                positions.add((sensor[0] - x, sensor[1] - y))
    return positions

beacons = []
sensors = []

with open('input.txt', 'r') as f:
    for line in f:
        sensor, beacon = re.findall(r'\d+,\d+', line)
        x, y = map(int, sensor.split(','))
        sensors.append((x, y))
        x, y = map(int, beacon.split(','))
        beacons.append((x, y))

infeasible_positions = infeasible_positions(beacons, sensors)

count = 0
for x in range(min(sensor[0] for sensor in sensors), max(sensor[0] for sensor in sensors) + 1):
    for y in range(min(sensor[1] for sensor in sensors), max(sensor[1] for sensor in sensors) + 1):
        if (x, y) not in infeasible_positions:
            count += 1

print(count)
",2
190,2022,16,1,runtime_error,,2080,"Traceback (most recent call last):
  File ""/tmp/tmpfkjv46t1/tmp.py"", line 72, in <module>
    main()
  File ""/tmp/tmpfkjv46t1/tmp.py"", line 64, in main
    valve, flow, tunnels = re.findall(r'Valve ([A-Za-z]+) has flow rate=([\d]+); tunnels lead to (.*)', line)[0]
IndexError: list index out of range
","
import re
from collections import defaultdict
from heapq import heappush, heappop

def get_flow(valves_dict, valve):
    if valve not in valves_dict:
        return 0
    return valves_dict[valve]

def generate_path(valves_dict, start, end, visited, path):
    if start == end:
        return path
    visited.add(start)
    for valve in valves_dict[start]:
        if valve not in visited:
            path_new = generate_path(valves_dict, valve, end, visited, path + [valve])
            if path_new:
                return path_new
    return None

def get_max_pressure(valves_dict, start='AA', target='EE', max_minutes=30):
    valves = set(valves_dict.keys())
    valves.discard(start)
    valves.discard(target)
    path = generate_path(valves_dict, start, target, set(), [start])
    if not path:
        return None
    path.append(target)
    path.reverse()
    path.append(start)
    visited = set()
    pressure = 0
    opened = set()
    q = [(0, start)]
    for minute in range(max_minutes + 1):
        if not q:
            break
        new_valves = []
        while q:
            t, valve = heappop(q)
            if valve in visited:
                continue
            visited.add(valve)
            if valve != start:
                pressure += get_flow(valves_dict, valve)
            opened.add(valve)
            for next_valve in valves_dict[valve]:
                if next_valve not in visited:
                    new_valves.append((t + 1, next_valve))
        for t, valve in new_valves:
            heappush(q, (t, valve))
        if minute != 0 and minute % 2 == 0:
            for valve in opened:
                valves.discard(valve)
            opened = set()
    return pressure

def main():
    with open('input.txt', 'r') as f:
        lines = f.readlines()
    valves_dict = defaultdict(list)
    for line in lines:
        valve, flow, tunnels = re.findall(r'Valve ([A-Za-z]+) has flow rate=([\d]+); tunnels lead to (.*)', line)[0]
        for tunnel in tunnels.split(', '):
            valves_dict[tunnel].append(valve)
        valves_dict[valve] = int(flow)
    max_pressure = get_max_pressure(valves_dict)
    print(f'The maximum pressure release is {max_pressure}')

if __name__ == '__main__':
    main()
",2
191,2022,17,1,runtime_error,"><<<>>>><<<>>>><>><<><<>>>><<<<>><<>><<<>>>><<<>>>><<<<>>><>>><<>>><<>>>><<>>>><>><>><<>>>><><<<<>>>><><>>><>>>><>>>><<>>>><><<<>>><<<<>><<<><<<<>>>><<>>><<<>>><><<>>><<<<>>><<<<>>><<<<>>>><<<><<<<>><>><<<>>>><><<<<><><><<>>><><>>><>>>><<<<><>>>><<>><<>>>><<>><<<>>>><<>>>><<>><<<>>>><<<<>>><<><<<<>>><<<>><><<<<>><<>><><<><<><>>>><<><<<>><<>>>><<<><<<>>><<<<>>><<<>>>><<<<><<>><<>>><>><<<>>><<<>>><<>><>><<>>>><<>>><<<<>><<<<>>><>>><>>>><<<>>><<<><>><<<>><<<>>>><<<><<<<><<>><>><<<>><>>><<>>><<<><<><><>>><<<<><<<<><<><<><<<<>><<<>>><<<>><<>><<<>><>>><<<>>><<>><<<<><<<<>><<<><>><<>><><<>><<<>><<>>><<<<><><>><<>>>><<<<><<<>><<<><<<<>>>><<<<><<<>>><<><<<<><<<<>>><<><<<>>>><>>>><<>>><><<>><<<<>><>>><<<>>>><<><<<><<<>><<>>><<<>><<<>>>><<<<>>>><>><><>>><<<>>><<<>>>><<<><<<<>>>><<><<<<>>>><<<<>>><<<>><><<><<<<><><<>>>><<<<>><>>><<<>><<<<><>>><><<>>><>>><<>>>><>><<>>><>>>><><<>>><<<>>>><<<>>><>>><<<>>>><<>>>><<<<>>><>><<<><<><>>>><<<>>><<>><<<<>>><<><<<<>>><<<>>><<<>>><>>><<><<<>><<<<>>>><>>><<<>>>><<>>><<<<><<<>><<<><<<<><<>>>><<>><>>><<>>>><<<<>>>><<<>>><<>>><<<>><<><>>>><<>>>><<>>>><>>><<>>>><<>><<><<>><<<<>><<<><<>>>><<>><<<<>>>><<<<>>>><<<>><>>><<<>>><>>>><<<<><<<>><>>><<<<><<<<><<<>><>>>><>><<<<><<>>>><<<<>>><<<<>><<<>>>><<>>>><>><<>>>><<<<>>><<>>><>>><<<<>><>>><<<<>>><<>>>><<>>><<><>>><<<<>>><<<><<<<>>>><<>>><><>>><<>>>><<>>>><<>><><>>>><<<<>>>><>><>>>><<<>>>><>>>><<>>><<<<>>><<<>><><<<><<><<<<>>><<><<>><<<<>><><><<<>>>><<<<>><><<<>>>><><<<>>>><>>>><<<<>><<<><<>>><<<<>>><<>>>><<<<>>><>><<<><<>><<>>>><>>>><<>>><<>>>><<<>><>><<<>>><<<<>>>><<>><<<<>>><<<<>><<>>><<<>>>><>>><<<<>>>><<>>>><<>>><><<<><>><<>>>><<<>>>><<<>><>><<<>><<><<<>>>><<><<>><<<<><<>><<<><><<<<>>><<>>>><<><<<><<<<>>><<<>>><<>><><<<><<>><<>><<<><>>><<<<>>>><<>>><><<<<>>><<>><<<>>>><><<<<><<<>>><>>><<<<><<<<>>><<<<>><<<<><<><<>><<<><<<>><<<><><<>>><>><<<<>>><<>><<>><<<>>>><<<<>><<<<><>>>><<><>><<<<><<<>>><<<<><<><<<>>><<<><><>>>><<>>>><>><<<<><<<>><<<><>>><<>><<<><<<<>>><>>><<<>><<<<><>><<<><<<>>><>>>><>>><<><<>>><<>><<><<<<>>>><<>><<>>>><>>>><<><<<><<<<>>>><<<>>><<<>>><<<<>><<<>>>><>>><<><<<<>>>><<<>>>><<><<<<>>><<<>><><<<<>>>><<<<>>><>>><<>>><>>>><<<<>>><<<>><<>><<<>><<<>>><>>><><<>><<<>><<><<<>><><<>>><<><<>>><<><<<<>>>><>>>><<>>>><<<<>>><<<<><>><<><<<>><>><<>><<>>><<<>><<>><>>><<<<><<<><<<<><>>>><<><<>><<>>><<<>><<<<>>><<<<><<<>>>><<><<>><<<<><<<<>><>>><<><<<>><<<>><<<>>><><<><><<<<>>>><<<>><<<><<<<>>>><<<>>>><<<<>>>><<<<>><<<>>>><>><<<><><<<><<<<><><<<<><<<<><<<<><<<<>>>><<>>><<<<>>><><<<>>><<<>><<<<>>><<<>><>>>><<<<>>>><<<>><<<>>>><<<>><>>><>>>><<<<>><<<>>><<>><<<<>>><<<<>>>><>>><<<<><>>>><<<>>>><<<>><<<>>><<><<>><<<<>>><<<<>><<<>>><<>><<>>><<<>><<>>>><<<>><<<>>><<>>><<<<>>><>>>><><<<<>>><>>>><<<>>><>><<<<>>><<<>><<<>>>><<>>>><<><<<<>>>><<<<>>>><<>>>><<<><<>>>><<><<>>>><>>><<<<><<>>>><>>>><<<<><<<>>>><<<>><>>><<<<>>><<><<<<>><>>><<<<>>>><><<<>>><<<<>><>><>><<<<>>><<<<>>>><<>>>><<<>>>><>>><<<>>><<<<>><<<><<<>><<<><>><<<>>>><<<><>>>><>><<<<>><>>><><<<<>>>><<>>><<<<>>>><<<>>><<<>><<<>>><><>><<<>><<>>><<<<><<><<<>>>><<<<><<><<<<>>><<>>>><>><<>>><<<<>>><<>>><<>>><<<<>>><>><<<>>><<>>>><<<>><<<<>><<>>>><<<><>>>><<>>><<><<<<><>>><>>><<<>>><>>>><<<<>>>><<<<>>><<<>>>><>>>><<>>>><<<>>><<<<><<>>><<>>>><<<>>>><<<<>><<<<>><<><>><<<<>><>>>><<><<<>>><>><>>><<<<>><<<><<<>>><<<<><>>><<>>>><>>><<<<>>><>><<>><>>><<>>>><<>><<<<>><<>>><<<>>>><<<><<<><<>>><<<<>>>><<>><<<><<>><<>><<<<>>><<<<>>><<<<>>><>>><><<><<<<><<<<>>><<<>>>><<<>>><>>>><<<<>><<><>>>><<<<><<<<><<<<>>><<<<>>>><<<<>>><<<<><<<<>><<<<>><>><<<<>><<<>>><<>><<<>><<<<>>><<<>>><<>>><<<>><<><<<>>><<><<<<>>>><<<<>>><<<>><>><>>>><<>>>><<<<>>><<><<<<>><<<><<<<>>>><><<<<>>>><<<<>><<>>>><>>>><<>>><<<>>>><<<<>>>><<>><<>>><<<<>>><<><><>>><>>>><<<<>>><>>>><<<<>><<<<><<<>><<<<>><<>>><><<><<>><<<<>>>><<<>><<>><<<>>>><>>><<<>>>><><>>>><<<>>>><<><<<<><<<<>>>><>>>><<<>>><>>>><<<<>><>><>><<<<><<>>><<<<>>>><<><<<>>>><<>><<>>><<<><<<><<<<><><<>>><<>><<<>>>><<<<><>>><><><><<<>>>><<<><<<<><>><><<<<><<<>>>><<><>><<>>><<<<>>>><<>><<<>><<<<>><<<<><<>>><>><<<<>>>><>>><><>><>><<>>><>><<<>>><<<<>>>><<><<<<>>>><<<<>>>><><<>>>><<>>>><>><<>><<<<>>>><>><<<<>>><<>><<<>>><<<<><<><<>>>><><>>>><<<<>>><>><<<<>><<<>><<<>>><<<<>>><<>><<<>>><<<<>>><<<<><<>>>><><<>>>><<<><<<<>>>><>><<<<>><<<<>>><<>><<<<>>>><<>>><>>><<<>>><<<<>>><<<<><<<>><>>>><><<><<><<><<>>><<<>>>><<<<>><<<<>>>><<>>>><>>><>>><>><<><<<>>>><>>><<<>><>>>><>>><>>>><<<<>><>>><<<<>>>><><<<><<<>>><<<>>>><<<<>><>><<<<>>><<<<><<>><<><<><<>>><<>>>><<<<>>>><<><<><<<>><<<>><<>>><<<><><>>>><>>><<<<>>><<>><<>>><<<<>>><<<><<>><<<>><<<<>>>><>>>><<><>>>><<<<>>>><<<<>>><<>>><<>>><><>><><<<<><<>>>><<><>><<<><<<<>><<>><<>>><><>>><<><<<<>>>><>>>><><<<><<<>><<<>>><>>>><<<<>><<>>>><>>>><>><<>>><<<><<>>>><>><>><><<<><>><<>>><<<><>>><<<>>>><<<><<>>><<<>><<<>><<>><<<<><<<<>><>><<<>>>><><<<>>>><<<<>>>><<<<>>><<<><<<<>>>><<><<<>>><<<>>><>>>><>>><<<<><<<<>>><><<>>>><<<><<>><<<<>><<>>>><<><<<<><<><<>>>><<<>>><>>><>>>><<<>>>><<<>><><<<>><<<>><<><<>>><><<<<>>>><>>><>>><<<><<>>>><<<>>>><<>><>>>><<<<>>><><><<<<><<<<>>>><<<>><>>>><>>><<<<>>><<<<>>><><<>>><<>>><<<<><<>>><>><<<>>><<<><<<<>>>><><<<><<><><<<>>><<>>><<<<><<<>>><<<><>><<><<>>><<<<>>>><>>>><<><<<>><>>>><<><<>>>><<<<><>>><>>>><<>>>><<<<>>><<<<>>><<><<><<<<>><<>>><<<<>><<<<>><<<>>>><<<<>>><<>>>><<<>>><<<><<<<>>><<<>>><>><<<>><<>>>><>>>><<<<>>><>>>><<<>>>><<<<>>>><<<>><<>><<<<><<<<><<<<><<<>>><<><<<<>>>><<><>><<<<>>><<>><><<<>>><<<><>>><<<<><<>>>><<<>>>><><><<<>><<<<>>><<>><<>>><<<>><<<>><<>>>><<<><><<><<<>><><>><<<>><<>>>><<><<<<>><<><<<<>><>>><<>>>><<>><>>>><<<>>><<>>><>>>><<>>><<<>>><><<>><>>><<<<>>>><<<>>><<<<>>>><<>>><<<<><<<>>>><>><<<><>>><<>><<<>>><<<><<<<>><<>>><<>><><<>><<<>><<<>>>><<<<>><><<<<><>>>><<>>>><<><<>><<>><<<><<>>>><<<>><<>>><<<>><>>>><<<>><<<<>><<>><<<<>>>><><<>>><<><>>><<<>>>><<>>><>>><<<<><<<>>><<>><<>><<>><<<>>>><<<>><<>>><<<<>>>><><<<>>>><<<<>><>>><<>><<<<><<<>>>><>><>><<<>><>>><<<>>><<<<>><<>>>><><<<>>>><<<>><<<>>>><<>>>><<>><<<>>>><>>>><>>><>>>><><>>>><<<<>><<<>>>><>><<<>>><<<><<<<><<<><<<><<<<>>>><<>>>><><<<>><<>>>><<><<<<>>>><>>><><<<<>>><<<>><<<<>><<<<>>>><<<>>><>><<<<>>>><<>><<><<>>><<<<>>>><<<<><<>><<<>><<<<>><<>>><><<>>><>>><<<<>>><<><<>>><<<<>><><<<>><<<<><<>><<><<<>><<<<>>><<<<>>><<<<><<>><>>><<>>><>>>><>><<<<>><<<<>><<<>><>>>><>><<<>>>><<<<>>><<<>>>><<><><><<<<>>>><<<>>><<<<>>>><<<<>><<>><<<>>>><<>><<><<>><<<<>>><<<>>><<<>>>><<<><<><>>><<<>>><<<>><<<><<>><<<<>><>><<<>><<<<>>><><<<><>><><<<<>>>><<>>>><<<>>><<<<>>><<<<><>><<>>>><>>><<<>>>><><<>>><<<>>>><<<>>>><<<<>>>><<<<>>><<<<>>>><<><<<<><<<>><>>>><<<<><><<>>><<>>>><<<<>><<<<>>><<<><><><>><<<>>><<<<><>><<<>>>><<<>><>><<<<>>><<><>>>><><<<><>><<<>>><<<<>><<>>><>>><<>><<>>><>>><<<><><<<<><<<><<><<<><<>><>>><>><<<<><<<>><>><<><<>>>><>>><>>>><>>>><<<<>>><>>>><<>>><<>>>><<<>><<<<>><<><<>><<<<>><<><<<>>><>><<>><<<<>><>><><<<>>>><<<>>><<>>>><>><<<<>><>>>><<>>><<>>><<<>><<<>>><<<<><<><<>><<<<>>>><<<<>><<>><>>>><<<<>>><<<<>>><<<><<<<>>>><<<<>><<<<>><>>><<<<>>><<<><<<<>>><<<<>><<<<>>>><<<<>>>><<<<>>>><<><>>>><<>>><<><>><<>>>><<><>><<>>>><<>>>><<>>>><<<<>><><>>>><<>>><<>>>><<<>>>><<<<>><<>><<>><<<><<<>>>><<<><>>><<<<>><<<<>>>><<<<>>>><<<><<<<><<<<>>>><>>>><>>>><<<<>><><<<><<<<>>><<><<<>><<<>>>><<<<>>>><<<>><<>>>><<>>>><<<<>><<<<>>><<<>>><<<>><<<>><>>><<<>>>><<<<>>>><<<>>>><>>><<<<>>>><<<<>>><<<>>><>><<<>><<<>><<<<>>><<<>>>><<><<><<<>>><<>>>><<<>>><<<>>><<>><<<<>>>><<><<><<>>><>>>><<>>>><<>>>><<<<>>>><<<<><<<<>>><>>>><<><>>><><<<><<<>><>><>>><<<>><<<<>>>><<<><><>>>><<>>><<>>>><<<>>>><><>>>><<<>><<<><<<>>>><<>>>><<>>>><<><<>>><>><<<>>><<<<>><<<<><><<<<>>>><<><>><<<>>>><><<<<>><>>>><<<>>><<<>><>><<<>><<><<<>>><<<>>><<><<>>><<<><<<>>>><<>>>><><<<<><<<<>>><><<<>>><<>>><<>><>><>>><<>>><<<>>>><<><<>>>><<<<>><<<><>><<<<><<<><><<>><<<<><<<>><<<<>>><<<<><<<<>>>><<<>><><>><<><<>>>><<><<<<>><<<>>><<<><<<>>>><<>><<<>>><>>><<>><<><<<<><>><<<<>><>><<<<><<<<><<<><>>>><<>>>><>><<>>>><<>><<>>><>>><<<>>>><<>>>><>><>>><<><<<>>><<><<><><<<<><>><<<>>><<>><<<>>><<<<>>><<<<>>><<<><><<<>>>><<<>>>><>><<>>>><>><>>>><<<>><<<<>>><<>>><<<>>><<<<>>><<<<><<>><><<<<>>>><<>><<<<>><<<><>>><<><>><>>>><<>><<<<>><<<>>><<<>>><<<<><<<<>><<<<>>>><<<>>><<><<<><<<<>><><<>><<<<>>><<><>>><<<<>>><<>><<>>>><<<<>>>><<<<>>>><>>>><<>>>><>>>><<><<><>>>><<><<<<>>>><<<><<<>>>><<>>>><<<<>>>><<<>>>><<<<>>><>>><<<><<<>><<>><<<<>><<>>><<>>><<>>><<<<><>>>><<>><<><<<<>>><<<<>>><<<<><<<<>>><<<>>>><>>>><<>>>><>>>><<>><<>>>><<<><<<<><>><<<<><<>>>><>>>><<<<>>><<>><<<<>>>><<>>><<>>>><<<<>>><<<<>>><<<<>><<<<>>>><<><<<<>><<<<>>>><<><><<<<><<<>>><<<<><<<>>><<<>><<<><<>>>><<<<>><<<<><<<<><<<<>>>><<><<>>>><<>><<<>>><<<>>>><<<>><<<>>><<>><>><<<<><<<<>><<<<><<>>>><<<<>><<<<>>>><<><<<<>>>><<><<<<><<>>><<><<<>>><<><<<<>>><<>><<<<><<<<><<<<><<><<<<>>>><<<<><<>>>><<<<>>>><>><<<<>>><>>><<<>>>><>>>><>>>><<<><>>><>><<<<>>>><<<<>><<<>>>><<<<>><<<<>>>><<<<>>>><><<<<>>>><<<>><<>>>><>>>><>>>><><<>>>><<><><<<><>>>><>>>><<<><<<>>>><<<<>>>><<<>>><<<<><<<><<>>>><<>>>><<>>><<<>><>><<<><<<<><<>>>><<<>><<>><>>>><>>>><<>>>><<<>>><>>><>>><<>><<><<<>><<>><<<<>>>><<>><<>>>><<<>><<<<>>><<<><<<<><<<<>>><>><<>><><<>><<<>><<<<>>>><<<><<>><>><<<><<>><<<<>>><<<>><<<<><<>>>><<>><<<<><<>>>><<<><>>><<><<<<>><<<<>><<>><<<<>>>><<><<<<>>><<<><<<>><<>>><<<<>>>><<><>>><<<>>><<>>><<<<>>><<<>><<<<>>><<<>>>><>>>><<>><<<<>><<>>>><<<<>>>><<>>>><<<<>><<>>>><>>>><>>><<<<>>><<<<><<<>>><<>><<<<>>><>><<<<><<<<><>>>><<<<>>>><>>>><<<<>>><<>><<<>>><<<>>><<<>>>><>>>><<<>>><<<<><<>>><<<<>>><<<<><<<<>>>><>><>>>><>>><>><<<<>>>><<>><<<>>>><<>><<>><<<<>><<<>>><<>>>><<<><<<>>><<<<>><<<<><>>>><<<<>><<<<><><<>>><<<>>>><<<<>>>><<<>>>><<>>>><<>><>><>>><<>><<<<>>>><<<>><<>><<<>>>><<<>><<<>><<<<>>><<<><<>><<<<>>>><<<<>><>>><<<>><<><<<>>><<<>>>><>>>><<<>>>><<<>><<>>>><>>>><><<<<>><<>><><>><<<<>>>><<>><<<<>>><<>><>>><<<>>><<<><<<>>><<<<>>><<>>>><<<>><<>><<>>><<<>>><>><<>><>><<<>>>><<<<>><>>><<>>><<<<>><<>><>>>><>><<<>>><<>>>><>>><><<>>>><<><<<<>>>><<<>>>><<<<><<>>><<<<><><<>>><>><>>>><<>><<<>>><<>>><<>>><<<<>><>>>><<<<>><<<<><<>>>><<<><<<<>>>><<>><<>>>><>>><<<><<<>>><<<<>>><<>>><<<<>><<<><<<<><<<>><<<<>><<>>><<<<><<<<><>>>><<<<>><<><>><<>><<>>>><><<<>>><<><>>>><<<><<<>><<<><<<>><<<<>>><<<>>>><<<>>><<>><<<
",3235,"Traceback (most recent call last):
  File ""/tmp/tmp8z0t8_bj/tmp.py"", line 78, in <module>
    main()
  File ""/tmp/tmp8z0t8_bj/tmp.py"", line 54, in main
    floor[i] = '#'
IndexError: list assignment index out of range
","
import sys
from collections import deque

def read_input(file_name):
    with open(file_name, 'r') as file:
        lines = file.readlines()
    return lines[0].strip()

def generate_rock(shape_index):
    if shape_index == 0:
        return ['.', '.', '#', '.', '#', '.']
    elif shape_index == 1:
        return ['.', '#', '#', '#', '.', '#']
    elif shape_index == 2:
        return ['#', '#', '.', '#', '.', '#']
    elif shape_index == 3:
        return ['#', '#', '#', '#', '#', '#']
    elif shape_index == 4:
        return ['#', '#', '#', '#']
    else:
        return ['#', '#']

def process_rock(rock, jet_pattern, left, right):
    if jet_pattern[0] == '<':
        if left >= 2:
            rock = [' '] + rock[:-1]
        else:
            jet_pattern = jet_pattern[1:]
    else:
        if right < 2:
            rock.append('#')
        else:
            rock = rock[1:] + [' ']
        jet_pattern = jet_pattern[1:]
    return rock, jet_pattern

def main():
    jet_pattern = read_input('input.txt')
    print(jet_pattern)
    rock_shapes = [generate_rock(i) for i in range(5)]
    rock_shape_index = 0
    floor = []
    rock_positions = deque([2])
    rock_heights = [0, 0, 0, 0, 0, 0]
    max_height = 0
    rock_count = 0
    while rock_count < 2022:
        rock_shape = rock_shapes[rock_shape_index]
        left_boundary = min(rock_positions)
        right_boundary = max(rock_positions)
        for i in range(left_boundary, right_boundary + 1):
            if i in rock_positions:
                floor[i] = '#'
            else:
                floor[i] = '.'
        for i in range(len(rock_shapes[rock_shape_index]) - 1, -1, -1):
            if i + left_boundary < 7:
                floor[i + left_boundary] = rock_shape[i]
        new_rock_position = right_boundary + 3
        while new_rock_position in rock_positions:
            new_rock_position += 1
        rock_positions.append(new_rock_position)
        rock_shape_index = (rock_shape_index + 1) % 5
        rock_heights[rock_shape_index] = max(rock_heights) + 1
        rock_count += 1
        max_height = max(max_height, rock_heights[rock_shape_index])
        if rock_count % 5 == 0:
            jet_pattern = '>>><<<' + jet_pattern
        rock_positions, jet_pattern = process_rock(rock_positions, jet_pattern, left_boundary, right_boundary)
        if len(jet_pattern) == 0:
            jet_pattern = '>>><<<'
        floor = ['.'] * 7
        print(''.join(floor))
    print(max_height)

if __name__ == '__main__':
    main()
",2
192,2022,18,1,wrong_output,"5746
",4310,,"
import re

def surface_area(data):
    cubes = set()
    for line in data.splitlines():
        x, y, z = map(int, re.findall(r'-?\d+', line))
        cubes.add((x, y, z))

    surface_area = 0
    for cube in cubes:
        x, y, z = cube
        for dx, dy, dz in [(0, 0, 1), (0, 0, -1), (1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]:
            neighbor = (x + dx, y + dy, z + dz)
            if neighbor not in cubes:
                surface_area += 1

    return surface_area

with open('input.txt', 'r') as f:
    data = f.read()
    print(surface_area(data))
",2
193,2022,19,1,syntax_error,,1613,"  File ""/tmp/tmp1duohc7r/tmp.py"", line 7
    return [list(map(int, blueprint.split(':')[1].split(',')) for blueprint in blueprints]
                                                                                         ^
SyntaxError: closing parenthesis ']' does not match opening parenthesis '('
","
import math

def parse_input(input_file):
    with open(input_file, 'r') as f:
        blueprints = [line.strip() for line in f.readlines()]
    return [list(map(int, blueprint.split(':')[1].split(',')) for blueprint in blueprints]

def build_ore_collecting_robot():
    global ore
    ore += 1

def build_clay_collecting_robot():
    global ore, clay
    if ore >= 3:
        ore -= 3
        clay += 1

def build_obsidian_collecting_robot():
    global ore, clay, obsidian
    if ore >= 3 and clay >= 14:
        ore -= 3
        clay -= 14
        obsidian += 1

def build_geode_cracking_robot():
    global ore, clay, obsidian, geodes
    if ore >= 2 and obsidian >= 7:
        ore -= 2
        clay -= 7
        geodes += 1

def main(blueprints):
    # Initialize robots and resources
    robots = [build_ore_collecting_robot, build_clay_collecting_robot, build_obsidian_collecting_robot, build_geode_cracking_robot]
    robot_counts = [1, 0, 0, 0]
    ore = 0
    clay = 0
    obsidian = 0
    geodes = 0

    for minute in range(1, 25):
        for i in range(3):
            robots[i]()
        for i in range(robot_counts[0]):
            build_ore_collecting_robot()
        for i in range(robot_counts[1]):
            build_clay_collecting_robot()
        for i in range(robot_counts[2]):
            build_obsidian_collecting_robot()
        geodes += robot_counts[3]
        if minute == 12:
            for i in range(math.floor(minute / 4)):
                build_clay_collecting_robot()
            for i in range(math.floor(minute / 7)):
                build_obsidian_collecting_robot()
        if minute == 18:
            for i in range(math.floor(minute / 4)):
                build_geode_cracking_robot()
        print(f""Minute {minute}: {geodes} geodes opened"")

    return geodes

def quality_level(blueprints, minutes):
    total_quality = 0
    for i, blueprint in enumerate(blueprints):
        quality = main(blueprint)
        total_quality += i * quality
    return total_quality

if __name__ == ""__main__"":
    blueprints = parse_input('input.txt')
    print(quality_level(blueprints, 24))
",2
194,2022,20,1,wrong_output,"9439
",18257,,"
import sys

def mix_numbers(numbers):
    index = 0
    for i in numbers:
        numbers = numbers[index:] + numbers[:index]
        index += i
        index %= len(numbers)
    return numbers

def main():
    file = open('input.txt', 'r')
    numbers = [int(line.strip()) for line in file.readlines()]
    mixed_numbers = mix_numbers(numbers)

    grove_coordinates = [mixed_numbers[0], mixed_numbers[len(numbers)//2], mixed_numbers[-1]]
    sum_of_coordinates = sum(grove_coordinates)
    print(sum_of_coordinates)

if __name__ == ""__main__"":
    main()
",2
195,2022,21,1,runtime_error,,118565889858886,"Traceback (most recent call last):
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 54, in <module>
    print(yell_number('root'))
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 45, in yell_number
    num1 = yell_number(monkeys[0])
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 45, in yell_number
    num1 = yell_number(monkeys[0])
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 45, in yell_number
    num1 = yell_number(monkeys[0])
  [Previous line repeated 10 more times]
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 47, in yell_number
    result = perform_operation(operation, num1, num2)
  File ""/tmp/tmpdv0in5zc/tmp.py"", line 16, in perform_operation
    return int(num1) / int(num2)
ZeroDivisionError: division by zero
","
import re

# Dictionary to store the job and value of each monkey
monkey_jobs = {}

# Function to perform the given operation
def perform_operation(operation, num1, num2):
    if operation == '+':
        return int(num1) + int(num2)
    elif operation == '-':
        return int(num1) - int(num2)
    elif operation == '*':
        return int(num1) * int(num2)
    else:
        return int(num1) / int(num2)

# Read the input file
with open('input.txt', 'r') as f:
    for line in f.readlines():
        # Extract the monkey name and job
        monkey_name, job = line.strip().split(': ')
        # If the job is a number, store it in the dictionary
        if job.isdigit():
            monkey_jobs[monkey_name] = int(job)
        # If the job is an operation, extract the other monkeys' names and operation
        else:
            monkey_jobs[monkey_name] = (re.findall(r'\w+', job), job[1])

# Keep track of the monkeys that have yelled their numbers
yelled_monkeys = []

# Function to yell the number for a given monkey
def yell_number(monkey):
    # If the monkey has already yelled its number, return it
    if monkey in yelled_monkeys:
        return monkey_jobs[monkey]
    # If the monkey's job is a number, store it in the dictionary and return it
    elif isinstance(monkey_jobs[monkey], int):
        yelled_monkeys.append(monkey)
        return monkey_jobs[monkey]
    # If the monkey's job is an operation, find the numbers it needs and perform it
    else:
        monkeys, operation = monkey_jobs[monkey]
        num1 = yell_number(monkeys[0])
        num2 = yell_number(monkeys[1])
        result = perform_operation(operation, num1, num2)
        # Store the result in the dictionary and return it
        monkey_jobs[monkey] = result
        yelled_monkeys.append(monkey)
        return result

# Call the function for the monkey named 'root' and print the result
print(yell_number('root'))


monkey_jobs = {}

def perform_operation(operation, num1, num2):
    if operation == '+':
        return int(num1) + int(num2)
    elif operation == '-':
        return int(num1) - int(num2)
    elif operation == '*':
        return int(num1) * int(num2)
    else:
        return int(num1) / int(num2)

with open('input.txt', 'r') as f:
    for line in f.readlines():
        monkey_name, job = line.strip().split(': ')
        if job.isdigit():
            monkey_jobs[monkey_name] = int(job)
        else:
            monkey_jobs[monkey_name] = (re.findall(r'\w+', job), job[1])

yelled_monkeys = []

def yell_number(monkey):
    if monkey in yelled_monkeys:
        return monkey_jobs[monkey]
    elif isinstance(monkey_jobs[monkey], int):
        yelled_monkeys.append(monkey)
        return monkey_jobs[monkey]
    else:
        monkeys, operation = monkey_jobs[monkey]
        num1 = yell_number(monkeys[0])
        num2 = yell_number(monkeys[1])
        result = perform_operation(operation, num1, num2)
        monkey_jobs[monkey] = result
        yelled_monkeys.append(monkey)
        return result

print(yell_number('root'))
",2
196,2022,22,1,wrong_output,"Final position: (0, 0), facing: 0
Final password: 104
Final position: (0, 0), facing: 0
Final password: 104
",93226,,"
import re

with open(""input.txt"", ""r"") as f:
    data = f.readlines()

board = data[0:4]
password = data[4].strip()

# Clean up and convert board to list
board = [list(line.strip()) for line in board]

# Create a 2D list of the board
board = [list(row) for row in board]

# Initialize position and facing
position = (0, 0)
facing = 0

# Directional movement vectors
directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

# Iterate through the password
for move in re.findall(r'\d+|\w', password):
    if move.isdigit():
        # Move specified number of steps in current direction
        steps = int(move)
        for i in range(steps):
            # Get next position
            next_pos = (position[0] + directions[facing][0], position[1] + directions[facing][1])
            # Check if next position is off the board and wrap around if necessary
            if next_pos[0] < 0:
                next_pos = (len(board) - 1, next_pos[1])
            elif next_pos[0] >= len(board):
                next_pos = (0, next_pos[1])
            if next_pos[1] < 0:
                next_pos = (next_pos[0], len(board[0]) - 1)
            elif next_pos[1] >= len(board[0]):
                next_pos = (next_pos[0], 0)
            # If the next position is a wall, stop moving in this direction
            if board[next_pos[0]][next_pos[1]] == ""#"":
                break
            # Move to next position and update facing
            position = next_pos
            board[position[0]][position[1]] = ""*""
    else:
        # Turn in the specified direction
        if move == ""R"":
            facing = (facing + 1) % 4
        else:
            facing = (facing - 1) % 4

print(""Final position: {}, facing: {}"".format(position, facing))
print(""Final password: {}"".format(100 * (position[0] + 1) + 4 * (position[1] + 1) + facing))


def main():
    # Read input file
    with open(""input.txt"", ""r"") as f:
        data = f.readlines()

    # Get board and password
    board = data[0:4]
    password = data[4].strip()

    # Clean up and convert board to list
    board = [list(line.strip()) for line in board]

    # Create a 2D list of the board
    board = [list(row) for row in board]

    # Initialize position and facing
    position = (0, 0)
    facing = 0

    # Directional movement vectors
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

    # Iterate through the password
    for move in re.findall(r'\d+|\w', password):
        if move.isdigit():
            # Move specified number of steps in current direction
            steps = int(move)
            for i in range(steps):
                # Get next position
                next_pos = (position[0] + directions[facing][0], position[1] + directions[facing][1])
                # Check if next position is off the board and wrap around if necessary
                if next_pos[0] < 0:
                    next_pos = (len(board) - 1, next_pos[1])
                elif next_pos[0] >= len(board):
                    next_pos = (0, next_pos[1])
                if next_pos[1] < 0:
                    next_pos = (next_pos[0], len(board[0]) - 1)
                elif next_pos[1] >= len(board[0]):
                    next_pos = (next_pos[0], 0)
                # If the next position is a wall, stop moving in this direction
                if board[next_pos[0]][next_pos[1]] == ""#"":
                    break
                # Move to next position and update facing
                position = next_pos
                board[position[0]][position[1]] = ""*""
        else:
            # Turn in the specified direction
            if move == ""R"":
                facing = (facing + 1) % 4
            else:
                facing = (facing - 1) % 4

    print(""Final position: {}, facing: {}"".format(position, facing))
    print(""Final password: {}"".format(100 * (position[0] + 1) + 4 * (position[1] + 1) + facing))

if __name__ == ""__main__"":
    main()
",2
197,2022,23,1,wrong_output,"Usage: python3 elves.py <file_path>
",4109,,"
import sys
import os

def get_input(file_path):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(""File not found at the given path."")
    
    with open(file_path, 'r') as file:
        lines = file.readlines()
        return [line.strip() for line in lines]

def count_empty_tiles(grid):
    count = 0
    for row in grid:
        count += row.count('.')
    return count

def is_valid_move(x, y, grid, elf_positions):
    for dx, dy in [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == '.' and (nx, ny) not in elf_positions:
            return True
    return False

def move_elves(grid, elf_positions, dx, dy):
    new_positions = set()
    for x, y in elf_positions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == '.' and (nx, ny) not in elf_positions:
            new_positions.add((nx, ny))
        else:
            new_positions.add((x, y))
    return new_positions

def simulate_elves(grid, elf_positions, rounds):
    directions = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1)]
    for _ in range(rounds):
        moves = []
        for x, y in elf_positions:
            for i in range(len(directions)):
                if is_valid_move(x, y, grid, elf_positions):
                    moves.append((x, y, i))
                    break
        elf_positions = set([(x + dx, y + dy) for x, y, i in moves if all((x + dx, y + dy) not in elf_positions for x, y, j in moves if i != j)])
        directions = directions[1:] + directions[:1]
    return elf_positions

def find_smallest_rectangle(grid, elf_positions):
    min_x, max_x, min_y, max_y = min(x for x, y in elf_positions), max(x for x, y in elf_positions), min(y for x, y in elf_positions), max(y for x, y in elf_positions)
    return count_empty_tiles([row[min_y:max_y+1] for row in grid[min_x:max_x+1]])

def main(file_path):
    grid = get_input(file_path)
    elf_positions = {(x, y) for y, row in enumerate(grid) for x, tile in enumerate(row) if tile == '#'}
    elf_positions = simulate_elves(grid, elf_positions, 10)
    print(find_smallest_rectangle(grid, elf_positions))

if __name__ == ""__main__"":
    if len(sys.argv) != 2:
        print(""Usage: python3 elves.py <file_path>"")
    else:
        main(sys.argv[1])
",2
198,2022,24,1,syntax_error,,279,"  File ""/tmp/tmpd7me7fg0/tmp.py"", line 77
    return None
    ^
SyntaxError: invalid syntax
","
import sys
import re
from collections import deque
from itertools import count

def read_input_file(filename):
    with open(filename, 'r') as f:
        return [line.strip() for line in f.readlines()]

def find_start_end(grid):
    start = None
    end = None
    for y, row in enumerate(grid):
        for x, col in enumerate(row):
            if col == 'E':
                start = (x, y)
            elif col == 'v':
                end = (x, y)
    return start, end

def get_blizzard_positions(grid):
    blizzards = []
    for y, row in enumerate(grid):
        for x, col in enumerate(row):
            if col in ['>', 'v', '<', '^']:
                blizzards.append((x, y, col))
    return blizzards

def move_blizzards(blizzards, width, height):
    new_blizzards = []
    for x, y, direction in blizzards:
        if direction == '>':
            new_x, new_y = ((x + 1) % width, y)
        elif direction == '<':
            new_x, new_y = ((x - 1) % width, y)
        elif direction == 'v':
            new_x, new_y = (x, (y + 1) % height)
        else:
            new_x, new_y = (x, (y - 1) % height)
        new_blizzards.append((new_x, new_y, direction))
    return new_blizzards

def generate_blizzard_map(grid):
    blizzard_map = {}
    for y, row in enumerate(grid):
        for x, col in enumerate(row):
            if col in ['>', 'v', '<', '^']:
                blizzard_map[(x, y)] = col
    return blizzard_map

def print_blizzard_map(blizzard_map, width, height):
    for y in range(height):
        for x in range(width):
            if (x, y) in blizzard_map:
                print(blizzard_map[(x, y)], end='')
            else:
                print('.', end='')
        print('')

def find_path(grid, start, end, width, height):
    visited = set()
    queue = deque([(start, 0)])
    while queue:
        position, minutes = queue.popleft()
        if position == end:
            return minutes
        if position in visited:
            continue
        visited.add(position)
        x, y = position
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            new_x, new_y = (x + dx, y + dy)
            if 0 <= new_x < width and 0 <= new_y < height and (new_x, new_y) not in blizzard_map:
                queue.append(((new_x, new_y, minutes + 1))

    return None

def main():
    grid = read_input_file('input.txt')
    width = len(grid[0])
    height = len(grid)
    start, end = find_start_end(grid)
    blizzard_map = generate_blizzard_map(grid)
    blizzards = get_blizzard_positions(grid)
    for minute in count(1):
        blizzards = move_blizzards(blizzards, width, height)
        blizzard_map = {pos: direction for pos, direction in blizzards}
        if start in blizzard_map or end in blizzard_map:
            continue
        path_length = find_path(grid, start, end, width, height)
        if path_length is not None:
            print(f'Minutes required: {path_length}')
            break

if __name__ == '__main__':
    main()
",2
199,2022,25,1,timeout_error,,2=0=02-0----2-=02-10,TIMEOUT,"
import re

def snafu_to_decimal(snafu_number):
    snafu_dict = {""2"": 5, ""1"": 1, ""0"": 0, ""-"": -1, ""="": -2}
    snafu_exp = 0
    decimal_sum = 0
    for digit in snafu_number[::-1]:
        decimal_sum += snafu_dict[digit] * 5**snafu_exp
        snafu_exp += 1
    return decimal_sum

def decimal_to_snafu(decimal_number):
    snafu_dict = {25: ""2"", 20: ""1="", 15: ""1-"", 10: ""10"", 5: ""2"", 0: ""0"", -5: ""-"", -10: ""1="", -15: ""1-"", -20: ""2="", -25: ""-""}
    snafu_number = """"
    while decimal_number != 0:
        for key in snafu_dict:
            if decimal_number >= key:
                snafu_number += snafu_dict[key]
                decimal_number -= key
                break
    return snafu_number

with open(""input.txt"", ""r"") as file:
    total_fuel = sum(snafu_to_decimal(line.strip()) for line in file)
    snafu_total_fuel = decimal_to_snafu(total_fuel)
    print(snafu_total_fuel)
",2
